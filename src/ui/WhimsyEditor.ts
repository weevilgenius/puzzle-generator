/**
 * WhimsyEditor - Modal component for creating and editing whimsies (custom puzzle pieces)
 */

import m from 'mithril';
import type { PathCommand, CustomPiece } from '../geometry/types';
import { PathEditor } from './PathEditor';
import { validateCustomPiece, isPathClosed, type ValidationResult } from '../utils/pathValidation';
import { parseSVGFile, fitPathToCanvas } from './PathEditor/svgParser';
import Dialog from './Dialog';
import StringInputControl from './inputs/StringInputControl';
import type MithrilViewEvent from '../utils/MithrilViewEvent';

// Web Awesome components
import '@awesome.me/webawesome/dist/components/button/button.js';
import '@awesome.me/webawesome/dist/components/icon/icon.js';

// include our CSS
import './WhimsyEditor.css';

/* ========================================================= *\
 *  Component Interface                                      *
\* ========================================================= */

/**
 * Attributes for the WhimsyEditor component.
 */
export interface WhimsyEditorAttrs extends m.Attributes {
  /**
   * Whether the editor dialog is currently open.
   */
  open: boolean;

  /**
   * Optional existing custom piece to edit.
   * If undefined, creates a new custom piece.
   */
  piece?: CustomPiece;

  /**
   * Width of the PathEditor canvas in pixels.
   * Default: 600
   */
  editorWidth?: number;

  /**
   * Height of the PathEditor canvas in pixels.
   * Default: 600
   */
  editorHeight?: number;

  /**
   * Callback invoked when the user saves a custom piece.
   * For new pieces, the id and created timestamp should be generated by the caller.
   *
   * @param piece - The saved custom piece (may be partial for caller to complete)
   */
  onSave: (path: PathCommand[], name?: string) => void;

  /**
   * Callback invoked when the user cancels editing.
   */
  onCancel: () => void;
}

/* ========================================================= *\
 *  Component State                                          *
\* ========================================================= */

interface WhimsyEditorState {
  /** Initial path passed to PathEditor (only set on dialog open) */
  initialPath: PathCommand[];
  /** Current path being edited (for validation) */
  path: PathCommand[];
  /** Current piece name */
  name: string;
  /** Current validation result */
  validation: ValidationResult;
  /** Whether SVG import dialog is open */
  importDialogOpen: boolean;
  /** Track previous open state from last view render */
  prevOpen: boolean;
  /** ID of the piece from last view render */
  prevPieceId: string | null;
  /** Unique key for the current editing session - forces content remount when changed */
  contentKey: string;
}

/* ========================================================= *\
 *  Component Implementation                                 *
\* ========================================================= */

/**
 * WhimsyEditor - A modal dialog for creating/editing custom pieces
 */
export const WhimsyEditor: m.ClosureComponent<WhimsyEditorAttrs> = () => {
  const state: WhimsyEditorState = {
    initialPath: [],
    path: [],
    name: '',
    validation: { isValid: false, errors: [] },
    importDialogOpen: false,
    prevOpen: false,
    prevPieceId: null,
    contentKey: 'initial',
  };

  // Reference to the file input element
  let fileInputRef: HTMLInputElement | null = null;

  /**
   * Initialize state from attrs when dialog opens or piece changes
   */
  const initializeState = (attrs: WhimsyEditorAttrs) => {
    if (attrs.piece) {
      // Editing existing piece - use piece ID as content key
      state.contentKey = attrs.piece.id;
      state.initialPath = attrs.piece.path;
      state.path = attrs.piece.path;
      state.name = attrs.piece.name ?? '';
      // Validate existing piece
      state.validation = validateCustomPiece(state.path);
    } else {
      // Creating new piece - use timestamp as content key to force fresh remount
      state.contentKey = `new-${Date.now()}`;
      state.initialPath = [];
      state.path = [];
      state.name = '';
      // Don't show validation errors for empty canvas
      state.validation = { isValid: false, errors: [] };
    }
  };

  /**
   * Handle path changes from PathEditor
   */
  const handlePathChanged = (newPath: PathCommand[]) => {
    state.path = newPath;

    // Only validate if there's a path
    if (newPath.length === 0) {
      state.validation = { isValid: false, errors: [] };
    } else {
      // Always run validation to check if path is closed
      const validationResult = validateCustomPiece(newPath);
      state.validation = validationResult;
    }

    // Don't call m.redraw() here - it triggers a global redraw that can
    // interfere with PuzzleRenderer's Paper.js state. PathEditor already
    // handles its own redraws, and the validation status will update
    // when the user completes the path.
  };

  /**
   * Handle name input changes
   */
  const handleNameChanged = (newName: string) => {
    state.name = newName;
  };

  /**
   * Handle save button click
   */
  const handleSave = (attrs: WhimsyEditorAttrs) => {
    if (!state.validation.isValid) {
      return;
    }
    // Call the onSave callback with path and name
    // The caller is responsible for generating id, transform, and timestamp
    attrs.onSave(state.path, state.name.length > 0 ? state.name : undefined);
  };

  /**
   * Handle SVG file upload
   */
  const handleSVGUpload = (files: FileList | null, editorWidth: number, editorHeight: number) => {
    if (!files || files.length === 0) {
      return;
    }

    const file = files[0];
    if (!file.name.endsWith('.svg')) {
      console.error('Please select an SVG file');
      return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      const svgContent = e.target?.result as string;
      if (svgContent) {
        const parseResult = parseSVGFile(svgContent);

        if (parseResult.warning) {
          console.warn('SVG import warning:', parseResult.warning);
        }

        if (parseResult.commands.length > 0) {
          // Fit the path to the canvas size
          const fittedPath = fitPathToCanvas(
            parseResult.commands,
            editorWidth,
            editorHeight
          );

          // Update both initialPath (to reload PathEditor) and path (for validation)
          state.initialPath = fittedPath;
          handlePathChanged(fittedPath);

          // If the file name doesn't have a name yet, use the file name
          if (!state.name) {
            const nameWithoutExtension = file.name.replace(/\.svg$/i, '');
            handleNameChanged(nameWithoutExtension);
          }

          // Trigger redraw to show imported path
          // This is safe here because it's a user-initiated action (file upload)
          m.redraw();
        } else {
          console.error('Failed to parse SVG file');
        }
      }
    };
    reader.readAsText(file);
  };

  return {
    view: ({ attrs }) => {
      // Detect if dialog just opened or piece changed
      const currentPieceId = attrs.piece?.id ?? null;
      const dialogJustOpened = attrs.open && !state.prevOpen;
      const pieceChanged = currentPieceId !== state.prevPieceId;

      if (attrs.open && (dialogJustOpened || pieceChanged)) {
        // Dialog opened or piece changed - reinitialize state immediately before rendering
        initializeState(attrs);
      }

      // Update tracked state for next render
      state.prevOpen = attrs.open;
      state.prevPieceId = currentPieceId;

      const editorWidth = attrs.editorWidth ?? 600;
      const editorHeight = attrs.editorHeight ?? 600;

      return m(Dialog, {
        open: attrs.open,
        title: attrs.piece ? 'Edit Whimsy' : 'Create Whimsy',
        className: 'custom-piece-editor',
        width: '50vw',
        contentKey: state.contentKey,
        onStateChanged: (open) => {
          if (!open) {
            attrs.onCancel();
          }
        },
      }, [
        // Dialog content
        m('.editor-content', [
          // Name input
          m(StringInputControl, {
            config: {
              type: 'string',
              name: 'name',
              label: 'Piece Name (optional)',
              optional: true,
            },
            value: state.name,
            onChange: (newName: string | undefined) => {
              state.name = newName ?? '';
              m.redraw();
            },

          }),
          // m('wa-input.name-field', {
          //   label: 'Piece Name (optional)',
          //   type: 'text',
          //   size: 'small',
          //   value: state.name,
          //   placeholder: 'Enter a name for this piece',
          //   oninput: (e: Event & MithrilViewEvent) => {
          //     e.redraw = false;
          //     const input = e.target as WaInput;
          //     state.name = input.value ?? '';
          //   },
          // }),

          // Validation status
          // Show valid message only when path is closed and valid
          // Show error messages whenever there's a path with validation errors
          state.path.length > 0 && (
            state.validation.isValid
              ? (isPathClosed(state.path) && m('.validation-status', [
                m('.valid', [
                  m('wa-icon', {
                    library: 'material',
                    name: 'check_circle',
                    style: 'color: green;',
                  }),
                  m('span', 'Valid piece'),
                ]),
              ]))
              : (state.validation.errors.length > 0 && m('.validation-status', [
                m('.invalid', [
                  m('wa-icon', {
                    library: 'material',
                    name: 'error',
                    style: 'color: red;',
                  }),
                  m('span', state.validation.errors.join(', ')),
                ]),
              ]))
          ),

          // PathEditor
          m('.editor-canvas', [
            m(PathEditor, {
              initialPath: state.initialPath,
              onPathChanged: handlePathChanged,
              width: editorWidth,
              height: editorHeight,
              strokeColor: state.validation.isValid ? '#2196F3' : '#f44336',
            }),
          ]),

          // SVG Import button
          m('.import-controls', [
            m('input', {
              type: 'file',
              accept: '.svg',
              style: 'display: none;',
              oncreate: (vnode: m.VnodeDOM) => {
                fileInputRef = vnode.dom as HTMLInputElement;
              },
              onchange: (e: Event & MithrilViewEvent) => {
                e.redraw = false;
                const input = e.target as HTMLInputElement;
                handleSVGUpload(input.files, editorWidth, editorHeight);
                // Reset the input so the same file can be selected again
                input.value = '';
              },
            }),
            m('wa-button', {
              variant: 'default',
              size: 'small',
              onclick: (e: Event & MithrilViewEvent) => {
                e.redraw = false;
                fileInputRef?.click();
              },
            }, 'Import SVG'),
          ]),
        ]),

        // Dialog footer with action buttons
        m('div', {
          slot: 'footer',
          style: 'display: flex; gap: 8px; justify-content: flex-end;',
        }, [
          m('wa-button', {
            variant: 'default',
            onclick: (e: Event & MithrilViewEvent) => {
              e.redraw = false;
              attrs.onCancel();
            },
          }, 'Cancel'),
          m('wa-button', {
            variant: 'primary',
            disabled: !state.validation.isValid,
            onclick: (e: Event & MithrilViewEvent) => {
              e.redraw = false;
              handleSave(attrs);
            },
          }, 'Save'),
        ]),
      ]);
    },
  };
};

export default WhimsyEditor;
