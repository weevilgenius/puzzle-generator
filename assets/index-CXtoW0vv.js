import{m as v,g as He}from"./mithril-DD6GaBKN.js";import"./shoelace-OiOJKAO3.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))o(i);new MutationObserver(i=>{for(const t of i)if(t.type==="childList")for(const s of t.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&o(s)}).observe(document,{childList:!0,subtree:!0});function n(i){const t={};return i.integrity&&(t.integrity=i.integrity),i.referrerPolicy&&(t.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?t.credentials="include":i.crossOrigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function o(i){if(i.ep)return;i.ep=!0;const t=n(i);fetch(i.href,t)}})();const Fe={view:({attrs:l})=>v("a.github-corner",{href:l.link,"aria-label":"View source on GitHub",title:"View source on GitHub",target:"_blank"},v("svg",{width:80,height:80,viewBox:"0 0 250 250","aria-hidden":"true"},[v("path",{d:"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"}),v("path.octo-arm",{fill:"currentColor",style:"transform-origin: 130px 106px;",d:"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"}),v("path.octo-body",{fill:"currentColor",d:"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"})]))};class de{generators=new Map;register(e,n,o){this.generators.has(e)&&console.warn(`Generator "${e}" is already registered, overwriting`),this.generators.set(e,{factory:n,uiMetadata:o})}create(e,n,o){const i=this.generators.get(o.name);if(!i)throw new Error(`Unknown generator "${o.name}". Is it registered?`);return i.factory(e,n,o)}getAvailableGenerators(){return Array.from(this.generators.values()).sort((e,n)=>e.uiMetadata.sortHint-n.uiMetadata.sortHint).map(e=>({name:e.uiMetadata.name,displayName:e.uiMetadata.displayName}))}getUIMetadata(e){return this.generators.get(e)?.uiMetadata}getDefaultConfig(e,n,o){const i={name:e,width:n,height:o},t=this.getUIMetadata(e);if(t)for(const s of t.controls)i[s.name]=s.defaultValue;return i}}const Y=new de,X=new de,O=new de;function Ve(l){return function(){let e=l+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}async function ye(l){const{width:e,height:n,pieceSize:o}=l,{pointConfig:i,pieceConfig:t,tabConfig:s}=l;console.log(`rebuilding puzzle with dimensions ${e}x${n}, piece size ${o}`);const r=Y.create(e,n,i),a=X.create(e,n,t),h=O.create(e,n,s),u=l.seed??new Date().getTime(),c=Ve(u),d=r.generatePoints({width:e,height:n,pieceSize:o,random:c});console.log(`Generated ${d.length} points`);const g=a.generatePieces(d,{random:c,pieceSize:o});console.log(`Generated ${g.pieces.size} pieces`);for(const f of g.edges.values())f.heRight!==-1&&h.addTab(f,{topology:g,random:c});const p={created:new Date().toISOString(),seed:u,width:e,height:n,vertices:g.vertices,boundary:g.boundary,pieces:g.pieces,edges:g.edges,halfEdges:g.halfEdges};return Promise.resolve(p)}function be(l,e,n,o=!1){const i=e.getContext("2d");if(!i){console.error("Could not get 2D context from canvas");return}i.clearRect(0,0,e.width,e.height);{i.strokeStyle=n,i.lineWidth=1,i.beginPath();for(const t of l.edges.values()){const s=l.halfEdges.get(t.heLeft);if(s)if(i.moveTo(s.origin[0],s.origin[1]),s.segments)for(const r of s.segments)switch(r.type){case"bezier":i.bezierCurveTo(r.p1[0],r.p1[1],r.p2[0],r.p2[1],r.p3[0],r.p3[1]);break;case"line":i.lineTo(r.p[0],r.p[1]);break}else{let r;s.twin!==-1?r=l.halfEdges.get(s.twin).origin:r=l.halfEdges.get(s.next).origin,i.lineTo(r[0],r[1])}}i.stroke()}if(o){i.fillStyle="red";for(const t of l.pieces.values()){const[s,r]=t.site;i.beginPath(),i.arc(s,r,3,0,2*Math.PI),i.fill()}}}const qe=()=>{const l={canvas:null};return{oncreate:({dom:e,attrs:n})=>{if(l.canvas=e.querySelector("canvas.puzzle"),!l.canvas){console.log("couldn't get canvas element");return}n.isDirty||be(n.puzzle,l.canvas,n.color)},onupdate:({attrs:e})=>{if(!l.canvas){console.log("couldn't get canvas element");return}e.isDirty||be(e.puzzle,l.canvas,e.color)},view:({attrs:e})=>v(".puzzle-stack",[v("img.background",{width:e.width,height:e.height,src:e.imageUrl}),v("canvas.puzzle",{width:e.width,height:e.height,style:{width:`${e.width}px`,height:`${e.height}px`}})])}};function je(l,e,n,o="black"){const t=[];for(const a of l.edges.values()){const h=l.halfEdges.get(a.heLeft);if(h)if(t.push(`M ${h.origin[0].toFixed(3)} ${h.origin[1].toFixed(3)}`),h.segments)for(const u of h.segments)switch(u.type){case"bezier":t.push(`C ${u.p1[0].toFixed(3)} ${u.p1[1].toFixed(3)}, ${u.p2[0].toFixed(3)} ${u.p2[1].toFixed(3)}, ${u.p3[0].toFixed(3)} ${u.p3[1].toFixed(3)}`);break;case"line":t.push(`L ${u.p[0].toFixed(3)} ${u.p[1].toFixed(3)}`);break}else{let u;h.twin!==-1?u=l.halfEdges.get(h.twin).origin:u=l.halfEdges.get(h.next).origin,t.push(`L ${u[0].toFixed(3)} ${u[1].toFixed(3)}`)}}const s=t.join(" ");return`
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg
  width="${e}"
  height="${n}"
  viewBox="0 0 ${e} ${n}"
  xmlns="http://www.w3.org/2000/svg"
  version="1.1"
>
  <path
    d="${s}"
    fill="none"
    stroke="${o}"
    stroke-width="1"
    vector-effect="non-scaling-stroke"
  />
</svg>`.trim().replace(/\r\n/g,`
`)}function We(l,e="puzzle.svg"){const n=new Blob([l],{type:"image/svg+xml"}),o=URL.createObjectURL(n),i=document.createElement("a");i.href=o,i.download=e,i.hidden=!0,document.body.appendChild(i),i.click(),document.body.removeChild(i),setTimeout(()=>URL.revokeObjectURL(o),100)}const Oe={view:({attrs:l})=>v("sl-button.download-svg",{onclick:()=>{const e=je(l.puzzle,l.width,l.height,l.color);We(e,l.filename??"puzzle.svg")}},"Download SVG")};function Be(l,e,n=800){if(l<=n)return{width:l,height:e};const o=e/l;return{width:n,height:Math.round(n*o)}}const Ke=()=>{const l={inputElement:void 0};return{view:({attrs:e})=>[v("sl-button.upload-button",{disabled:e.disabled===!0,onclick:()=>{l.inputElement&&l.inputElement.click()}},e.label??"Upload Image"),v("input[type=file]",{style:{display:"none"},accept:"image/*",oncreate:({dom:n})=>{l.inputElement=n},onchange:n=>{if(n.redraw=!1,l.inputElement){const o=l.inputElement.files?.[0];o?.type.startsWith("image/")&&createImageBitmap(o).then(i=>{const{width:t,height:s}=Be(i.width,i.height),r=URL.createObjectURL(o);i.close(),e.onUpload(r,o.name,t,s)}).catch(i=>{console.error("could not create a bitmap image: ",i)})}}})]}},Ye=()=>({view:({attrs:l})=>v("sl-checkbox.boolean-input",{"help-text":l.config.helpText,disabled:l.disabled,checked:l.value,"onsl-change":e=>{const o=e.target.checked;l.onChange(o)}},l.config.label)}),ce=()=>({view:({attrs:l})=>v("sl-input.number-input",{label:l.config.label,"help-text":l.config.helpText,type:"number",inputmode:"numeric",size:"small",disabled:l.disabled,value:l.value,min:l.config.min,max:l.config.max,"onsl-change":e=>{const o=e.target.valueAsNumber;l.onChange(isNaN(o)?void 0:o)}})}),Xe=()=>({view:({attrs:l})=>v("sl-range.range-input",{label:l.config.label,"help-text":l.config.helpText,disabled:l.disabled,value:l.value,min:l.config.min,max:l.config.max,step:l.config.step,"onsl-change":e=>{const o=e.target.value;l.onChange(isNaN(o)?void 0:o)}})}),Je=()=>({view:({attrs:l})=>v("sl-input.string-input",{label:l.config.label,"help-text":l.config.helpText,type:"text",inputmode:"text",size:"small",disabled:l.disabled,value:l.value,"onsl-change":e=>{const o=e.target.value;l.onChange(o.length>0?o:void 0)}})}),Ze=()=>({oncreate:({dom:l,attrs:e})=>{l.querySelector("sl-tab-group").show(e.generator)},onupdate:({dom:l,attrs:e})=>{l.querySelector("sl-tab-group").show(e.generator)},view:({attrs:l})=>{const e=l.registry.getAvailableGenerators();return v(".generator-picker",v("sl-tab-group",{"onsl-tab-show":n=>{const o=n.detail.name;l.generator!==o&&l.onGeneratorChange(o)}},[...e.map(n=>{const o=l.registry.getUIMetadata(n.name),i=v("sl-tab",{slot:"nav",panel:n.name},n.displayName),t=v("sl-tab-panel",{name:n.name},v(".controls",[o?.description?v("p",o.description):null,...o?.controls.map(s=>{switch(s.type){case"range":return v(Xe,{config:s,value:l.config?.[s.name]??s.defaultValue,onChange:r=>{l.onConfigChange(s.name,r)}});case"boolean":return v(Ye,{config:s,value:(l.config?.[s.name]??s.defaultValue)===!0,onChange:r=>{l.onConfigChange(s.name,r)}});case"number":return v(ce,{config:s,value:l.config?.[s.name]??s.defaultValue,onChange:r=>{l.onConfigChange(s.name,r)}});case"string":return v(Je,{config:s,value:l.config?.[s.name]??s.defaultValue,onChange:r=>{l.onConfigChange(s.name,r)}})}})??[],!o?.description&&o?.controls.length==0?v("p","No controls for this strategy."):null]));return[i,t]})]))}}),we=[["Square","1:1",1],["Classic Photo","5:4",5/4],["Standard Photo","4:3",4/3],["35mm/DSLR","3:2",3/2],["Widescreen","16:9",16/9],["UltraWide","21:9",21/9],["Panorama","2:1",2/1],["Instagram Portrait","4:5",4/5],["Classic Portrait","3:4",3/4],["DSLR Portrait","2:3",2/3],["Phone Portrait","9:16",9/16],["Tall Poster","9:21",9/21],["Tall Panorama","1:2",1/2]],Qe={view:({attrs:l})=>{const e=!we.some(([,,o])=>o===l.ratio),n=we.map(([o,i,t])=>v("sl-option",{value:String(t)},`${o} [${i}]`));return e&&n.unshift(v("sl-option",{value:"custom"},"Custom")),v(".aspect-ratio-picker",[v("sl-select",{label:"Aspect Ratio",size:"small",disabled:l.disabled,value:e?"custom":String(l.ratio),"onsl-change":o=>{o.redraw=!1;const t=o.target.value;t&&t!=="custom"&&l.onChange(Number(t))}},n),v("sl-range",{min:.25,max:4,step:.01,disabled:l.disabled,value:l.ratio,"onsl-change":o=>{o.redraw=!1;const i=o.target;l.onChange(i.value)}})])}},et={view:({attrs:l})=>v(".color-picker",[v(".label",l.label),v("sl-color-picker",{label:"Select a color",value:l.color,size:l.size??"medium",format:"rgb","onsl-change":e=>{e.redraw=!1;const n=e.target;l.onUpdate(n.value)}})])};var te,ve;function Ae(){if(ve)return te;ve=1;function l(n){var o=n.length,i=1,t=new Array(o),s;for(s=o;s>0;s--)t[s-1]=i,i=i*n[s-1];return{stride:t,data:new Uint32Array(i)}}function e(n){var o=n.length,i=1,t=new Array(o),s=[],r,a;for(r=o;r>0;r--)t[r-1]=i,i=i*n[r-1];for(a=0;a<i;a++)s.push([]);return{stride:t,data:s}}return te={integer:l,array:e},te}var ne,_e;function Ge(){if(_e)return ne;_e=1,ne=l;function l(e,n){var o=new Array(e),i=Math.floor(e/2)<<1,t=0,s,r,a,h,u;for(u=0;u<i;u+=2)s=-2*Math.log(n()),r=Math.sqrt(s),a=2*Math.PI*n(),t+=s,o[u]=r*Math.cos(a),o[u+1]=r*Math.sin(a);if(e%2){var c=Math.sqrt(-2*Math.log(n()))*Math.cos(2*Math.PI*n());o[e-1]=c,t+=Math.pow(c,2)}for(h=1/Math.sqrt(t),u=0;u<e;++u)o[u]*=h;return o}return ne}var ie,Pe;function tt(){return Pe||(Pe=1,ie=function(e,n){e=e||1,n=n||2;for(var o=e*2+1,i=Math.pow(o,n)-1,t=new Array(i),s=0;s<i;s++)for(var r=t[s]=new Array(n),a=s<i/2?s:s+1,h=1;h<=n;h++){var u=a%Math.pow(o,h);r[h-1]=u/Math.pow(o,h-1)-e,a-=u}return t}),ie}var se,xe;function $e(){if(xe)return se;xe=1;var l=tt();function e(i){var t=l(2,i),s=[],r;for(t=t.filter(function(a){for(var h=0,u=0;u<i;u++)h+=Math.pow(Math.max(0,Math.abs(a[u])-1),2);return h<i}),r=0;r<i;r++)s.push(0);return t.push(s),t.sort(function(a,h){var u=0,c=0,d;for(d=0;d<i;d++)u+=Math.pow(a[d],2),c+=Math.pow(h[d],2);return u<c?-1:u>c?1:0}),t}var n={};function o(i){return n[i]||(n[i]=e(i)),n[i]}return se=o,se}var oe,De;function nt(){if(De)return oe;De=1;var l=Ae().integer,e=Ge(),n=$e();function o(t,s){for(var r=0,a=0;a<t.length;a++)r+=Math.pow(t[a]-s[a],2);return r}function i(t,s){if(typeof t.distanceFunction=="function")throw new Error("PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction");this.shape=t.shape,this.minDistance=t.minDistance,this.maxDistance=t.maxDistance||t.minDistance*2,this.maxTries=Math.ceil(Math.max(1,t.tries||30)),this.rng=s||Math.random;for(var r=0,a=0;a<this.shape.length;a++)r=Math.max(r,this.shape[a]);var h=Math.max(1,r/128|0),u=1e-14*h;this.dimension=this.shape.length,this.squaredMinDistance=this.minDistance*this.minDistance,this.minDistancePlusEpsilon=this.minDistance+u,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.minDistance/Math.sqrt(this.dimension),this.neighbourhood=n(this.dimension),this.currentPoint=null,this.processList=[],this.samplePoints=[],this.gridShape=[];for(var a=0;a<this.dimension;a++)this.gridShape.push(Math.ceil(this.shape[a]/this.cellSize));this.grid=l(this.gridShape)}return i.prototype.shape=null,i.prototype.dimension=null,i.prototype.minDistance=null,i.prototype.maxDistance=null,i.prototype.minDistancePlusEpsilon=null,i.prototype.squaredMinDistance=null,i.prototype.deltaDistance=null,i.prototype.cellSize=null,i.prototype.maxTries=null,i.prototype.rng=null,i.prototype.neighbourhood=null,i.prototype.currentPoint=null,i.prototype.processList=null,i.prototype.samplePoints=null,i.prototype.gridShape=null,i.prototype.grid=null,i.prototype.addRandomPoint=function(){for(var t=new Array(this.dimension),s=0;s<this.dimension;s++)t[s]=this.rng()*this.shape[s];return this.directAddPoint(t)},i.prototype.addPoint=function(t){var s,r=!0;if(t.length===this.dimension)for(s=0;s<this.dimension&&r;s++)r=t[s]>=0&&t[s]<this.shape[s];else r=!1;return r?this.directAddPoint(t):null},i.prototype.directAddPoint=function(t){var s=0,r=this.grid.stride,a;for(this.processList.push(t),this.samplePoints.push(t),a=0;a<this.dimension;a++)s+=(t[a]/this.cellSize|0)*r[a];return this.grid.data[s]=this.samplePoints.length,t},i.prototype.inNeighbourhood=function(t){var s=this.dimension,r=this.grid.stride,a,h,u,c,d;for(a=0;a<this.neighbourhood.length;a++){for(h=0,u=0;u<s;u++){if(c=(t[u]/this.cellSize|0)+this.neighbourhood[a][u],c<0||c>=this.gridShape[u]){h=-1;break}h+=c*r[u]}if(h!==-1&&this.grid.data[h]!==0&&(d=this.samplePoints[this.grid.data[h]-1],o(t,d)<this.squaredMinDistance))return!0}return!1},i.prototype.next=function(){for(var t,s,r,a,h,u,c;this.processList.length>0;){for(this.currentPoint===null&&(this.currentPoint=this.processList.shift()),a=this.currentPoint,t=0;t<this.maxTries;t++){for(u=!0,r=this.minDistancePlusEpsilon+this.deltaDistance*this.rng(),this.dimension===2?(s=this.rng()*Math.PI*2,h=[Math.cos(s),Math.sin(s)]):h=e(this.dimension,this.rng),c=0;u&&c<this.dimension;c++)h[c]=a[c]+h[c]*r,u=h[c]>=0&&h[c]<this.shape[c];if(u&&!this.inNeighbourhood(h))return this.directAddPoint(h)}t===this.maxTries&&(this.currentPoint=null)}return null},i.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},i.prototype.getAllPoints=function(){return this.samplePoints},i.prototype.getAllPointsWithDistance=function(){throw new Error("PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation")},i.prototype.reset=function(){var t=this.grid.data,s=0;for(s=0;s<t.length;s++)t[s]=0;this.samplePoints=[],this.currentPoint=null,this.processList.length=0},oe=i,oe}var re,Me;function it(){if(Me)return re;Me=1;var l=Ae().array,e=Ge(),n=$e();function o(t,s){for(var r=0,a=0;a<t.length;a++)r+=Math.pow(t[a]-s[a],2);return Math.sqrt(r)}function i(t,s){if(typeof t.distanceFunction!="function")throw new Error("PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction");this.shape=t.shape,this.minDistance=t.minDistance,this.maxDistance=t.maxDistance||t.minDistance*2,this.maxTries=Math.ceil(Math.max(1,t.tries||30)),this.distanceFunction=t.distanceFunction,this.bias=Math.max(0,Math.min(1,t.bias||0)),this.rng=s||Math.random;for(var r=0,a=0;a<this.shape.length;a++)r=Math.max(r,this.shape[a]);var h=Math.max(1,r/128|0),u=1e-14*h;this.dimension=this.shape.length,this.minDistancePlusEpsilon=this.minDistance+u,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.maxDistance/Math.sqrt(this.dimension),this.neighbourhood=n(this.dimension),this.currentPoint=null,this.currentDistance=0,this.processList=[],this.samplePoints=[],this.sampleDistance=[],this.gridShape=[];for(var a=0;a<this.dimension;a++)this.gridShape.push(Math.ceil(this.shape[a]/this.cellSize));this.grid=l(this.gridShape)}return i.prototype.shape=null,i.prototype.dimension=null,i.prototype.minDistance=null,i.prototype.maxDistance=null,i.prototype.minDistancePlusEpsilon=null,i.prototype.deltaDistance=null,i.prototype.cellSize=null,i.prototype.maxTries=null,i.prototype.distanceFunction=null,i.prototype.bias=null,i.prototype.rng=null,i.prototype.neighbourhood=null,i.prototype.currentPoint=null,i.prototype.currentDistance=null,i.prototype.processList=null,i.prototype.samplePoints=null,i.prototype.sampleDistance=null,i.prototype.gridShape=null,i.prototype.grid=null,i.prototype.addRandomPoint=function(){for(var t=new Array(this.dimension),s=0;s<this.dimension;s++)t[s]=this.rng()*this.shape[s];return this.directAddPoint(t)},i.prototype.addPoint=function(t){var s,r=!0;if(t.length===this.dimension)for(s=0;s<this.dimension&&r;s++)r=t[s]>=0&&t[s]<this.shape[s];else r=!1;return r?this.directAddPoint(t):null},i.prototype.directAddPoint=function(t){var s=0,r=this.grid.stride,a=this.samplePoints.length,h;for(this.processList.push(a),this.samplePoints.push(t),this.sampleDistance.push(this.distanceFunction(t)),h=0;h<this.dimension;h++)s+=(t[h]/this.cellSize|0)*r[h];return this.grid.data[s].push(a),t},i.prototype.inNeighbourhood=function(t){var s=this.dimension,r=this.grid.stride,a,h,u,c,d,g,p=this.distanceFunction(t);for(a=0;a<this.neighbourhood.length;a++){for(h=0,u=0;u<s;u++){if(c=(t[u]/this.cellSize|0)+this.neighbourhood[a][u],c<0||c>=this.gridShape[u]){h=-1;break}h+=c*r[u]}if(h!==-1&&this.grid.data[h].length>0)for(var f=0;f<this.grid.data[h].length;f++){d=this.samplePoints[this.grid.data[h][f]],g=this.sampleDistance[this.grid.data[h][f]];var y=Math.min(g,p),m=Math.max(g,p),b=y+(m-y)*this.bias;if(o(t,d)<this.minDistance+this.deltaDistance*b)return!0}}return!1},i.prototype.next=function(){for(var t,s,r,a,h,u,c,d;this.processList.length>0;){if(this.currentPoint===null){var g=this.processList.shift();this.currentPoint=this.samplePoints[g],this.currentDistance=this.sampleDistance[g]}for(a=this.currentPoint,h=this.currentDistance,t=0;t<this.maxTries;t++){for(c=!0,r=this.minDistancePlusEpsilon+this.deltaDistance*(h+(1-h)*this.bias),this.dimension===2?(s=this.rng()*Math.PI*2,u=[Math.cos(s),Math.sin(s)]):u=e(this.dimension,this.rng),d=0;c&&d<this.dimension;d++)u[d]=a[d]+u[d]*r,c=u[d]>=0&&u[d]<this.shape[d];if(c&&!this.inNeighbourhood(u))return this.directAddPoint(u)}t===this.maxTries&&(this.currentPoint=null)}return null},i.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},i.prototype.getAllPoints=function(){return this.samplePoints},i.prototype.getAllPointsWithDistance=function(){var t=new Array(this.samplePoints.length),s=0,r=0,a;for(s=0;s<this.samplePoints.length;s++){for(a=new Array(this.dimension+1),r=0;r<this.dimension;r++)a[r]=this.samplePoints[s][r];a[this.dimension]=this.sampleDistance[s],t[s]=a}return t},i.prototype.reset=function(){var t=this.grid.data,s=0;for(s=0;s<t.length;s++)t[s]=[];this.samplePoints=[],this.currentPoint=null,this.processList.length=0},re=i,re}var ae,Te;function st(){if(Te)return ae;Te=1;var l=nt(),e=it();function n(o,i){this.shape=o.shape,typeof o.distanceFunction=="function"?this.implementation=new e(o,i):this.implementation=new l(o,i)}return n.prototype.implementation=null,n.prototype.addRandomPoint=function(){return this.implementation.addRandomPoint()},n.prototype.addPoint=function(o){return this.implementation.addPoint(o)},n.prototype.next=function(){return this.implementation.next()},n.prototype.fill=function(){return this.implementation.fill()},n.prototype.getAllPoints=function(){return this.implementation.getAllPoints()},n.prototype.getAllPointsWithDistance=function(){return this.implementation.getAllPointsWithDistance()},n.prototype.reset=function(){this.implementation.reset()},ae=n,ae}var ot=st();const rt=He(ot),ge="PoissonPointGenerator",at={name:ge,displayName:"Poisson",description:"Generate seed points using Poisson disk sampling. The algorithm produces points that are tightly-packed, but no closer to each other than a specified minimum distance (the piece size), resulting in a natural, organic look.",sortHint:1,controls:[]},lt=(l,e,n)=>({generatePoints(i){const{width:t,height:s,pieceSize:r,random:a}=i;return new rt({shape:[t,s],minDistance:r,tries:20},a).fill()}});Y.register(ge,lt,at);const N=11102230246251565e-32,R=134217729,ht=(3+8*N)*N;function le(l,e,n,o,i){let t,s,r,a,h=e[0],u=o[0],c=0,d=0;u>h==u>-h?(t=h,h=e[++c]):(t=u,u=o[++d]);let g=0;if(c<l&&d<n)for(u>h==u>-h?(s=h+t,r=t-(s-h),h=e[++c]):(s=u+t,r=t-(s-u),u=o[++d]),t=s,r!==0&&(i[g++]=r);c<l&&d<n;)u>h==u>-h?(s=t+h,a=s-t,r=t-(s-a)+(h-a),h=e[++c]):(s=t+u,a=s-t,r=t-(s-a)+(u-a),u=o[++d]),t=s,r!==0&&(i[g++]=r);for(;c<l;)s=t+h,a=s-t,r=t-(s-a)+(h-a),h=e[++c],t=s,r!==0&&(i[g++]=r);for(;d<n;)s=t+u,a=s-t,r=t-(s-a)+(u-a),u=o[++d],t=s,r!==0&&(i[g++]=r);return(t!==0||g===0)&&(i[g++]=t),g}function ct(l,e){let n=e[0];for(let o=1;o<l;o++)n+=e[o];return n}function J(l){return new Float64Array(l)}const ut=(3+16*N)*N,dt=(2+12*N)*N,gt=(9+64*N)*N*N,q=J(4),Se=J(8),ze=J(12),Ce=J(16),L=J(4);function ft(l,e,n,o,i,t,s){let r,a,h,u,c,d,g,p,f,y,m,b,_,P,M,I,S,C;const w=l-i,T=n-i,D=e-t,x=o-t;P=w*x,d=R*w,g=d-(d-w),p=w-g,d=R*x,f=d-(d-x),y=x-f,M=p*y-(P-g*f-p*f-g*y),I=D*T,d=R*D,g=d-(d-D),p=D-g,d=R*T,f=d-(d-T),y=T-f,S=p*y-(I-g*f-p*f-g*y),m=M-S,c=M-m,q[0]=M-(m+c)+(c-S),b=P+m,c=b-P,_=P-(b-c)+(m-c),m=_-I,c=_-m,q[1]=_-(m+c)+(c-I),C=b+m,c=C-b,q[2]=b-(C-c)+(m-c),q[3]=C;let k=ct(4,q),G=dt*s;if(k>=G||-k>=G||(c=l-w,r=l-(w+c)+(c-i),c=n-T,h=n-(T+c)+(c-i),c=e-D,a=e-(D+c)+(c-t),c=o-x,u=o-(x+c)+(c-t),r===0&&a===0&&h===0&&u===0)||(G=gt*s+ht*Math.abs(k),k+=w*u+x*r-(D*h+T*a),k>=G||-k>=G))return k;P=r*x,d=R*r,g=d-(d-r),p=r-g,d=R*x,f=d-(d-x),y=x-f,M=p*y-(P-g*f-p*f-g*y),I=a*T,d=R*a,g=d-(d-a),p=a-g,d=R*T,f=d-(d-T),y=T-f,S=p*y-(I-g*f-p*f-g*y),m=M-S,c=M-m,L[0]=M-(m+c)+(c-S),b=P+m,c=b-P,_=P-(b-c)+(m-c),m=_-I,c=_-m,L[1]=_-(m+c)+(c-I),C=b+m,c=C-b,L[2]=b-(C-c)+(m-c),L[3]=C;const $=le(4,q,4,L,Se);P=w*u,d=R*w,g=d-(d-w),p=w-g,d=R*u,f=d-(d-u),y=u-f,M=p*y-(P-g*f-p*f-g*y),I=D*h,d=R*D,g=d-(d-D),p=D-g,d=R*h,f=d-(d-h),y=h-f,S=p*y-(I-g*f-p*f-g*y),m=M-S,c=M-m,L[0]=M-(m+c)+(c-S),b=P+m,c=b-P,_=P-(b-c)+(m-c),m=_-I,c=_-m,L[1]=_-(m+c)+(c-I),C=b+m,c=C-b,L[2]=b-(C-c)+(m-c),L[3]=C;const z=le($,Se,4,L,ze);P=r*u,d=R*r,g=d-(d-r),p=r-g,d=R*u,f=d-(d-u),y=u-f,M=p*y-(P-g*f-p*f-g*y),I=a*h,d=R*a,g=d-(d-a),p=a-g,d=R*h,f=d-(d-h),y=h-f,S=p*y-(I-g*f-p*f-g*y),m=M-S,c=M-m,L[0]=M-(m+c)+(c-S),b=P+m,c=b-P,_=P-(b-c)+(m-c),m=_-I,c=_-m,L[1]=_-(m+c)+(c-I),C=b+m,c=C-b,L[2]=b-(C-c)+(m-c),L[3]=C;const A=le(z,ze,4,L,Ce);return Ce[A-1]}function Z(l,e,n,o,i,t){const s=(e-t)*(n-i),r=(l-i)*(o-t),a=s-r,h=Math.abs(s+r);return Math.abs(a)>=ut*h?a:-ft(l,e,n,o,i,t,h)}const Ie=Math.pow(2,-52),Q=new Uint32Array(512);class ee{static from(e,n=wt,o=vt){const i=e.length,t=new Float64Array(i*2);for(let s=0;s<i;s++){const r=e[s];t[2*s]=n(r),t[2*s+1]=o(r)}return new ee(t)}constructor(e){const n=e.length>>1;if(n>0&&typeof e[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=e;const o=Math.max(2*n-5,0);this._triangles=new Uint32Array(o*3),this._halfedges=new Int32Array(o*3),this._hashSize=Math.ceil(Math.sqrt(n)),this._hullPrev=new Uint32Array(n),this._hullNext=new Uint32Array(n),this._hullTri=new Uint32Array(n),this._hullHash=new Int32Array(this._hashSize),this._ids=new Uint32Array(n),this._dists=new Float64Array(n),this.update()}update(){const{coords:e,_hullPrev:n,_hullNext:o,_hullTri:i,_hullHash:t}=this,s=e.length>>1;let r=1/0,a=1/0,h=-1/0,u=-1/0;for(let w=0;w<s;w++){const T=e[2*w],D=e[2*w+1];T<r&&(r=T),D<a&&(a=D),T>h&&(h=T),D>u&&(u=D),this._ids[w]=w}const c=(r+h)/2,d=(a+u)/2;let g,p,f;for(let w=0,T=1/0;w<s;w++){const D=he(c,d,e[2*w],e[2*w+1]);D<T&&(g=w,T=D)}const y=e[2*g],m=e[2*g+1];for(let w=0,T=1/0;w<s;w++){if(w===g)continue;const D=he(y,m,e[2*w],e[2*w+1]);D<T&&D>0&&(p=w,T=D)}let b=e[2*p],_=e[2*p+1],P=1/0;for(let w=0;w<s;w++){if(w===g||w===p)continue;const T=yt(y,m,b,_,e[2*w],e[2*w+1]);T<P&&(f=w,P=T)}let M=e[2*f],I=e[2*f+1];if(P===1/0){for(let D=0;D<s;D++)this._dists[D]=e[2*D]-e[0]||e[2*D+1]-e[1];W(this._ids,this._dists,0,s-1);const w=new Uint32Array(s);let T=0;for(let D=0,x=-1/0;D<s;D++){const k=this._ids[D],G=this._dists[k];G>x&&(w[T++]=k,x=G)}this.hull=w.subarray(0,T),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(Z(y,m,b,_,M,I)<0){const w=p,T=b,D=_;p=f,b=M,_=I,f=w,M=T,I=D}const S=bt(y,m,b,_,M,I);this._cx=S.x,this._cy=S.y;for(let w=0;w<s;w++)this._dists[w]=he(e[2*w],e[2*w+1],S.x,S.y);W(this._ids,this._dists,0,s-1),this._hullStart=g;let C=3;o[g]=n[f]=p,o[p]=n[g]=f,o[f]=n[p]=g,i[g]=0,i[p]=1,i[f]=2,t.fill(-1),t[this._hashKey(y,m)]=g,t[this._hashKey(b,_)]=p,t[this._hashKey(M,I)]=f,this.trianglesLen=0,this._addTriangle(g,p,f,-1,-1,-1);for(let w=0,T,D;w<this._ids.length;w++){const x=this._ids[w],k=e[2*x],G=e[2*x+1];if(w>0&&Math.abs(k-T)<=Ie&&Math.abs(G-D)<=Ie||(T=k,D=G,x===g||x===p||x===f))continue;let $=0;for(let V=0,Ne=this._hashKey(k,G);V<this._hashSize&&($=t[(Ne+V)%this._hashSize],!($!==-1&&$!==o[$]));V++);$=n[$];let z=$,A;for(;A=o[z],Z(k,G,e[2*z],e[2*z+1],e[2*A],e[2*A+1])>=0;)if(z=A,z===$){z=-1;break}if(z===-1)continue;let U=this._addTriangle(z,x,o[z],-1,-1,i[z]);i[x]=this._legalize(U+2),i[z]=U,C++;let E=o[z];for(;A=o[E],Z(k,G,e[2*E],e[2*E+1],e[2*A],e[2*A+1])<0;)U=this._addTriangle(E,x,A,i[x],-1,i[E]),i[x]=this._legalize(U+2),o[E]=E,C--,E=A;if(z===$)for(;A=n[z],Z(k,G,e[2*A],e[2*A+1],e[2*z],e[2*z+1])<0;)U=this._addTriangle(A,x,z,-1,i[z],i[A]),this._legalize(U+2),i[A]=U,o[z]=z,C--,z=A;this._hullStart=n[x]=z,o[z]=n[E]=x,o[x]=E,t[this._hashKey(k,G)]=x,t[this._hashKey(e[2*z],e[2*z+1])]=z}this.hull=new Uint32Array(C);for(let w=0,T=this._hullStart;w<C;w++)this.hull[w]=T,T=o[T];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(e,n){return Math.floor(pt(e-this._cx,n-this._cy)*this._hashSize)%this._hashSize}_legalize(e){const{_triangles:n,_halfedges:o,coords:i}=this;let t=0,s=0;for(;;){const r=o[e],a=e-e%3;if(s=a+(e+2)%3,r===-1){if(t===0)break;e=Q[--t];continue}const h=r-r%3,u=a+(e+1)%3,c=h+(r+2)%3,d=n[s],g=n[e],p=n[u],f=n[c];if(mt(i[2*d],i[2*d+1],i[2*g],i[2*g+1],i[2*p],i[2*p+1],i[2*f],i[2*f+1])){n[e]=f,n[r]=d;const m=o[c];if(m===-1){let _=this._hullStart;do{if(this._hullTri[_]===c){this._hullTri[_]=e;break}_=this._hullPrev[_]}while(_!==this._hullStart)}this._link(e,m),this._link(r,o[s]),this._link(s,c);const b=h+(r+1)%3;t<Q.length&&(Q[t++]=b)}else{if(t===0)break;e=Q[--t]}}return s}_link(e,n){this._halfedges[e]=n,n!==-1&&(this._halfedges[n]=e)}_addTriangle(e,n,o,i,t,s){const r=this.trianglesLen;return this._triangles[r]=e,this._triangles[r+1]=n,this._triangles[r+2]=o,this._link(r,i),this._link(r+1,t),this._link(r+2,s),this.trianglesLen+=3,r}}function pt(l,e){const n=l/(Math.abs(l)+Math.abs(e));return(e>0?3-n:1+n)/4}function he(l,e,n,o){const i=l-n,t=e-o;return i*i+t*t}function mt(l,e,n,o,i,t,s,r){const a=l-s,h=e-r,u=n-s,c=o-r,d=i-s,g=t-r,p=a*a+h*h,f=u*u+c*c,y=d*d+g*g;return a*(c*y-f*g)-h*(u*y-f*d)+p*(u*g-c*d)<0}function yt(l,e,n,o,i,t){const s=n-l,r=o-e,a=i-l,h=t-e,u=s*s+r*r,c=a*a+h*h,d=.5/(s*h-r*a),g=(h*u-r*c)*d,p=(s*c-a*u)*d;return g*g+p*p}function bt(l,e,n,o,i,t){const s=n-l,r=o-e,a=i-l,h=t-e,u=s*s+r*r,c=a*a+h*h,d=.5/(s*h-r*a),g=l+(h*u-r*c)*d,p=e+(s*c-a*u)*d;return{x:g,y:p}}function W(l,e,n,o){if(o-n<=20)for(let i=n+1;i<=o;i++){const t=l[i],s=e[t];let r=i-1;for(;r>=n&&e[l[r]]>s;)l[r+1]=l[r--];l[r+1]=t}else{const i=n+o>>1;let t=n+1,s=o;B(l,i,t),e[l[n]]>e[l[o]]&&B(l,n,o),e[l[t]]>e[l[o]]&&B(l,t,o),e[l[n]]>e[l[t]]&&B(l,n,t);const r=l[t],a=e[r];for(;;){do t++;while(e[l[t]]<a);do s--;while(e[l[s]]>a);if(s<t)break;B(l,t,s)}l[n+1]=l[s],l[s]=r,o-t+1>=s-n?(W(l,e,t,o),W(l,e,n,s-1)):(W(l,e,n,s-1),W(l,e,t,o))}}function B(l,e,n){const o=l[e];l[e]=l[n],l[n]=o}function wt(l){return l[0]}function vt(l){return l[1]}const ke=1e-6;class F{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(e,n){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+n}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(e,n){this._+=`L${this._x1=+e},${this._y1=+n}`}arc(e,n,o){e=+e,n=+n,o=+o;const i=e+o,t=n;if(o<0)throw new Error("negative radius");this._x1===null?this._+=`M${i},${t}`:(Math.abs(this._x1-i)>ke||Math.abs(this._y1-t)>ke)&&(this._+="L"+i+","+t),o&&(this._+=`A${o},${o},0,1,1,${e-o},${n}A${o},${o},0,1,1,${this._x1=i},${this._y1=t}`)}rect(e,n,o,i){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+n}h${+o}v${+i}h${-o}Z`}value(){return this._||null}}class ue{constructor(){this._=[]}moveTo(e,n){this._.push([e,n])}closePath(){this._.push(this._[0].slice())}lineTo(e,n){this._.push([e,n])}value(){return this._.length?this._:null}}class _t{constructor(e,[n,o,i,t]=[0,0,960,500]){if(!((i=+i)>=(n=+n))||!((t=+t)>=(o=+o)))throw new Error("invalid bounds");this.delaunay=e,this._circumcenters=new Float64Array(e.points.length*2),this.vectors=new Float64Array(e.points.length*2),this.xmax=i,this.xmin=n,this.ymax=t,this.ymin=o,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:e,hull:n,triangles:o},vectors:i}=this;let t,s;const r=this.circumcenters=this._circumcenters.subarray(0,o.length/3*2);for(let f=0,y=0,m=o.length,b,_;f<m;f+=3,y+=2){const P=o[f]*2,M=o[f+1]*2,I=o[f+2]*2,S=e[P],C=e[P+1],w=e[M],T=e[M+1],D=e[I],x=e[I+1],k=w-S,G=T-C,$=D-S,z=x-C,A=(k*z-G*$)*2;if(Math.abs(A)<1e-9){if(t===void 0){t=s=0;for(const E of n)t+=e[E*2],s+=e[E*2+1];t/=n.length,s/=n.length}const U=1e9*Math.sign((t-S)*z-(s-C)*$);b=(S+D)/2-U*z,_=(C+x)/2+U*$}else{const U=1/A,E=k*k+G*G,V=$*$+z*z;b=S+(z*E-G*V)*U,_=C+(k*V-$*E)*U}r[y]=b,r[y+1]=_}let a=n[n.length-1],h,u=a*4,c,d=e[2*a],g,p=e[2*a+1];i.fill(0);for(let f=0;f<n.length;++f)a=n[f],h=u,c=d,g=p,u=a*4,d=e[2*a],p=e[2*a+1],i[h+2]=i[u]=g-p,i[h+3]=i[u+1]=d-c}render(e){const n=e==null?e=new F:void 0,{delaunay:{halfedges:o,inedges:i,hull:t},circumcenters:s,vectors:r}=this;if(t.length<=1)return null;for(let u=0,c=o.length;u<c;++u){const d=o[u];if(d<u)continue;const g=Math.floor(u/3)*2,p=Math.floor(d/3)*2,f=s[g],y=s[g+1],m=s[p],b=s[p+1];this._renderSegment(f,y,m,b,e)}let a,h=t[t.length-1];for(let u=0;u<t.length;++u){a=h,h=t[u];const c=Math.floor(i[h]/3)*2,d=s[c],g=s[c+1],p=a*4,f=this._project(d,g,r[p+2],r[p+3]);f&&this._renderSegment(d,g,f[0],f[1],e)}return n&&n.value()}renderBounds(e){const n=e==null?e=new F:void 0;return e.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),n&&n.value()}renderCell(e,n){const o=n==null?n=new F:void 0,i=this._clip(e);if(i===null||!i.length)return;n.moveTo(i[0],i[1]);let t=i.length;for(;i[0]===i[t-2]&&i[1]===i[t-1]&&t>1;)t-=2;for(let s=2;s<t;s+=2)(i[s]!==i[s-2]||i[s+1]!==i[s-1])&&n.lineTo(i[s],i[s+1]);return n.closePath(),o&&o.value()}*cellPolygons(){const{delaunay:{points:e}}=this;for(let n=0,o=e.length/2;n<o;++n){const i=this.cellPolygon(n);i&&(i.index=n,yield i)}}cellPolygon(e){const n=new ue;return this.renderCell(e,n),n.value()}_renderSegment(e,n,o,i,t){let s;const r=this._regioncode(e,n),a=this._regioncode(o,i);r===0&&a===0?(t.moveTo(e,n),t.lineTo(o,i)):(s=this._clipSegment(e,n,o,i,r,a))&&(t.moveTo(s[0],s[1]),t.lineTo(s[2],s[3]))}contains(e,n,o){return n=+n,n!==n||(o=+o,o!==o)?!1:this.delaunay._step(e,n,o)===e}*neighbors(e){const n=this._clip(e);if(n)for(const o of this.delaunay.neighbors(e)){const i=this._clip(o);if(i){e:for(let t=0,s=n.length;t<s;t+=2)for(let r=0,a=i.length;r<a;r+=2)if(n[t]===i[r]&&n[t+1]===i[r+1]&&n[(t+2)%s]===i[(r+a-2)%a]&&n[(t+3)%s]===i[(r+a-1)%a]){yield o;break e}}}}_cell(e){const{circumcenters:n,delaunay:{inedges:o,halfedges:i,triangles:t}}=this,s=o[e];if(s===-1)return null;const r=[];let a=s;do{const h=Math.floor(a/3);if(r.push(n[h*2],n[h*2+1]),a=a%3===2?a-2:a+1,t[a]!==e)break;a=i[a]}while(a!==s&&a!==-1);return r}_clip(e){if(e===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const n=this._cell(e);if(n===null)return null;const{vectors:o}=this,i=e*4;return this._simplify(o[i]||o[i+1]?this._clipInfinite(e,n,o[i],o[i+1],o[i+2],o[i+3]):this._clipFinite(e,n))}_clipFinite(e,n){const o=n.length;let i=null,t,s,r=n[o-2],a=n[o-1],h,u=this._regioncode(r,a),c,d=0;for(let g=0;g<o;g+=2)if(t=r,s=a,r=n[g],a=n[g+1],h=u,u=this._regioncode(r,a),h===0&&u===0)c=d,d=0,i?i.push(r,a):i=[r,a];else{let p,f,y,m,b;if(h===0){if((p=this._clipSegment(t,s,r,a,h,u))===null)continue;[f,y,m,b]=p}else{if((p=this._clipSegment(r,a,t,s,u,h))===null)continue;[m,b,f,y]=p,c=d,d=this._edgecode(f,y),c&&d&&this._edge(e,c,d,i,i.length),i?i.push(f,y):i=[f,y]}c=d,d=this._edgecode(m,b),c&&d&&this._edge(e,c,d,i,i.length),i?i.push(m,b):i=[m,b]}if(i)c=d,d=this._edgecode(i[0],i[1]),c&&d&&this._edge(e,c,d,i,i.length);else if(this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return i}_clipSegment(e,n,o,i,t,s){const r=t<s;for(r&&([e,n,o,i,t,s]=[o,i,e,n,s,t]);;){if(t===0&&s===0)return r?[o,i,e,n]:[e,n,o,i];if(t&s)return null;let a,h,u=t||s;u&8?(a=e+(o-e)*(this.ymax-n)/(i-n),h=this.ymax):u&4?(a=e+(o-e)*(this.ymin-n)/(i-n),h=this.ymin):u&2?(h=n+(i-n)*(this.xmax-e)/(o-e),a=this.xmax):(h=n+(i-n)*(this.xmin-e)/(o-e),a=this.xmin),t?(e=a,n=h,t=this._regioncode(e,n)):(o=a,i=h,s=this._regioncode(o,i))}}_clipInfinite(e,n,o,i,t,s){let r=Array.from(n),a;if((a=this._project(r[0],r[1],o,i))&&r.unshift(a[0],a[1]),(a=this._project(r[r.length-2],r[r.length-1],t,s))&&r.push(a[0],a[1]),r=this._clipFinite(e,r))for(let h=0,u=r.length,c,d=this._edgecode(r[u-2],r[u-1]);h<u;h+=2)c=d,d=this._edgecode(r[h],r[h+1]),c&&d&&(h=this._edge(e,c,d,r,h),u=r.length);else this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(r=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return r}_edge(e,n,o,i,t){for(;n!==o;){let s,r;switch(n){case 5:n=4;continue;case 4:n=6,s=this.xmax,r=this.ymin;break;case 6:n=2;continue;case 2:n=10,s=this.xmax,r=this.ymax;break;case 10:n=8;continue;case 8:n=9,s=this.xmin,r=this.ymax;break;case 9:n=1;continue;case 1:n=5,s=this.xmin,r=this.ymin;break}(i[t]!==s||i[t+1]!==r)&&this.contains(e,s,r)&&(i.splice(t,0,s,r),t+=2)}return t}_project(e,n,o,i){let t=1/0,s,r,a;if(i<0){if(n<=this.ymin)return null;(s=(this.ymin-n)/i)<t&&(a=this.ymin,r=e+(t=s)*o)}else if(i>0){if(n>=this.ymax)return null;(s=(this.ymax-n)/i)<t&&(a=this.ymax,r=e+(t=s)*o)}if(o>0){if(e>=this.xmax)return null;(s=(this.xmax-e)/o)<t&&(r=this.xmax,a=n+(t=s)*i)}else if(o<0){if(e<=this.xmin)return null;(s=(this.xmin-e)/o)<t&&(r=this.xmin,a=n+(t=s)*i)}return[r,a]}_edgecode(e,n){return(e===this.xmin?1:e===this.xmax?2:0)|(n===this.ymin?4:n===this.ymax?8:0)}_regioncode(e,n){return(e<this.xmin?1:e>this.xmax?2:0)|(n<this.ymin?4:n>this.ymax?8:0)}_simplify(e){if(e&&e.length>4){for(let n=0;n<e.length;n+=2){const o=(n+2)%e.length,i=(n+4)%e.length;(e[n]===e[o]&&e[o]===e[i]||e[n+1]===e[o+1]&&e[o+1]===e[i+1])&&(e.splice(o,2),n-=2)}e.length||(e=null)}return e}}const Pt=2*Math.PI,j=Math.pow;function xt(l){return l[0]}function Dt(l){return l[1]}function Mt(l){const{triangles:e,coords:n}=l;for(let o=0;o<e.length;o+=3){const i=2*e[o],t=2*e[o+1],s=2*e[o+2];if((n[s]-n[i])*(n[t+1]-n[i+1])-(n[t]-n[i])*(n[s+1]-n[i+1])>1e-10)return!1}return!0}function Tt(l,e,n){return[l+Math.sin(l+e)*n,e+Math.cos(l-e)*n]}class fe{static from(e,n=xt,o=Dt,i){return new fe("length"in e?St(e,n,o,i):Float64Array.from(zt(e,n,o,i)))}constructor(e){this._delaunator=new ee(e),this.inedges=new Int32Array(e.length/2),this._hullIndex=new Int32Array(e.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const e=this._delaunator,n=this.points;if(e.hull&&e.hull.length>2&&Mt(e)){this.collinear=Int32Array.from({length:n.length/2},(d,g)=>g).sort((d,g)=>n[2*d]-n[2*g]||n[2*d+1]-n[2*g+1]);const a=this.collinear[0],h=this.collinear[this.collinear.length-1],u=[n[2*a],n[2*a+1],n[2*h],n[2*h+1]],c=1e-8*Math.hypot(u[3]-u[1],u[2]-u[0]);for(let d=0,g=n.length/2;d<g;++d){const p=Tt(n[2*d],n[2*d+1],c);n[2*d]=p[0],n[2*d+1]=p[1]}this._delaunator=new ee(n)}else delete this.collinear;const o=this.halfedges=this._delaunator.halfedges,i=this.hull=this._delaunator.hull,t=this.triangles=this._delaunator.triangles,s=this.inedges.fill(-1),r=this._hullIndex.fill(-1);for(let a=0,h=o.length;a<h;++a){const u=t[a%3===2?a-2:a+1];(o[a]===-1||s[u]===-1)&&(s[u]=a)}for(let a=0,h=i.length;a<h;++a)r[i[a]]=a;i.length<=2&&i.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=i[0],s[i[0]]=1,i.length===2&&(s[i[1]]=0,this.triangles[1]=i[1],this.triangles[2]=i[1]))}voronoi(e){return new _t(this,e)}*neighbors(e){const{inedges:n,hull:o,_hullIndex:i,halfedges:t,triangles:s,collinear:r}=this;if(r){const c=r.indexOf(e);c>0&&(yield r[c-1]),c<r.length-1&&(yield r[c+1]);return}const a=n[e];if(a===-1)return;let h=a,u=-1;do{if(yield u=s[h],h=h%3===2?h-2:h+1,s[h]!==e)return;if(h=t[h],h===-1){const c=o[(i[e]+1)%o.length];c!==u&&(yield c);return}}while(h!==a)}find(e,n,o=0){if(e=+e,e!==e||(n=+n,n!==n))return-1;const i=o;let t;for(;(t=this._step(o,e,n))>=0&&t!==o&&t!==i;)o=t;return t}_step(e,n,o){const{inedges:i,hull:t,_hullIndex:s,halfedges:r,triangles:a,points:h}=this;if(i[e]===-1||!h.length)return(e+1)%(h.length>>1);let u=e,c=j(n-h[e*2],2)+j(o-h[e*2+1],2);const d=i[e];let g=d;do{let p=a[g];const f=j(n-h[p*2],2)+j(o-h[p*2+1],2);if(f<c&&(c=f,u=p),g=g%3===2?g-2:g+1,a[g]!==e)break;if(g=r[g],g===-1){if(g=t[(s[e]+1)%t.length],g!==p&&j(n-h[g*2],2)+j(o-h[g*2+1],2)<c)return g;break}}while(g!==d);return u}render(e){const n=e==null?e=new F:void 0,{points:o,halfedges:i,triangles:t}=this;for(let s=0,r=i.length;s<r;++s){const a=i[s];if(a<s)continue;const h=t[s]*2,u=t[a]*2;e.moveTo(o[h],o[h+1]),e.lineTo(o[u],o[u+1])}return this.renderHull(e),n&&n.value()}renderPoints(e,n){n===void 0&&(!e||typeof e.moveTo!="function")&&(n=e,e=null),n=n==null?2:+n;const o=e==null?e=new F:void 0,{points:i}=this;for(let t=0,s=i.length;t<s;t+=2){const r=i[t],a=i[t+1];e.moveTo(r+n,a),e.arc(r,a,n,0,Pt)}return o&&o.value()}renderHull(e){const n=e==null?e=new F:void 0,{hull:o,points:i}=this,t=o[0]*2,s=o.length;e.moveTo(i[t],i[t+1]);for(let r=1;r<s;++r){const a=2*o[r];e.lineTo(i[a],i[a+1])}return e.closePath(),n&&n.value()}hullPolygon(){const e=new ue;return this.renderHull(e),e.value()}renderTriangle(e,n){const o=n==null?n=new F:void 0,{points:i,triangles:t}=this,s=t[e*=3]*2,r=t[e+1]*2,a=t[e+2]*2;return n.moveTo(i[s],i[s+1]),n.lineTo(i[r],i[r+1]),n.lineTo(i[a],i[a+1]),n.closePath(),o&&o.value()}*trianglePolygons(){const{triangles:e}=this;for(let n=0,o=e.length/3;n<o;++n)yield this.trianglePolygon(n)}trianglePolygon(e){const n=new ue;return this.renderTriangle(e,n),n.value()}}function St(l,e,n,o){const i=l.length,t=new Float64Array(i*2);for(let s=0;s<i;++s){const r=l[s];t[s*2]=e.call(o,r,s,l),t[s*2+1]=n.call(o,r,s,l)}return t}function*zt(l,e,n,o){let i=0;for(const t of l)yield e.call(o,t,i,l),yield n.call(o,t,i,l),++i}let Ct=0;function H(){return Ct++}const pe="VoronoiPieceGenerator",It={name:pe,displayName:"Voronoi",description:"Construct pieces by building a Voronoi diagram from the seed points. Each piece consists of all area of the plane closer to its seed point than any other seed point. In practice, this creates irregular polygons with 3-8 sides.",sortHint:1,controls:[]};function kt(l){if(l.length===0)return[0,0,0,0];let e=l[0][0],n=l[0][1],o=e,i=n;for(let t=1;t<l.length;t++){const s=l[t];e=Math.min(e,s[0]),n=Math.min(n,s[1]),o=Math.max(o,s[0]),i=Math.max(i,s[1])}return[e,n,o,i]}function At(l,e){const n=l.length;for(let o=0;o<n;o++){const i=e.get(l[o]);i.next=l[(o+1)%n],i.prev=l[(o-1+n)%n]}}function K(l){return`${l[0].toPrecision(7)},${l[1].toPrecision(7)}`}function Gt(l,e){return Math.abs(l[0]-e[0])<1e-6&&Math.abs(l[1]-e[1])<1e-6}const $t=(l,e,n)=>({generatePieces(i,t){console.log(`VoronoiPieceGenerator using dimensions ${l}x${e}`);const r=fe.from(i).voronoi([0,0,l,e]),a={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},h=new Map;for(let c=0;c<i.length;c++){const d=i[c],g=r.cellPolygon(c);if(!g)continue;const p={id:c,site:d,halfEdge:-1,bbox:kt(g)},f=[];for(let y=0;y<g.length-1;y++){const m=g[y],b=g[y+1];if(Gt(m,b))continue;const _={id:H(),origin:m,twin:-1,next:-1,prev:-1,piece:c};a.halfEdges.set(_.id,_),f.push(_.id);const P=`${K(m)}-${K(b)}`;h.set(P,_.id)}f.length!==0&&(At(f,a.halfEdges),p.halfEdge=f[0],a.pieces.set(c,p))}for(const c of a.halfEdges.values()){if(c.twin!==-1)continue;const d=a.halfEdges.get(c.next),g=c.origin,p=d.origin,f=`${K(p)}-${K(g)}`,y=h.get(f),m=H();let b;if(y!==void 0){const _=a.halfEdges.get(y);c.twin=_.id,_.twin=c.id,b={id:m,heLeft:c.id,heRight:_.id}}else b={id:m,heLeft:c.id,heRight:-1},a.boundary.push(m);a.edges.set(m,b)}const u=new Map;for(const c of a.halfEdges.values()){const d=K(c.origin);u.has(d)||u.set(d,c.origin)}return a.vertices=Array.from(u.values()),a}});X.register(pe,$t,It);const me="TraditionalTabGenerator",Et={name:me,displayName:"Traditional",description:"Creates a traditional rounded tab for each (internal) piece edge.",sortHint:1,controls:[{type:"range",name:"size",label:"Tab Size",defaultValue:20,min:1,max:100,step:1,helpText:"Size of each tab as a percent relative to its edge length"},{type:"range",name:"jitter",label:"Randomness",defaultValue:8,min:0,max:100,step:1,helpText:"Adds randomness to the tab shape. 0 means completely uniform tabs"},{type:"number",name:"minTabSize",label:"Minimum Tab Size",defaultValue:20,optional:!0,helpText:"If provided, tabs will not generate on edges shorter than this value"},{type:"number",name:"maxTabSize",label:"Maximum Tab Width",optional:!0,helpText:"If provided, the width of a tab's features will be clamped to this value"}]};function Rt(l,e,n,o,i,t=!1,s){const r=e[0]-l[0],a=e[1]-l[1],h=Math.hypot(r,a);if(h===0)throw new Error("Edge has zero length");const u=[r/h,a/h],c=[-u[1],u[0]],d=(D,x)=>[l[0]+(u[0]*D+c[0]*x)*h,l[1]+(u[1]*D+c[1]*x)*h],g=o/100,p=()=>(i()*2-1)*g,f=p(),y=p(),m=p(),b=p(),_=p();let P=n/200;s&&4*P*h>s&&(P=s/(4*h));const M=t?-1:1,S=[[0,0],[.2,f],[.5+y+b,M*(-P+m)],[.5-P+y,M*(P+m)],[.5-2*P+y-b,M*(3*P+m)],[.5+2*P+y-b,M*(3*P+m)],[.5+P+y,M*(P+m)],[.5+y+b,M*(-P+m)],[.8,_],[1,0]].map(([D,x])=>d(D,x)),C={type:"bezier",p1:S[1],p2:S[2],p3:S[3]},w={type:"bezier",p1:S[4],p2:S[5],p3:S[6]},T={type:"bezier",p1:S[7],p2:S[8],p3:S[9]};return[C,w,T]}function Lt(l,e){return{type:"bezier",p1:l.p2,p2:l.p1,p3:e}}const Ut=(l,e,n)=>{const{size:o=20,jitter:i=8,minTabSize:t,maxTabSize:s}=n;return{addTab(a,h){const{topology:u,random:c}=h,d=u.halfEdges.get(a.heLeft),g=u.halfEdges.get(a.heRight);if(!d||!g)return;const p=d.origin,f=g.origin;if(t&&Math.hypot(f[0]-p[0],f[1]-p[1])<t)return;const y=c()>.5,m=Rt(p,f,o,i,c,y,s);if(m.length===0)return;const b=[];for(let _=m.length-1;_>=0;_--){const P=m[_],M=_>0?m[_-1].p3:p;b.push(Lt(P,M))}d.segments=m,g.segments=b}}};O.register(me,Ut,Et);const Ee="GridJitterPointGenerator",Nt={name:Ee,displayName:"Grid",description:"Generate seed points using a grid with optional random jitter. Has a uniform, regular look, especially with low randomness values.",sortHint:2,controls:[{type:"range",name:"jitter",label:"Randomness",min:0,max:100,step:5,defaultValue:50,helpText:"Amount of jitter to apply to each grid point (0 to 100%)"}]},Ht=(l,e,n)=>{const{jitter:o=50}=n;return{generatePoints(t){const{width:s,height:r,pieceSize:a,random:h}=t,u=[];for(let c=0;c<s;c+=a)for(let d=0;d<r;d+=a){const g=[c+a/2,d+a/2];o>0&&(g[0]+=(h()-.5)*(o/100)*a,g[1]+=(h()-.5)*(o/100)*a),u.push(g)}return u}}};Y.register(Ee,Ht,Nt);const Re="RectangularPieceGenerator",Ft={name:Re,displayName:"Rectangular",description:"Construct pieces from a regular grid. All pieces have 4 sides and are the same size. This generator ignores seed points.",sortHint:2,controls:[]},Vt=(l,e,n)=>({generatePieces(i,t){const{pieceSize:s}=t,r={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},a=Math.ceil(l/s),h=Math.ceil(e/s),u=Math.round(l/a),c=Math.round(e/h),d=[];for(let p=0;p<=h;p++){const f=[];for(let y=0;y<=a;y++){const m=y*u,b=p*c;f.push([m,b])}d.push(f)}r.vertices=d.flat();const g=new Map;for(let p=0;p<h;p++)for(let f=0;f<a;f++){const y=p*a+f,m=d[p][f],b=d[p][f+1],_=d[p+1][f],P=d[p+1][f+1],M={id:H(),origin:m,twin:-1,next:-1,prev:-1,piece:y},I={id:H(),origin:b,twin:-1,next:-1,prev:-1,piece:y},S={id:H(),origin:P,twin:-1,next:-1,prev:-1,piece:y},C={id:H(),origin:_,twin:-1,next:-1,prev:-1,piece:y};M.next=I.id,I.next=S.id,S.next=C.id,C.next=M.id,M.prev=C.id,C.prev=S.id,S.prev=I.id,I.prev=M.id,r.halfEdges.set(M.id,M),r.halfEdges.set(I.id,I),r.halfEdges.set(S.id,S),r.halfEdges.set(C.id,C);const w={id:y,site:[(m[0]+P[0])/2,(m[1]+P[1])/2],halfEdge:M.id,bbox:[m[0],m[1],P[0],P[1]]};r.pieces.set(y,w);const T=(x,k)=>`${x[0]},${x[1]}-${k[0]},${k[1]}`,D=[{he:M,p1:m,p2:b,isBoundary:p===0},{he:I,p1:b,p2:P,isBoundary:f===a-1},{he:S,p1:P,p2:_,isBoundary:p===h-1},{he:C,p1:_,p2:m,isBoundary:f===0}];for(const x of D){const k=T(x.p2,x.p1),G=g.get(k),$=H();let z;if(G!==void 0){const A=r.halfEdges.get(G);x.he.twin=A.id,A.twin=x.he.id,z={id:$,heLeft:A.id,heRight:x.he.id},g.delete(k)}else{const A=T(x.p1,x.p2);if(g.set(A,x.he.id),x.isBoundary)z={id:$,heLeft:x.he.id,heRight:-1},r.boundary.push($);else continue}r.edges.set($,z)}}return r}});X.register(Re,Vt,Ft);const Le="NullTabGenerator",qt={name:Le,displayName:"None",description:"Do not generate tabs. All pieces have straight edges.",sortHint:3,controls:[]},jt=(l,e,n)=>({addTab(i,t){}});O.register(Le,jt,qt);const Ue="TriangleTabGenerator",Wt={name:Ue,displayName:"Triangle",description:"Creates a simple triangle between each (internal) piece edge.",sortHint:2,controls:[{type:"range",name:"tabHeightRatio",label:"Tab Height",optional:!0,min:0,max:100,step:1,defaultValue:20,helpText:'Determines how "tall" the tab is relative to the length of the edge as a percent'}]},Ot=(l,e,n)=>{const{tabHeightRatio:o=20}=n;return{addTab(t,s){const{topology:r,random:a}=s,h=r.halfEdges.get(t.heLeft),u=r.halfEdges.get(t.heRight);if(!h||!u){console.warn("Could not find half-edges for a given internal edge:",t.id);return}const c=h.origin,d=u.origin,g=[d[0]-c[0],d[1]-c[1]],p=Math.sqrt(g[0]**2+g[1]**2);if(p<1e-6)return;const f=[g[0]/p,g[1]/p],y=[-f[1],f[0]],m=[c[0]+g[0]/2,c[1]+g[1]/2],b=a()>.5?1:-1,_=p*(o/100)*b,P=[m[0]+y[0]*_,m[1]+y[1]*_],M={type:"bezier",p1:P,p2:P,p3:d},I=[m[0]-y[0]*_,m[1]-y[1]*_],S={type:"bezier",p1:I,p2:I,p3:c};h.segments=[M],u.segments=[S]}}};O.register(Ue,Ot,Wt);const Bt=()=>{const n=ge,o=pe,i=me,t={seed:new Date().getTime()%10240,canvasWidth:800,canvasHeight:600,aspectRatio:800/600,distance:40,color:"#333333",dirty:!0,generators:{point:{label:"Seed Points",registry:Y,name:n,config:Y.getDefaultConfig(n,800,600)},piece:{label:"Piece Generation",registry:X,name:o,config:X.getDefaultConfig(o,800,600)},tab:{label:"Tabs",registry:O,name:i,config:O.getDefaultConfig(i,800,600)}},puzzle:void 0,backgroundImageUrl:void 0,backgroundImageName:""};return{oncreate:()=>{ye({width:t.canvasWidth,height:t.canvasHeight,pieceSize:t.distance,pointConfig:t.generators.point.config,pieceConfig:t.generators.piece.config,tabConfig:t.generators.tab.config,seed:t.seed}).then(s=>{t.puzzle=s,v.redraw()}).catch(s=>{console.error(s)})},onupdate:()=>{t.dirty&&(t.dirty=!1,ye({width:t.canvasWidth,height:t.canvasHeight,pieceSize:t.distance,pointConfig:t.generators.point.config,pieceConfig:t.generators.piece.config,tabConfig:t.generators.tab.config,seed:t.seed}).then(s=>{t.puzzle=s,v.redraw()}).catch(s=>{console.error(s)}))},onremove:()=>{t.backgroundImageUrl&&(URL.revokeObjectURL(t.backgroundImageUrl),t.backgroundImageUrl=void 0)},view:()=>v(".page",[v(Fe,{link:"https://github.com/weevilgenius/puzzle-generator"}),v("h1","Puzzle Generator"),v(".container",[t.puzzle&&v(".puzzle-stack",[v(qe,{width:t.canvasWidth,height:t.canvasHeight,color:t.color,imageUrl:t.backgroundImageUrl,puzzle:t.puzzle,isDirty:t.dirty}),v(Oe,{puzzle:t.puzzle,width:t.canvasWidth,height:t.canvasHeight,color:t.color})]),v(".controls",[v(".background-image",[v(Ke,{label:"Background Image",onUpload:(s,r,a,h)=>{t.backgroundImageUrl&&URL.revokeObjectURL(t.backgroundImageUrl),t.canvasWidth=a,t.canvasHeight=h,t.aspectRatio=a/h,t.backgroundImageUrl=s,t.backgroundImageName=r,t.dirty=!0,v.redraw()}}),v("span.background-image-label",t.backgroundImageName)]),v(Qe,{ratio:t.aspectRatio,disabled:t.backgroundImageUrl!==void 0,onChange:s=>{t.aspectRatio=s,t.canvasWidth=t.canvasHeight*s,t.dirty=!0,v.redraw()}}),v(ce,{config:{name:"seed",label:"Seed",type:"number"},value:t.seed,onChange:s=>{t.seed=s??0,t.dirty=!0,v.redraw()}}),v(ce,{config:{name:"pieceSize",label:"Piece size",type:"number"},value:t.distance,onChange:s=>{t.distance=s??0,t.dirty=!0,v.redraw()}}),v(et,{label:"Piece color",color:t.color,size:"small",onUpdate:s=>{t.color=s,v.redraw()}}),...Object.entries(t.generators).map(([s,r])=>v("label",[r.label+":",v(Ze,{generator:r.name,registry:r.registry,config:r.config,onGeneratorChange:a=>{a!=r.name&&(console.log(`${s} generator changed to ${a}`),r.name=a,t.generators[s].config=r.registry.getDefaultConfig(a,t.canvasWidth,t.canvasHeight),t.dirty=!0,v.redraw())},onConfigChange:(a,h)=>{console.log(`${s} generator config "${a}" changed to ${String(h)}`),r.config[a]=h,t.dirty=!0,v.redraw()}})]))])])])}};v.mount(document.body,Bt);
//# sourceMappingURL=index-CXtoW0vv.js.map
