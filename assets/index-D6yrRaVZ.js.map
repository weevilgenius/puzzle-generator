{"version":3,"file":"index-D6yrRaVZ.js","sources":["../../src/ui/GitHubCorner.ts","../../src/ui/PuzzleRenderer/constants.ts","../../src/utils/paperScope.ts","../../src/geometry/paperUtils.ts","../../src/geometry/PuzzleRenderer.ts","../../src/utils/performance.ts","../../src/ui/PuzzleRenderer/rendering.ts","../../src/geometry/generators/Generator.ts","../../src/utils/UniqueId.ts","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/utils.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/poly-bezier.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js","../../node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js","../../node_modules/.pnpm/splaytree@0.1.4/node_modules/splaytree/index.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/edge_type.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/operation.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/compute_fields.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/sweep_event.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/equals.js","../../node_modules/.pnpm/robust-predicates@2.0.4/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@2.0.4/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/signed_area.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/compare_events.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/divide_segment.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/segment_intersection.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/possible_intersection.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/compare_segments.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/subdivide_segments.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/contour.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/connect_edges.js","../../node_modules/.pnpm/tinyqueue@1.2.3/node_modules/tinyqueue/index.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/fill_queue.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/index.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/index.js","../../src/geometry/utils.ts","../../src/utils/mulberry.ts","../../src/geometry/PuzzleMaker.ts","../../src/geometry/borderShapes.ts","../../src/geometry/modifiers.ts","../../src/ui/PuzzleRenderer/interaction.ts","../../src/ui/PuzzleRenderer/PuzzleRenderer.ts","../../src/utils/svg.ts","../../src/ui/DownloadPuzzleButton.ts","../../src/ui/GeometryCheckIndicator.ts","../../src/ui/UploadImageButton.ts","../../src/ui/inputs/BooleanInputControl.ts","../../src/ui/inputs/ChoiceInputControl.ts","../../src/ui/inputs/NumberInputControl.ts","../../src/ui/inputs/RangeInputControl.ts","../../src/ui/inputs/StringInputControl.ts","../../src/ui/GeneratorPicker.ts","../../src/ui/AspectRatioPicker.ts","../../src/ui/ColorPicker.ts","../../src/ui/BorderShapePicker.ts","../../src/ui/PathEditor/constants.ts","../../src/ui/PathEditor/interaction.ts","../../src/ui/PathEditor/PathEditor.ts","../../src/geometry/customPieces.ts","../../src/utils/pathValidation.ts","../../src/geometry/svgUtils.ts","../../src/ui/Dialog.ts","../../src/ui/WhimsyEditor.ts","../../src/utils/thumbnails.ts","../../src/ui/CustomPieceTile.ts","../../src/ui/Confirm.ts","../../src/ui/WhimsyManager.ts","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/tiny-ndarray.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/sphere-random.js","../../node_modules/.pnpm/moore@1.0.0/node_modules/moore/index.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/neighbourhood.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/fixed-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/variable-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js","../../src/geometry/generators/point/PoissonPointGenerator.ts","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/delaunator@5.0.1/node_modules/delaunator/index.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/path.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/polygon.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/voronoi.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/delaunay.js","../../src/geometry/generators/piece/PieceGeneratorHelpers.ts","../../src/geometry/generators/piece/VoronoiPieceGenerator.ts","../../src/geometry/generators/tab_placement/SimpleTabPlacementStrategy.ts","../../src/geometry/generators/tab/TraditionalTabGenerator.ts","../../src/geometry/GeometryChecker.ts","../../src/geometry/generators/point/GridJitterPointGenerator.ts","../../src/geometry/generators/piece/RectangularPieceGenerator.ts","../../src/geometry/generators/tab/NullTabGenerator.ts","../../src/geometry/generators/tab/TriangleTabGenerator.ts","../../src/pages/PuzzlePage.ts","../../src/index.ts"],"sourcesContent":["// SVG rendering the GitHub Octocat in a corner with a link\n// adapted from https://github.com/tholman/github-corners/\nimport m from 'mithril';\n\n// include our CSS\nimport './GitHubCorner.css';\n\n// component attributes\nexport interface GitHubCornerAttrs extends m.Attributes {\n  /** Url to use when clicked */\n  link: string;\n}\n\n// Mithril component\nexport const GitHubCorner: m.Component<GitHubCornerAttrs, unknown> = {\n\n  view: ({ attrs }) => {\n\n    return m(\"a.github-corner\", {\n      href: attrs.link,\n      \"aria-label\": \"View source on GitHub\",\n      title: \"View source on GitHub\",\n      target: \"_blank\",\n    }, m(\"svg\", {\n      width: 80,\n      height: 80,\n      viewBox: \"0 0 250 250\",\n      \"aria-hidden\": \"true\",\n    }, [\n      m('path', {\n        d: \"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\",\n      }),\n      m('path.octo-arm', {\n        fill: \"currentColor\",\n        style: \"transform-origin: 130px 106px;\",\n        d: \"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\",\n      }),\n      m('path.octo-body', {\n        fill: \"currentColor\",\n        d: \"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\",\n      }),\n    ]));\n  },\n\n};\nexport default GitHubCorner;\n","/**\n * Types and constants for the PuzzleRenderer component\n */\n\nimport m from 'mithril';\nimport type { PieceID, VertexID, PuzzleGeometry, Vec2, CustomPiece, CustomPieceTransform } from '../../geometry/types';\nimport type { PaperContext } from '../../utils/paperScope';\n\n/**\n * Interaction mode for the puzzle renderer\n */\nexport type InteractionMode =\n  | 'viewing'\n  | 'editingVertices'\n  | 'editingSeedPoints'\n  | 'positioningCustomPiece';\n\n/**\n * Component attributes for PuzzleRenderer\n */\nexport interface PuzzleRendererAttrs extends m.Attributes {\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Generated puzzle geometry */\n  puzzle: PuzzleGeometry,\n  /** If true, geometry is being regenerated */\n  isDirty: boolean;\n  /** If set, draw the seed points in this color */\n  pointColor?: string;\n  /** User uploaded image */\n  imageUrl?: string;\n  /** Callback indicating user modified the puzzle geometry */\n  onPuzzleChanged: (puzzle: PuzzleGeometry) => void;\n  /** Callback when user drags a seed point */\n  onSeedPointMoved?: (pieceId: PieceID, newPosition: Vec2) => void;\n  /** Callback when zoom level changes */\n  onZoomChanged?: (zoom: number) => void;\n  /** Custom pieces to render on the puzzle */\n  customPieces?: CustomPiece[];\n  /** Current interaction mode */\n  interactionMode?: InteractionMode;\n  /** ID of the currently selected custom piece */\n  selectedCustomPieceId?: string | null;\n  /** Callback when a custom piece is transformed */\n  onCustomPieceTransformed?: (id: string, transform: CustomPieceTransform) => void;\n  /** Callback when a custom piece is selected */\n  onCustomPieceSelected?: (id: string | null) => void;\n}\n\n/**\n * Internal component state for PuzzleRenderer\n */\nexport interface PuzzleRendererState {\n  /** Canvas HTML element */\n  canvas: HTMLCanvasElement | null;\n  /** Is the user currently dragging something? */\n  isDragging: boolean;\n  /** The index of the vertex being dragged. */\n  draggedVertexId: VertexID;\n  /** The ID of the seed point (piece) being dragged. */\n  draggedSeedPointId: PieceID;\n  /** Timestamp of last regeneration (for throttling). */\n  lastRegenerationTime: number;\n  /** Pending setTimeout ID for throttled regeneration. */\n  pendingRegeneration: number | null;\n  /** Document-level mousemove handler for dragging outside canvas */\n  documentMouseMove: ((e: MouseEvent) => void) | null;\n  /** Document-level mouseup handler for ending drag outside canvas */\n  documentMouseUp: ((e: MouseEvent) => void) | null;\n\n  // Paper.js items\n  /** Paper.js context with isolated scope for this renderer */\n  paperCtx: PaperContext | null;\n  /** Background image raster */\n  backgroundRaster: paper.Raster | null;\n\n  // Paper.js layer architecture\n  /** Layer for procedurally generated puzzle pieces */\n  puzzleLayer: paper.Layer | null;\n  /** Layer for custom pieces (whimsies) */\n  customPiecesLayer: paper.Layer | null;\n  /** Layer for transform handles on custom pieces */\n  customHandlesLayer: paper.Layer | null;\n  /** Layer for seed point indicators */\n  seedPointsLayer: paper.Layer | null;\n  /** Layer for vertex circles (shown on hover) */\n  verticesLayer: paper.Layer | null;\n  /** Layer for problem indicators */\n  problemsLayer: paper.Layer | null;\n\n  /** Main puzzle group containing border and all piece paths (within puzzleLayer) */\n  paperPath: paper.Group | null;\n  /** Group for seed point circles (within seedPointsLayer) */\n  seedPointItems: paper.Group | null;\n  /** Group for problem indicators (within problemsLayer) */\n  problemItems: paper.Group | null;\n  /** Group for vertex circles (within verticesLayer) */\n  vertexItems: paper.Group | null;\n\n  // Hover and selection state\n  /** Currently hovered vertex ID */\n  hoveredVertexId: VertexID;\n  /** Currently selected piece ID (for future features) */\n  selectedPieceId: PieceID;\n\n  // Custom piece interaction state\n  /** ID of custom piece being dragged */\n  draggedCustomPieceId: string | null;\n  /** Type of handle being dragged */\n  draggedHandleType: 'piece' | 'rotation' | 'scale' | null;\n  /** For scale handles, which corner */\n  draggedCorner: string | null;\n  /** Initial mouse position when drag started */\n  customPieceDragStart: Vec2 | null;\n  /** Initial transform when drag started */\n  customPieceInitialTransform: CustomPieceTransform | null;\n  /** Initial angle from center to mouse (for rotation) */\n  customPieceInitialAngle: number | null;\n\n  // Pan and zoom state\n  /** Current zoom level (1.0 = 100%) */\n  zoom: number;\n  /** Whether spacebar is currently pressed (for panning) */\n  isSpacebarPressed: boolean;\n}\n\n// Throttling constant for real-time regeneration during drag\nexport const REGENERATION_THROTTLE_MS = 50; // Limit to ~20 updates/second\n\n// Distance thresholds for hover feedback (smaller than click/drag threshold)\nexport const HOVER_DISTANCE = 5; // pixels\nexport const HOVER_DISTANCE_SQ = HOVER_DISTANCE * HOVER_DISTANCE;\n\n// Used for the background image when there is none\nexport const TRANSPARENT_PIXEL = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\n/* ========================================================= *\\\n *  Zoom and Pan Constants                                   *\n\\* ========================================================= */\n\n/** Minimum zoom level (10%) */\nexport const MIN_ZOOM = 0.1;\n\n/** Maximum zoom level (1000%) */\nexport const MAX_ZOOM = 10;\n\n/** Default zoom level (100%) */\nexport const DEFAULT_ZOOM = 1;\n\n/** Zoom step for mouse wheel (2.5% per wheel event) */\nexport const ZOOM_STEP = 0.025;\n\n/** Preset zoom levels for dropdown */\nexport const PRESET_ZOOM_LEVELS = [0.25, 0.5, 1, 2, 4];\n\n/** Preset zoom labels for dropdown */\nexport const PRESET_ZOOM_LABELS = ['25%', '50%', '100%', '200%', '400%'];\n","/**\n * Helper utilities for creating isolated Paper.js scopes.\n * This ensures multiple Paper.js instances don't interfere with each other.\n */\n\n// 'paper-core' is smaller and omits things we don't need like PaperScript, acorn etc\nimport PaperCore from 'paper/dist/paper-core';\n\n/**\n * Debug helper to check if a Paper.js scope is ready for rendering.\n * Returns false if the canvas has been detached/replaced or the scope is invalid.\n */\nexport function assertPaperReady(scope: paper.PaperScope, tag: string): boolean {\n  const ok =\n    !!scope &&\n    !!scope.project &&\n    !!scope.project.activeLayer &&\n    !!scope.view &&\n    // view._context is null if the canvas was detached/replaced\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    !!(scope.view as any)._context &&\n    // Paper sets a hidden flag on live views\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    (scope.view as any)._visible !== false;\n\n  if (!ok) {\n    console.warn(`[${tag}] Paper not ready`, {\n      hasScope: !!scope,\n      hasProject: !!scope?.project,\n      hasLayer: !!scope?.project?.activeLayer,\n      hasView: !!scope?.view,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n      ctx: !!(scope?.view as any)?._context,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      visible: (scope?.view as any)?._visible,\n    });\n  }\n  return ok;\n}\n\n/**\n * Paper.js context containing only an isolated scope.\n *\n * IMPORTANT: Always access Paper.js classes through the scope (e.g., scope.Group, scope.Path)\n * rather than destructuring them. This keeps them bound to their scope and prevents them\n * from falling back to the global paper scope.\n *\n * Each component should create its own context and use classes from its scope.\n */\nexport interface PaperContext {\n  scope: paper.PaperScope;\n}\n\n/**\n * Helper function to ensure a particular paper scope is active.\n *\n * Example usage:\n * ```ts\n * withPaper(state.paperCtx.scope, \"PuzzleRenderer.draw\", () => {\n *   const S = state.paperCtx.scope;\n *   const group = new S.Group();\n *   // ... rest of your draw\n * });\n * ```\n * @param S - Context to be activated for the given block\n * @param label - Block label for console logs\n * @param fn - Block to execute in context\n */\nexport function withPaper<S extends PaperContext, T>(S: S, label: string, fn: () => T): T | undefined {\n  try {\n    S.scope.activate(); // make this scope the active one\n    return fn();\n  } catch (e) {\n    console.error(`[${label}] block in paper scope failed`, e);\n  }\n}\n\n/**\n * Create an isolated Paper.js scope for a canvas.\n * This is the proper way to use multiple Paper.js instances in one application.\n *\n * @param canvas - The canvas element to bind Paper.js to\n * @param width - Canvas width in pixels\n * @param height - Canvas height in pixels\n * @returns PaperContext with isolated scope\n */\nexport function createPaperContext(\n  canvas: HTMLCanvasElement,\n  width: number,\n  height: number\n): PaperContext {\n  const scope = new PaperCore.PaperScope();\n  scope.setup(canvas);\n  scope.view.viewSize = new scope.Size(width, height);\n\n  return { scope };\n}\n","/**\n * Shared Paper.js utilities for converting between Paper.js paths and PathCommand arrays.\n * Used by both PathEditor and PuzzlePaper components.\n */\n\nimport type { PathCommand, MoveTo, LineTo, CurveTo } from './types';\nimport type { PaperContext } from '../utils/paperScope';\n\n/* ========================================================= *\\\n *  Paper.js to PathCommand conversion                      *\n\\* ========================================================= */\n\n/**\n * Convert a Paper.js path to an array of PathCommand objects.\n * Supports MoveTo, LineTo, and CurveTo (bezier) commands.\n *\n * @param path - The Paper.js path to convert\n * @returns Array of PathCommand objects representing the path\n */\nexport function paperPathToPathCommands(path: paper.Path): PathCommand[] {\n  const commands: PathCommand[] = [];\n\n  if (path.segments.length === 0) {\n    return commands;\n  }\n\n  // First segment is always a MoveTo\n  const firstSegment = path.segments[0];\n  const moveTo: MoveTo = {\n    type: 'move',\n    p: [firstSegment.point.x, firstSegment.point.y],\n  };\n  commands.push(moveTo);\n\n  // Remaining segments\n  for (let i = 1; i < path.segments.length; i++) {\n    const prevSegment = path.segments[i - 1];\n    const segment = path.segments[i];\n\n    // Check if this segment has curve handles\n    const hasHandles = (prevSegment.handleOut && prevSegment.handleOut.length > 0)\n      || (segment.handleIn && segment.handleIn.length > 0);\n\n    if (hasHandles) {\n      // Create a CurveTo command\n      // Convert relative handles to absolute control points\n      const p1 = prevSegment.handleOut\n        ? [prevSegment.point.x + prevSegment.handleOut.x, prevSegment.point.y + prevSegment.handleOut.y]\n        : [prevSegment.point.x, prevSegment.point.y];\n\n      const p2 = segment.handleIn\n        ? [segment.point.x + segment.handleIn.x, segment.point.y + segment.handleIn.y]\n        : [segment.point.x, segment.point.y];\n\n      const curveTo: CurveTo = {\n        type: 'bezier',\n        p1: p1 as [number, number],\n        p2: p2 as [number, number],\n        p3: [segment.point.x, segment.point.y],\n      };\n      commands.push(curveTo);\n    } else {\n      // Create a LineTo command\n      const lineTo: LineTo = {\n        type: 'line',\n        p: [segment.point.x, segment.point.y],\n      };\n      commands.push(lineTo);\n    }\n  }\n\n  // If the path is closed, add a final segment back to the first point\n  if (path.closed && path.segments.length >= 2) {\n    const lastSegment = path.segments[path.segments.length - 1];\n    const firstSegment = path.segments[0];\n\n    // Check if the closing segment has curve handles\n    const hasHandles = (lastSegment.handleOut && lastSegment.handleOut.length > 0)\n      || (firstSegment.handleIn && firstSegment.handleIn.length > 0);\n\n    if (hasHandles) {\n      // Create a CurveTo command to close the path\n      const p1 = lastSegment.handleOut\n        ? [lastSegment.point.x + lastSegment.handleOut.x, lastSegment.point.y + lastSegment.handleOut.y]\n        : [lastSegment.point.x, lastSegment.point.y];\n\n      const p2 = firstSegment.handleIn\n        ? [firstSegment.point.x + firstSegment.handleIn.x, firstSegment.point.y + firstSegment.handleIn.y]\n        : [firstSegment.point.x, firstSegment.point.y];\n\n      const curveTo: CurveTo = {\n        type: 'bezier',\n        p1: p1 as [number, number],\n        p2: p2 as [number, number],\n        p3: [firstSegment.point.x, firstSegment.point.y],\n      };\n      commands.push(curveTo);\n    } else {\n      // Create a LineTo command to close the path\n      const lineTo: LineTo = {\n        type: 'line',\n        p: [firstSegment.point.x, firstSegment.point.y],\n      };\n      commands.push(lineTo);\n    }\n  }\n\n  return commands;\n}\n\n/* ========================================================= *\\\n *  PathCommand to Paper.js conversion                      *\n\\* ========================================================= */\n\n/**\n * Convert an array of PathCommand objects to a Paper.js path.\n * Supports MoveTo, LineTo, and CurveTo (bezier) commands.\n *\n * @param commands - Array of PathCommand objects\n * @param ctx - Paper.js context with isolated scope\n * @returns A new Paper.js path representing the commands\n */\nexport function pathCommandsToPaperPath(\n  commands: PathCommand[],\n  ctx: PaperContext\n): paper.Path {\n  // Scope is already activated by caller\n  const paperScope = ctx.scope;\n  const path = new paperScope.Path();\n\n  if (commands.length === 0) {\n    return path;\n  }\n\n  let currentPoint: paper.Point | null = null;\n\n  for (const command of commands) {\n    switch (command.type) {\n    case 'move': {\n      const [x, y] = command.p;\n      currentPoint = new paperScope.Point(x, y);\n      path.moveTo(currentPoint);\n      break;\n    }\n    case 'line': {\n      const [x, y] = command.p;\n      currentPoint = new paperScope.Point(x, y);\n      path.lineTo(currentPoint);\n      break;\n    }\n    case 'bezier': {\n      if (!currentPoint) {\n        console.warn('paperUtils: CurveTo command without a current point, skipping');\n        break;\n      }\n\n      // Convert absolute control points to relative handles\n      const [cp1x, cp1y] = command.p1;\n      const [cp2x, cp2y] = command.p2;\n      const [x, y] = command.p3;\n\n      const endPoint = new paperScope.Point(x, y);\n      const cp1 = new paperScope.Point(cp1x, cp1y);\n      const cp2 = new paperScope.Point(cp2x, cp2y);\n\n      // Add the new segment\n      path.add(endPoint);\n\n      // Get the last segment we just added\n      const segment = path.lastSegment;\n\n      // Set handleIn relative to the new point\n      const handleIn = cp2.subtract(endPoint);\n      segment.handleIn = handleIn;\n\n      // Set handleOut on the previous segment (relative to previous point)\n      if (path.segments.length >= 2) {\n        const handleOut = cp1.subtract(currentPoint);\n        path.segments[path.segments.length - 2].handleOut = handleOut;\n      }\n\n      currentPoint = endPoint;\n      break;\n    }\n    case 'arc':\n      // Arc commands not yet supported\n      console.warn('paperUtils: Arc commands not yet supported, skipping arc command');\n      break;\n    }\n  }\n\n  return path;\n}\n","/**\n * Paper.js-based rendering for puzzle geometry.\n * This module provides functions to render PuzzleGeometry using Paper.js.\n */\n\nimport { type PaperContext } from '../utils/paperScope';\nimport type { PuzzleGeometry, EdgeSegment, Piece } from './types';\nimport { pathCommandsToPaperPath } from './paperUtils';\n\n/**\n * Draws puzzle geometry using Paper.js.\n * Creates one Path per piece plus one for the border, all grouped together.\n * This enables easy piece selection, highlighting, and manipulation.\n *\n * @param puzzle - The puzzle geometry to render\n * @param strokeColor - Color for the puzzle edges (CSS color string)\n * @param ctx - Paper.js context with isolated scope\n * @returns A Paper.js Group containing the border path and all piece paths\n */\nexport function drawPuzzleWithPaper(\n  puzzle: PuzzleGeometry,\n  strokeColor: string,\n  ctx: PaperContext\n): paper.Group {\n  // Scope is already activated by caller (renderPuzzle via withPaper)\n  const paperScope = ctx.scope;\n  const group = new paperScope.Group();\n\n  // Draw the border path\n  const borderPath = pathCommandsToPaperPath(puzzle.borderPath, ctx);\n  borderPath.strokeColor = new paperScope.Color(strokeColor);\n  borderPath.strokeWidth = 1;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  borderPath.data.isBorder = true; // Mark for future features\n  group.addChild(borderPath);\n\n  // Draw each piece as a separate path\n  for (const piece of puzzle.pieces.values()) {\n    const piecePath = createPiecePath(piece, puzzle, ctx);\n    piecePath.strokeColor = new paperScope.Color(strokeColor);\n    piecePath.strokeWidth = 1;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    piecePath.data.pieceId = piece.id; // Store for future selection features\n    group.addChild(piecePath);\n  }\n\n  return group;\n}\n\n/**\n * Create a Paper.js Path for a single piece by traversing its boundary.\n * This follows the half-edge structure around the piece's perimeter.\n *\n * @param piece - The piece to create a path for\n * @param puzzle - The puzzle geometry containing the half-edge data\n * @param ctx - Paper.js context with isolated scope\n * @returns A Paper.js Path representing the piece's complete outline\n */\nfunction createPiecePath(\n  piece: Piece,\n  puzzle: PuzzleGeometry,\n  ctx: PaperContext\n): paper.Path {\n  // Scope is already activated by caller (drawPuzzleWithPaper)\n  const paperScope = ctx.scope;\n  const path = new paperScope.Path();\n\n  // Get the starting half-edge for this piece's boundary\n  let currentHe = puzzle.halfEdges.get(piece.halfEdge);\n  if (!currentHe) return path;\n\n  const startHeId = currentHe.id;\n  path.moveTo(new paperScope.Point(currentHe.origin[0], currentHe.origin[1]));\n\n  // Traverse the boundary of the piece by following the 'next' pointers\n  // until we get back to the starting half-edge\n  do {\n    if (currentHe.segments) {\n      // If the edge has a custom tab, draw its segments\n      for (const segment of currentHe.segments) {\n        addSegmentToPaperPath(path, segment, ctx);\n      }\n    } else {\n      // Otherwise, draw a straight line to the start of the next half-edge\n      const nextHe = puzzle.halfEdges.get(currentHe.next)!;\n      path.lineTo(new paperScope.Point(nextHe.origin[0], nextHe.origin[1]));\n    }\n    // Move to the next half-edge in the loop\n    currentHe = puzzle.halfEdges.get(currentHe.next)!;\n  } while (currentHe.id !== startHeId);\n\n  return path;\n}\n\n/**\n * Add a single EdgeSegment to a Paper.js path.\n * Handles both line and bezier curve segments.\n *\n * @param path - The Paper.js path to add the segment to\n * @param segment - The edge segment to convert and add\n * @param ctx - Paper.js context with isolated scope\n */\nfunction addSegmentToPaperPath(\n  path: paper.Path,\n  segment: EdgeSegment,\n  ctx: PaperContext\n): void {\n  // Scope is already activated by caller (createPiecePath)\n  const paperScope = ctx.scope;\n  switch (segment.type) {\n  case 'line': {\n    path.lineTo(new paperScope.Point(segment.p[0], segment.p[1]));\n    break;\n  }\n  case 'bezier': {\n    // Paper.js cubicCurveTo takes: handle1, handle2, endPoint (all absolute)\n    path.cubicCurveTo(\n      new paperScope.Point(segment.p1[0], segment.p1[1]),\n      new paperScope.Point(segment.p2[0], segment.p2[1]),\n      new paperScope.Point(segment.p3[0], segment.p3[1])\n    );\n    break;\n  }\n  }\n}\n\n\n/**\n * Draw seed points (piece centers) as circles.\n * Clears any existing circles in the group before drawing.\n *\n * @param puzzle - The puzzle geometry containing piece data\n * @param group - The Paper.js Group to add circles to\n * @param color - Color for the seed point circles (optional)\n * @param ctx - Paper.js context with isolated scope\n */\nexport function drawSeedPoints(\n  puzzle: PuzzleGeometry,\n  group: paper.Group,\n  color: string | undefined,\n  ctx: PaperContext\n): void {\n  // Scope is already activated by caller (renderPuzzle via withPaper)\n  // Clear existing circles\n  group.removeChildren();\n\n  if (!color) return;\n\n  const paperScope = ctx.scope;\n\n  // Draw each seed point\n  for (const piece of puzzle.pieces.values()) {\n    const [x, y] = piece.site;\n    const circle = new paperScope.Path.Circle(new paperScope.Point(x, y), 3);\n    circle.fillColor = new paperScope.Color(color);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    circle.data.pieceId = piece.id; // Store piece ID for hit testing\n    group.addChild(circle);\n  }\n}\n\n/**\n * Draw problem indicators (red circles) at intersection points.\n * Clears any existing indicators in the group before drawing.\n *\n * @param puzzle - The puzzle geometry containing problem data\n * @param group - The Paper.js Group to add indicators to\n * @param ctx - Paper.js context with isolated scope\n */\nexport function drawProblems(\n  puzzle: PuzzleGeometry,\n  group: paper.Group,\n  ctx: PaperContext\n): void {\n  // Scope is already activated by caller (renderPuzzle via withPaper)\n  // Clear existing indicators\n  group.removeChildren();\n\n  if (!puzzle.problems || puzzle.problems.length === 0) return;\n\n  const paperScope = ctx.scope;\n\n  // Draw each problem point\n  for (const problemPoint of puzzle.problems) {\n    const [x, y] = problemPoint;\n    const circle = new paperScope.Path.Circle(new paperScope.Point(x, y), 8);\n    circle.strokeColor = new paperScope.Color('red');\n    circle.strokeWidth = 2;\n    group.addChild(circle);\n  }\n}\n","/**\n * Performance logging utilities\n *\n * Set ENABLE_PERFORMANCE_LOGGING to true to enable performance measurements\n * and console logging for puzzle generation and rendering times.\n */\n\n// Global flag for performance logging - change this to enable/disable\nconst ENABLE_PERFORMANCE_LOGGING = false;\n\n/**\n * Logs a performance measurement if logging is enabled\n * @param label - Description of what was measured\n * @param timeMs - Time in milliseconds\n */\nexport function logPerformance(label: string, timeMs: number): void {\n  if (ENABLE_PERFORMANCE_LOGGING) {\n    console.log(`[Performance] ${label}: ${timeMs.toFixed(2)}ms`);\n  }\n}\n\n/**\n * Measures the execution time of a synchronous function\n * @param label - Description for logging\n * @param fn - Function to measure\n * @returns The return value of the function\n */\nexport function measureSync<T>(label: string, fn: () => T): T {\n  if (!ENABLE_PERFORMANCE_LOGGING) {\n    return fn();\n  }\n\n  const start = performance.now();\n  const result = fn();\n  const end = performance.now();\n  logPerformance(label, end - start);\n  return result;\n}\n\n/**\n * Measures the execution time of an async function\n * @param label - Description for logging\n * @param fn - Async function to measure\n * @returns A promise with the return value of the function\n */\nexport async function measureAsync<T>(label: string, fn: () => Promise<T>): Promise<T> {\n  if (!ENABLE_PERFORMANCE_LOGGING) {\n    return fn();\n  }\n\n  const start = performance.now();\n  const result = await fn();\n  const end = performance.now();\n  logPerformance(label, end - start);\n  return result;\n}\n","/**\n * Rendering logic for PuzzleRenderer component using Paper.js\n */\n\nimport { createPaperContext, assertPaperReady, withPaper } from '../../utils/paperScope';\nimport {\n  drawPuzzleWithPaper,\n  drawSeedPoints,\n  drawProblems,\n} from '../../geometry/PuzzleRenderer';\nimport type { PuzzleGeometry, CustomPiece, PathCommand } from '../../geometry/types';\nimport type { PuzzleRendererState } from './constants';\nimport { measureSync } from '../../utils/performance';\n\n/**\n * Initialize Paper.js on a canvas element with an isolated scope\n */\nexport function initializePaper(\n  canvas: HTMLCanvasElement,\n  width: number,\n  height: number,\n  state: PuzzleRendererState\n): void {\n  // Create an isolated Paper.js scope for this renderer\n  state.paperCtx = createPaperContext(canvas, width, height);\n\n  // Verify context was created successfully\n  if (!state.paperCtx) {\n    console.error('PuzzleRenderer: Failed to create Paper.js context');\n  }\n}\n\n/**\n * Render the puzzle geometry using Paper.js\n */\nexport function renderPuzzle(\n  state: PuzzleRendererState,\n  puzzle: PuzzleGeometry,\n  color: string,\n  pointColor?: string\n): void {\n  // Use this renderer's isolated Paper.js scope\n  if (!state.paperCtx) {\n    console.error('PuzzleRenderer: Cannot render - Paper.js context not initialized');\n    return;\n  }\n\n  measureSync('Paper.js Rendering', () => {\n    withPaper(state.paperCtx!, 'PuzzleRenderer:renderPuzzle', () => {\n      const paperScope = state.paperCtx!.scope;\n\n      // Check if Paper.js is ready before creating objects\n      if (!assertPaperReady(paperScope, 'PuzzleRenderer:renderPuzzle')) {\n        console.error('PuzzleRenderer: Paper.js not ready - canvas may have been replaced');\n        return;\n      }\n\n      // Activate puzzle layer for rendering procedural pieces\n      if (state.puzzleLayer) {\n        state.puzzleLayer.activate();\n      }\n\n      // Remove existing path if present\n      if (state.paperPath) {\n        state.paperPath.remove();\n        state.paperPath = null;\n      }\n\n      // Draw the puzzle edges using this scope's context\n      state.paperPath = drawPuzzleWithPaper(puzzle, color, state.paperCtx!);\n\n      // Activate vertices layer and create/update vertex circles\n      if (state.verticesLayer) {\n        state.verticesLayer.activate();\n      }\n      createVertexItems(puzzle, state);\n\n      // Activate seed points layer and draw seed points if enabled\n      if (state.seedPointsLayer) {\n        state.seedPointsLayer.activate();\n      }\n      if (state.seedPointItems && state.paperCtx) {\n        drawSeedPoints(puzzle, state.seedPointItems, pointColor, state.paperCtx);\n      }\n\n      // Activate problems layer and draw problem indicators if present\n      if (state.problemsLayer) {\n        state.problemsLayer.activate();\n      }\n      if (state.problemItems && state.paperCtx) {\n        drawProblems(puzzle, state.problemItems, state.paperCtx);\n      }\n\n      // Explicitly trigger an update on the isolated scope's view\n      paperScope.view.update();\n    });\n  });\n}\n\n/**\n * Create Paper.js layer architecture for different visual elements\n *\n * LAYER ARCHITECTURE (rendering order from bottom to top):\n * =========================================================\n *\n * 1. puzzleLayer\n *    - Contains the procedurally generated puzzle pieces and border\n *    - Contains backgroundRaster (if user uploaded an image)\n *    - Contains paperPath group: border outline and all piece path segments\n *    - Rendered first so puzzle appears behind all other elements\n *\n * 2. customPiecesLayer\n *    - Contains custom pieces (whimsies) overlaid on the puzzle\n *    - Each custom piece is rendered as a Path with applied transforms\n *    - Selected pieces are highlighted with blue stroke and thicker line\n *    - Unselected pieces match puzzle styling (no fill, same color/stroke)\n *\n * 3. customHandlesLayer\n *    - Contains transform handles for the currently selected custom piece\n *    - Includes bounding box (dashed blue rectangle)\n *    - Includes 4 corner scale handles (white circles with blue stroke)\n *    - Includes rotation handle (circle above top center, connected by dashed line)\n *    - All handles rotate with the piece but maintain constant visual size\n *    - Cleared when no custom piece is selected\n *\n * 4. seedPointsLayer\n *    - Contains seedPointItems group with seed point indicators\n *    - Seed points mark the centers of procedurally generated pieces\n *    - Only visible when pointColor is specified\n *\n * 5. verticesLayer\n *    - Contains vertexItems group with vertex circles\n *    - Vertices are the control points on piece edges\n *    - Shown on hover when in vertex editing mode\n *\n * 6. problemsLayer\n *    - Contains problemItems group with problem indicators\n *    - Highlights geometry issues detected by the problem checker\n *    - Rendered on top so issues are always visible\n */\nexport function createPaperLayers(state: PuzzleRendererState): void {\n  // Use this renderer's isolated Paper.js scope\n  if (!state.paperCtx) {\n    console.error('PuzzleRenderer: Cannot create layers - Paper.js context not initialized');\n    return;\n  }\n\n  withPaper(state.paperCtx, 'PuzzleRenderer:createPaperLayers', () => {\n    const paperScope = state.paperCtx!.scope;\n\n    // Check if Paper.js is ready before creating objects\n    if (!assertPaperReady(paperScope, 'PuzzleRenderer:createPaperLayers')) {\n      console.error('PuzzleRenderer: Paper.js not ready - canvas may have been replaced');\n      return;\n    }\n\n    // Create layers in bottom-to-top order\n    state.puzzleLayer = new paperScope.Layer();\n    state.customPiecesLayer = new paperScope.Layer();\n    state.customHandlesLayer = new paperScope.Layer();\n    state.seedPointsLayer = new paperScope.Layer();\n    state.verticesLayer = new paperScope.Layer();\n    state.problemsLayer = new paperScope.Layer();\n\n    // Create groups within their respective layers\n    state.puzzleLayer.activate();\n    state.backgroundRaster = null;\n    state.paperPath = null;\n\n    state.seedPointsLayer.activate();\n    state.seedPointItems = new paperScope.Group();\n\n    state.problemsLayer.activate();\n    state.problemItems = new paperScope.Group();\n\n    state.verticesLayer.activate();\n    state.vertexItems = new paperScope.Group();\n\n    // Activate puzzle layer by default for rendering\n    state.puzzleLayer.activate();\n  });\n}\n\n/**\n * Update the background image raster\n * @param state - The PuzzleRenderer state\n * @param imageUrl - The image URL to display, or undefined to remove\n * @param width - The canvas width\n * @param height - The canvas height\n */\nexport function updateBackgroundImage(\n  state: PuzzleRendererState,\n  imageUrl: string | undefined,\n  width: number,\n  height: number\n): void {\n  // Use this renderer's isolated Paper.js scope\n  if (!state.paperCtx) {\n    console.error('PuzzleRenderer: Cannot update background - Paper.js context not initialized');\n    return;\n  }\n\n  withPaper(state.paperCtx, 'PuzzleRenderer:updateBackgroundImage', () => {\n    const paperScope = state.paperCtx!.scope;\n\n    // Activate puzzle layer for background image\n    if (state.puzzleLayer) {\n      state.puzzleLayer.activate();\n    }\n\n    // Remove existing background raster\n    if (state.backgroundRaster) {\n      state.backgroundRaster.remove();\n      state.backgroundRaster = null;\n    }\n\n    // Create new background raster if imageUrl is provided\n    if (imageUrl) {\n      const raster = new paperScope.Raster(imageUrl);\n\n      // Position at center of view\n      raster.position = new paperScope.Point(width / 2, height / 2);\n\n      // Scale to fit the canvas size\n      raster.onLoad = () => {\n        if (raster.width && raster.height) {\n          const scaleX = width / raster.width;\n          const scaleY = height / raster.height;\n          raster.scale(scaleX, scaleY);\n        }\n      };\n\n      // Send to back within puzzle layer\n      raster.sendToBack();\n\n      state.backgroundRaster = raster;\n    }\n  });\n}\n\n/**\n * Get a Set of all vertex indices that lie on boundary edges\n * (half-edges with twin === -1)\n */\nexport function getBoundaryEdgeVertexIds(puzzle: PuzzleGeometry): Set<number> {\n  const boundaryVertexIds = new Set<number>();\n\n  // Find all half-edges on the boundary (twin === -1)\n  for (const halfEdge of puzzle.halfEdges.values()) {\n    if (halfEdge.twin === -1) {\n      // Find the index of this vertex\n      const vertexIndex = puzzle.vertices.findIndex(\n        (v) => v[0] === halfEdge.origin[0] && v[1] === halfEdge.origin[1]\n      );\n      if (vertexIndex >= 0) {\n        boundaryVertexIds.add(vertexIndex);\n      }\n    }\n  }\n\n  return boundaryVertexIds;\n}\n\n/**\n * Create vertex circles for interactive dragging\n * Vertices are hidden by default and shown on hover\n * Excludes boundary edge vertices (not draggable)\n */\nexport function createVertexItems(\n  puzzle: PuzzleGeometry,\n  state: PuzzleRendererState\n): void {\n  if (!state.vertexItems || !state.paperCtx) return;\n\n  // Scope is already activated by caller (renderPuzzle via withPaper)\n  const paperScope = state.paperCtx.scope;\n\n  // Clear existing vertex items\n  state.vertexItems.removeChildren();\n\n  // Get all vertices that lie on boundary edges\n  const boundaryVertexIds = getBoundaryEdgeVertexIds(puzzle);\n\n  // Create a circle for each non-boundary vertex\n  for (let i = 0; i < puzzle.vertices.length; i++) {\n    // Skip boundary edge vertices - they should not be draggable\n    if (boundaryVertexIds.has(i)) continue;\n\n    const [x, y] = puzzle.vertices[i];\n    const circle = new paperScope.Path.Circle(new paperScope.Point(x, y), 4);\n    circle.fillColor = new paperScope.Color('#4363d8');\n    circle.strokeColor = new paperScope.Color('#ffffff');\n    circle.strokeWidth = 1;\n    circle.visible = false; // Hidden by default, shown on hover\n    // Store vertex ID in data for hit testing\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    circle.data.vertexId = i;\n    state.vertexItems.addChild(circle);\n  }\n}\n\n/**\n * Converts a PathCommand array to a Paper.js path\n */\nfunction pathCommandsToPath(\n  commands: PathCommand[],\n  paperScope: paper.PaperScope\n): paper.Path {\n  const path = new paperScope.Path();\n\n  for (const command of commands) {\n    switch (command.type) {\n    case 'move':\n      path.moveTo(new paperScope.Point(command.p[0], command.p[1]));\n      break;\n    case 'line':\n      path.lineTo(new paperScope.Point(command.p[0], command.p[1]));\n      break;\n    case 'bezier':\n      path.cubicCurveTo(\n        new paperScope.Point(command.p1[0], command.p1[1]),\n        new paperScope.Point(command.p2[0], command.p2[1]),\n        new paperScope.Point(command.p3[0], command.p3[1])\n      );\n      break;\n    case 'arc':\n      // For arcs, we'll use lineTo as a simplified approximation\n      // A more sophisticated implementation would compute the arc properly\n      path.lineTo(new paperScope.Point(command.p[0], command.p[1]));\n      break;\n    }\n  }\n\n  return path;\n}\n\n/**\n * Render custom pieces on the custom pieces layer\n */\nexport function renderCustomPieces(\n  state: PuzzleRendererState,\n  customPieces: CustomPiece[],\n  color: string,\n  selectedCustomPieceId?: string | null\n): void {\n  if (!state.paperCtx || !state.customPiecesLayer) {\n    return;\n  }\n\n  withPaper(state.paperCtx, 'PuzzleRenderer:renderCustomPieces', () => {\n    const paperScope = state.paperCtx!.scope;\n\n    // Activate custom pieces layer\n    state.customPiecesLayer!.activate();\n\n    // Clear existing custom pieces\n    state.customPiecesLayer!.removeChildren();\n\n    // Render each custom piece\n    for (const customPiece of customPieces) {\n      // Convert path commands to Paper.js path\n      const path = pathCommandsToPath(customPiece.path, paperScope);\n\n      // Apply transform to match exactly what handle rendering does:\n      // 1. Center path at origin\n      // 2. Apply scale, rotation, translation via matrix\n      const { position, rotation, scale } = customPiece.transform;\n\n      // Center the path at origin (same as handle rendering does with tempPath)\n      path.position = new paperScope.Point(0, 0);\n\n      // Build transformation matrix to apply: scale, then rotate, then translate\n      // Paper.js uses post-multiplication: matrix.op() does matrix = matrix * op\n      // To get final matrix T * R * S, we apply operations in reverse order\n      const matrix = new paperScope.Matrix();\n\n      // Apply in reverse: translate, rotate, scale\n      // This builds: matrix = T * R * S\n      matrix.translate(new paperScope.Point(position[0], position[1]));\n      matrix.rotate(rotation * (180 / Math.PI), new paperScope.Point(0, 0));\n      matrix.scale(scale[0], scale[1], new paperScope.Point(0, 0));\n\n      // Apply the transformation matrix to the centered path\n      path.transform(matrix);\n\n      // Set styling\n      const isSelected = customPiece.id === selectedCustomPieceId;\n      if (isSelected) {\n        // Selected: blue fill with transparency and blue stroke\n        path.fillColor = new paperScope.Color(0, 0.5, 1, 0.3);\n        path.strokeColor = new paperScope.Color(0, 0.5, 1);\n        path.strokeWidth = 2;\n      } else {\n        // Unselected: same styling as main puzzle (no fill, same color and stroke width)\n        path.fillColor = null;\n        path.strokeColor = new paperScope.Color(color);\n        path.strokeWidth = 1;\n      }\n\n      // Store custom piece ID in path data for hit testing\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      path.data.customPieceId = customPiece.id;\n    }\n  });\n}\n\n/**\n * Render transform handles for a selected custom piece\n */\nexport function renderCustomPieceHandles(\n  state: PuzzleRendererState,\n  customPiece: CustomPiece\n): void {\n  if (!state.paperCtx || !state.customHandlesLayer) {\n    return;\n  }\n\n  withPaper(state.paperCtx, 'PuzzleRenderer:renderCustomPieceHandles', () => {\n    const paperScope = state.paperCtx!.scope;\n\n    // Activate custom handles layer\n    state.customHandlesLayer!.activate();\n\n    // Clear existing handles\n    state.customHandlesLayer!.removeChildren();\n\n    // Create a temporary path to get the unscaled, unrotated bounds\n    const tempPath = pathCommandsToPath(customPiece.path, paperScope);\n    tempPath.position = new paperScope.Point(0, 0);\n    const baseBounds = tempPath.bounds;\n    tempPath.remove(); // Clean up temporary path\n\n    const { scale, rotation, position } = customPiece.transform;\n\n    // Transform corners manually to match exactly what Paper.js does for the piece:\n    // 1. Path is centered at (0, 0)\n    // 2. Scale is applied\n    // 3. Rotation is applied\n    // 4. Position is set to final location\n    const corners = [\n      baseBounds.topLeft,\n      baseBounds.topRight,\n      baseBounds.bottomRight,\n      baseBounds.bottomLeft,\n    ];\n\n    const transformedCorners = corners.map((corner) => {\n      // Apply scale\n      const scaledX = corner.x * scale[0];\n      const scaledY = corner.y * scale[1];\n\n      // Apply rotation\n      const cos = Math.cos(rotation);\n      const sin = Math.sin(rotation);\n      const rotatedX = scaledX * cos - scaledY * sin;\n      const rotatedY = scaledX * sin + scaledY * cos;\n\n      // Apply translation\n      return new paperScope.Point(\n        rotatedX + position[0],\n        rotatedY + position[1]\n      );\n    });\n\n    // Draw circumscribed circle around the bounding box\n    // The circle is centered at the piece position and passes through all corners\n    // const center = new paperScope.Point(position[0], position[1]);\n    // const radius = center.getDistance(transformedCorners[0]); // radius is distance from center to any corner\n    // const circumscribedCircle = new paperScope.Path.Circle(center, radius);\n    // circumscribedCircle.strokeColor = new paperScope.Color(0, 0.5, 1, 1); // Blue with transparency\n    // circumscribedCircle.strokeWidth = 1;\n    // circumscribedCircle.dashArray = [2, 4]; // Dotted line\n    // circumscribedCircle.fillColor = null;\n    // // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    // circumscribedCircle.data.handleType = 'circumscribed-circle';\n    // state.customHandlesLayer!.addChild(circumscribedCircle);\n\n    // Draw bounding box connecting the transformed corners\n    const bbox = new paperScope.Path();\n    bbox.moveTo(transformedCorners[0]);\n    bbox.lineTo(transformedCorners[1]);\n    bbox.lineTo(transformedCorners[2]);\n    bbox.lineTo(transformedCorners[3]);\n    bbox.closePath();\n    bbox.strokeColor = new paperScope.Color(0, 0.5, 1); // Blue\n    bbox.strokeWidth = 1;\n    bbox.dashArray = [4, 4]; // Dashed line\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    bbox.data.handleType = 'bbox';\n    state.customHandlesLayer!.addChild(bbox);\n\n    // Draw corner scale handles with constant size\n    const handleRadius = 4;\n    const cornerTypes = ['nw', 'ne', 'se', 'sw'];\n\n    transformedCorners.forEach((corner, index) => {\n      const handle = new paperScope.Path.Circle(corner, handleRadius);\n      handle.fillColor = new paperScope.Color(1, 1, 1); // White fill\n      handle.strokeColor = new paperScope.Color(0, 0.5, 1); // Blue stroke\n      handle.strokeWidth = 2;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      handle.data.handleType = 'scale';\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      handle.data.corner = cornerTypes[index];\n      state.customHandlesLayer!.addChild(handle);\n    });\n\n    // Draw rotation handle (above center top)\n    const rotationHandleDistance = 40;\n    const centerTop = new paperScope.Point(baseBounds.center.x, baseBounds.top);\n\n    // Transform the center top point the same way as the corners\n    const scaledCenterTopX = centerTop.x * scale[0];\n    const scaledCenterTopY = centerTop.y * scale[1];\n    const cos = Math.cos(rotation);\n    const sin = Math.sin(rotation);\n    const rotatedCenterTopX = scaledCenterTopX * cos - scaledCenterTopY * sin;\n    const rotatedCenterTopY = scaledCenterTopX * sin + scaledCenterTopY * cos;\n    const rotationHandleBase = new paperScope.Point(\n      rotatedCenterTopX + position[0],\n      rotatedCenterTopY + position[1]\n    );\n\n    // Rotation handle position is along the rotated \"up\" direction (no scaling)\n    const offsetX = 0;\n    const offsetY = -rotationHandleDistance;\n    const rotatedOffsetX = offsetX * cos - offsetY * sin;\n    const rotatedOffsetY = offsetX * sin + offsetY * cos;\n\n    const rotationHandlePos = new paperScope.Point(\n      rotationHandleBase.x + rotatedOffsetX,\n      rotationHandleBase.y + rotatedOffsetY\n    );\n\n    // Line from center top to rotation handle (dashed like the bounding box)\n    const rotationLine = new paperScope.Path.Line(rotationHandleBase, rotationHandlePos);\n    rotationLine.strokeColor = new paperScope.Color(0, 0.5, 1);\n    rotationLine.strokeWidth = 1;\n    rotationLine.dashArray = [4, 4]; // Dashed line\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    rotationLine.data.handleType = 'rotation-line';\n    state.customHandlesLayer!.addChild(rotationLine);\n\n    // Rotation handle circle with constant size\n    const rotationHandle = new paperScope.Path.Circle(rotationHandlePos, handleRadius);\n    rotationHandle.fillColor = new paperScope.Color(1, 1, 1);\n    rotationHandle.strokeColor = new paperScope.Color(0, 0.5, 1);\n    rotationHandle.strokeWidth = 2;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    rotationHandle.data.handleType = 'rotation';\n    state.customHandlesLayer!.addChild(rotationHandle);\n  });\n}\n\n/**\n * Clear transform handles\n */\nexport function clearCustomPieceHandles(state: PuzzleRendererState): void {\n  if (state.customHandlesLayer) {\n    state.customHandlesLayer.removeChildren();\n  }\n}\n\n/**\n * Clean up Paper.js resources\n */\nexport function cleanupPaper(state: PuzzleRendererState): void {\n  if (state.backgroundRaster) {\n    state.backgroundRaster.remove();\n    state.backgroundRaster = null;\n  }\n  if (state.paperPath) {\n    state.paperPath.remove();\n    state.paperPath = null;\n  }\n  if (state.seedPointItems) {\n    state.seedPointItems.remove();\n    state.seedPointItems = null;\n  }\n  if (state.problemItems) {\n    state.problemItems.remove();\n    state.problemItems = null;\n  }\n  if (state.vertexItems) {\n    state.vertexItems.remove();\n    state.vertexItems = null;\n  }\n\n  // Clean up layers\n  if (state.puzzleLayer) {\n    state.puzzleLayer.remove();\n    state.puzzleLayer = null;\n  }\n  if (state.customPiecesLayer) {\n    state.customPiecesLayer.remove();\n    state.customPiecesLayer = null;\n  }\n  if (state.customHandlesLayer) {\n    state.customHandlesLayer.remove();\n    state.customHandlesLayer = null;\n  }\n  if (state.seedPointsLayer) {\n    state.seedPointsLayer.remove();\n    state.seedPointsLayer = null;\n  }\n  if (state.verticesLayer) {\n    state.verticesLayer.remove();\n    state.verticesLayer = null;\n  }\n  if (state.problemsLayer) {\n    state.problemsLayer.remove();\n    state.problemsLayer = null;\n  }\n\n  // Remove the Paper.js project\n  if (state.paperCtx) {\n    state.paperCtx.scope.project.remove();\n  }\n}\n","import type { GeneratorUIMetadata } from '../ui_types';\nimport type { PathCommand } from '../types';\n\n/** The name of a particular generator implementation. Must be unique. */\nexport type GeneratorName = string;\n\n/** Base configuration for any generator */\nexport interface GeneratorConfig {\n  /** The name of the generator to which this config belongs */\n  name: GeneratorName;\n  // additional fields specific to this generator\n  [key: string]: unknown;\n}\n\n/**\n * A generic interface for a function that creates a configured generator instance.\n * @template T - The particular generator desired, e.g. RectangularPieceGenerator\n * @param border - The border of the puzzle\n * @param bounds - The maximum bounds of the puzzle\n * @param options - Options specific to this generator\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type GeneratorFactory<T> = (border: PathCommand[], bounds: { width: number; height: number }, options: any) => T;\n\n\ninterface RegisteredGenerator<T> {\n  factory: GeneratorFactory<T>;\n  uiMetadata: GeneratorUIMetadata;\n}\n\n/**\n * A generic registry for creating instances of generates from configurations.\n * This allows for a pluggable system where generators can be added dynamically.\n *\n * @template T The base interface for this type of generator, e.g. `TabGenerator`\n */\nexport class GeneratorRegistry<T> {\n  private generators = new Map<GeneratorName, RegisteredGenerator<T>>();\n\n  /**\n   * Registers a new generator factory associated with a specific generator type.\n   * Intended to be called from within each generator's implementation file.\n   * @param name The unique string identifier for the generator, e.g. \"TraditionalTabGenerator\"\n   * @param factory A function that takes an options object and returns a generator\n   * @param uiMetadata A description of the UI needed to configure the generator\n   */\n  public register(name: GeneratorName, factory: GeneratorFactory<T>, uiMetadata: GeneratorUIMetadata): void {\n    if (this.generators.has(name)) {\n      console.warn(`Generator \"${name}\" is already registered, overwriting`);\n    }\n    this.generators.set(name, { factory, uiMetadata });\n  }\n\n  /**\n   * Creates an instance of a generator based on the provided configuration object.\n   * It looks up the correct factory using the `name` property from the config.\n   * @param border The path of the border of the puzzle\n   * @param bounds The maximum bounds of the puzzle\n   * @param config A configuration object for the generator\n   * @returns A configured instance of the requested generator\n   */\n  public create(border: PathCommand[], bounds: { width: number; height: number }, config: GeneratorConfig): T {\n    const generator = this.generators.get(config.name);\n    if (!generator) {\n      throw new Error(`Unknown generator \"${config.name}\". Is it registered?`);\n    }\n    return generator.factory(border, bounds, config);\n  }\n\n  /**\n   * Returns a list of all available generators for populating a selector UI.\n   * @returns An array of objects with the name and human-readable display name.\n   */\n  public getAvailableGenerators(): { name: GeneratorName, displayName: string }[] {\n    return Array.from(this.generators.values())\n      .sort((a, b) => a.uiMetadata.sortHint - b.uiMetadata.sortHint)\n      .map((g) => ({\n        name: g.uiMetadata.name,\n        displayName: g.uiMetadata.displayName,\n      }));\n  }\n\n  /**\n   * Retrieves the full UI metadata for a single generator.\n   * @param name The name of the generator.\n   * @returns The UI metadata object, or undefined if not found.\n   */\n  public getUIMetadata(name: GeneratorName): GeneratorUIMetadata | undefined {\n    return this.generators.get(name)?.uiMetadata;\n  }\n\n  /**\n   * Builds a default (empty) config object for a given generator.\n   * @param name The name of the generator.\n   * @param width The width of the puzzle\n   * @param height The height of the puzzle\n   * @returns Default config object for the given generator\n   */\n  public getDefaultConfig(name: GeneratorName, width: number, height: number): GeneratorConfig {\n    const newConfig: GeneratorConfig = {\n      name: name,\n      width: width,\n      height: height,\n    };\n\n    const metadata = this.getUIMetadata(name);\n    if (metadata) {\n      for (const control of metadata.controls) {\n        newConfig[control.name] = control.defaultValue;\n      }\n    }\n\n    return newConfig;\n  }\n}\n\n/* ========================================================= *\\\n *  Public registeries                                       *\n\\* ========================================================= */\n\n// Public registry for PointGenerators\nimport type { PointGenerator } from \"./point/PointGenerator\";\nexport const PointGeneratorRegistry = new GeneratorRegistry<PointGenerator>();\n\n// Public registry for PieceGenerators\nimport type { PieceGenerator } from \"./piece/PieceGenerator\";\nexport const PieceGeneratorRegistry = new GeneratorRegistry<PieceGenerator>();\n\n// Public registry for TabPlacementStrategies\nimport type { TabPlacementStrategy } from \"./tab_placement/TabPlacementStrategy\";\nexport const TabPlacementStrategyRegistry = new GeneratorRegistry<TabPlacementStrategy>();\n\n// Public registry for TabGenerators\nimport type { TabGenerator } from \"./tab/TabGenerator\";\nexport const TabGeneratorRegistry = new GeneratorRegistry<TabGenerator>();\n","\nexport type UniqueId = number;\n\nlet id = 0;\nexport function getUniqueId(): UniqueId {\n  return id++;\n}\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x' + y')^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z') + (z'x\" - z\"x') + (x'y\" - x\"y'))\n    //   k(t) = -------------------------------------------------------\n    //                     (x' + y' + z')^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexport default arcToBezier;","function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\nexport default class SplayTree {\n\n  constructor(compare = DEFAULT_COMPARE, noDuplicates = false) {\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  }\n\n\n  rotateLeft(x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) y.left.parent = x;\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)                this._root = y;\n    else if (x === x.parent.left) x.parent.left = y;\n    else                          x.parent.right = y;\n    if (y) y.left = x;\n    x.parent = y;\n  }\n\n\n  rotateRight(x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) y.right.parent = x;\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)               this._root = y;\n    else if(x === x.parent.left) x.parent.left = y;\n    else                         x.parent.right = y;\n    if (y) y.right = x;\n    x.parent = y;\n  }\n\n\n  _splay(x) {\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) this.rotateRight(p);\n        else              this.rotateLeft(p);\n      } else if (p.left === x && p.parent.left === p) {\n        this.rotateRight(p.parent);\n        this.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this.rotateLeft(p.parent);\n        this.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this.rotateRight(p);\n        this.rotateLeft(p);\n      } else {\n        this.rotateLeft(p);\n        this.rotateRight(p);\n      }\n    }\n  }\n\n\n  splay(x) {\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) ggp.left  = x;\n        else                 ggp.right = x;\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else gp.left = null;\n\n            p.right   = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else gp.right = null;\n\n            x.left    = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else p.left = null;\n\n        x.right  = p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else gp.right = null;\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else gp.left = null;\n\n            x.right   = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else p.right = null;\n\n        x.left   = p;\n        p.parent = x;\n      }\n    }\n  }\n\n\n  replace(u, v) {\n    if (!u.parent) this._root = v;\n    else if (u === u.parent.left) u.parent.left = v;\n    else u.parent.right = v;\n    if (v) v.parent = u.parent;\n  }\n\n\n  minNode(u = this._root) {\n    if (u) while (u.left) u = u.left;\n    return u;\n  }\n\n\n  maxNode(u = this._root) {\n    if (u) while (u.right) u = u.right;\n    return u;\n  }\n\n\n  insert(key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) return;\n        else if (comp(z.key, key) < 0) z = z.right;\n        else z = z.left;\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) z = z.right;\n        else z = z.left;\n      }\n    }\n\n    z = { key, data, left: null, right: null, parent: p };\n\n    if (!p)                          this._root = z;\n    else if (comp(p.key, z.key) < 0) p.right = z;\n    else                             p.left  = z;\n\n    this.splay(z);\n    this._size++;\n    return z;\n  }\n\n\n  find (key) {\n    var z    = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if      (cmp < 0) z = z.right;\n      else if (cmp > 0) z = z.left;\n      else              return z;\n    }\n    return null;\n  }\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param  {Key} key\n   * @return {boolean} true/false\n   */\n  contains (key) {\n    var node       = this._root;\n    var comparator = this._compare;\n    while (node)  {\n      var cmp = comparator(key, node.key);\n      if      (cmp === 0) return true;\n      else if (cmp < 0)   node = node.left;\n      else                node = node.right;\n    }\n\n    return false;\n  }\n\n\n  remove (key) {\n    var z = this.find(key);\n\n    if (!z) return false;\n\n    this.splay(z);\n\n    if (!z.left) this.replace(z, z.right);\n    else if (!z.right) this.replace(z, z.left);\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  }\n\n\n  removeNode(z) {\n    if (!z) return false;\n\n    this.splay(z);\n\n    if (!z.left) this.replace(z, z.right);\n    else if (!z.right) this.replace(z, z.left);\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  }\n\n\n  erase (key) {\n    var z = this.find(key);\n    if (!z) return;\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) sMax.right = t;\n      else   this._root = t;\n      t.parent = sMax;\n    }\n\n    this._size--;\n  }\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) node = node.left;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) successor = successor.left;\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  }\n\n\n  /**\n   * Predecessor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) predecessor = predecessor.right;\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  }\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param  {forEachCallback} callback\n   * @return {SplayTree}\n   */\n  forEach(callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range(low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._compare;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param  {Array<Key>}    keys\n   * @param  {Array<Value>}  [values]\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n   *                                         tree's comparator. Sorting is done\n   *                                         in-place\n   * @return {AVLTree}\n   */\n  load(keys = [], values = [], presort = false) {\n    if (this._size !== 0) throw new Error('bulk-load: tree is not empty');\n    const size = keys.length;\n    if (presort) sort(keys, values, 0, size - 1, this._compare);\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  }\n\n\n  min() {\n    var node = this.minNode(this._root);\n    if (node) return node.key;\n    else      return null;\n  }\n\n\n  max() {\n    var node = this.maxNode(this._root);\n    if (node) return node.key;\n    else      return null;\n  }\n\n  isEmpty() { return this._root === null; }\n  get size() { return this._size; }\n\n\n  /**\n   * Create a tree and load it with items\n   * @param  {Array<Key>}          keys\n   * @param  {Array<Value>?}        [values]\n\n   * @param  {Function?}            [comparator]\n   * @param  {Boolean?}             [presort=false] Pre-sort keys and values, using\n   *                                               tree's comparator. Sorting is done\n   *                                               in-place\n   * @param  {Boolean?}             [noDuplicates=false]   Allow duplicates\n   * @return {SplayTree}\n   */\n  static createTree(keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  }\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","export const NORMAL               = 0;\nexport const NON_CONTRIBUTING     = 1;\nexport const SAME_TRANSITION      = 2;\nexport const DIFFERENT_TRANSITION = 3;\n","export const INTERSECTION = 0;\nexport const UNION        = 1;\nexport const DIFFERENCE   = 2;\nexport const XOR          = 3;\n","import {\n  NORMAL,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION,\n  NON_CONTRIBUTING\n} from './edge_type';\nimport {\n  INTERSECTION,\n  UNION,\n  DIFFERENCE,\n  XOR\n} from './operation';\n\n/**\n * @param  {SweepEvent} event\n * @param  {SweepEvent} prev\n * @param  {Operation} operation\n */\nexport default function computeFields (event, prev, operation) {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else {\n    if (event.isSubject === prev.isSubject) {\n      event.inOut      = !prev.inOut;\n      event.otherInOut = prev.otherInOut;\n\n    // previous line segment in sweepline belongs to the clipping polygon\n    } else {\n      event.inOut      = !prev.otherInOut;\n      event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n    }\n\n    // compute prevInResult field\n    if (prev) {\n      event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n        ? prev.prevInResult : prev;\n    }\n  }\n\n  // check if the line segment belongs to the Boolean operation\n  let isInResult = inResult(event, operation);\n  if (isInResult) {\n    event.resultTransition = determineResultTransition(event, operation);\n  } else {\n    event.resultTransition = 0;\n  }\n}\n\n\n/* eslint-disable indent */\nfunction inResult(event, operation) {\n  switch (event.type) {\n    case NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          // return (event.isSubject && !event.otherInOut) ||\n          //         (!event.isSubject && event.otherInOut);\n          return (event.isSubject && event.otherInOut) ||\n                  (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n      break;\n    case SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}\n/* eslint-enable indent */\n\n\nfunction determineResultTransition(event, operation) {\n  let thisIn = !event.inOut;\n  let thatIn = !event.otherInOut;\n\n  let isIn;\n  switch (operation) {\n    case INTERSECTION:\n      isIn = thisIn && thatIn; break;\n    case UNION:\n      isIn = thisIn || thatIn; break;\n    case XOR:\n      isIn = thisIn ^ thatIn; break;\n    case DIFFERENCE:\n      if (event.isSubject) {\n        isIn = thisIn && !thatIn;\n      } else {\n        isIn = thatIn && !thisIn;\n      }\n      break;\n  }\n  return isIn ? +1 : -1;\n}\n","import { NORMAL } from './edge_type';\n\n\nexport default class SweepEvent {\n\n\n  /**\n   * Sweepline event\n   *\n   * @class {SweepEvent}\n   * @param {Array.<Number>}  point\n   * @param {Boolean}         left\n   * @param {SweepEvent=}     otherEvent\n   * @param {Boolean}         isSubject\n   * @param {Number}          edgeType\n   */\n  constructor (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Type of result transition (0 = not in result, +1 = out-in, -1, in-out)\n     * @type {Number}\n     */\n    this.resultTransition = 0;\n\n    // connection step\n\n    /**\n     * @type {Number}\n     */\n    this.otherPos = -1;\n\n    /**\n     * @type {Number}\n     */\n    this.outputContourId = -1;\n\n    this.isExteriorRing = true;   // TODO: Looks unused, remove?\n  }\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isBelow (p) {\n    const p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  }\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isAbove (p) {\n    return !this.isBelow(p);\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  }\n\n\n  /**\n   * Does event belong to result?\n   * @return {Boolean}\n   */\n  get inResult() {\n    return this.resultTransition !== 0;\n  }\n\n\n  clone () {\n    const copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.contourId        = this.contourId;\n    copy.resultTransition = this.resultTransition;\n    copy.prevInResult     = this.prevInResult;\n    copy.isExteriorRing   = this.isExteriorRing;\n    copy.inOut            = this.inOut;\n    copy.otherInOut       = this.otherInOut;\n\n    return copy;\n  }\n}\n","export default function equals(p1, p2) {\n  if (p1[0] === p2[0]) {\n    if (p1[1] === p2[1]) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n// const EPSILON = 1e-9;\n// const abs = Math.abs;\n// TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n// Precision problem.\n//\n// module.exports = function equals(p1, p2) {\n//   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n// };\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import {orient2d} from 'robust-predicates';\n\n/**\n * Signed area of the triangle (p0, p1, p2)\n * @param  {Array.<Number>} p0\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Number}\n */\nexport default function signedArea(p0, p1, p2) {\n  const res = orient2d(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]);\n  if (res > 0) return -1;\n  if (res < 0) return 1;\n  return 0;\n}\n","import signedArea from './signed_area';\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nexport default function compareEvents(e1, e2) {\n  const p1 = e1.point;\n  const p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  return specialCases(e1, e2, p1, p2);\n}\n\n\n/* eslint-disable no-unused-vars */\nfunction specialCases(e1, e2, p1, p2) {\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n  // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n/* eslint-enable no-unused-vars */\n","import SweepEvent    from './sweep_event';\nimport equals        from './equals';\nimport compareEvents from './compare_events';\n\n/**\n * @param  {SweepEvent} se\n * @param  {Array.<Number>} p\n * @param  {Queue} queue\n * @return {Queue}\n */\nexport default function divideSegment(se, p, queue)  {\n  const r = new SweepEvent(p, false, se,            se.isSubject);\n  const l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  /* eslint-disable no-console */\n  if (equals(se.point, se.otherEvent.point)) {\n    console.warn('what is that, a collapsed segment?', se);\n  }\n  /* eslint-enable no-console */\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n}\n","//const EPS = 1e-9;\n\n/**\n * Finds the magnitude of the cross product of two vectors (if we pretend\n * they're in three dimensions)\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The magnitude of the cross product\n */\nfunction crossProduct(a, b) {\n  return (a[0] * b[1]) - (a[1] * b[0]);\n}\n\n/**\n * Finds the dot product of two vectors.\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The dot product\n */\nfunction dotProduct(a, b) {\n  return (a[0] * b[0]) + (a[1] * b[1]);\n}\n\n/**\n * Finds the intersection (if any) between two line segments a and b, given the\n * line segments' end points a1, a2 and b1, b2.\n *\n * This algorithm is based on Schneider and Eberly.\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n * Page 244.\n *\n * @param {Array.<Number>} a1 point of first line\n * @param {Array.<Number>} a2 point of first line\n * @param {Array.<Number>} b1 point of second line\n * @param {Array.<Number>} b2 point of second line\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n *                                         (meaning connected segments) as\n *                                         intersections\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n * intersection. If they overlap, the two end points of the overlapping segment.\n * Otherwise, null.\n */\nexport default function (a1, a2, b1, b2, noEndpointTouch) {\n  // The algorithm expects our lines in the form P + sd, where P is a point,\n  // s is on the interval [0, 1], and d is a vector.\n  // We are passed two points. P can be the first point of each pair. The\n  // vector, then, could be thought of as the distance (in x and y components)\n  // from the first point to the second point.\n  // So first, let's make our vectors:\n  const va = [a2[0] - a1[0], a2[1] - a1[1]];\n  const vb = [b2[0] - b1[0], b2[1] - b1[1]];\n  // We also define a function to convert back to regular point form:\n\n  /* eslint-disable arrow-body-style */\n\n  function toPoint(p, s, d) {\n    return [\n      p[0] + s * d[0],\n      p[1] + s * d[1]\n    ];\n  }\n\n  /* eslint-enable arrow-body-style */\n\n  // The rest is pretty much a straight port of the algorithm.\n  const e = [b1[0] - a1[0], b1[1] - a1[1]];\n  let kross    = crossProduct(va, vb);\n  let sqrKross = kross * kross;\n  const sqrLenA  = dotProduct(va, va);\n  //const sqrLenB  = dotProduct(vb, vb);\n\n  // Check for line intersection. This works because of the properties of the\n  // cross product -- specifically, two vectors are parallel if and only if the\n  // cross product is the 0 vector. The full calculation involves relative error\n  // to account for possible very small line segments. See Schneider & Eberly\n  // for details.\n  if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n    // If they're not parallel, then (because these are line segments) they\n    // still might not actually intersect. This code checks that the\n    // intersection point of the lines is actually on both line segments.\n    const s = crossProduct(e, vb) / kross;\n    if (s < 0 || s > 1) {\n      // not on line segment a\n      return null;\n    }\n    const t = crossProduct(e, va) / kross;\n    if (t < 0 || t > 1) {\n      // not on line segment b\n      return null;\n    }\n    if (s === 0 || s === 1) {\n      // on an endpoint of line segment a\n      return noEndpointTouch ? null : [toPoint(a1, s, va)];\n    }\n    if (t === 0 || t === 1) {\n      // on an endpoint of line segment b\n      return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n    }\n    return [toPoint(a1, s, va)];\n  }\n\n  // If we've reached this point, then the lines are either parallel or the\n  // same, but the segments could overlap partially or fully, or not at all.\n  // So we need to find the overlap, if any. To do that, we can use e, which is\n  // the (vector) difference between the two initial points. If this is parallel\n  // with the line itself, then the two lines are the same line, and there will\n  // be overlap.\n  //const sqrLenE = dotProduct(e, e);\n  kross = crossProduct(e, va);\n  sqrKross = kross * kross;\n\n  if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n  // Lines are just parallel, not the same. No overlap.\n    return null;\n  }\n\n  const sa = dotProduct(va, e) / sqrLenA;\n  const sb = sa + dotProduct(va, vb) / sqrLenA;\n  const smin = Math.min(sa, sb);\n  const smax = Math.max(sa, sb);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n\n    // overlap on an end point\n    if (smin === 1) {\n      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n    }\n\n    if (smax === 0) {\n      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    if (noEndpointTouch && smin === 0 && smax === 1) return null;\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    return [\n      toPoint(a1, smin > 0 ? smin : 0, va),\n      toPoint(a1, smax < 1 ? smax : 1, va)\n    ];\n  }\n\n  return null;\n}\n","import divideSegment from './divide_segment';\nimport intersection  from './segment_intersection';\nimport equals        from './equals';\nimport compareEvents from './compare_events';\nimport {\n  NON_CONTRIBUTING,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION\n} from './edge_type';\n\n/**\n * @param  {SweepEvent} se1\n * @param  {SweepEvent} se2\n * @param  {Queue}      queue\n * @return {Number}\n */\nexport default function possibleIntersection (se1, se2, queue) {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n  const inter = intersection(\n    se1.point, se1.otherEvent.point,\n    se2.point, se2.otherEvent.point\n  );\n\n  const nintersections = inter ? inter.length : 0;\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n    // if(se1.contourId === se2.contourId){\n    // console.warn('Edges of the same polygon overlap',\n    //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    // }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n      divideSegment(se1, inter[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n      divideSegment(se2, inter[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  const events        = [];\n  let leftCoincide  = false;\n  let rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se2.type = NON_CONTRIBUTING;\n    se1.type = (se2.inOut === se1.inOut)\n      ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[1].otherEvent, events[0].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n}\n","import signedArea    from './signed_area';\nimport compareEvents from './compare_events';\nimport equals        from './equals';\n\n\n/**\n * @param  {SweepEvent} le1\n * @param  {SweepEvent} le2\n * @return {Number}\n */\nexport default function compareSegments(le1, le2) {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return le1.isBelow(le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    let p1 = le1.point, p2 = le2.point;\n    if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n      p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]) return 0;\n      else return le1.contourId > le2.contourId ? 1 : -1;\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n}\n","import Tree                 from 'splaytree';\nimport computeFields        from './compute_fields';\nimport possibleIntersection from './possible_intersection';\nimport compareSegments      from './compare_segments';\nimport {\n  INTERSECTION,\n  DIFFERENCE\n} from './operation';\n\n\nexport default function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n  const sweepLine = new Tree(compareSegments);\n  const sortedEvents = [];\n\n  const rightbound = Math.min(sbbox[2], cbbox[2]);\n\n  let prev, next, begin;\n\n  while (eventQueue.length !== 0) {\n    let event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      next  = prev = sweepLine.insert(event);\n      begin = sweepLine.minNode();\n\n      if (prev !== begin) prev = sweepLine.prev(prev);\n      else                prev = null;\n\n      next = sweepLine.next(next);\n\n      const prevEvent = prev ? prev.key : null;\n      let prevprevEvent;\n      computeFields(event, prevEvent, operation);\n      if (next) {\n        if (possibleIntersection(event, next.key, eventQueue) === 2) {\n          computeFields(event, prevEvent, operation);\n          computeFields(next.key, event, operation);\n        }\n      }\n\n      if (prev) {\n        if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n          let prevprev = prev;\n          if (prevprev !== begin) prevprev = sweepLine.prev(prevprev);\n          else                    prevprev = null;\n\n          prevprevEvent = prevprev ? prevprev.key : null;\n          computeFields(prevEvent, prevprevEvent, operation);\n          computeFields(event,     prevEvent,     operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = prev = sweepLine.find(event);\n\n      if (prev && next) {\n\n        if (prev !== begin) prev = sweepLine.prev(prev);\n        else                prev = null;\n\n        next = sweepLine.next(next);\n        sweepLine.remove(event);\n\n        if (next && prev) {\n          possibleIntersection(prev.key, next.key, eventQueue);\n        }\n      }\n    }\n  }\n  return sortedEvents;\n}\n","export default class Contour {\n\n  /**\n   * Contour\n   *\n   * @class {Contour}\n   */\n  constructor() {\n    this.points = [];\n    this.holeIds = [];\n    this.holeOf = null;\n    this.depth = null;\n  }\n\n  isExterior() {\n    return this.holeOf == null;\n  }\n\n}\n","import compareEvents from './compare_events';\nimport Contour from './contour';\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<SweepEvent>}\n */\nfunction orderEvents(sortedEvents) {\n  let event, i, len, tmp;\n  const resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  let sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        tmp = resultEvents[i];\n        resultEvents[i] = resultEvents[i + 1];\n        resultEvents[i + 1] = tmp;\n        sorted = false;\n      }\n    }\n  }\n\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    event.otherPos = i;\n  }\n\n  // imagine, the right event is found in the beginning of the queue,\n  // when his left counterpart is not marked yet\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    if (!event.left) {\n      tmp = event.otherPos;\n      event.otherPos = event.otherEvent.otherPos;\n      event.otherEvent.otherPos = tmp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\n/**\n * @param  {Number} pos\n * @param  {Array.<SweepEvent>} resultEvents\n * @param  {Object>}    processed\n * @return {Number}\n */\nfunction nextPos(pos, resultEvents, processed, origPos) {\n  let newPos = pos + 1,\n    p = resultEvents[pos].point,\n    p1;\n  const length = resultEvents.length;\n\n  if (newPos < length)\n    p1 = resultEvents[newPos].point;\n\n  while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else {\n      newPos++;\n    }\n    if (newPos < length) {\n      p1 = resultEvents[newPos].point;\n    }\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos] && newPos > origPos) {\n    newPos--;\n  }\n\n  return newPos;\n}\n\n\nfunction initializeContourFromContext(event, contours, contourId) {\n  const contour = new Contour();\n  if (event.prevInResult != null) {\n    const prevInResult = event.prevInResult;\n    // Note that it is valid to query the \"previous in result\" for its output contour id,\n    // because we must have already processed it (i.e., assigned an output contour id)\n    // in an earlier iteration, otherwise it wouldn't be possible that it is \"previous in\n    // result\".\n    const lowerContourId = prevInResult.outputContourId;\n    const lowerResultTransition = prevInResult.resultTransition;\n    if (lowerResultTransition > 0) {\n      // We are inside. Now we have to check if the thing below us is another hole or\n      // an exterior contour.\n      const lowerContour = contours[lowerContourId];\n      if (lowerContour.holeOf != null) {\n        // The lower contour is a hole => Connect the new contour as a hole to its parent,\n        // and use same depth.\n        const parentContourId = lowerContour.holeOf;\n        contours[parentContourId].holeIds.push(contourId);\n        contour.holeOf = parentContourId;\n        contour.depth = contours[lowerContourId].depth;\n      } else {\n        // The lower contour is an exterior contour => Connect the new contour as a hole,\n        // and increment depth.\n        contours[lowerContourId].holeIds.push(contourId);\n        contour.holeOf = lowerContourId;\n        contour.depth = contours[lowerContourId].depth + 1;\n      }\n    } else {\n      // We are outside => this contour is an exterior contour of same depth.\n      contour.holeOf = null;\n      contour.depth = contours[lowerContourId].depth;\n    }\n  } else {\n    // There is no lower/previous contour => this contour is an exterior contour of depth 0.\n    contour.holeOf = null;\n    contour.depth = 0;\n  }\n  return contour;\n}\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<*>} polygons\n */\nexport default function connectEdges(sortedEvents) {\n  let i, len;\n  const resultEvents = orderEvents(sortedEvents);\n\n  // \"false\"-filled array\n  const processed = {};\n  const contours = [];\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n\n    if (processed[i]) {\n      continue;\n    }\n\n    const contourId = contours.length;\n    const contour = initializeContourFromContext(resultEvents[i], contours, contourId);\n\n    // Helper function that combines marking an event as processed with assigning its output contour ID\n    const markAsProcessed = (pos) => {\n      processed[pos] = true;\n      if (pos < resultEvents.length && resultEvents[pos]) {\n        resultEvents[pos].outputContourId = contourId;\n      }\n    };\n\n    let pos = i;\n    let origPos = i;\n\n    const initial = resultEvents[i].point;\n    contour.points.push(initial);\n\n    /* eslint no-constant-condition: \"off\" */\n    while (true) {\n      markAsProcessed(pos);\n\n      pos = resultEvents[pos].otherPos;\n\n      markAsProcessed(pos);\n      contour.points.push(resultEvents[pos].point);\n\n      pos = nextPos(pos, resultEvents, processed, origPos);\n\n      if (pos == origPos || pos >= resultEvents.length || !resultEvents[pos]) {\n        break;\n      }\n    }\n\n    contours.push(contour);\n  }\n\n  return contours;\n}\n","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","import Queue           from 'tinyqueue';\nimport SweepEvent      from './sweep_event';\nimport compareEvents   from './compare_events';\nimport { DIFFERENCE }  from './operation';\n\nconst max = Math.max;\nconst min = Math.min;\n\nlet contourId = 0;\n\n\nfunction processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n  let i, len, s1, s2, e1, e2;\n  for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n    s1 = contourOrHole[i];\n    s2 = contourOrHole[i + 1];\n    e1 = new SweepEvent(s1, false, undefined, isSubject);\n    e2 = new SweepEvent(s2, false, e1,        isSubject);\n    e1.otherEvent = e2;\n\n    if (s1[0] === s2[0] && s1[1] === s2[1]) {\n      continue; // skip collapsed edges, or it breaks\n    }\n\n    e1.contourId = e2.contourId = depth;\n    if (!isExteriorRing) {\n      e1.isExteriorRing = false;\n      e2.isExteriorRing = false;\n    }\n    if (compareEvents(e1, e2) > 0) {\n      e2.left = true;\n    } else {\n      e1.left = true;\n    }\n\n    const x = s1[0], y = s1[1];\n    bbox[0] = min(bbox[0], x);\n    bbox[1] = min(bbox[1], y);\n    bbox[2] = max(bbox[2], x);\n    bbox[3] = max(bbox[3], y);\n\n    // Pushing it so the queue is sorted from left to right,\n    // with object on the left having the highest priority.\n    Q.push(e1);\n    Q.push(e2);\n  }\n}\n\n\nexport default function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n  const eventQueue = new Queue(null, compareEvents);\n  let polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n  for (i = 0, ii = subject.length; i < ii; i++) {\n    polygonSet = subject[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n    }\n  }\n\n  for (i = 0, ii = clipping.length; i < ii; i++) {\n    polygonSet = clipping[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (operation === DIFFERENCE) isExteriorRing = false;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n    }\n  }\n\n  return eventQueue;\n}\n","import subdivideSegments from './subdivide_segments';\nimport connectEdges      from './connect_edges';\nimport fillQueue         from './fill_queue';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  UNION,\n  XOR\n}        from './operation';\n\nconst EMPTY = [];\n\n\nfunction trivialOperation(subject, clipping, operation) {\n  let result = null;\n  if (subject.length * clipping.length === 0) {\n    if        (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n  let result = null;\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if        (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) {\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nexport default function boolean(subject, clipping, operation) {\n  if (typeof subject[0][0][0] === 'number') {\n    subject = [subject];\n  }\n  if (typeof clipping[0][0][0] === 'number') {\n    clipping = [clipping];\n  }\n  let trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  const sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n  const cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  // console.time('fill queue');\n  const eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('fill queue');\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  // console.time('subdivide edges');\n  const sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('subdivide edges');\n\n  // console.time('connect vertices');\n  const contours = connectEdges(sortedEvents, operation);\n  //console.timeEnd('connect vertices');\n\n  // Convert contours to polygons\n  const polygons = [];\n  for (let i = 0; i < contours.length; i++) {\n    let contour = contours[i];\n    if (contour.isExterior()) {\n      // The exterior ring goes first\n      let rings = [contour.points];\n      // Followed by holes if any\n      for (let j = 0; j < contour.holeIds.length; j++) {\n        let holeId = contour.holeIds[j];\n        rings.push(contours[holeId].points);\n      }\n      polygons.push(rings);\n    }\n  }\n\n  return polygons;\n}\n","import boolean from './src/';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  UNION,\n  XOR\n} from './src/operation';\n\nexport function union (subject, clipping) {\n  return boolean(subject, clipping, UNION);\n}\n\nexport function diff (subject, clipping) {\n  return boolean(subject, clipping, DIFFERENCE);\n}\n\nexport function xor (subject, clipping) {\n  return boolean(subject, clipping, XOR);\n}\n\nexport function intersection (subject, clipping) {\n  return boolean(subject, clipping, INTERSECTION);\n}\n\n/**\n * @enum {Number}\n */\nexport const operations = { UNION, DIFFERENCE, INTERSECTION, XOR };\n","// this file contains various geometry-related utilities\nimport type {\n  AABB,\n  ArcTo,\n  CurveTo,\n  Edge,\n  EdgeID,\n  EdgeSegment,\n  HalfEdge,\n  HalfEdgeID,\n  PathCommand,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  RandomFn,\n  Vec2,\n  Vertex,\n  VertexID,\n} from \"./types\";\nimport { getUniqueId } from \"../utils/UniqueId\";\nimport { Bezier } from \"bezier-js\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\nimport * as martinez from 'martinez-polygon-clipping';\nimport type { TabGenerator } from \"./generators/tab/TabGenerator\";\n\n/**\n * Calculates the squared Euclidean distance between two points.\n * Used for efficient distance comparisons without the need for Math.sqrt().\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns The squared distance between the points.\n */\nexport function distanceSq(p1: Vec2, p2: Vec2): number {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\n\n/** Serializable version of PuzzleTopology */\nexport interface PuzzleTopologySerializable {\n  vertices: Vertex[];\n  pieces: [PieceID, Piece][];\n  edges: [EdgeID, Edge][];\n  halfEdges: [HalfEdgeID, HalfEdge][];\n  boundary: EdgeID[];\n  borderPath: PathCommand[];\n}\n\n/**\n * Converts a PuzzleTopology with Maps to a plain object representation. Note that\n * modern browsers support Map with structuredClone(), but older browsers do not,\n * so it is safer to manually serialize.\n */\nexport function serializeTopology(topology: PuzzleTopology): PuzzleTopologySerializable {\n  return {\n    vertices: topology.vertices,\n    pieces: Array.from(topology.pieces.entries()),\n    edges: Array.from(topology.edges.entries()),\n    halfEdges: Array.from(topology.halfEdges.entries()),\n    boundary: topology.boundary,\n    borderPath: topology.borderPath,\n  };\n}\n\n/** Revives a serialized topology back into a PuzzleTopology with Maps. */\nexport function deserializeTopology(serialized: PuzzleTopologySerializable): PuzzleTopology {\n  return {\n    vertices: serialized.vertices,\n    pieces: new Map(serialized.pieces),\n    edges: new Map(serialized.edges),\n    halfEdges: new Map(serialized.halfEdges),\n    boundary: serialized.boundary,\n    borderPath: serialized.borderPath,\n  };\n}\n\n\n/**\n * Checks if two Axis-Aligned Bounding Boxes intersect.\n * @param a - The first AABB.\n * @param b - The second AABB.\n * @returns `true` if they overlap, `false` otherwise.\n */\nexport function doAABBsIntersect(a: AABB, b: AABB): boolean {\n  // x-axis check\n  if (a[2] < b[0] || a[0] > b[2]) {\n    return false;\n  }\n  // y-axis check\n  if (a[3] < b[1] || a[1] > b[3]) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a path.\n *\n * @param startPoint The starting point of the path.\n * @param segments The array of segments defining the rest of the path.\n * @returns Bounding box for the entire set of segments\n */\nexport function calculateSegmentsBounds(startPoint: Vec2, segments: EdgeSegment[]): AABB {\n  let [xmin, ymin] = startPoint;\n  let [xmax, ymax] = startPoint;\n\n  const updateBounds = (p: Vec2) => {\n    xmin = Math.min(xmin, p[0]);\n    ymin = Math.min(ymin, p[1]);\n    xmax = Math.max(xmax, p[0]);\n    ymax = Math.max(ymax, p[1]);\n  };\n\n  for (const segment of segments) {\n    if (segment.type === 'line') {\n      updateBounds(segment.p);\n    } else { // 'bezier'\n      // For a robust bounding box, we must check the control points,\n      // as the curve can extend beyond its endpoint.\n      updateBounds(segment.p1);\n      updateBounds(segment.p2);\n      updateBounds(segment.p3);\n    }\n  }\n\n  return [xmin, ymin, xmax, ymax];\n}\n\n/**\n * Calculates the precise bounding box for a single puzzle piece by traversing\n * its boundary and finding the extremities of all its geometric segments.\n *\n * @param piece The piece whose bounding box needs to be recalculated.\n * @param topology The full puzzle topology, used to access half-edge data.\n * @returns A new AABB for the piece.\n */\nexport function getPieceBounds(piece: Piece, topology: PuzzleTopology): AABB {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  const startingEdgeId = piece.halfEdge;\n  let currentEdge = topology.halfEdges.get(startingEdgeId);\n\n  if (!currentEdge) {\n    // Should not happen in a valid topology\n    return piece.bounds;\n  }\n\n  // helper function expands the bounding box to include a given point.\n  const updateBounds = (p: Vec2) => {\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  };\n\n  // Traverse the entire boundary of the piece, one half-edge at a time.\n  do {\n    // account for the starting point of the current edge\n    updateBounds(currentEdge.origin);\n\n    // account for all points within the edge's segments (if any)\n    if (currentEdge.segments) {\n      const segmentBounds = calculateSegmentsBounds(currentEdge.origin, currentEdge.segments);\n      updateBounds([segmentBounds[0], segmentBounds[1]]);\n      updateBounds([segmentBounds[2], segmentBounds[3]]);\n    }\n\n    // move to the next half-edge around the piece\n    currentEdge = topology.halfEdges.get(currentEdge.next);\n\n  } while (currentEdge && currentEdge.id !== startingEdgeId);\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n// The maximum distance (in pixels) from a click to a vertex to consider it a \"hit\".\nconst MAX_CLICK_DISTANCE = 100;\nconst MAX_CLICK_DISTANCE_SQ = MAX_CLICK_DISTANCE * MAX_CLICK_DISTANCE;\n\n/**\n * Finds the index of the vertex closest to a given point.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The index of the closest vertex in the `topology.vertices` array,\n * or `null` if no vertex is within the click threshold.\n */\nexport function findClosestVertex(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): VertexID | null {\n  let closestVertexIndex = -1;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (let i = 0; i < puzzle.vertices.length; i++) {\n    const distSq = distanceSq(puzzle.vertices[i], clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestVertexIndex = i;\n    }\n  }\n\n  return closestVertexIndex === -1 ? null : closestVertexIndex;\n}\n\n/**\n * Finds the piece ID of the seed point closest to a given position.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The PieceID whose seed point is closest, or null if none within threshold.\n */\nexport function findClosestSeedPoint(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): PieceID | null {\n  let closestPieceId: PieceID | null = null;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (const piece of puzzle.pieces.values()) {\n    const distSq = distanceSq(piece.site, clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestPieceId = piece.id;\n    }\n  }\n\n  return closestPieceId;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a given polygon.\n * @param polygon - An array of vertices representing the polygon.\n * @returns The AABB or a zero-area box at the origin if the polygon is empty.\n */\nexport function polygonBounds(polygon: Vec2[]): AABB {\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = polygon[0][0];\n  let minY = polygon[0][1];\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 1; i < polygon.length; i++) {\n    const p = polygon[i];\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n/**\n * Checks if two points are effectively at the same location.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns `true` if points are equal.\n */\nexport function arePointsEqual(p1: Vec2, p2: Vec2): boolean {\n  return Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6;\n}\n\n/**\n * Calculates the area of a polygon using the shoelace formula.\n * @param polygon The polygon vertices.\n * @returns The absolute area of the polygon.\n */\nexport function polygonArea(polygon: Vec2[]): number {\n  if (polygon.length < 3) return 0;\n\n  let area = 0;\n  for (let i = 0; i < polygon.length; i++) {\n    const j = (i + 1) % polygon.length;\n    area += polygon[i][0] * polygon[j][1];\n    area -= polygon[j][0] * polygon[i][1];\n  }\n  return Math.abs(area / 2);\n}\n\n/**\n * Calculates the centroid of a polygon.\n * @param polygon The polygon vertices.\n * @returns The centroid point.\n */\nexport function calculateCentroid(polygon: Vec2[]): Vec2 {\n  if (polygon.length === 0) return [0, 0];\n\n  const sum = polygon.reduce(\n    (acc, v) => [acc[0] + v[0], acc[1] + v[1]] as Vec2,\n    [0, 0] as Vec2\n  );\n\n  return [sum[0] / polygon.length, sum[1] / polygon.length];\n}\n\n/**\n * Extracts the polygon vertices for a piece by traversing its half-edge loop.\n * @param piece The piece to extract vertices from.\n * @param topology The puzzle topology.\n * @returns Array of vertices in counter-clockwise order.\n */\nexport function extractPiecePolygon(piece: Piece, topology: PuzzleTopology): Vec2[] {\n  const vertices: Vec2[] = [];\n  const startHeId = piece.halfEdge;\n\n  if (startHeId === -1) return vertices;\n\n  let currentHeId = startHeId;\n  do {\n    const he = topology.halfEdges.get(currentHeId);\n    if (!he) break;\n\n    vertices.push(he.origin);\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId && currentHeId !== -1);\n\n  return vertices;\n}\n\n/**\n * Collects all half-edges for a piece by traversing its half-edge loop.\n * @param piece The piece to collect half-edges from.\n * @param topology The puzzle topology.\n * @returns Array of half-edges belonging to this piece.\n */\nexport function collectPieceHalfEdges(piece: Piece, topology: PuzzleTopology): HalfEdge[] {\n  const halfEdges: HalfEdge[] = [];\n  const startHeId = piece.halfEdge;\n\n  if (startHeId === -1) return halfEdges;\n\n  let currentHeId = startHeId;\n  do {\n    const he = topology.halfEdges.get(currentHeId);\n    if (!he) break;\n\n    halfEdges.push(he);\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId && currentHeId !== -1);\n\n  return halfEdges;\n}\n\n/**\n * Gets all neighboring pieces for a given piece by traversing twin edges.\n * Includes geometric proximity fallback for fragments created by polygon clipping.\n * @param piece The piece to find neighbors for.\n * @param topology The puzzle topology.\n * @param proximityThreshold Maximum distance to consider pieces adjacent (default: 2 pixels).\n * @returns Array of [pieceId, sharedEdgeLength] tuples for procedural piece neighbors.\n */\nexport function getPieceNeighbors(\n  piece: Piece,\n  topology: PuzzleTopology,\n  proximityThreshold = 2.0\n): [PieceID, number][] {\n  const neighbors = new Map<PieceID, number>();\n  const startHeId = piece.halfEdge;\n\n  // First pass: collect neighbors via twin edges (fast, accurate)\n  if (startHeId !== -1) {\n    let currentHeId = startHeId;\n    do {\n      const he = topology.halfEdges.get(currentHeId);\n      if (!he) break;\n\n      // Check if this half-edge has a twin (neighbor piece)\n      if (he.twin !== -1) {\n        const twin = topology.halfEdges.get(he.twin);\n        if (twin && twin.piece !== piece.id) {\n          const neighborPiece = topology.pieces.get(twin.piece);\n          // Only include procedural pieces (exclude custom pieces)\n          if (neighborPiece && !neighborPiece.isCustomPiece) {\n            // Calculate edge length\n            const next = topology.halfEdges.get(he.next);\n            if (next) {\n              const edgeLength = Math.hypot(\n                next.origin[0] - he.origin[0],\n                next.origin[1] - he.origin[1]\n              );\n\n              // Accumulate edge length for this neighbor\n              const currentLength = neighbors.get(twin.piece) ?? 0;\n              neighbors.set(twin.piece, currentLength + edgeLength);\n            }\n          }\n        }\n      }\n\n      currentHeId = he.next;\n    } while (currentHeId !== startHeId && currentHeId !== -1);\n  }\n\n  // If we found neighbors via twins, return them\n  if (neighbors.size > 0) {\n    return Array.from(neighbors.entries());\n  }\n\n  // Fallback: geometric proximity check for fragments with no valid twins\n  // This happens when polygon clipping creates edges that don't match existing topology\n  const piecePolygon = extractPiecePolygon(piece, topology);\n  const pieceBounds = piece.bounds;\n\n  for (const [candidateId, candidate] of topology.pieces) {\n    // Skip self and custom pieces\n    if (candidateId === piece.id || candidate.isCustomPiece) continue;\n\n    // Quick rejection: check bounding boxes\n    const dx = Math.max(\n      pieceBounds[0] - candidate.bounds[2],\n      candidate.bounds[0] - pieceBounds[2]\n    );\n    const dy = Math.max(\n      pieceBounds[1] - candidate.bounds[3],\n      candidate.bounds[1] - pieceBounds[3]\n    );\n\n    if (dx < proximityThreshold && dy < proximityThreshold) {\n      // Bounding boxes are close, check vertex-to-edge distances\n      const candidatePolygon = extractPiecePolygon(candidate, topology);\n      let sharedEdgeLength = 0;\n\n      // Check if vertices of piece are close to edges of candidate\n      for (const vertex of piecePolygon) {\n        for (let i = 0; i < candidatePolygon.length; i++) {\n          const p1 = candidatePolygon[i];\n          const p2 = candidatePolygon[(i + 1) % candidatePolygon.length];\n\n          const dist = distanceToSegment(vertex, p1, p2);\n          if (dist < proximityThreshold) {\n            // Approximate shared edge length as distance between vertices\n            const edgeLen = Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);\n            sharedEdgeLength += edgeLen;\n            break; // Move to next vertex\n          }\n        }\n      }\n\n      if (sharedEdgeLength > 0) {\n        neighbors.set(candidateId, sharedEdgeLength);\n      }\n    }\n  }\n\n  return Array.from(neighbors.entries());\n}\n\n/**\n * Checks if a piece is adjacent to any custom pieces.\n * Uses both topology (twin edges) and geometric proximity as fallback.\n * @param piece The piece to check.\n * @param topology The puzzle topology.\n * @param proximityThreshold Maximum distance to consider pieces adjacent (default: 2 pixels).\n * @returns True if the piece is adjacent to at least one custom piece.\n */\nexport function isAdjacentToCustomPiece(\n  piece: Piece,\n  topology: PuzzleTopology,\n  proximityThreshold = 2.0\n): boolean {\n  // First, check via twin edges (fast path)\n  const startHeId = piece.halfEdge;\n  if (startHeId !== -1) {\n    let currentHeId = startHeId;\n    do {\n      const he = topology.halfEdges.get(currentHeId);\n      if (!he) break;\n\n      if (he.twin !== -1) {\n        const twin = topology.halfEdges.get(he.twin);\n        if (twin) {\n          const neighborPiece = topology.pieces.get(twin.piece);\n          if (neighborPiece?.isCustomPiece) {\n            return true;\n          }\n        }\n      }\n\n      currentHeId = he.next;\n    } while (currentHeId !== startHeId && currentHeId !== -1);\n  }\n\n  // Fallback: check geometric proximity to custom pieces\n  // This catches fragments created by polygon clipping that don't have proper twin edges\n  const customPieces = Array.from(topology.pieces.values()).filter((p) => p.isCustomPiece);\n  if (customPieces.length === 0) return false;\n\n  // Quick rejection: check bounding boxes\n  for (const customPiece of customPieces) {\n    const dx = Math.max(\n      piece.bounds[0] - customPiece.bounds[2],\n      customPiece.bounds[0] - piece.bounds[2]\n    );\n    const dy = Math.max(\n      piece.bounds[1] - customPiece.bounds[3],\n      customPiece.bounds[1] - piece.bounds[3]\n    );\n\n    if (dx < proximityThreshold && dy < proximityThreshold) {\n      // Bounding boxes are close, do detailed check\n      const piecePolygon = extractPiecePolygon(piece, topology);\n      const customPolygon = extractPiecePolygon(customPiece, topology);\n\n      // Check if any vertex of the piece is very close to any edge of the custom piece\n      for (const vertex of piecePolygon) {\n        for (let i = 0; i < customPolygon.length; i++) {\n          const p1 = customPolygon[i];\n          const p2 = customPolygon[(i + 1) % customPolygon.length];\n\n          const dist = distanceToSegment(vertex, p1, p2);\n          if (dist < proximityThreshold) {\n            return true;\n          }\n        }\n      }\n\n      // Also check if any vertex of the custom piece is close to any edge of the piece\n      for (const vertex of customPolygon) {\n        for (let i = 0; i < piecePolygon.length; i++) {\n          const p1 = piecePolygon[i];\n          const p2 = piecePolygon[(i + 1) % piecePolygon.length];\n\n          const dist = distanceToSegment(vertex, p1, p2);\n          if (dist < proximityThreshold) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Calculates the minimum distance from a point to a line segment.\n * @param point The point.\n * @param segStart Start of the line segment.\n * @param segEnd End of the line segment.\n * @returns The minimum distance.\n */\nfunction distanceToSegment(point: Vec2, segStart: Vec2, segEnd: Vec2): number {\n  const [px, py] = point;\n  const [x1, y1] = segStart;\n  const [x2, y2] = segEnd;\n\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lengthSq = dx * dx + dy * dy;\n\n  if (lengthSq === 0) {\n    // Degenerate segment (point)\n    return Math.hypot(px - x1, py - y1);\n  }\n\n  // Project point onto line, clamped to segment\n  let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;\n  t = Math.max(0, Math.min(1, t));\n\n  const projX = x1 + t * dx;\n  const projY = y1 + t * dy;\n\n  return Math.hypot(px - projX, py - projY);\n}\n\n/**\n * Merges two pieces into one by performing a polygon union and updating the topology.\n * This function:\n * 1. Extracts polygons for both pieces\n * 2. Performs a union operation\n * 3. Removes old half-edges and edges\n * 4. Creates a new half-edge loop for the merged polygon\n * 5. Re-links to neighboring pieces\n *\n * @param pieceAId The ID of the first piece (will be kept).\n * @param pieceBId The ID of the second piece (will be removed).\n * @param topology The puzzle topology to modify.\n * @param halfEdgeTwinMap The map of unmatched half-edges for re-linking.\n * @param isBoundaryEdgeFn Callback to determine if an edge is on the puzzle boundary.\n * @returns True if merge was successful, false otherwise.\n */\nexport function mergePieces(\n  pieceAId: PieceID,\n  pieceBId: PieceID,\n  topology: PuzzleTopology,\n  halfEdgeTwinMap: Map<string, HalfEdgeID>,\n  isBoundaryEdgeFn: (p1: Vec2, p2: Vec2) => boolean\n): boolean {\n  const pieceA = topology.pieces.get(pieceAId);\n  const pieceB = topology.pieces.get(pieceBId);\n\n  if (!pieceA || !pieceB) {\n    console.warn(`  Merge failed: piece not found (A: ${pieceA ? 'ok' : 'missing'}, B: ${pieceB ? 'ok' : 'missing'})`);\n    return false;\n  }\n\n  // 1. Extract polygons for both pieces\n  const polyA = extractPiecePolygon(pieceA, topology);\n  const polyB = extractPiecePolygon(pieceB, topology);\n\n  if (polyA.length < 3 || polyB.length < 3) {\n    console.warn(`  Merge failed: invalid polygons (A: ${polyA.length} verts, B: ${polyB.length} verts)`);\n    return false;\n  }\n\n  // 2. Union them using martinez polygon clipping\n  const martinezA: martinez.Polygon = [polyA.map((p) => [p[0], p[1]])];\n  const martinezB: martinez.Polygon = [polyB.map((p) => [p[0], p[1]])];\n\n  const union = martinez.union(martinezA, martinezB);\n\n  if (!union || union.length === 0) {\n    console.warn(`  Merge failed: union returned empty/null (polyA: ${polyA.length} verts, polyB: ${polyB.length} verts)`);\n    return false;\n  }\n\n  // Martinez returns either Polygon or MultiPolygon\n  // MultiPolygon: [[[[x,y]...]...]]\n  // Polygon: [[[x,y]...]...]\n  let mergedPolygon: Vec2[];\n\n  if (isMartinezPolygon(union)) {\n    // It's a Polygon - extract the outer ring (first element)\n    mergedPolygon = union[0].map((p) => [p[0], p[1]] as Vec2);\n  } else {\n    // It's a MultiPolygon - extract outer ring of first polygon\n    const firstPolygon = union[0];\n    if (!firstPolygon || !Array.isArray(firstPolygon[0])) {\n      console.warn(`  Merge failed: unexpected union format`);\n      return false;\n    }\n    mergedPolygon = firstPolygon[0].map((p) => [p[0], p[1]] as Vec2);\n  }\n\n  if (mergedPolygon.length < 3) {\n    console.warn(`  Merge failed: merged polygon has ${mergedPolygon.length} vertices`);\n    return false;\n  }\n\n  // 3. Collect all half-edges to remove\n  const halfEdgesToRemove = [\n    ...collectPieceHalfEdges(pieceA, topology),\n    ...collectPieceHalfEdges(pieceB, topology),\n  ];\n\n  // 4. For each half-edge to remove, handle its twin and clean up the map\n  const key = (p1: Vec2, p2: Vec2) => `${p1[0]},${p1[1]}-${p2[0]},${p2[1]}`;\n\n  for (const he of halfEdgesToRemove) {\n    // Remove this half-edge's entry from the twin map (if it exists)\n    const nextHe = topology.halfEdges.get(he.next);\n    if (nextHe) {\n      const selfKey = key(he.origin, nextHe.origin);\n      halfEdgeTwinMap.delete(selfKey);\n    }\n\n    if (he.twin !== -1) {\n      const twin = topology.halfEdges.get(he.twin);\n      if (twin && twin.piece !== pieceAId && twin.piece !== pieceBId) {\n        // This twin belongs to a different piece (neighbor), unlink it\n        twin.twin = -1;\n\n        // Add twin back to map for re-linking\n        const nextOfTwin = topology.halfEdges.get(twin.next);\n        if (nextOfTwin) {\n          const edgeKey = key(twin.origin, nextOfTwin.origin);\n          halfEdgeTwinMap.set(edgeKey, twin.id);\n        }\n      }\n    }\n  }\n\n  // 5. Remove old half-edges and their associated edges\n  for (const he of halfEdgesToRemove) {\n    // Find and remove any edge that references this half-edge\n    for (const [edgeId, edge] of topology.edges) {\n      if (edge.heLeft === he.id || edge.heRight === he.id) {\n        topology.edges.delete(edgeId);\n\n        // Remove from boundary list if present\n        const boundaryIndex = topology.boundary.indexOf(edgeId);\n        if (boundaryIndex !== -1) {\n          topology.boundary.splice(boundaryIndex, 1);\n        }\n        break;\n      }\n    }\n\n    // Remove the half-edge itself\n    topology.halfEdges.delete(he.id);\n  }\n\n  // 6. Remove pieceB from the topology\n  topology.pieces.delete(pieceBId);\n\n  // 7. Create new half-edge loop for the merged polygon\n  const newHalfEdges = createHalfEdgeLoop(mergedPolygon, pieceAId, topology);\n\n  if (newHalfEdges.length === 0) return false;\n\n  // 8. Update pieceA with new geometry\n  pieceA.halfEdge = newHalfEdges[0].id;\n  pieceA.bounds = polygonBounds(mergedPolygon);\n  pieceA.site = calculateCentroid(mergedPolygon);\n\n  // 9. Link new half-edges to neighbors\n  linkAndCreateEdges(newHalfEdges, topology, halfEdgeTwinMap, isBoundaryEdgeFn);\n\n  return true;\n}\n\n/**\n * Merges undersized fragments adjacent to custom pieces into their smallest procedural neighbors.\n * This is a post-processing step that can be applied after piece generation.\n *\n * @param topology The puzzle topology to process.\n * @param minFragmentArea Minimum area threshold - fragments smaller than this will be merged.\n * @param halfEdgeTwinMap The map of unmatched half-edges for re-linking after merges.\n * @param isBoundaryEdgeFn Callback to determine if an edge is on the puzzle boundary.\n * @returns The number of fragments merged.\n */\nexport function mergeFragmentsIntoNeighbors(\n  topology: PuzzleTopology,\n  minFragmentArea: number,\n  halfEdgeTwinMap: Map<string, HalfEdgeID>,\n  isBoundaryEdgeFn: (p1: Vec2, p2: Vec2) => boolean\n): number {\n  // Collect fragments to merge\n  const fragmentsToMerge: { pieceId: PieceID; area: number }[] = [];\n\n  for (const piece of topology.pieces.values()) {\n    // Skip custom pieces\n    if (piece.isCustomPiece) continue;\n\n    // Calculate actual polygon area (not bounding box)\n    const polygon = extractPiecePolygon(piece, topology);\n    const area = polygonArea(polygon);\n\n    // Check if it's below threshold\n    if (area < minFragmentArea) {\n      // Check if this piece is adjacent to any custom pieces\n      const isAdjacent = isAdjacentToCustomPiece(piece, topology);\n\n      if (!isAdjacent) {\n        console.log(`  Fragment ${piece.id} (${area.toFixed(0)}px) is undersized but NOT adjacent to custom pieces (skipping)`);\n        continue;\n      }\n\n      fragmentsToMerge.push({ pieceId: piece.id, area });\n    }\n  }\n\n  if (fragmentsToMerge.length === 0) {\n    return 0;\n  }\n\n  console.log(`Merge mode: found ${fragmentsToMerge.length} fragments to merge (< ${minFragmentArea.toFixed(0)}px)`);\n\n  // Sort fragments by area (smallest first) to avoid cascading size issues\n  fragmentsToMerge.sort((a, b) => a.area - b.area);\n\n  let mergedCount = 0;\n\n  for (const fragment of fragmentsToMerge) {\n    const piece = topology.pieces.get(fragment.pieceId);\n\n    // Piece may have been merged already in a previous iteration\n    if (!piece) continue;\n\n    // Get neighbors (excluding custom pieces)\n    const neighbors = getPieceNeighbors(piece, topology);\n\n    if (neighbors.length === 0) {\n      // Fragment has no procedural neighbors (only touches whimsies/boundary)\n      // Skip it - this is rare but possible\n      console.log(`  Skipping fragment ${fragment.pieceId}: no procedural neighbors`);\n      continue;\n    }\n\n    // Sort neighbors by area (smallest first)\n    neighbors.sort((a, b) => {\n      const pieceA = topology.pieces.get(a[0]);\n      const pieceB = topology.pieces.get(b[0]);\n      if (!pieceA || !pieceB) return 0;\n\n      const polyA = extractPiecePolygon(pieceA, topology);\n      const polyB = extractPiecePolygon(pieceB, topology);\n      const areaA = polygonArea(polyA);\n      const areaB = polygonArea(polyB);\n\n      return areaA - areaB;\n    });\n\n    // Merge into the smallest neighbor\n    const [targetPieceId] = neighbors[0];\n\n    const success = mergePieces(\n      targetPieceId,\n      fragment.pieceId,\n      topology,\n      halfEdgeTwinMap,\n      isBoundaryEdgeFn\n    );\n\n    if (success) {\n      mergedCount++;\n    } else {\n      console.warn(`  Failed to merge fragment ${fragment.pieceId} into piece ${targetPieceId}`);\n    }\n  }\n\n  console.log(`Merge mode: successfully merged ${mergedCount} fragments`);\n\n  return mergedCount;\n}\n\n/**\n * Generates the full segment path for an edge based on its TabPlacements.\n * This function modifies the half-edges of the provided edge in place.\n */\nexport function generateSegmentsForEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  tabGenerator: TabGenerator,\n  random: RandomFn\n): void {\n  if (!edge.tabs) { return; }\n  const heLeft = topology.halfEdges.get(edge.heLeft)!;\n  const heRight = topology.halfEdges.get(edge.heRight)!;\n\n  const edgeStart = heLeft.origin;\n  const edgeEnd = heRight.origin;\n  //const edgeLength = Math.hypot(edgeEnd[0] - edgeStart[0], edgeEnd[1] - edgeStart[1]);\n\n  const heLeftSegments: EdgeSegment[] = [];\n  let currentPos = edgeStart;\n\n  // Sort tabs by their position to process them in order\n  edge.tabs.sort((a, b) => a.position - b.position);\n\n  for (const tab of edge.tabs) {\n    //const tabWidth = edgeLength * tab.size;\n    // Calculate the start point of this tab's region\n    const tabStartPos = tab.position - tab.size / 2;\n    const tabStartPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * tabStartPos,\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * tabStartPos,\n    ];\n\n    // Add a straight line from the last position to the start of this tab\n    if (Math.hypot(tabStartPoint[0] - currentPos[0], tabStartPoint[1] - currentPos[1]) > 1e-6) {\n      heLeftSegments.push({ type: 'line', p: tabStartPoint });\n    }\n\n    // Generate segments for the tab itself\n    const tabEndPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * (tabStartPos + tab.size),\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * (tabStartPos + tab.size),\n    ];\n    const tabSegments = tabGenerator.createTabSegments(tabStartPoint, tabEndPoint, tab, random);\n    heLeftSegments.push(...tabSegments);\n\n    currentPos = tabEndPoint;\n  }\n\n  // Add a final line segment to the end of the edge\n  if (Math.hypot(edgeEnd[0] - currentPos[0], edgeEnd[1] - currentPos[1]) > 1e-6) {\n    heLeftSegments.push({ type: 'line', p: edgeEnd });\n  }\n\n  // Assign the generated segments and create the inverse for the twin\n  heLeft.segments = heLeftSegments;\n  heRight.segments = invertSegments(heLeftSegments, edgeStart);\n\n  // update the edge bounding box\n  edge.bounds = calculateSegmentsBounds(edgeStart, heLeftSegments);\n}\n\n/**\n * Creates an inverted copy of an array of edge segments.\n */\nexport function invertSegments(segments: EdgeSegment[], originalStart: Vec2): EdgeSegment[] {\n  const inverted: EdgeSegment[] = [];\n\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const segment = segments[i];\n    let segmentStart = originalStart;\n    if (i > 0) {\n      const prevSegment = segments[i-1];\n      segmentStart = (prevSegment.type === 'line') ? prevSegment.p : prevSegment.p3;\n    }\n\n    if (segment.type === 'line') {\n      inverted.push({ type: 'line', p: segmentStart });\n    } else { // 'bezier'\n      inverted.push({\n        type: 'bezier',\n        p1: segment.p2,\n        p2: segment.p1,\n        p3: segmentStart,\n      });\n    }\n  }\n  return inverted;\n}\n\n\n/**\n * Helper function to reverse a single Bzier curve segment.\n * The new curve starts where the old one ended and vice-versa.\n */\nexport function invertCurve(segment: CurveTo, newEndPoint: Vec2): CurveTo {\n  return {\n    type: 'bezier',\n    p1: segment.p2, // Control points are swapped\n    p2: segment.p1,\n    p3: newEndPoint, // The new end point is the start point of the original\n  };\n}\n\n/**\n * Converts an arc segment into an array of cubic Bzier curves.\n * @param start - The starting point of the arc.\n * @param arc - The ArcTo segment.\n * @returns An array of Bzier curve definitions.\n */\nfunction arcToBeziers(start: Vec2, arc: ArcTo): CurveTo[] {\n  const { p, radii, rotation, largeArc, sweep } = arc;\n  const [startX, startY] = start;\n  const [endX, endY] = p;\n  const [rx, ry] = radii;\n\n  const cubicBeziers = arcToBezier({\n    px: startX,\n    py: startY,\n    cx: endX,\n    cy: endY,\n    rx,\n    ry,\n    xAxisRotation: rotation,\n    largeArcFlag: largeArc ? 1 : 0,\n    sweepFlag: sweep ? 1 : 0,\n  });\n\n\n  // convert output to CurveTo\n  const curves: CurveTo[] = cubicBeziers.map((curve) => {\n    return {\n      type: 'bezier',\n      p1: [ curve.x1, curve.y1 ],\n      p2: [ curve.x2, curve.y2 ],\n      p3: [ curve.x, curve.y ],\n    };\n  });\n  return curves;\n}\n\n/**\n * Flattens a complex boundary path into an array of simple polygons.\n * This is used to prepare the boundary for geometric clipping operations.\n * @param boundary The boundary path to flatten.\n * @returns An array of polygons, where each polygon is an array of vertices.\n * The first polygon is the outer boundary, and subsequent ones are holes.\n */\nexport function flattenBoundary(boundary: PathCommand[]): Vec2[][] {\n  const polygons: Vec2[][] = [];\n  let currentPolygon: Vec2[] = [];\n\n  if (boundary.length === 0 || boundary[0].type !== 'move') {\n    // Return an empty array if the boundary is malformed or empty\n    return [];\n  }\n\n  let currentPoint: Vec2 = [0, 0];\n  for (const command of boundary) {\n    switch (command.type) {\n    case 'move':\n      if (currentPolygon.length > 0) {\n        polygons.push(currentPolygon);\n      }\n      currentPoint = command.p;\n      currentPolygon = [currentPoint];\n      break;\n\n    case 'line':\n      currentPolygon.push(command.p);\n      currentPoint = command.p;\n      break;\n\n    case 'bezier': {\n      // use bezier-js to create a Look-Up Table (LUT) of points\n      const { p1, p2, p3 } = command;\n      const curve = new Bezier([...currentPoint, ...p1, ...p2, ...p3]);\n      const points = curve.getLUT(100);\n      currentPolygon.push(...points.slice(1).map((p) => [p.x, p.y] as Vec2));\n      currentPoint = p3;\n      break;\n    }\n\n    case 'arc': {\n      // Convert the arc into one or more Bzier curves.\n      const beziers = arcToBeziers(currentPoint, command);\n      let arcStartPoint = currentPoint;\n      for (const b of beziers) {\n        // convert each Bzier as above\n        const curve = new Bezier([...arcStartPoint, ...b.p1, ...b.p2, ...b.p3]);\n        const points = curve.getLUT(100); // 100 points is a good approximation\n        currentPolygon.push(...points.slice(1).map((p) => [p.x, p.y] as Vec2));\n        arcStartPoint = b.p3;\n      }\n      currentPoint = command.p;\n      break;\n    }}\n  }\n  if (currentPolygon.length > 0) {\n    polygons.push(currentPolygon);\n  }\n\n  return polygons;\n}\n\n/**\n * Determines if a point is inside a complex boundary path.\n *\n * This function uses the ray casting (even-odd) algorithm. It handles complex\n * paths by first flattening them into a series of simple polygons. It also correctly\n * handles \"holes\" created by sub-paths (via `MoveTo`), assuming standard winding\n * rules.\n *\n * @param point The point to check.\n * @param boundary The boundary path defining the shape.\n * @param excludeVertices Optional set of vertices to exclude from the check.\n *                        If the point matches one of these vertices, it's considered inside\n *                        (useful for boundary edge vertices that may have floating point precision issues).\n * @returns `true` if the point is inside the boundary, `false` otherwise.\n */\nexport function isPointInBoundary(\n  point: Vec2,\n  boundary: PathCommand[],\n  excludeVertices?: Set<Vec2>\n): boolean {\n\n  // If this point should be excluded (e.g., it's a boundary vertex), treat it as inside\n  if (excludeVertices) {\n    for (const excludeVertex of excludeVertices) {\n      if (point[0] === excludeVertex[0] && point[1] === excludeVertex[1]) {\n        return true;\n      }\n    }\n  }\n\n  if (boundary.length > 0 && boundary[0].type !== 'move') {\n    throw new Error(\"Boundary path must start with a 'move' command.\");\n  }\n\n  // flatten the entire path into simple polygons\n  const polygons = flattenBoundary(boundary);\n\n  // use the even-odd rule to determine inclusion\n  let insideCount = 0;\n  for (const poly of polygons) {\n    if (isPointInPolygon(point, poly)) {\n      insideCount++;\n    }\n  }\n  return insideCount % 2 === 1;\n}\n\n// type guard for Martinez library return values\nfunction isMartinezPolygon(geometry: martinez.Geometry): geometry is martinez.Polygon {\n  return Array.isArray(geometry[0]) && Array.isArray(geometry[0][0]) && typeof geometry[0][0][0] === 'number';\n}\n\n/**\n * Clips a polygon against the puzzle boundary.\n *\n * @param polygon The polygon to be clipped (e.g., a grid cell). This should be a simple array of vertices.\n * @param boundary The pre-flattened boundary to clip against.\n * @returns An array of resulting polygons, or null if there is no intersection.\n * Each resulting polygon is an array of vertices.\n */\nexport function clipPolygonAgainstBoundary(polygon: Vec2[], boundary: Vec2[]): Vec2[][] | null {\n\n  // use the martinez-polygon-clipping library to handle clipping\n  // It expects input in a specific GeoJSON-like format, so we must wrap our\n  // simple polygons in arrays to match.\n  const subject = [polygon.map((p) => ([p[0], p[1]]))];\n  const clipper = [boundary.map((p) => ([p[0], p[1]]))];\n\n  const clipped = martinez.intersection(subject, clipper);\n\n  if (!clipped || clipped.length === 0) {\n    return null; // No intersection found.\n  }\n\n  if (isMartinezPolygon(clipped)) {\n    return clipped as Vec2[][];\n  }\n\n  // unwrap the result back to our Vec2[][] format.\n  return clipped.map((poly) =>\n    poly[0].map((p) => ([p[0], p[1]] as Vec2))\n  );\n}\n\n/**\n * Checks if a point is inside a simple polygon using the ray casting algorithm.\n * @param point The point to check.\n * @param polygon An array of vertices defining the polygon.\n * @returns `true` if the point is inside.\n */\nexport function isPointInPolygon(point: Vec2, polygon: Vec2[]): boolean {\n  const [x, y] = point;\n  let isInside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [xi, yi] = polygon[i];\n    const [xj, yj] = polygon[j];\n\n    // This condition checks if the horizontal ray from the point intersects the edge.\n    const intersect = ((yi > y) !== (yj > y)) &&\n      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n\n  return isInside;\n}\n\n/**\n * Creates a closed, doubly-linked loop of half-edges from an ordered list of vertices.\n * @param vertices - An array of vertices in counter-clockwise order.\n * @param pieceId - The ID of the piece this half-edge loop belongs to.\n * @param topology - The main puzzle topology object, which will be mutated.\n * @returns The array of newly created HalfEdge objects.\n */\nexport function createHalfEdgeLoop(\n  vertices: Vec2[],\n  pieceId: PieceID,\n  topology: PuzzleTopology,\n): HalfEdge[] {\n  const newHalfEdges: HalfEdge[] = [];\n\n  // 1. Add any new, unique vertices to the main list\n  for (const vertex of vertices) {\n    if (!topology.vertices.find((v) => arePointsEqual(v, vertex))) {\n      topology.vertices.push(vertex);\n    }\n  }\n\n  // 2. Create a half-edge for each vertex\n  for (const vertex of vertices) {\n    const he: HalfEdge = {\n      id: getUniqueId(),\n      origin: vertex,\n      twin: -1,\n      next: -1,\n      prev: -1,\n      piece: pieceId,\n    };\n    newHalfEdges.push(he);\n  }\n\n  // 3. Link the created half-edges into a circular doubly-linked list\n  const numEdges = newHalfEdges.length;\n  for (let i = 0; i < numEdges; i++) {\n    const nextIndex = (i + 1) % numEdges;\n    const prevIndex = (i + numEdges - 1) % numEdges;\n    newHalfEdges[i].next = newHalfEdges[nextIndex].id;\n    newHalfEdges[i].prev = newHalfEdges[prevIndex].id;\n  }\n\n  // 4. Add all new half-edges to the topology\n  newHalfEdges.forEach((he) => topology.halfEdges.set(he.id, he));\n\n  return newHalfEdges;\n}\n\n/**\n * Links a set of half-edges to their twins or creates new boundary edges.\n * @param halfEdges - The list of half-edges to process.\n * @param topology - The main puzzle topology object, which will be mutated.\n * @param halfEdgeTwinMap - The map used to look up twin half-edges.\n * @param isBoundaryEdgeFn - A callback function that returns true if a given edge should be treated as part of the puzzle's outer boundary.\n */\nexport function linkAndCreateEdges(\n  halfEdges: HalfEdge[],\n  topology: PuzzleTopology,\n  halfEdgeTwinMap: Map<string, HalfEdgeID>,\n  isBoundaryEdgeFn: (p1: Vec2, p2: Vec2) => boolean,\n): void {\n  const key = (p1: Vec2, p2: Vec2) => `${p1[0]},${p1[1]}-${p2[0]},${p2[1]}`;\n  const numEdges = halfEdges.length;\n  const PROXIMITY_THRESHOLD = 0.1; // 0.1 pixel tolerance for matching edges\n\n  for (let i = 0; i < numEdges; i++) {\n    const he = halfEdges[i];\n    const p1 = he.origin;\n    const p2 = topology.halfEdges.get(he.next)!.origin;\n\n    const twinKey = key(p2, p1);\n    const selfKey = key(p1, p2);\n    let twinId = halfEdgeTwinMap.get(twinKey);\n\n    // If exact match not found, try geometric proximity search\n    if (twinId === undefined) {\n      for (const [mapKey, candidateId] of halfEdgeTwinMap.entries()) {\n        const candidateHe = topology.halfEdges.get(candidateId)!;\n        const cp1 = candidateHe.origin;\n        const cp2 = topology.halfEdges.get(candidateHe.next)!.origin;\n\n        // Check if edges match in reverse direction with proximity tolerance\n        const d1 = Math.sqrt((p1[0] - cp2[0]) ** 2 + (p1[1] - cp2[1]) ** 2);\n        const d2 = Math.sqrt((p2[0] - cp1[0]) ** 2 + (p2[1] - cp1[1]) ** 2);\n\n        if (d1 < PROXIMITY_THRESHOLD && d2 < PROXIMITY_THRESHOLD) {\n          twinId = candidateId;\n          halfEdgeTwinMap.delete(mapKey);\n          break;\n        }\n      }\n    }\n\n    const edgeId = getUniqueId();\n    let edge: Edge;\n\n    if (twinId !== undefined) {\n      // Found a twin! This is an internal edge.\n      const twinHe = topology.halfEdges.get(twinId)!;\n      he.twin = twinHe.id;\n      twinHe.twin = he.id;\n      edge = { id: edgeId, heLeft: twinHe.id, heRight: he.id, bounds: polygonBounds([p1, p2]) };\n      if (halfEdgeTwinMap.get(twinKey) === twinId) {\n        halfEdgeTwinMap.delete(twinKey);\n      }\n    } else {\n      // No twin found.\n      halfEdgeTwinMap.set(selfKey, he.id);\n\n      if (isBoundaryEdgeFn(p1, p2)) {\n        // This is a new edge on the puzzle's custom boundary.\n        edge = { id: edgeId, heLeft: he.id, heRight: -1, bounds: polygonBounds([p1, p2]) };\n        topology.boundary.push(edgeId);\n      } else {\n        // It's an internal grid edge, wait for its neighbor to find it.\n        continue;\n      }\n    }\n    topology.edges.set(edgeId, edge);\n  }\n}\n\n/**\n * Scale and translate path commands to fit within canvas bounds\n *\n * @param commands - Array of PathCommand objects\n * @param canvasWidth - Target canvas width\n * @param canvasHeight - Target canvas height\n * @param padding - Padding around the path (default: 20)\n * @returns Transformed PathCommand array\n */\nexport function fitPathToCanvas(\n  commands: PathCommand[],\n  canvasWidth: number,\n  canvasHeight: number,\n  padding = 20,\n): PathCommand[] {\n  if (commands.length === 0) return commands;\n\n  // Find bounding box\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  const updateBounds = (x: number, y: number) => {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  };\n\n  for (const cmd of commands) {\n    if (cmd.type === 'move' || cmd.type === 'line') {\n      updateBounds(cmd.p[0], cmd.p[1]);\n    } else if (cmd.type === 'bezier') {\n      updateBounds(cmd.p1[0], cmd.p1[1]);\n      updateBounds(cmd.p2[0], cmd.p2[1]);\n      updateBounds(cmd.p3[0], cmd.p3[1]);\n    }\n  }\n\n  const pathWidth = maxX - minX;\n  const pathHeight = maxY - minY;\n\n  // Calculate scale to fit within canvas with padding\n  const availableWidth = canvasWidth - 2 * padding;\n  const availableHeight = canvasHeight - 2 * padding;\n  const scale = Math.min(availableWidth / pathWidth, availableHeight / pathHeight);\n\n  // Calculate offset to center the path\n  const scaledWidth = pathWidth * scale;\n  const scaledHeight = pathHeight * scale;\n  const offsetX = padding + (availableWidth - scaledWidth) / 2 - minX * scale;\n  const offsetY = padding + (availableHeight - scaledHeight) / 2 - minY * scale;\n\n  // Transform all commands\n  const transformedCommands: PathCommand[] = [];\n\n  for (const cmd of commands) {\n    if (cmd.type === 'move' || cmd.type === 'line') {\n      transformedCommands.push({\n        ...cmd,\n        p: [cmd.p[0] * scale + offsetX, cmd.p[1] * scale + offsetY],\n      });\n    } else if (cmd.type === 'bezier') {\n      transformedCommands.push({\n        type: 'bezier',\n        p1: [cmd.p1[0] * scale + offsetX, cmd.p1[1] * scale + offsetY],\n        p2: [cmd.p2[0] * scale + offsetX, cmd.p2[1] * scale + offsetY],\n        p3: [cmd.p3[0] * scale + offsetX, cmd.p3[1] * scale + offsetY],\n      });\n    }\n  }\n\n  return transformedCommands;\n}\n","\n/**\n * Simple seeded PRNG. The state space is 32 bits, so the period (the point at\n * which random numbers repeat for the same seed) is 2^32.\n * See https://github.com/cprosche/mulberry32 for more details.\n * @param seed seed number\n * @returns function which returns a random number each time it is called\n */\nexport function mulberry32(seed: number) {\n  return function() {\n    let t = seed += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nexport default mulberry32;\n","import type { CustomPiece, PathCommand, PieceID, PuzzleGeometry, Vec2 } from \"./types\";\nimport {\n  PointGeneratorRegistry,\n  PieceGeneratorRegistry,\n  TabPlacementStrategyRegistry,\n  TabGeneratorRegistry,\n  type GeneratorConfig,\n} from \"./generators/Generator\";\nimport { generateSegmentsForEdge } from \"./utils\";\nimport mulberry32 from \"../utils/mulberry\";\nimport { measureAsync, measureSync } from '../utils/performance';\n\n/**\n * Configuration options for the entire puzzle generation process.\n */\nexport interface PuzzleGenerationOptions {\n  /** Maximum bounds of the puzzle (pre-computed from the boundary path) */\n  bounds: {\n    width: number;\n    height: number;\n  };\n  /** A rough guide for piece size */\n  pieceSize: number;\n  /** Random seed to produce repeatable puzzles */\n  seed?: number;\n  /** How should the points that control the pieces get generated? */\n  pointConfig: GeneratorConfig;\n  /** How should the pieces get built? */\n  pieceConfig: GeneratorConfig;\n  /** How should tabs get placed on piece edges? */\n  placementConfig: GeneratorConfig;\n  /** How should tabs get constructed? */\n  tabConfig: GeneratorConfig;\n  /** Boundary path of the puzzle border */\n  border: PathCommand[];\n  /** Custom pieces defined for this puzzle */\n  customPieces?: CustomPiece[];\n  /** Optional pre-generated seed points. If provided, point generation is skipped. */\n  seedPoints?: Vec2[];\n  /** If true, skip tab placement and generation (for real-time preview) */\n  skipTabs?: boolean;\n}\n\n/**\n * Orchestrates the procedural generation of a jigsaw puzzle\n * by coordinating various pluggable generators.\n */\n \nexport async function buildPuzzle(options: PuzzleGenerationOptions): Promise<PuzzleGeometry> {\n  return measureAsync('Puzzle Generation', () => {\n    const { bounds, pieceSize, border } = options;\n    const { pointConfig, pieceConfig, placementConfig, tabConfig } = options;\n\n    console.log(`rebuilding puzzle with dimensions ${bounds.width}x${bounds.height}, piece size ${pieceSize}`);\n\n    // get and configure the necessary generators\n    const pointGenerator = PointGeneratorRegistry.create(border, bounds, pointConfig);\n    const pieceGenerator = PieceGeneratorRegistry.create(border, bounds, pieceConfig);\n    const placementStrategy = TabPlacementStrategyRegistry.create(border, bounds, placementConfig);\n    const tabGenerator = TabGeneratorRegistry.create(border, bounds, tabConfig);\n\n    // seeded PRNG used to generate repeatable random numbers\n    const seed = options.seed ?? new Date().getTime();\n    const random = mulberry32(seed);\n\n    // 1. Generate or use provided seed points for the pieces\n    const points = options.seedPoints ??\n      pointGenerator.generatePoints({ width: bounds.width, height: bounds.height, pieceSize, random, border });\n    console.log(`${options.seedPoints ? 'Using' : 'Generated'} ${points.length} points`);\n\n    // 2. Convert points to a puzzle topology (pieces and edges)\n    const topology = pieceGenerator.generatePieces(points, {\n      random,\n      pieceSize,\n      border,\n      bounds,\n      customPieces: options.customPieces,\n    });\n    console.log(`Generated ${topology.pieces.size} pieces`);\n\n    // 3. Place tabs on internal edges (skip if requested)\n    if (!options.skipTabs) {\n      placementStrategy.placeTabs({ topology, random });\n\n      // 4. Generate geometry for placed tabs\n      for (const edge of topology.edges.values()) {\n        // only internal edges can accept tabs\n        const isInternal = edge.heRight !== -1;\n        if (isInternal && edge.tabs && edge.tabs.length > 0) {\n          // use the tab generator to create the segment path for an edge based on its TabPlacements\n          generateSegmentsForEdge(edge, topology, tabGenerator, random);\n        }\n      }\n    }\n\n    // 5. Assemble the final puzzle data structure\n    const puzzle: PuzzleGeometry = {\n      created: new Date().toISOString(),\n      seed,\n      width: bounds.width,\n      height: bounds.height,\n      pieceSize,\n      pointConfig,\n      pieceConfig,\n      placementConfig,\n      tabConfig,\n      seedPoints: points,\n      vertices: topology.vertices,\n      boundary: topology.boundary,\n      borderPath: topology.borderPath,\n      pieces: topology.pieces,\n      edges: topology.edges,\n      halfEdges: topology.halfEdges,\n      customPieces: options.customPieces,\n    };\n\n    return Promise.resolve(puzzle);\n  });\n}\n\n/**\n * Rebuilds a puzzle with modified seed points, preserving all other configuration.\n * This is used when the user drags a seed point to a new location.\n *\n * @param originalPuzzle The original puzzle geometry\n * @param pieceId The ID of the piece whose seed point was moved\n * @param newSeedPosition The new position for the seed point\n * @returns A new puzzle with the updated seed point\n */\nexport async function rebuildPuzzleWithUpdatedSeedPoint(\n  originalPuzzle: PuzzleGeometry,\n  pieceId: PieceID,\n  newSeedPosition: Vec2\n): Promise<PuzzleGeometry> {\n  // Create updated points array by finding the piece index\n  const updatedPoints = [...originalPuzzle.seedPoints];\n  let pointIndex = 0;\n  for (const piece of originalPuzzle.pieces.values()) {\n    if (piece.id === pieceId) {\n      updatedPoints[pointIndex] = newSeedPosition;\n      break;\n    }\n    pointIndex++;\n  }\n\n  // Rebuild with updated points but same configuration (INCLUDING tabs this time)\n  return buildPuzzle({\n    bounds: {\n      width: originalPuzzle.width,\n      height: originalPuzzle.height,\n    },\n    border: originalPuzzle.borderPath,\n    pieceSize: originalPuzzle.pieceSize,\n    pointConfig: originalPuzzle.pointConfig,\n    pieceConfig: originalPuzzle.pieceConfig,\n    placementConfig: originalPuzzle.placementConfig,\n    tabConfig: originalPuzzle.tabConfig,\n    seed: originalPuzzle.seed,\n    seedPoints: updatedPoints,\n    customPieces: originalPuzzle.customPieces,\n    skipTabs: false, // Include tabs in final version\n  });\n}\n\n/** Draws puzzle geometry onto a canvas */\nexport function drawPuzzle(puzzle: PuzzleGeometry, canvas: HTMLCanvasElement, pieceColor: string, pointColor?: string) {\n  measureSync('Canvas 2D Rendering', () => {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      console.error(\"Could not get 2D context from canvas\");\n      return;\n    }\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // In debug mode, we draw each piece's full boundary in a different color.\n    // This helps visualize the ownership of each edge.\n    const debugMode = false;\n\n    if (debugMode) {\n      const debugColors = [\n        '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',\n        '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff',\n        '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',\n      ];\n      ctx.lineWidth = 2; // Use a thicker line for better visibility\n\n      let pieceIndex = 0;\n      for (const piece of puzzle.pieces.values()) {\n        const pieceColor = debugColors[pieceIndex % debugColors.length];\n        ctx.strokeStyle = pieceColor;\n        ctx.beginPath();\n        ctx.setLineDash([5, 5]); // use dashed lines\n\n        // Get the starting half-edge for this piece's boundary\n        let currentHe = puzzle.halfEdges.get(piece.halfEdge);\n        if (!currentHe) continue;\n\n        const startHeId = currentHe.id;\n        ctx.moveTo(currentHe.origin[0], currentHe.origin[1]);\n\n        // Traverse the boundary of the piece by following the 'next' pointers\n        // until we get back to the starting half-edge.\n        do {\n          if (currentHe.segments) {\n          // If the edge has a custom tab, draw its segments\n            for (const segment of currentHe.segments) {\n              switch (segment.type) {\n              case 'bezier':\n                ctx.bezierCurveTo(segment.p1[0], segment.p1[1], segment.p2[0], segment.p2[1], segment.p3[0], segment.p3[1]);\n                break;\n              case 'line':\n                ctx.lineTo(segment.p[0], segment.p[1]);\n                break;\n              }\n            }\n          } else {\n          // Otherwise, draw a straight line to the start of the next half-edge\n            const nextHe = puzzle.halfEdges.get(currentHe.next)!;\n            ctx.lineTo(nextHe.origin[0], nextHe.origin[1]);\n          }\n          // Move to the next half-edge in the loop\n          currentHe = puzzle.halfEdges.get(currentHe.next)!;\n        } while (currentHe.id !== startHeId);\n\n        ctx.stroke();\n        pieceIndex++;\n      }\n\n      // Reset line dash for subsequent drawing operations.\n      ctx.setLineDash([]);\n\n    } else {\n    // normal mode drawing, optimized for efficiency\n\n      // Style for piece boundaries\n      ctx.strokeStyle = pieceColor;\n      ctx.lineWidth = 1;\n\n      // it's more efficient to batch all paths together\n      ctx.beginPath();\n\n      // By iterating through all unique edges and drawing the curve for one of\n      // its half-edges, we ensure every cut is defined exactly once.\n      for (const edge of puzzle.edges.values()) {\n      // We consistently choose heLeft. The tab generator puts the \"outie\"\n      // or \"innie\" on this half-edge, and the twin gets the inverse.\n        const he = puzzle.halfEdges.get(edge.heLeft);\n        if (!he) continue; // should not happen\n\n        // move to the start of this edge segment\n        ctx.moveTo(he.origin[0], he.origin[1]);\n\n        if (he.segments && he.segments.length > 0) {\n        // if a custom tab is defined, draw each segment in order\n          for (const segment of he.segments) {\n            switch (segment.type) {\n            case 'bezier':\n              ctx.bezierCurveTo(\n                segment.p1[0], segment.p1[1],\n                segment.p2[0], segment.p2[1],\n                segment.p3[0], segment.p3[1]\n              );\n              break;\n            case 'line':\n              ctx.lineTo(segment.p[0], segment.p[1]);\n              break;\n            }\n          }\n        } else {\n        // no tab, draw a straight line to the edge's endpoint.\n        // The end point of a half-edge is the origin of its twin.\n        // For boundary edges, the twin is -1, so we find the end point\n        // by looking at the start of the next half-edge around the piece.\n          let destination: Vec2;\n          // For an internal edge, the destination is the origin of the twin half-edge.\n          if (he.twin !== -1) {\n            const twinHe = puzzle.halfEdges.get(he.twin)!;\n            destination = twinHe.origin;\n          } else {\n          // For a boundary edge, the destination is the origin of the next half-edge in the loop.\n            const nextHe = puzzle.halfEdges.get(he.next)!;\n            destination = nextHe.origin;\n          }\n          ctx.lineTo(destination[0], destination[1]);\n        }\n      }\n\n      // stroke the entire path containing all the unique puzzle edges\n      ctx.stroke();\n    }\n\n    // if the puzzle has problems like intersecting/overlapping pieces, highlight them\n    if (puzzle.problems && puzzle.problems.length > 0) {\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = 'red';\n      for (const problemPoint of puzzle.problems) {\n        const [x, y] = problemPoint;\n        ctx.beginPath();\n        ctx.arc(x, y, 8, 0, 2 * Math.PI);\n        ctx.stroke();\n      }\n    }\n\n    // draw the piece sites (original Voronoi points) for reference\n    if (pointColor) {\n      ctx.fillStyle = pointColor;\n      for (const piece of puzzle.pieces.values()) {\n        const [x, y] = piece.site;\n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n    }\n  });\n}\n","/**\n * Utility functions for generating common puzzle border shapes.\n *\n * These functions create PathCommand arrays that define various boundary shapes\n * for puzzles. The paths are compatible with SVG path syntax and can be used\n * for both rendering and geometric clipping operations.\n */\n\nimport type { PathCommand } from './types';\n\n/**\n * Creates a rectangular border path.\n *\n * @param width - Width of the rectangle in pixels\n * @param height - Height of the rectangle in pixels\n * @returns A PathCommand array representing a closed rectangle\n *\n * @example\n * const border = createRectangleBorder(800, 600); // a rectangle from (0,0) to (800,600)\n */\nexport function createRectangleBorder(width: number, height: number): PathCommand[] {\n  return [\n    { type: 'move', p: [0, 0] },\n    { type: 'line', p: [width, 0] },\n    { type: 'line', p: [width, height] },\n    { type: 'line', p: [0, height] },\n    { type: 'line', p: [0, 0] },\n  ];\n}\n\n/**\n * Creates a circular border path using elliptical arcs.\n *\n * The circle is centered within the bounding box defined by diameter.\n * Uses two 180-degree arcs to form a complete circle.\n *\n * @param diameter - Diameter of the circle in pixels\n * @returns A PathCommand array representing a closed circle\n *\n * @example\n * const border = createCircleBorder(600); // a circle with radius 300, centered at (300, 300)\n */\nexport function createCircleBorder(diameter: number): PathCommand[] {\n  const radius = diameter / 2;\n  const center = radius;\n\n  return [\n    // Start at the leftmost point of the circle\n    { type: 'move', p: [0, center] },\n    // Draw top semicircle (left to right)\n    {\n      type: 'arc',\n      p: [diameter, center],\n      radii: [radius, radius],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n    // Draw bottom semicircle (right to left)\n    {\n      type: 'arc',\n      p: [0, center],\n      radii: [radius, radius],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n  ];\n}\n\n/**\n * Creates an elliptical border path.\n *\n * The ellipse is centered within the bounding box defined by width and height.\n * Uses two 180-degree arcs to form a complete ellipse.\n *\n * @param width - Width of the ellipse (horizontal diameter) in pixels\n * @param height - Height of the ellipse (vertical diameter) in pixels\n * @returns A PathCommand array representing a closed ellipse\n *\n * @example\n * const border = createEllipseBorder(800, 600); // an ellipse with horizontal radius 400, vertical radius 300\n */\nexport function createEllipseBorder(width: number, height: number): PathCommand[] {\n  const radiusX = width / 2;\n  const radiusY = height / 2;\n\n  return [\n    // Start at the leftmost point of the ellipse\n    { type: 'move', p: [0, radiusY] },\n    // Draw top half (left to right)\n    {\n      type: 'arc',\n      p: [width, radiusY],\n      radii: [radiusX, radiusY],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n    // Draw bottom half (right to left)\n    {\n      type: 'arc',\n      p: [0, radiusY],\n      radii: [radiusX, radiusY],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n  ];\n}\n\n/**\n * Creates a rectangle with rounded corners.\n *\n * The rectangle is created with four straight edges and four quarter-circle arcs\n * at the corners. The corner radius is clamped to prevent invalid geometry.\n *\n * @param width - Width of the rectangle in pixels\n * @param height - Height of the rectangle in pixels\n * @param cornerRadius - Radius of the corner arcs in pixels\n * @returns A PathCommand array representing a rounded rectangle\n *\n * @example\n * const border = createRoundedRectBorder(800, 600, 50);\n * // Creates an 800x600 rectangle with 50px rounded corners\n */\nexport function createRoundedRectBorder(\n  width: number,\n  height: number,\n  cornerRadius: number\n): PathCommand[] {\n  // Clamp corner radius to prevent invalid geometry\n  // (radius can't be more than half the shortest side)\n  const maxRadius = Math.min(width, height) / 2;\n  const r = Math.min(cornerRadius, maxRadius);\n\n  return [\n    // Start at top-left corner (after the arc)\n    { type: 'move', p: [r, 0] },\n\n    // Top edge\n    { type: 'line', p: [width - r, 0] },\n\n    // Top-right corner\n    {\n      type: 'arc',\n      p: [width, r],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n\n    // Right edge\n    { type: 'line', p: [width, height - r] },\n\n    // Bottom-right corner\n    {\n      type: 'arc',\n      p: [width - r, height],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n\n    // Bottom edge\n    { type: 'line', p: [r, height] },\n\n    // Bottom-left corner\n    {\n      type: 'arc',\n      p: [0, height - r],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n\n    // Left edge\n    { type: 'line', p: [0, r] },\n\n    // Top-left corner (back to start)\n    {\n      type: 'arc',\n      p: [r, 0],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n  ];\n}\n","import type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  Piece,\n  PieceID,\n  PuzzleGeometry,\n  Vec2,\n  VertexID,\n} from './types';\nimport { TabPlacementStrategyRegistry, TabGeneratorRegistry } from './generators/Generator';\nimport { generateSegmentsForEdge, getPieceBounds } from './utils';\nimport { createRectangleBorder } from './borderShapes';\nimport mulberry32 from \"../utils/mulberry\";\n\n\n/**\n * Finds the closest vertex to a click position and moves it to a new position,\n * updating all connected edges and pieces. This function directly modifies the\n * provided puzzle object.\n *\n * @param puzzle The puzzle data structure to modify.\n * @param vertexIndex The index of the vertex to move in the `puzzle.vertices` array\n * @param newPos The new [x, y] coordinates to move the vertex to.\n */\nexport function moveVertex(\n  puzzle: PuzzleGeometry,\n  vertexIndex: VertexID,\n  newPos: Vec2\n): void {\n  // --- 1. Get the vertex's original position ---\n  if (vertexIndex < 0 || vertexIndex >= puzzle.vertices.length) {\n    console.warn(\"moveVertex called with invalid vertex index:\", vertexIndex);\n    return;\n  }\n  const oldPos = puzzle.vertices[vertexIndex];\n\n  // --- 2. Update the master vertex in the vertices array ---\n  puzzle.vertices[vertexIndex] = newPos;\n\n  // --- 3. Identify all half-edges that are affected by this move ---\n  const departingEdges: HalfEdge[] = [];\n  for (const he of puzzle.halfEdges.values()) {\n    // A half-edge \"departs\" from the vertex if its origin is at the old position.\n    if (he.origin[0] === oldPos[0] && he.origin[1] === oldPos[1]) {\n      departingEdges.push(he);\n    }\n  }\n\n  const affectedPieceIDs = new Set<PieceID>();\n  const delta: Vec2 = [newPos[0] - oldPos[0], newPos[1] - oldPos[1]];\n\n  // --- 4. Update the geometry of all affected half-edges ---\n  for (const departingEdge of departingEdges) {\n    // The origin of the departing edge is now the new position.\n    departingEdge.origin = newPos;\n    affectedPieceIDs.add(departingEdge.piece);\n\n    // Now we must update the half-edge that *flows into* this vertex.\n    // This is the predecessor in the piece's boundary loop.\n    const predecessorEdge = puzzle.halfEdges.get(departingEdge.prev);\n\n    if (predecessorEdge?.segments) {\n      const lastSegment = predecessorEdge.segments[predecessorEdge.segments.length - 1];\n\n      // Update the endpoint of the predecessor's final segment.\n      if (lastSegment.type === 'line') {\n        lastSegment.p = newPos;\n      } else { // 'bezier'\n        lastSegment.p3 = newPos;\n        // For a smooth transition, we translate the control points by the same\n        // amount as the endpoint. More sophisticated logic could be used here\n        // for better curve preservation.\n        lastSegment.p1 = [lastSegment.p1[0] + delta[0], lastSegment.p1[1] + delta[1]];\n        lastSegment.p2 = [lastSegment.p2[0] + delta[0], lastSegment.p2[1] + delta[1]];\n      }\n      affectedPieceIDs.add(predecessorEdge.piece);\n    }\n  }\n\n  // --- 5. Rebuild any tabs affected by the vertex move ---\n  regenerateAffectedTabs(puzzle, vertexIndex);\n\n  // --- 6. Recalculate the bounding boxes for all affected pieces ---\n  for (const pieceId of affectedPieceIDs) {\n    const piece = puzzle.pieces.get(pieceId);\n    if (piece) {\n      piece.bounds = getPieceBounds(piece, puzzle);\n    }\n  }\n}\n\n\n/**\n * Finds all full (interior) edges connected to a given vertex and regenerates their tabs.\n *\n * @param puzzle The puzzle and its topology.\n * @param vertex The the vertex that was modified.\n */\nexport function regenerateAffectedTabs(\n  puzzle: PuzzleGeometry,\n  vertex: VertexID\n): void {\n\n  const { seed, width, height, placementConfig, tabConfig } = puzzle;\n  const random = mulberry32(seed);\n\n  // Create a simple rectangular border for the modifier operations\n  const border = createRectangleBorder(width, height);\n  const bounds = { width, height };\n\n  // recreate the placement strategy and tab generator that were used for this puzzle\n  const placementStrategy = TabPlacementStrategyRegistry.create(border, bounds, placementConfig);\n  const tabGenerator = TabGeneratorRegistry.create(border, bounds, tabConfig);\n\n  const affectedEdges = new Set<Edge>();\n  const movedVertexPos = puzzle.vertices[vertex];\n\n  // To efficiently find the parent Edge of a HalfEdge, we can build a lookup map.\n  // This is much faster than iterating through all edges every time.\n  const halfEdgeToEdgeMap = new Map<EdgeID, Edge>();\n  for (const edge of puzzle.edges.values()) {\n    halfEdgeToEdgeMap.set(edge.heLeft, edge);\n    // heRight can be -1 for boundary edges, so check first.\n    if (edge.heRight !== -1) {\n      halfEdgeToEdgeMap.set(edge.heRight, edge);\n    }\n  }\n\n  // Find all half-edges that either start or end at the moved vertex.\n  for (const he of puzzle.halfEdges.values()) {\n    const destinationVertex = puzzle.halfEdges.get(he.next)?.origin;\n\n    // Is this half-edge starting at the moved vertex?\n    const startsAtVertex = he.origin === movedVertexPos;\n    // Is this half-edge ending at the moved vertex?\n    const endsAtVertex = destinationVertex === movedVertexPos;\n\n    if (startsAtVertex || endsAtVertex) {\n      const parentEdge = halfEdgeToEdgeMap.get(he.id);\n      if (parentEdge) {\n        affectedEdges.add(parentEdge);\n      }\n    }\n  }\n\n  // re-run the placement strategy in case it needs to make a change\n  placementStrategy.updateTabPlacements(Array.from(affectedEdges), { topology: puzzle, random });\n\n  const affectedPieces = new Set<Piece>();\n\n  // Now, regenerate the tabs for the unique set of affected edges.\n  for (const edge of affectedEdges) {\n    // only add tabs to internal edges\n    const isInternal = edge.heRight !== -1;\n    if (isInternal) {\n      // remove any existing segments\n      const he1 = puzzle.halfEdges.get(edge.heLeft);\n      if (he1) {\n        he1.segments = undefined;\n        affectedPieces.add(puzzle.pieces.get(he1.piece)!);\n      }\n      const he2 = puzzle.halfEdges.get(edge.heRight);\n      if (he2) {\n        he2.segments = undefined;\n        affectedPieces.add(puzzle.pieces.get(he2.piece)!);\n      }\n\n      // regenerate segments\n      generateSegmentsForEdge(edge, puzzle, tabGenerator, random);\n    }\n  }\n\n  // recalculate boundaries for affected pieces\n  for (const piece of affectedPieces) {\n    piece.bounds = getPieceBounds(piece, puzzle);\n  }\n\n}","/**\n * Mouse/touch event handling and interaction logic for PuzzleRenderer component\n */\n\nimport m from 'mithril';\nimport { buildPuzzle } from '../../geometry/PuzzleMaker';\nimport { moveVertex } from '../../geometry/modifiers';\nimport { distanceSq } from '../../geometry/utils';\nimport type { PuzzleRendererAttrs, PuzzleRendererState } from './constants';\nimport { REGENERATION_THROTTLE_MS, HOVER_DISTANCE_SQ, MIN_ZOOM, MAX_ZOOM, ZOOM_STEP } from './constants';\nimport type MithrilViewEvent from '../../utils/MithrilViewEvent';\nimport type { Vec2, PieceID, CustomPieceTransform } from '../../geometry/types';\nimport { renderPuzzle, getBoundaryEdgeVertexIds, renderCustomPieces, renderCustomPieceHandles } from './rendering';\n\n/* ========================================================= *\\\n *  Pan and Zoom Event Handlers                              *\n\\* ========================================================= */\n\n// Store event handler references for cleanup\nlet keyDownHandler: ((event: KeyboardEvent) => void) | null = null;\nlet keyUpHandler: ((event: KeyboardEvent) => void) | null = null;\nlet wheelHandler: ((event: WheelEvent) => void) | null = null;\nlet panMouseDownHandler: ((event: MouseEvent) => void) | null = null;\nlet panMouseMoveHandler: ((event: MouseEvent) => void) | null = null;\nlet panMouseUpHandler: ((event: MouseEvent) => void) | null = null;\n\n// Track panning state for raw mouse events\nlet isPanningWithRawEvents = false;\nlet lastPanPoint: { x: number; y: number } | null = null;\n\n/**\n * Set up pan and zoom event handlers for keyboard and wheel\n *\n * @param state - The PuzzleRenderer state object\n * @param onZoomChanged - Optional callback when zoom changes\n */\nexport function setupPanZoomHandling(\n  state: PuzzleRendererState,\n  onZoomChanged?: (zoom: number) => void,\n): void {\n  // Set up keyboard event listeners for spacebar (pan mode)\n  keyDownHandler = (event: KeyboardEvent) => {\n    // Don't intercept keyboard events if user is typing in an input field\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'INPUT' || target.tagName === 'WA-INPUT' ||target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return;\n    }\n\n    if (event.code === 'Space') {\n      // Always prevent default to stop page scrolling (even on repeated keydown events)\n      event.preventDefault();\n\n      if (!state.isSpacebarPressed) {\n        state.isSpacebarPressed = true;\n        updateCursor(state);\n      }\n    }\n  };\n\n  keyUpHandler = (event: KeyboardEvent) => {\n    // Don't intercept keyboard events if user is typing in an input field\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'INPUT' || target.tagName === 'WA-INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return;\n    }\n\n    if (event.code === 'Space') {\n      state.isSpacebarPressed = false;\n      updateCursor(state);\n      event.preventDefault();\n    }\n  };\n\n  // Set up wheel event listener for zooming\n  wheelHandler = (event: WheelEvent) => {\n    event.preventDefault();\n\n    // Use this renderer's isolated Paper.js scope\n    if (!state.paperCtx) {\n      return;\n    }\n\n    const paperScope = state.paperCtx.scope;\n\n    // Calculate zoom delta (negative deltaY means zoom in)\n    const delta = -Math.sign(event.deltaY) * ZOOM_STEP;\n    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom + delta));\n\n    if (newZoom !== state.zoom) {\n      // Get mouse position in view coordinates\n      const mousePos = new paperScope.Point(event.offsetX, event.offsetY);\n\n      // Zoom centered on mouse position\n      const viewPos = paperScope.view.viewToProject(mousePos);\n      const zoomFactor = newZoom / state.zoom;\n\n      paperScope.view.scale(zoomFactor, viewPos);\n      state.zoom = newZoom;\n\n      // Notify parent of zoom change\n      if (onZoomChanged) {\n        onZoomChanged(newZoom);\n      }\n\n      // Trigger redraw to update zoom display\n      m.redraw();\n    }\n  };\n\n  // Set up raw mouse event listeners for panning (to avoid Paper.js coordinate feedback)\n  panMouseDownHandler = (event: MouseEvent) => {\n    if (state.isSpacebarPressed) {\n      isPanningWithRawEvents = true;\n      lastPanPoint = { x: event.clientX, y: event.clientY };\n      updateCursor(state);\n      event.preventDefault();\n    }\n  };\n\n  panMouseMoveHandler = (event: MouseEvent) => {\n    // Prevent default scroll behavior whenever spacebar is pressed\n    if (state.isSpacebarPressed) {\n      event.preventDefault();\n    }\n\n    if (isPanningWithRawEvents && lastPanPoint) {\n      // Use this renderer's isolated Paper.js scope\n      if (!state.paperCtx) {\n        return;\n      }\n\n      const paperScope = state.paperCtx.scope;\n\n      const dx = event.clientX - lastPanPoint.x;\n      const dy = event.clientY - lastPanPoint.y;\n\n      // Scale delta by inverse of zoom to maintain 1:1 mouse tracking\n      // Paper.js translate() expects project coordinates, not view coordinates\n      const scaledDx = dx / state.zoom;\n      const scaledDy = dy / state.zoom;\n\n      // Pan by translating the view (move content with the mouse)\n      paperScope.view.translate(new paperScope.Point(scaledDx, scaledDy));\n\n      lastPanPoint = { x: event.clientX, y: event.clientY };\n    }\n  };\n\n  panMouseUpHandler = () => {\n    if (isPanningWithRawEvents) {\n      isPanningWithRawEvents = false;\n      lastPanPoint = null;\n      updateCursor(state);\n    }\n  };\n\n  // Add event listeners\n  window.addEventListener('keydown', keyDownHandler);\n  window.addEventListener('keyup', keyUpHandler);\n  if (state.canvas) {\n    state.canvas.addEventListener('wheel', wheelHandler, { passive: false });\n    state.canvas.addEventListener('mousedown', panMouseDownHandler);\n    state.canvas.addEventListener('mousemove', panMouseMoveHandler);\n    state.canvas.addEventListener('mouseup', panMouseUpHandler);\n    // Also handle mouse leaving canvas while panning\n    state.canvas.addEventListener('mouseleave', panMouseUpHandler);\n  }\n}\n\n/**\n * Clean up pan and zoom event listeners\n */\nexport function cleanupPanZoomHandling(canvas: HTMLCanvasElement | null): void {\n  // Remove event listeners\n  if (keyDownHandler) {\n    window.removeEventListener('keydown', keyDownHandler);\n    keyDownHandler = null;\n  }\n  if (keyUpHandler) {\n    window.removeEventListener('keyup', keyUpHandler);\n    keyUpHandler = null;\n  }\n  if (canvas) {\n    if (wheelHandler) {\n      canvas.removeEventListener('wheel', wheelHandler);\n      wheelHandler = null;\n    }\n    if (panMouseDownHandler) {\n      canvas.removeEventListener('mousedown', panMouseDownHandler);\n      panMouseDownHandler = null;\n    }\n    if (panMouseMoveHandler) {\n      canvas.removeEventListener('mousemove', panMouseMoveHandler);\n      panMouseMoveHandler = null;\n    }\n    if (panMouseUpHandler) {\n      canvas.removeEventListener('mouseup', panMouseUpHandler);\n      canvas.removeEventListener('mouseleave', panMouseUpHandler);\n      panMouseUpHandler = null;\n    }\n  }\n\n  // Reset panning state\n  isPanningWithRawEvents = false;\n  lastPanPoint = null;\n}\n\n/**\n * Update the cursor based on the current state\n *\n * @param state - The PuzzleRenderer state object\n */\nfunction updateCursor(state: PuzzleRendererState): void {\n  if (!state.canvas) return;\n\n  // Priority 1: Panning with spacebar\n  if (state.isSpacebarPressed) {\n    state.canvas.style.cursor = isPanningWithRawEvents ? 'grabbing' : 'grab';\n    return;\n  }\n\n  // Priority 2: Dragging (set by handleDragMove)\n  if (state.isDragging) {\n    state.canvas.style.cursor = 'grabbing';\n    return;\n  }\n\n  // Default cursor (will be updated by handleMouseMove)\n  state.canvas.style.cursor = 'default';\n}\n\n/* ========================================================= *\\\n *  Helper Functions                                         *\n\\* ========================================================= */\n\n/**\n * Helper to find a vertex circle by vertex ID\n * Since boundary vertices are skipped, array indices don't match vertex IDs\n */\nfunction findVertexCircle(\n  vertexItems: paper.Group,\n  vertexId: number\n): paper.Path | null {\n  for (const child of vertexItems.children) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (child.data.vertexId === vertexId) {\n      return child as paper.Path;\n    }\n  }\n  return null;\n}\n\n/**\n * Helper to convert mouse/touch event to Paper.js view point\n */\nfunction getViewPoint(\n  e: MouseEvent | TouchEvent,\n  canvas: HTMLCanvasElement,\n  state: PuzzleRendererState\n): paper.Point | null {\n  // Use this renderer's isolated Paper.js scope\n  if (!state.paperCtx) {\n    return null;\n  }\n\n  const paperScope = state.paperCtx.scope;\n\n  const rect = canvas.getBoundingClientRect();\n  let clientX: number;\n  let clientY: number;\n\n  if (e instanceof TouchEvent) {\n    if (e.changedTouches.length === 0) return null;\n    const touch = e.changedTouches[0];\n    clientX = touch.clientX;\n    clientY = touch.clientY;\n  } else {\n    clientX = e.clientX;\n    clientY = e.clientY;\n  }\n\n  const point = new paperScope.Point(\n    clientX - rect.left,\n    clientY - rect.top\n  );\n  return paperScope.view.viewToProject(point);\n}\n\n/**\n * Helper to convert Paper.js point to Vec2\n */\nfunction pointToVec2(point: paper.Point): Vec2 {\n  return [point.x, point.y];\n}\n\n/**\n * Helper to regenerate puzzle without tabs for real-time preview\n */\nfunction regeneratePuzzleWithoutTabs(\n  attrs: PuzzleRendererAttrs,\n  state: PuzzleRendererState,\n  pieceId: PieceID,\n  newPosition: Vec2\n): void {\n  // Update seed points array\n  const updatedPoints = [...attrs.puzzle.seedPoints];\n  let pointIndex = 0;\n  for (const piece of attrs.puzzle.pieces.values()) {\n    if (piece.id === pieceId) {\n      updatedPoints[pointIndex] = newPosition;\n      break;\n    }\n    pointIndex++;\n  }\n\n  // Regenerate WITHOUT tabs for real-time preview\n  buildPuzzle({\n    bounds: { width: attrs.puzzle.width, height: attrs.puzzle.height },\n    border: attrs.puzzle.borderPath,\n    pieceSize: attrs.puzzle.pieceSize,\n    pointConfig: attrs.puzzle.pointConfig,\n    pieceConfig: attrs.puzzle.pieceConfig,\n    placementConfig: attrs.puzzle.placementConfig,\n    tabConfig: attrs.puzzle.tabConfig,\n    seed: attrs.puzzle.seed,\n    seedPoints: updatedPoints,\n    skipTabs: true, // KEY: Skip expensive tab generation\n  }).then((previewPuzzle) => {\n    // Only update if still dragging the same point (avoid race conditions)\n    if (state.draggedSeedPointId === pieceId) {\n      renderPuzzle(state, previewPuzzle, attrs.color, attrs.pointColor);\n    }\n  }).catch((err) => {\n    console.error('Failed to regenerate preview:', err);\n  });\n}\n\n/**\n * Handle mouse movement for cursor changes and hover feedback (not dragging).\n */\nexport function handleMouseMove(\n  e: MouseEvent & MithrilViewEvent,\n  attrs: PuzzleRendererAttrs,\n  state: PuzzleRendererState\n): void {\n  e.redraw = false;\n\n  // Don't change cursor while dragging or panning\n  if (state.isDragging || state.isSpacebarPressed || !state.canvas) return;\n\n  const viewPoint = getViewPoint(e, state.canvas, state);\n  if (!viewPoint) return;\n\n  let isNearItem = false;\n  const mousePos = pointToVec2(viewPoint);\n\n  // Check for vertex hover using manual distance check\n  // (Paper.js hitTest doesn't work on invisible items)\n  if (state.vertexItems) {\n    let closestVertexId = -1;\n    let closestDistSq = HOVER_DISTANCE_SQ;\n\n    // Get all vertices that lie on boundary edges\n    const boundaryVertexIds = getBoundaryEdgeVertexIds(attrs.puzzle);\n\n    // Find closest non-boundary vertex within hover distance\n    for (let i = 0; i < attrs.puzzle.vertices.length; i++) {\n      // Skip boundary edge vertices - they should not be draggable\n      if (boundaryVertexIds.has(i)) continue;\n\n      const distSq = distanceSq(attrs.puzzle.vertices[i], mousePos);\n      if (distSq < closestDistSq) {\n        closestDistSq = distSq;\n        closestVertexId = i;\n      }\n    }\n\n    // Update visibility based on proximity\n    if (closestVertexId >= 0) {\n      // Show the closest vertex\n      if (state.hoveredVertexId !== closestVertexId) {\n        // Hide previously hovered vertex\n        if (state.hoveredVertexId >= 0) {\n          const prevCircle = findVertexCircle(state.vertexItems, state.hoveredVertexId);\n          if (prevCircle) prevCircle.visible = false;\n        }\n        // Show new hovered vertex\n        const newCircle = findVertexCircle(state.vertexItems, closestVertexId);\n        if (newCircle) {\n          newCircle.visible = true;\n          state.hoveredVertexId = closestVertexId;\n        }\n      }\n      isNearItem = true;\n    } else {\n      // Hide previously hovered vertex\n      if (state.hoveredVertexId >= 0) {\n        const prevCircle = findVertexCircle(state.vertexItems, state.hoveredVertexId);\n        if (prevCircle) {\n          prevCircle.visible = false;\n          state.hoveredVertexId = -1;\n        }\n      }\n    }\n  }\n\n  // Check for seed point hover (if visible)\n  if (attrs.pointColor && state.seedPointItems) {\n    const seedHit = state.seedPointItems.hitTest(viewPoint, {\n      fill: true,\n      tolerance: 5,\n    });\n    if (seedHit) {\n      isNearItem = true;\n    }\n  }\n\n  // Update cursor\n  state.canvas.style.cursor = isNearItem ? 'grab' : 'default';\n}\n\n/* ========================================================= *\\\n *  Custom Piece Interaction Handlers                       *\n\\* ========================================================= */\n\n/**\n * Handle custom piece drag move - updates transform in real-time\n */\nfunction handleCustomPieceDragMove(\n  viewPoint: paper.Point,\n  attrs: PuzzleRendererAttrs,\n  state: PuzzleRendererState\n): void {\n  if (!state.draggedCustomPieceId || !state.customPieceDragStart || !state.customPieceInitialTransform) {\n    return;\n  }\n\n  if (!attrs.customPieces) return;\n\n  const customPiece = attrs.customPieces.find((p) => p.id === state.draggedCustomPieceId);\n  if (!customPiece) return;\n\n  const currentPos: Vec2 = [viewPoint.x, viewPoint.y];\n  const deltaX = currentPos[0] - state.customPieceDragStart[0];\n  const deltaY = currentPos[1] - state.customPieceDragStart[1];\n\n  let newTransform: CustomPieceTransform;\n\n  if (state.draggedHandleType === 'piece') {\n    // Translate the piece\n    newTransform = {\n      ...state.customPieceInitialTransform,\n      position: [\n        state.customPieceInitialTransform.position[0] + deltaX,\n        state.customPieceInitialTransform.position[1] + deltaY,\n      ],\n    };\n  } else if (state.draggedHandleType === 'rotation' && state.customPieceInitialAngle !== null) {\n    // Calculate rotation based on change in angle from start\n    const center = state.customPieceInitialTransform.position;\n    const currentAngle = Math.atan2(\n      currentPos[1] - center[1],\n      currentPos[0] - center[0]\n    );\n    const angleDelta = currentAngle - state.customPieceInitialAngle;\n    newTransform = {\n      ...state.customPieceInitialTransform,\n      rotation: state.customPieceInitialTransform.rotation + angleDelta,\n    };\n  } else if (state.draggedHandleType === 'scale' && state.draggedCorner) {\n    // Calculate scale based on distance from center\n    const center = state.customPieceInitialTransform.position;\n    const initialDistance = Math.hypot(\n      state.customPieceDragStart[0] - center[0],\n      state.customPieceDragStart[1] - center[1]\n    );\n    const currentDistance = Math.hypot(\n      currentPos[0] - center[0],\n      currentPos[1] - center[1]\n    );\n    const scaleFactor = currentDistance / initialDistance;\n    newTransform = {\n      ...state.customPieceInitialTransform,\n      scale: [\n        state.customPieceInitialTransform.scale[0] * scaleFactor,\n        state.customPieceInitialTransform.scale[1] * scaleFactor,\n      ],\n    };\n  } else {\n    return;\n  }\n\n  // Update the transform in the custom piece (for live preview)\n  const updatedPieces = attrs.customPieces.map((p) =>\n    p.id === state.draggedCustomPieceId ? { ...p, transform: newTransform } : p\n  );\n\n  // Re-render custom pieces and handles with updated transform\n  if (state.paperCtx) {\n    renderCustomPieces(state, updatedPieces, attrs.color, attrs.selectedCustomPieceId);\n    const updatedPiece = updatedPieces.find((p) => p.id === state.draggedCustomPieceId);\n    if (updatedPiece) {\n      renderCustomPieceHandles(state, updatedPiece);\n    }\n  }\n}\n\n/**\n * Handle the start of a drag operation (mouse or mobile).\n */\nexport function handleDragStart(\n  e: (MouseEvent | TouchEvent) & MithrilViewEvent,\n  attrs: PuzzleRendererAttrs,\n  state: PuzzleRendererState\n): void {\n  e.redraw = false;\n\n  if (!state.canvas) return;\n\n  // Skip when panning with spacebar\n  if (state.isSpacebarPressed) return;\n\n  // For touch events, ignore multiple touches (like pinch zoom)\n  if (e instanceof TouchEvent) {\n    if (e.touches.length > 1) {\n      state.isDragging = false;\n      state.draggedVertexId = -1;\n      state.draggedSeedPointId = -1;\n      return;\n    }\n  }\n\n  // For mouse events, only handle the primary button\n  if (e instanceof MouseEvent && e.button !== 0) return;\n\n  const viewPoint = getViewPoint(e, state.canvas, state);\n  if (!viewPoint) return;\n\n  // Priority 1: Custom piece handles (if a piece is selected)\n  if (attrs.selectedCustomPieceId && state.customHandlesLayer) {\n    const handleHit = state.customHandlesLayer.hitTest(viewPoint, {\n      fill: true,\n      stroke: true,\n      tolerance: 5,\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (handleHit?.item.data.handleType) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      const handleType = handleHit.item.data.handleType as string;\n\n      if (handleType === 'rotation' || handleType === 'scale' || handleType === 'bbox') {\n        const customPiece = attrs.customPieces?.find((p) => p.id === attrs.selectedCustomPieceId);\n        if (customPiece) {\n          state.draggedCustomPieceId = attrs.selectedCustomPieceId;\n          state.draggedHandleType = handleType === 'bbox' ? 'piece' : (handleType === 'rotation' ? 'rotation' : 'scale');\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          state.draggedCorner = handleHit.item.data.corner as string | null;\n          state.customPieceDragStart = [viewPoint.x, viewPoint.y];\n          state.customPieceInitialTransform = { ...customPiece.transform };\n\n          // For rotation, store the initial angle from center to mouse\n          if (state.draggedHandleType === 'rotation') {\n            const center = customPiece.transform.position;\n            state.customPieceInitialAngle = Math.atan2(\n              viewPoint.y - center[1],\n              viewPoint.x - center[0]\n            );\n          } else {\n            state.customPieceInitialAngle = null;\n          }\n\n          state.isDragging = true;\n\n          // For mouse events, attach document-level listeners\n          if (e instanceof MouseEvent) {\n            state.documentMouseMove = (docEvent: MouseEvent) => {\n              const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n              mithrilEvent.redraw = false;\n              handleDragMove(mithrilEvent, attrs, state);\n            };\n            state.documentMouseUp = (docEvent: MouseEvent) => {\n              const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n              mithrilEvent.redraw = false;\n              handleDragEnd(mithrilEvent, attrs, state);\n            };\n            document.addEventListener('mousemove', state.documentMouseMove);\n            document.addEventListener('mouseup', state.documentMouseUp);\n          }\n          return;\n        }\n      }\n    }\n  }\n\n  // Priority 2: Custom pieces (for selection)\n  if (attrs.customPieces && state.customPiecesLayer) {\n    const customPieceHit = state.customPiecesLayer.hitTest(viewPoint, {\n      fill: true,\n      stroke: true,\n      tolerance: 5,\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (customPieceHit?.item.data.customPieceId) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      const clickedPieceId = customPieceHit.item.data.customPieceId as string;\n\n      // If clicking on a different piece, select it\n      if (clickedPieceId !== attrs.selectedCustomPieceId) {\n        if (attrs.onCustomPieceSelected) {\n          attrs.onCustomPieceSelected(clickedPieceId);\n        }\n        return;\n      }\n\n      // If clicking on already selected piece, start dragging it\n      const customPiece = attrs.customPieces.find((p) => p.id === clickedPieceId);\n      if (customPiece) {\n        state.draggedCustomPieceId = clickedPieceId;\n        state.draggedHandleType = 'piece';\n        state.draggedCorner = null;\n        state.customPieceDragStart = [viewPoint.x, viewPoint.y];\n        state.customPieceInitialTransform = { ...customPiece.transform };\n        state.customPieceInitialAngle = null; // Not needed for translation\n        state.isDragging = true;\n\n        // For mouse events, attach document-level listeners\n        if (e instanceof MouseEvent) {\n          state.documentMouseMove = (docEvent: MouseEvent) => {\n            const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n            mithrilEvent.redraw = false;\n            handleDragMove(mithrilEvent, attrs, state);\n          };\n          state.documentMouseUp = (docEvent: MouseEvent) => {\n            const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n            mithrilEvent.redraw = false;\n            handleDragEnd(mithrilEvent, attrs, state);\n          };\n          document.addEventListener('mousemove', state.documentMouseMove);\n          document.addEventListener('mouseup', state.documentMouseUp);\n        }\n        return;\n      }\n    }\n  }\n\n  // Priority 3: Seed points (if visible)\n  if (attrs.pointColor && state.seedPointItems) {\n    const seedHit = state.seedPointItems.hitTest(viewPoint, {\n      fill: true,\n      tolerance: 5,\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (seedHit?.item.data.pieceId !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      state.draggedSeedPointId = seedHit.item.data.pieceId as PieceID;\n      state.isDragging = false; // Will be set to true on first move\n\n      // For mouse events, attach document-level listeners to track drag outside canvas\n      if (e instanceof MouseEvent) {\n        state.documentMouseMove = (docEvent: MouseEvent) => {\n          const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n          mithrilEvent.redraw = false;\n          handleDragMove(mithrilEvent, attrs, state);\n        };\n        state.documentMouseUp = (docEvent: MouseEvent) => {\n          const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n          mithrilEvent.redraw = false;\n          handleDragEnd(mithrilEvent, attrs, state);\n        };\n        document.addEventListener('mousemove', state.documentMouseMove);\n        document.addEventListener('mouseup', state.documentMouseUp);\n      }\n      return;\n    }\n  }\n\n  // Priority 2: Vertices\n  if (state.vertexItems) {\n    const vertexHit = state.vertexItems.hitTest(viewPoint, {\n      fill: true,\n      tolerance: 8,\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (vertexHit?.item.data.vertexId !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      state.draggedVertexId = vertexHit.item.data.vertexId as number;\n      state.isDragging = false; // Will be set to true on first move\n\n      // For mouse events, attach document-level listeners to track drag outside canvas\n      if (e instanceof MouseEvent) {\n        state.documentMouseMove = (docEvent: MouseEvent) => {\n          const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n          mithrilEvent.redraw = false;\n          handleDragMove(mithrilEvent, attrs, state);\n        };\n        state.documentMouseUp = (docEvent: MouseEvent) => {\n          const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n          mithrilEvent.redraw = false;\n          handleDragEnd(mithrilEvent, attrs, state);\n        };\n        document.addEventListener('mousemove', state.documentMouseMove);\n        document.addEventListener('mouseup', state.documentMouseUp);\n      }\n      return;\n    }\n  }\n\n  // Priority 3: Piece selection (future feature)\n  // Currently no-op, but Paper.js hit testing is ready for it\n}\n\n/**\n * Handle drag movement (mouse or mobile).\n */\nexport function handleDragMove(\n  e: (MouseEvent | TouchEvent) & MithrilViewEvent,\n  attrs: PuzzleRendererAttrs,\n  state: PuzzleRendererState\n): void {\n  e.redraw = false;\n\n  if (!state.canvas) return;\n\n  const viewPoint = getViewPoint(e, state.canvas, state);\n  if (!viewPoint) return;\n\n  // Handle custom piece dragging\n  if (state.draggedCustomPieceId) {\n    state.isDragging = true;\n    e.preventDefault();\n\n    // Update cursor to grabbing\n    state.canvas.style.cursor = 'grabbing';\n\n    // Update custom piece transform in real-time\n    handleCustomPieceDragMove(viewPoint, attrs, state);\n    return;\n  }\n\n  // Handle vertex dragging\n  if (state.draggedVertexId >= 0) {\n    state.isDragging = true;\n    e.preventDefault();\n\n    // Update cursor to grabbing\n    state.canvas.style.cursor = 'grabbing';\n\n    // Update vertex position in geometry\n    const coords = pointToVec2(viewPoint);\n    moveVertex(attrs.puzzle, state.draggedVertexId, coords);\n\n    // Update vertex circle position\n    if (state.vertexItems) {\n      const circle = findVertexCircle(state.vertexItems, state.draggedVertexId);\n      if (circle) circle.position = viewPoint;\n    }\n\n    // Trigger puzzle re-render\n    renderPuzzle(state, attrs.puzzle, attrs.color, attrs.pointColor);\n    return;\n  }\n\n  // Handle seed point dragging with throttled regeneration\n  if (state.draggedSeedPointId >= 0) {\n    state.isDragging = true;\n    e.preventDefault();\n\n    // Update cursor to grabbing\n    state.canvas.style.cursor = 'grabbing';\n\n    const coords = pointToVec2(viewPoint);\n\n    // Throttle regeneration to avoid overwhelming the system\n    const now = performance.now();\n    if (now - state.lastRegenerationTime < REGENERATION_THROTTLE_MS) {\n      // Schedule a delayed regeneration\n      if (state.pendingRegeneration) {\n        clearTimeout(state.pendingRegeneration);\n      }\n      state.pendingRegeneration = window.setTimeout(() => {\n        regeneratePuzzleWithoutTabs(attrs, state, state.draggedSeedPointId, coords);\n      }, REGENERATION_THROTTLE_MS);\n      return;\n    }\n\n    // Perform immediate regeneration\n    state.lastRegenerationTime = now;\n    regeneratePuzzleWithoutTabs(attrs, state, state.draggedSeedPointId, coords);\n  }\n}\n\n/**\n * Handle the end of a drag (mouse or mobile).\n */\nexport function handleDragEnd(\n  e: (MouseEvent | TouchEvent) & MithrilViewEvent,\n  attrs: PuzzleRendererAttrs,\n  state: PuzzleRendererState\n): void {\n  e.redraw = false;\n\n  if (!state.canvas) return;\n\n  // Clear any pending regeneration\n  if (state.pendingRegeneration) {\n    clearTimeout(state.pendingRegeneration);\n    state.pendingRegeneration = null;\n  }\n\n  const wasDraggingCustomPiece = state.draggedCustomPieceId && state.isDragging;\n  const wasDraggingVertex = state.draggedVertexId >= 0 && state.isDragging;\n  const wasDraggingSeedPoint = state.draggedSeedPointId >= 0 && state.isDragging;\n\n  if (wasDraggingCustomPiece) {\n    e.preventDefault();\n    // Commit the custom piece transform by calling the callback\n    const viewPoint = getViewPoint(e, state.canvas, state);\n    if (viewPoint && state.customPieceInitialTransform && attrs.onCustomPieceTransformed) {\n      const currentPos: Vec2 = [viewPoint.x, viewPoint.y];\n      const deltaX = currentPos[0] - state.customPieceDragStart![0];\n      const deltaY = currentPos[1] - state.customPieceDragStart![1];\n\n      let finalTransform: CustomPieceTransform;\n\n      if (state.draggedHandleType === 'piece') {\n        // Translate the piece\n        finalTransform = {\n          ...state.customPieceInitialTransform,\n          position: [\n            state.customPieceInitialTransform.position[0] + deltaX,\n            state.customPieceInitialTransform.position[1] + deltaY,\n          ],\n        };\n      } else if (state.draggedHandleType === 'rotation' && state.customPieceInitialAngle !== null) {\n        // Calculate rotation based on change in angle from start\n        const center = state.customPieceInitialTransform.position;\n        const currentAngle = Math.atan2(\n          currentPos[1] - center[1],\n          currentPos[0] - center[0]\n        );\n        const angleDelta = currentAngle - state.customPieceInitialAngle;\n        finalTransform = {\n          ...state.customPieceInitialTransform,\n          rotation: state.customPieceInitialTransform.rotation + angleDelta,\n        };\n      } else if (state.draggedHandleType === 'scale') {\n        // Calculate scale\n        const center = state.customPieceInitialTransform.position;\n        const initialDistance = Math.hypot(\n          state.customPieceDragStart![0] - center[0],\n          state.customPieceDragStart![1] - center[1]\n        );\n        const currentDistance = Math.hypot(\n          currentPos[0] - center[0],\n          currentPos[1] - center[1]\n        );\n        const scaleFactor = currentDistance / initialDistance;\n        finalTransform = {\n          ...state.customPieceInitialTransform,\n          scale: [\n            state.customPieceInitialTransform.scale[0] * scaleFactor,\n            state.customPieceInitialTransform.scale[1] * scaleFactor,\n          ],\n        };\n      } else {\n        finalTransform = state.customPieceInitialTransform;\n      }\n\n      if (state.draggedCustomPieceId) {\n        attrs.onCustomPieceTransformed(state.draggedCustomPieceId, finalTransform);\n      }\n    }\n  }\n\n  if (wasDraggingVertex) {\n    e.preventDefault();\n    attrs.onPuzzleChanged(attrs.puzzle);\n  }\n\n  if (wasDraggingSeedPoint) {\n    e.preventDefault();\n    // Trigger final regeneration with FULL geometry including tabs\n    const pieceId = state.draggedSeedPointId;\n    const viewPoint = getViewPoint(e, state.canvas, state);\n    if (viewPoint && attrs.onSeedPointMoved) {\n      const finalPosition = pointToVec2(viewPoint);\n      attrs.onSeedPointMoved(pieceId, finalPosition);\n    }\n  }\n\n  // Remove document-level listeners if they were attached\n  if (state.documentMouseMove) {\n    document.removeEventListener('mousemove', state.documentMouseMove);\n    state.documentMouseMove = null;\n  }\n  if (state.documentMouseUp) {\n    document.removeEventListener('mouseup', state.documentMouseUp);\n    state.documentMouseUp = null;\n  }\n\n  // Reset drag state\n  state.isDragging = false;\n  state.draggedVertexId = -1;\n  state.draggedSeedPointId = -1;\n  state.draggedCustomPieceId = null;\n  state.draggedHandleType = null;\n  state.draggedCorner = null;\n  state.customPieceDragStart = null;\n  state.customPieceInitialTransform = null;\n  state.customPieceInitialAngle = null;\n\n  // Reset cursor\n  state.canvas.style.cursor = 'default';\n}\n","/**\n * PuzzleRenderer - Responsible for rendering the generated puzzle. Uses paper.js\n */\n\nimport m from 'mithril';\nimport type { PuzzleRendererAttrs, PuzzleRendererState } from './constants';\nimport type MithrilViewEvent from '../../utils/MithrilViewEvent';\nimport { DEFAULT_ZOOM, PRESET_ZOOM_LEVELS, PRESET_ZOOM_LABELS } from './constants';\nimport {\n  initializePaper,\n  renderPuzzle,\n  createPaperLayers,\n  cleanupPaper,\n  updateBackgroundImage,\n  renderCustomPieces,\n  renderCustomPieceHandles,\n  clearCustomPieceHandles,\n} from './rendering';\nimport {\n  handleMouseMove,\n  handleDragStart,\n  handleDragMove,\n  handleDragEnd,\n  setupPanZoomHandling,\n  cleanupPanZoomHandling,\n} from './interaction';\n\n// Include  CSS\nimport './PuzzleRenderer.css';\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/dropdown/dropdown.js';\nimport '@awesome.me/webawesome/dist/components/dropdown-item/dropdown-item.js';\nimport type WaDropdownItem from '@awesome.me/webawesome/dist/components/dropdown-item/dropdown-item.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\nimport '@awesome.me/webawesome/dist/components/tooltip/tooltip.js';\n\n/**\n * PuzzleRenderer - component that renders a puzzle using paper.js\n */\nexport const PuzzleRenderer: m.ClosureComponent<PuzzleRendererAttrs> = () => {\n  // Component state\n  const state: PuzzleRendererState = {\n    canvas: null,\n    isDragging: false,\n    draggedVertexId: -1,\n    draggedSeedPointId: -1,\n    lastRegenerationTime: 0,\n    pendingRegeneration: null,\n    documentMouseMove: null,\n    documentMouseUp: null,\n\n    // Paper.js items\n    paperCtx: null,\n    backgroundRaster: null,\n\n    // Paper.js layer architecture\n    puzzleLayer: null,\n    customPiecesLayer: null,\n    customHandlesLayer: null,\n    seedPointsLayer: null,\n    verticesLayer: null,\n    problemsLayer: null,\n\n    // Groups within layers\n    paperPath: null,\n    seedPointItems: null,\n    problemItems: null,\n    vertexItems: null,\n\n    // Hover and selection state\n    hoveredVertexId: -1,\n    selectedPieceId: -1,\n\n    // Custom piece interaction state\n    draggedCustomPieceId: null,\n    draggedHandleType: null,\n    draggedCorner: null,\n    customPieceDragStart: null,\n    customPieceInitialTransform: null,\n    customPieceInitialAngle: null,\n\n    // Pan and zoom state\n    zoom: DEFAULT_ZOOM,\n    isSpacebarPressed: false,\n  };\n\n  /**\n   * Set zoom level programmatically (from dropdown selection)\n   */\n  const setZoom = (newZoom: number, attrs?: PuzzleRendererAttrs) => {\n    if (newZoom === state.zoom || !state.paperCtx) return;\n\n    const paperScope = state.paperCtx.scope;\n    const zoomFactor = newZoom / state.zoom;\n    paperScope.view.scale(zoomFactor, paperScope.view.center);\n    state.zoom = newZoom;\n\n    // Notify parent of zoom change if callback provided\n    if (attrs?.onZoomChanged) {\n      attrs.onZoomChanged(newZoom);\n    }\n\n    m.redraw();\n  };\n\n  /**\n   * Reset zoom to 100% and center the view\n   */\n  const recenter = () => {\n    if (!state.paperCtx) return;\n\n    const paperScope = state.paperCtx.scope;\n\n    // Reset zoom to 100%\n    const zoomFactor = DEFAULT_ZOOM / state.zoom;\n    paperScope.view.scale(zoomFactor, paperScope.view.center);\n    state.zoom = DEFAULT_ZOOM;\n\n    // Pan to the middle of the view\n    paperScope.view.center = new paperScope.Point(\n      paperScope.view.viewSize.width / 2,\n      paperScope.view.viewSize.height / 2\n    );\n    m.redraw();\n  };\n\n  /**\n   * Get the current zoom as a percentage string\n   */\n  const getZoomPercentage = (): string => {\n    return `${Math.round(state.zoom * 100)}%`;\n  };\n\n  // Track previous imageUrl to detect changes\n  let previousImageUrl: string | undefined = undefined;\n\n  return {\n    // Component lifecycle: called after DOM element is created and attached\n    oncreate: ({ dom, attrs }) => {\n      state.canvas = dom.querySelector<HTMLCanvasElement>(\"canvas.puzzle-renderer\");\n      if (!state.canvas) {\n        console.error('PuzzleRenderer: couldn\\'t get canvas element');\n        return;\n      }\n\n      // Initialize Paper.js\n      initializePaper(state.canvas, attrs.width, attrs.height, state);\n\n      // Create Paper.js layer architecture\n      createPaperLayers(state);\n\n      // Set up pan and zoom event handlers\n      setupPanZoomHandling(state, attrs.onZoomChanged);\n\n      // Load background image if present\n      updateBackgroundImage(state, attrs.imageUrl, attrs.width, attrs.height);\n      previousImageUrl = attrs.imageUrl;\n\n      // Initial render\n      if (!attrs.isDirty) {\n        renderPuzzle(state, attrs.puzzle, attrs.color, attrs.pointColor);\n      }\n\n      // Render custom pieces if present\n      if (attrs.customPieces && attrs.customPieces.length > 0) {\n        renderCustomPieces(state, attrs.customPieces, attrs.color, attrs.selectedCustomPieceId);\n\n        // Render transform handles for selected custom piece\n        if (attrs.selectedCustomPieceId) {\n          const selectedPiece = attrs.customPieces.find((p) => p.id === attrs.selectedCustomPieceId);\n          if (selectedPiece) {\n            renderCustomPieceHandles(state, selectedPiece);\n          }\n        } else {\n          clearCustomPieceHandles(state);\n        }\n      }\n    },\n\n    // Component lifecycle: called when attributes change\n    onupdate: ({ attrs }) => {\n      if (!state.canvas) {\n        console.error('PuzzleRenderer: couldn\\'t get canvas element');\n        return;\n      }\n\n      // Update background image if it changed\n      if (attrs.imageUrl !== previousImageUrl) {\n        updateBackgroundImage(state, attrs.imageUrl, attrs.width, attrs.height);\n        previousImageUrl = attrs.imageUrl;\n      }\n\n      // Re-render if puzzle is not being regenerated\n      if (!attrs.isDirty) {\n        renderPuzzle(state, attrs.puzzle, attrs.color, attrs.pointColor);\n      }\n\n      // Render custom pieces (always update them, even if puzzle is dirty)\n      if (attrs.customPieces && attrs.customPieces.length > 0) {\n        renderCustomPieces(state, attrs.customPieces, attrs.color, attrs.selectedCustomPieceId);\n\n        // Render transform handles for selected custom piece\n        if (attrs.selectedCustomPieceId) {\n          const selectedPiece = attrs.customPieces.find((p) => p.id === attrs.selectedCustomPieceId);\n          if (selectedPiece) {\n            renderCustomPieceHandles(state, selectedPiece);\n          }\n        } else {\n          clearCustomPieceHandles(state);\n        }\n      } else if (state.customPiecesLayer) {\n        // Clear custom pieces layer if no custom pieces\n        state.customPiecesLayer.removeChildren();\n        clearCustomPieceHandles(state);\n      }\n    },\n\n    // Component lifecycle: cleanup when component is removed\n    onremove: () => {\n      // Clean up document-level listeners if component is destroyed during drag\n      if (state.documentMouseMove) {\n        document.removeEventListener('mousemove', state.documentMouseMove);\n        state.documentMouseMove = null;\n      }\n      if (state.documentMouseUp) {\n        document.removeEventListener('mouseup', state.documentMouseUp);\n        state.documentMouseUp = null;\n      }\n\n      // Clean up pan and zoom event handlers\n      cleanupPanZoomHandling(state.canvas);\n\n      // Clean up Paper.js resources\n      cleanupPaper(state);\n    },\n\n    // Component lifecycle: render our output\n    view: ({ attrs }) => {\n      // Get current zoom as percentage string\n      const currentZoomStr = getZoomPercentage();\n\n      return m('.puzzle-renderer-wrapper', [\n        // Canvas for rendering the puzzle with Paper.js (background image is now inside Paper.js)\n        m('canvas.puzzle-renderer', {\n          key: 'puzzle-renderer-canvas', // Stable key to prevent Mithril from replacing the canvas\n          width: attrs.width,\n          height: attrs.height,\n          style: {\n            width: `${attrs.width}px`,\n            height: `${attrs.height}px`,\n            touchAction: 'manipulation',\n          },\n\n          // Mouse events\n          onmousedown: (e: MouseEvent & MithrilViewEvent) => handleDragStart(e, attrs, state),\n          onmousemove: (e: MouseEvent & MithrilViewEvent) => {\n            handleMouseMove(e, attrs, state);\n            handleDragMove(e, attrs, state);\n          },\n          onmouseup: (e: MouseEvent & MithrilViewEvent) => handleDragEnd(e, attrs, state),\n\n          // Touch events\n          ontouchstart: (e: TouchEvent & MithrilViewEvent) => handleDragStart(e, attrs, state),\n          ontouchmove: (e: TouchEvent & MithrilViewEvent) => handleDragMove(e, attrs, state),\n          ontouchend: (e: TouchEvent & MithrilViewEvent) => handleDragEnd(e, attrs, state),\n          ontouchcancel: (e: TouchEvent & MithrilViewEvent) => handleDragEnd(e, attrs, state),\n        }),\n\n        // Controls row\n        m('.puzzle-renderer-controls', {\n          key: 'puzzle-renderer-controls', // Add key to all siblings\n        }, [\n          // Zoom control\n          m('wa-dropdown.zoom-control', {\n            'onwa-select': (e: CustomEvent<{ item: WaDropdownItem }> & MithrilViewEvent) => {\n              e.redraw = false;\n              const selectedValue = e.detail.item.value;\n\n              if (selectedValue && typeof selectedValue === 'string') {\n                const newZoom = parseFloat(selectedValue);\n                if (!isNaN(newZoom)) {\n                  setZoom(newZoom, attrs);\n                }\n              }\n            },\n          }, [\n            m('wa-button', {\n              slot: 'trigger',\n              'with-caret': true,\n              size: 'small',\n              value: state.zoom,\n            }, currentZoomStr),\n            ...PRESET_ZOOM_LEVELS.map((level, index) =>\n              m('wa-dropdown-item', {\n                type: 'checkbox',\n                checked: state.zoom == level ? true : undefined,\n                value: level.toString(),\n              }, PRESET_ZOOM_LABELS[index])\n            ),\n          ]),\n\n          // Recenter button\n          m('wa-tooltip', { for: \"recenter-button\" }, \"Recenter view\"),\n          m('wa-button#recenter-button', {\n            appearance: 'plain',\n            size: 'large',\n            onclick: () => {\n              recenter();\n            },\n          }, m('wa-icon', {\n            library: 'material',\n            name: 'recenter',\n            label: 'Recenter view',\n          })),\n        ]),\n      ]);\n    },\n  };\n};\n\nexport default PuzzleRenderer;\n","import { PuzzleTopology, Vec2 } from \"../geometry/types\";\n\n/**\n * Generates an SVG string representation of the puzzle's cut lines.\n *\n * @param topology - The puzzle topology containing the geometric data.\n * @param width - The width of the SVG viewport.\n * @param height - The height of the SVG viewport.\n * @param pieceColor - Optional color to draw the pieces (default black)\n * @returns A string containing the complete SVG markup.\n */\nexport function createSVG(topology: PuzzleTopology, width: number, height: number, pieceColor = \"black\"): string {\n  // how many digits to preserve when converting decimal numbers to SVG string\n  const precisionDigits = 3;\n\n  // Array to hold the individual path commands (e.g., \"M 10 10\", \"L 100 100\").\n  const pathData: string[] = [];\n\n  // Iterate over each unique edge, ensuring each cut is only defined once.\n  for (const edge of topology.edges.values()) {\n    const he = topology.halfEdges.get(edge.heLeft);\n    if (!he) continue;\n\n    // SVG Path Command: \"M\" - move to the starting point of the half-edge.\n    pathData.push(`M ${he.origin[0].toFixed(precisionDigits)} ${he.origin[1].toFixed(precisionDigits)}`);\n\n    if (he.segments) {\n      // if a custom tab is defined, draw each segment in order\n      for (const segment of he.segments) {\n        switch (segment.type) {\n        case 'bezier':\n          // SVG Path Command: \"C\" - draw a cubic Bzier curve.\n          pathData.push(\n            `C ${segment.p1[0].toFixed(precisionDigits)} ${segment.p1[1].toFixed(precisionDigits)}, ` +\n            `${segment.p2[0].toFixed(precisionDigits)} ${segment.p2[1].toFixed(precisionDigits)}, ` +\n            `${segment.p3[0].toFixed(precisionDigits)} ${segment.p3[1].toFixed(precisionDigits)}`\n          );\n          break;\n        case 'line':\n          // SVG Path Command: \"L\" - draw a straight line to the destination.\n          pathData.push(`L ${segment.p[0].toFixed(precisionDigits)} ${segment.p[1].toFixed(precisionDigits)}`);\n          break;\n        }\n      }\n    } else {\n      // SVG Path Command: \"L\" - draw a straight line to the destination.\n      let destination: Vec2;\n      if (he.twin !== -1) {\n        // Internal edge: destination is the start of the twin half-edge.\n        const twinHe = topology.halfEdges.get(he.twin)!;\n        destination = twinHe.origin;\n      } else {\n        // Boundary edge: destination is the start of the next half-edge.\n        const nextHe = topology.halfEdges.get(he.next)!;\n        destination = nextHe.origin;\n      }\n      pathData.push(`L ${destination[0].toFixed(precisionDigits)} ${destination[1].toFixed(precisionDigits)}`);\n    }\n  }\n\n  // Join all path commands into a single string for the 'd' attribute.\n  const pathD = pathData.join(' ');\n\n  // Construct the final SVG markup.\n  // The <path> element uses vector-effect=\"non-scaling-stroke\" which is a best\n  // practice for laser cutting files, as it ensures the line width remains\n  // constant regardless of scaling.\n  const svgString = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg\n  width=\"${width}\"\n  height=\"${height}\"\n  viewBox=\"0 0 ${width} ${height}\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  version=\"1.1\"\n>\n  <path\n    d=\"${pathD}\"\n    fill=\"none\"\n    stroke=\"${pieceColor}\"\n    stroke-width=\"1\"\n    vector-effect=\"non-scaling-stroke\"\n  />\n</svg>`\n    .trim() // strip leading and trailing whitespace\n    .replace(/\\r\\n/g, '\\n'); // use unix line endings for max compatibility\n\n  return svgString;\n}\n\n\n/**\n * Offers a SVG file for download\n * @param svg SVG string as generated by drawSVG()\n * @param filename Optional name of file for download\n */\nexport function downloadSvg(svg: string, filename = \"puzzle.svg\") {\n  // create a blob from the SVG string\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n\n  // create a temporary object URL for the blob\n  const url = URL.createObjectURL(blob);\n\n  // create a hidden <a> element with the download attribute\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  a.hidden = true;\n\n  // click it\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n\n  // clean up\n  setTimeout(() => URL.revokeObjectURL(url), 100);\n}\n","// UI component that offers a SVG download when clicked\nimport m from 'mithril';\nimport { createSVG, downloadSvg } from '../utils/svg';\nimport type { PuzzleTopology } from '../geometry/types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\nexport interface DownloadPuzzleButtonAttrs extends m.Attributes {\n  /** Generated puzzle geometry */\n  puzzle: PuzzleTopology;\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Optional filename for the download */\n  filename?: string;\n}\n\nexport const DownloadPuzzleButton: m.Component<DownloadPuzzleButtonAttrs> = {\n  view: ({ attrs }) => {\n    return m('wa-button.download-svg', {\n      size: 'small',\n      onclick: () => {\n        // convert the puzzle geometry into a SVG string\n        const svg = createSVG(attrs.puzzle, attrs.width, attrs.height, attrs.color);\n        // offer it as a download\n        downloadSvg(svg, attrs.filename ?? 'puzzle.svg');\n      },\n    }, 'Download SVG');\n  },\n};\nexport default DownloadPuzzleButton;\n","// UI component to initiate and display geometry checks\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/badge/badge.js';\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\nimport '@awesome.me/webawesome/dist/components/progress-bar/progress-bar.js';\nimport '@awesome.me/webawesome/dist/components/tooltip/tooltip.js';\n\n// component CSS\nimport './GeometryCheckIndicator.css';\n\n// component attributes\nexport interface GeometryCheckIndicatorAttrs extends m.Attributes {\n  /** If true, the auto check box is checked */\n  autoCheck: boolean;\n  /** If present, represents the number of geometry problems found in the most recent check */\n  problems?: number;\n  /** If present represents the percent complete of the current geometry check */\n  progressPercent?: number;\n  /** Handler called when user clicks the check now button */\n  onCheckRequested?: () => void;\n  /** Called when the user toggles the auto check on or off */\n  onAutocheckChanged?: (autocheck: boolean) => void;\n};\n\n// component\nexport const GeometryCheckIndicator: m.Component<GeometryCheckIndicatorAttrs> = {\n  view: ({ attrs }) => {\n    const showProgress = attrs.progressPercent !== undefined && attrs.progressPercent < 100;\n    const showOKBadge = !showProgress && attrs.problems !== undefined && attrs.problems == 0;\n    const showProblemBadge = !showProgress && attrs.problems !== undefined && attrs.problems > 0;\n\n    return m('.geometry-check-indicator', [\n\n      // label\n      m('.label', \"Geometry Check:\"),\n\n      // run now button\n      m('wa-tooltip', { for: 'check-geometry-now'}, 'Check geometry now'),\n      m('wa-button#check-geometry-now', {\n        variant: 'neutral',\n        appearance: 'plain',\n        size: 'small',\n        disabled: showProgress,\n        onclick: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          attrs.onCheckRequested?.();\n        },\n      }, m('wa-icon', {\n        library: 'material',\n        name: 'editor_choice',\n        label: 'Check geometry now',\n      })),\n\n      // auto check checkbox\n      m('wa-tooltip', { for: 'auto-check-geometry' }, 'Check geometry after every change'),\n      m('wa-checkbox#auto-check-geometry', {\n        checked: attrs.autoCheck,\n        disabled: showProgress,\n        size: 'small',\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const checkbox = e.target as WaCheckbox;\n          attrs.onAutocheckChanged?.(checkbox.checked);\n        },\n      }, 'auto check'),\n\n      // progress indicator\n      showProgress && m('wa-progress-bar', {\n        label: 'Geometry check progress',\n        value: attrs.progressPercent ?? 0,\n      }),\n\n      // OK badge\n      showOKBadge && m('wa-badge', {\n        variant: 'success',\n        pill: true,\n      }, 'OK'),\n\n      // Problems badge\n      showProblemBadge && m('wa-badge', {\n        variant: 'danger',\n        pill: true,\n      }, `${attrs.problems} issue${attrs.problems === 1 ? '' : 's'}`),\n\n    ]);\n  },\n};\nexport default GeometryCheckIndicator;\n","// UI component that allows the user to select an image to upload when clicked\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\n\n// include our CSS\nimport \"./UploadImageButton.css\";\n\n// component attributes\nexport interface UploadImageAttrs extends m.Attributes {\n  /** Optional label for the button, default \"Upload Image\" */\n  label?: string;\n  /** If true, the button will be disabled */\n  disabled?: boolean;\n  /**\n   * Called when the user uploads an image. The caller is responsible for\n   * cleaning up the returned image URL.\n   */\n  onUpload: (imageUrl: string, filename: string, width: number, height: number) => void;\n  /** Called when the user wants to clear the background image */\n  onClear: () => void;\n};\n\n// utility to determine display dimensions that are the same aspect ratio\nfunction calculateDisplayDimensions(originalWidth: number, originalHeight: number, maxWidth = 800): {\n  width: number;\n  height: number;\n} {\n  if (originalWidth <= maxWidth) {\n    return {\n      width: originalWidth,\n      height: originalHeight,\n    };\n  }\n\n  const aspectRatio = originalHeight / originalWidth;\n  return {\n    width: maxWidth,\n    height: Math.round(maxWidth * aspectRatio),\n  };\n}\n\n// component\nexport const UploadImageButton: m.ClosureComponent<UploadImageAttrs> = () => {\n\n  // component state\n  const state = {\n    inputElement: undefined as HTMLInputElement | undefined,\n    imageLoaded: false,\n    imageName: '',\n  };\n\n  return {\n\n    view: ({ attrs }) => {\n      return [\n\n        // button for display\n        m('wa-button.upload-button', {\n          size: 'small',\n          disabled: attrs.disabled === true,\n          onclick: () => {\n            if (state.inputElement) {\n              state.inputElement.click();\n            }\n          },\n        }, attrs.label ?? 'Upload Image'),\n\n        // hidden file input that does the work\n        m('input[type=file]', {\n          style: { display: 'none' },\n          accept: 'image/*',\n          oncreate: ({ dom }) => {\n            state.inputElement = dom as HTMLInputElement;\n          },\n          onchange: (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            if (state.inputElement) {\n              const file = state.inputElement.files?.[0];\n              if (file?.type.startsWith('image/')) {\n                createImageBitmap(file)\n                  .then((bitmap) => {\n                    // get the image dimensions, scaled to fit in the display area\n                    const { width, height } = calculateDisplayDimensions(bitmap.width, bitmap.height);\n                    const uploadUrl = URL.createObjectURL(file);\n                    bitmap.close();\n                    state.imageName = file.name;\n                    attrs.onUpload(uploadUrl, file.name, width, height);\n                    state.imageLoaded = true;\n                  })\n                  .catch((err) => {\n                    console.error('could not create a bitmap image: ', err);\n                  });\n              }\n            }\n          },\n        }),\n\n        m('span.background-image-label', state.imageName),\n\n        // clear button\n        state.imageLoaded && m('wa-icon.clear-button', {\n          library: 'material',\n          name: 'close',\n          label: 'Clear background image',\n          onclick: (e: MithrilViewEvent) => {\n            e.redraw = false;\n            if (attrs.disabled) { return; }\n            state.imageName = '';\n            state.imageLoaded = false;\n            attrs.onClear();\n          },\n        }, 'Clear'),\n\n      ];\n    },\n  };\n};\nexport default UploadImageButton;\n","// UI component to take boolean input\nimport m from 'mithril';\nimport type { BooleanUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\n\n// component attributes\nexport interface BooleanInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: BooleanUIControl;\n  /** Current value */\n  value: boolean;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: boolean) => void;\n}\n\n// component\nexport const BooleanInputControl: m.ClosureComponent<BooleanInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-checkbox.boolean-input', {\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        checked: attrs.value,\n        onchange: (e: Event) => {\n          const input = e.target as WaCheckbox;\n          const newValue = input.checked;\n          attrs.onChange(newValue);\n        },\n      }, attrs.config.label);\n    },\n  };\n};\nexport default BooleanInputControl;\n","// UI component to take choice input from a dropdown\nimport m from 'mithril';\nimport type { ChoiceUIControl } from '../../geometry/ui_types';\nimport MithrilViewEvent from '../../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/option/option.js';\nimport '@awesome.me/webawesome/dist/components/select/select.js';\nimport WaSelect from '@awesome.me/webawesome/dist/components/select/select.js';\n\n// component attributes\nexport interface ChoiceInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: ChoiceUIControl;\n  /** Current value */\n  value?: string;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: string | undefined) => void;\n}\n\n// component\nexport const ChoiceInputControl: m.ClosureComponent<ChoiceInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // Generate the list of <wa-option> elements\n      const selectOptions = attrs.config.choices.map(([value, label]) =>\n        m('wa-option', {\n          value: value,\n        }, label)\n      );\n\n      // Find help text for the currently selected choice\n      const currentValue = attrs.value ?? attrs.config.defaultValue;\n      const selectedChoice = attrs.config.choices.find(([value]) => value === currentValue);\n      const selectedChoiceHelpText = selectedChoice?.[2];\n\n      return m('.choice-input-wrapper', [\n        m('wa-select.choice-input', {\n          label: attrs.config.label,\n          hint: attrs.config.helpText,\n          size: 'small',\n          disabled: attrs.disabled,\n          value: currentValue,\n          onchange: (e: Event & MithrilViewEvent) => {\n            e.redraw = false; // parent component triggers redraws as necessary\n            const select = e.target as WaSelect;\n            const selectedValue = select.value as string;\n\n            // let parent decide whether to redraw\n            attrs.onChange(selectedValue || undefined);\n          },\n        }, selectOptions),\n        // Display help text for the selected choice if available\n        selectedChoiceHelpText ? m('p.choice-help-text', {\n          style: {\n            'margin-top': '0.25rem',\n            'font-size': '0.875rem',\n            'color': 'var(--wa-form-control-hint-color)',\n            'line-height': '1.25rem',\n          },\n        }, selectedChoiceHelpText) : null,\n      ]);\n    },\n  };\n};\nexport default ChoiceInputControl;\n","// UI component to take a number input\nimport m from 'mithril';\nimport type { NumberUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface NumberInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: NumberUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const NumberInputControl: m.ClosureComponent<NumberInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.number-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"number\",\n        inputmode: \"numeric\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        onchange: (e: Event) => {\n          const input = e.target as WaInput;\n          const newValue = parseFloat(input.value ?? '');\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default NumberInputControl;\n","// UI component to take number input from a slider\nimport m from 'mithril';\nimport type { RangeUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// component attributes\nexport interface RangeInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: RangeUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const RangeInputControl: m.ClosureComponent<RangeInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-slider.range-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        step: attrs.config.step,\n        'with-tooltip': true,\n        onchange: (e: Event) => {\n          const input = e.target as WaSlider;\n          const newValue = input.value;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default RangeInputControl;\n","// UI component to take string input\nimport m from 'mithril';\nimport type { StringUIControl } from '../../geometry/ui_types';\nimport MithrilViewEvent from '../../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport type WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface StringInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: StringUIControl;\n  /** Current value */\n  value?: string;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: string | undefined) => void;\n}\n\n// component\nexport const StringInputControl: m.ClosureComponent<StringInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.string-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"text\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        oninput: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const input = e.target as WaInput;\n          const newValue = input.value ?? '';\n          // let parent decide whether to redraw\n          attrs.onChange(newValue.length > 0 ? newValue : undefined);\n        },\n      });\n    },\n  };\n};\nexport default StringInputControl;\n","// UI component that lets the user pick and configure a generator\nimport m from 'mithril';\nimport type { GeneratorRegistry, GeneratorConfig, GeneratorName } from '../geometry/generators/Generator';\nimport type { UIControl } from '../geometry/ui_types';\nimport BooleanInputControl from './inputs/BooleanInputControl';\nimport ChoiceInputControl from './inputs/ChoiceInputControl';\nimport NumberInputControl from './inputs/NumberInputControl';\nimport RangeInputControl from './inputs/RangeInputControl';\nimport StringInputControl from './inputs/StringInputControl';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/tab/tab.js';\nimport '@awesome.me/webawesome/dist/components/tab-group/tab-group.js';\nimport '@awesome.me/webawesome/dist/components/tab-panel/tab-panel.js';\nimport type { WaTabShowEvent } from '@awesome.me/webawesome';\n\n\n// include our CSS\nimport './GeneratorPicker.css';\n\n// component attributes\nexport interface GeneratorPickerAttrs<C extends GeneratorConfig = GeneratorConfig> extends m.Attributes {\n  /** Currently selected generator for this type */\n  generator: GeneratorName;\n  /** All the registered generators for this type */\n  registry: GeneratorRegistry<unknown>;\n  /** Current configuration for the selected generator */\n  config: C;\n  /** Called when the selected generator changes */\n  onGeneratorChange: (generatorName: string) => void;\n  /** Called when any config value changes */\n  onConfigChange: <K extends keyof C>(key: K, value: C[K]) => void;\n}\n\n/**\n * Helper function to determine if a control should be shown based on its dependencies.\n * Returns true if the control has no dependencies, or if at least ONE dependency condition\n * matches the current config (OR logic).\n */\nconst shouldShowControl = (control: UIControl, config: GeneratorConfig): boolean => {\n  // If no dependencies, always show\n  if (!control.dependsOn || control.dependsOn.length === 0) {\n    return true;\n  }\n\n  // Show if ANY condition matches (OR logic)\n  return control.dependsOn.some((dep) => config[dep.config] === dep.value);\n};\n\n// component\nexport const GeneratorPicker: m.ClosureComponent<GeneratorPickerAttrs> = () => {\n\n  // no component state\n\n  // component\n  return {\n\n    view: ({ attrs }) => {\n\n      const generators = attrs.registry.getAvailableGenerators();\n\n      return m(\".generator-picker\",\n        m('wa-tab-group', {\n          active: attrs.generator,\n          // custom Webawesome event triggered when a new tab panel is shown\n          'onwa-tab-show': (e: WaTabShowEvent) => {\n            const newSelected = e.detail.name;\n            if (attrs.generator !== newSelected) {\n              attrs.onGeneratorChange(newSelected);\n            }\n          },\n        }, [\n          ...generators.map((generator) => {\n            // get the UI metadata associated with this generator\n            const uiMetadata = attrs.registry.getUIMetadata(generator.name);\n\n            // tab contains name of generator\n            const tab = m('wa-tab', { panel: generator.name }, generator.displayName);\n\n            // matching panel contains controls specific to that generator\n            const panel = m('wa-tab-panel', { name: generator.name }, m('.controls',\n              [\n                // detailed description of the generator if available\n                uiMetadata?.description ? m('p', uiMetadata.description) : null,\n\n                // UI controls defined by the generator (filtered by dependencies)\n                ...uiMetadata?.controls.filter((control) => shouldShowControl(control, attrs.config)).map((control) => {\n                  switch(control.type) {\n                  case \"range\":\n                    return m(RangeInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"boolean\":\n                    return m(BooleanInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) === true,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"number\":\n                    return m(NumberInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"string\":\n                    return m(StringInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as string | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"choice\":\n                    return m(ChoiceInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as string | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  }\n                }) ?? [],\n\n                // no controls message when appropriate\n                (!uiMetadata?.description && uiMetadata?.controls.length == 0) ? m('p', 'No controls for this strategy.') : null,\n              ])\n            );\n            return [tab, panel];\n          }),\n        ])\n      );\n    },\n  };\n};\nexport default GeneratorPicker;\n","// UI component to let the user select an aspect ratio\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/option/option.js';\nimport '@awesome.me/webawesome/dist/components/select/select.js';\nimport WaSelect from '@awesome.me/webawesome/dist/components/select/select.js';\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// this component's CSS\nimport './AspectRatioPicker.css';\n\n// component attributes\nexport interface AspectRatioPickerAttr extends m.Attributes {\n  /** Current ratio */\n  ratio: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current ratio */\n  onChange: (ratio: number) => void;\n}\n\n// data\nconst commonAspectRatios: [string, string, number][] = [\n  [\"Square\",           \"1:1\",    1],\n\n  // --- Landscape ---\n  [\"Classic Photo\",    \"5:4\",    5/4],\n  [\"Standard Photo\",   \"4:3\",    4/3],\n  [\"35mm/DSLR\",        \"3:2\",    3/2],\n  [\"Widescreen\",       \"16:9\",   16/9],\n  [\"UltraWide\",        \"21:9\",   21/9],\n  [\"Panorama\",         \"2:1\",    2/1],\n\n  // --- Portrait ---\n  [\"Instagram Portrait\",       \"4:5\",    4/5],\n  [\"Classic Portrait\",         \"3:4\",    3/4],\n  [\"DSLR Portrait\",            \"2:3\",    2/3],\n  [\"Phone Portrait\",           \"9:16\",   9/16],\n  [\"Tall Poster\",              \"9:21\",   9/21],\n  [\"Tall Panorama\",            \"1:2\",    1/2],\n];\n\n// component\nexport const AspectRatioPicker: m.Component<AspectRatioPickerAttr> = {\n  view: ({ attrs }) => {\n\n    // Determine if the current ratio is a custom value (not in our predefined list)\n    const isCustom = !commonAspectRatios.some(([, , value]) => value === attrs.ratio);\n\n    // Generate the list of <wa-option> elements\n    const selectOptions = commonAspectRatios.map(([name, ratioStr, value]) =>\n      m('wa-option', {\n        value: String(value), // select values are strings\n      }, `${name} [${ratioStr}]`)\n    );\n\n    // If the ratio is custom, add a temporary \"Custom\" option to the start of the list\n    if (isCustom) {\n      selectOptions.unshift(m('wa-option', { value: 'custom' }, 'Custom'));\n    }\n\n    return m('.aspect-ratio-picker', [\n\n      // drop down with common ratios\n      m('wa-select', {\n        label: 'Aspect Ratio',\n        size: 'small',\n        disabled: attrs.disabled,\n        value: isCustom ? 'custom' : String(attrs.ratio),\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const select = e.target as WaSelect;\n          const selectedValue = select.value as string;\n\n          // 'custom' is a placeholder, so we only trigger onChange for actual numeric values.\n          if (selectedValue && selectedValue !== 'custom') {\n            attrs.onChange(Number(selectedValue));\n          }\n        },\n      }, selectOptions),\n\n      // slider for any ratio\n      m('wa-slider', {\n        // allow ratios from 1:4 (0.25) to 4:1 (4.0)\n        min: 0.25,\n        max: 4,\n        step: 0.01,\n        'with-tooltip': true,\n        size: 'small',\n        disabled: attrs.disabled,\n        value: attrs.ratio,\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const range = e.target as WaSlider;\n          attrs.onChange(range.value);\n        },\n      }),\n    ]);\n  },\n};\nexport default AspectRatioPicker;\n","// UI component to let the user select a color\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\nimport WaColorPicker from '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\n\n// this component's CSS\nimport './ColorPicker.css';\n\n// component attributes\nexport interface ColorPickerAttrs extends m.Attributes {\n  /** Label to display next to the color picker */\n  label: string;\n  /** Current color */\n  color: string;\n  /** Optional size of picker trigger area */\n  size?: \"small\" | \"medium\" | \"large\";\n  /** Called when the user changes the color */\n  onUpdate: (newColor: string) => void;\n};\n\n// component with no state\nexport const ColorPicker: m.Component<ColorPickerAttrs> = {\n  view: ({ attrs }) => {\n    return m('wa-color-picker', {\n      label: attrs.label,\n      value: attrs.color,\n      size: attrs.size ?? \"medium\",\n      format: 'rgb',\n      onchange: (e: Event & MithrilViewEvent) => {\n        e.redraw = false;\n        const input = e.target as WaColorPicker;\n        attrs.onUpdate(input.value ?? '');\n      },\n    });\n  },\n};\nexport default ColorPicker;\n","// UI component to let the user select a border shape\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/option/option.js';\nimport '@awesome.me/webawesome/dist/components/select/select.js';\nimport WaSelect from '@awesome.me/webawesome/dist/components/select/select.js';\n\n// component attributes\nexport interface BorderShapePickerAttr extends m.Attributes {\n  /** Current border shape */\n  shape: BorderShapeType;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the border shape */\n  onChange: (shape: BorderShapeType) => void;\n}\n\n// Available border shape types\nexport type BorderShapeType = 'rectangle' | 'circle' | 'ellipse' | 'rounded-rect';\n\n// data\nconst borderShapes: [BorderShapeType, string][] = [\n  ['rectangle', 'Rectangle'],\n  ['circle', 'Circle'],\n  ['ellipse', 'Ellipse'],\n  ['rounded-rect', 'Rounded Rectangle'],\n];\n\n// component\nexport const BorderShapePicker: m.Component<BorderShapePickerAttr> = {\n  view: ({ attrs }) => {\n\n    // Generate the list of <wa-option> elements\n    const selectOptions = borderShapes.map(([value, name]) =>\n      m('wa-option', {\n        value: value,\n      }, name)\n    );\n\n    return m('wa-select', {\n      label: 'Border Shape',\n      size: 'small',\n      disabled: attrs.disabled,\n      value: attrs.shape,\n      onchange: (e: Event & MithrilViewEvent) => {\n        e.redraw = false; // parent component triggers redraws as necessary\n        const select = e.target as WaSelect;\n        const selectedValue = select.value as BorderShapeType;\n\n        if (selectedValue) {\n          attrs.onChange(selectedValue);\n        }\n      },\n    }, selectOptions);\n  },\n};\nexport default BorderShapePicker;\n","/**\n * Constants and types for the PathEditor component\n */\n\nimport type { PaperContext } from '../../utils/paperScope';\n\n/* ========================================================= *\\\n *  Types                                                    *\n\\* ========================================================= */\n\n/**\n * Editor mode - automatically managed based on path state\n */\nexport type EditorMode = 'draw' | 'edit';\n\n/**\n * Internal state for the PathEditor component\n */\nexport interface PathEditorState {\n  /** The canvas element */\n  canvas: HTMLCanvasElement | null;\n  /** Paper.js context with isolated scope for this editor */\n  paperCtx: PaperContext | null;\n  /** The Paper.js path being edited */\n  path: paper.Path | null;\n  /** The preview path showing next segment in draw mode */\n  previewPath: paper.Path | null;\n  /** Current editor mode */\n  mode: EditorMode;\n  /** Currently selected segment (for moving anchor points) */\n  selectedSegment: paper.Segment | null;\n  /** Currently selected handle for editing curves */\n  selectedHandle: { segment: paper.Segment; type: 'handleIn' | 'handleOut' } | null;\n  /** Current zoom level (1.0 = 100%) */\n  zoom: number;\n  /** Whether spacebar is currently pressed (for panning) */\n  isSpacebarPressed: boolean;\n  /** Whether shift key is currently pressed (for insert point mode in edit) */\n  isShiftPressed: boolean;\n  /** Pending point location during curve creation (draw mode) */\n  pendingPoint: paper.Point | null;\n  /** Whether user is currently dragging to create a curve */\n  isDraggingCurve: boolean;\n  /** Whether cursor is near first point for snapping to close path */\n  isNearFirstPoint: boolean;\n  /** Visual indicator for first point when snapping */\n  snapIndicator: paper.Path.Circle | null;\n}\n\n/* ========================================================= *\\\n *  Configuration Constants                                  *\n\\* ========================================================= */\n\n/** Threshold distance for hit testing anchor points */\nexport const HIT_TOLERANCE = 10;\n\n/** Default stroke color for path */\nexport const DEFAULT_STROKE_COLOR = '#2196F3';\n\n/** Default stroke width */\nexport const DEFAULT_STROKE_WIDTH = 2;\n\n/** Preview path stroke color */\nexport const PREVIEW_STROKE_COLOR = '#999999';\n\n/** Preview path stroke width */\nexport const PREVIEW_STROKE_WIDTH = 1;\n\n/** Preview path dash array */\nexport const PREVIEW_DASH_ARRAY = [4, 4];\n\n/** Anchor point selection radius (pixels) */\nexport const ANCHOR_POINT_RADIUS = 5;\n\n/**\n * Handle length multiplier for curve creation during drag\n * Controls how much the drag distance influences bezier handle length\n * Higher values create more pronounced curves\n */\nexport const DRAG_HANDLE_MULTIPLIER = 0.5;\n\n/**\n * Distance threshold (in pixels) for snapping to first point to close path\n * When cursor is within this distance of the first point, snap mode is enabled\n */\nexport const SNAP_THRESHOLD = 15;\n\n/**\n * Snap indicator circle radius (pixels)\n * Visual indicator shown around the first point when snapping\n */\nexport const SNAP_INDICATOR_RADIUS = 10;\n\n/**\n * Snap indicator stroke color\n */\nexport const SNAP_INDICATOR_COLOR = '#4CAF50';\n\n/**\n * Snap indicator stroke width\n */\nexport const SNAP_INDICATOR_WIDTH = 2;\n\n/* ========================================================= *\\\n *  Zoom and Pan Constants                                   *\n\\* ========================================================= */\n\n/** Minimum zoom level (10%) */\nexport const MIN_ZOOM = 0.1;\n\n/** Maximum zoom level (1000%) */\nexport const MAX_ZOOM = 10;\n\n/** Default zoom level (100%) */\nexport const DEFAULT_ZOOM = 1;\n\n/** Zoom step for mouse wheel (2.5% per wheel event) */\nexport const ZOOM_STEP = 0.025;\n\n/** Preset zoom levels for dropdown */\nexport const PRESET_ZOOM_LEVELS = [0.25, 0.5, 1, 2, 4];\n\n/** Preset zoom labels for dropdown */\nexport const PRESET_ZOOM_LABELS = ['25%', '50%', '100%', '200%', '400%'];\n","/**\n * Interaction handling for the PathEditor component\n * Manages mouse/touch events, keyboard shortcuts, and cursor feedback\n */\n\nimport type { PathEditorState } from './constants';\nimport {\n  HIT_TOLERANCE,\n  DRAG_HANDLE_MULTIPLIER,\n  MIN_ZOOM,\n  MAX_ZOOM,\n  ZOOM_STEP,\n  SNAP_THRESHOLD,\n  SNAP_INDICATOR_RADIUS,\n  SNAP_INDICATOR_COLOR,\n  SNAP_INDICATOR_WIDTH,\n} from './constants';\nimport { withPaper } from '../../utils/paperScope';\n\n/* ========================================================= *\\\n *  Tool Setup                                               *\n\\* ========================================================= */\n\n// Store event handler references for cleanup\nlet keyDownHandler: ((event: KeyboardEvent) => void) | null = null;\nlet keyUpHandler: ((event: KeyboardEvent) => void) | null = null;\nlet wheelHandler: ((event: WheelEvent) => void) | null = null;\nlet mouseDownHandler: ((event: MouseEvent) => void) | null = null;\nlet mouseMoveHandler: ((event: MouseEvent) => void) | null = null;\nlet mouseUpHandler: ((event: MouseEvent) => void) | null = null;\n\n// Track panning state for raw mouse events\nlet isPanningWithRawEvents = false;\nlet lastPanPoint: { x: number; y: number } | null = null;\n\n/**\n * Initialize Paper.js tool and set up mouse event handlers\n *\n * @param state - The PathEditor state object\n * @param onPathChanged - Callback to invoke when the path changes\n * @param onZoomChanged - Callback to invoke when the zoom level changes\n * @returns The initialized Paper.js Tool\n */\nexport function setupMouseHandling(\n  state: PathEditorState,\n  onPathChanged: () => void,\n  onZoomChanged: () => void,\n): paper.Tool {\n  if (!state.paperCtx) {\n    throw new Error('PathEditor: Cannot setup mouse handling - Paper.js context not initialized');\n  }\n\n  // Create tool with activated scope\n  const tool = withPaper(state.paperCtx, 'PathEditor:setupTool', () => {\n    const paperScope = state.paperCtx!.scope;\n    return new paperScope.Tool();\n  })!;\n\n  // Set up keyboard event listeners for spacebar (pan mode), Shift (insert point mode), and Delete/Backspace\n  keyDownHandler = (event: KeyboardEvent) => {\n    // Don't intercept keyboard events if user is typing in an input field\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'INPUT' || target.tagName === 'WA-INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return;\n    }\n\n    if (event.code === 'Space') {\n      // Always prevent default to stop page scrolling (even on repeated keydown events)\n      event.preventDefault();\n\n      if (!state.isSpacebarPressed) {\n        state.isSpacebarPressed = true;\n        updateCursor(state);\n      }\n    } else if (event.key === 'Shift' && !state.isShiftPressed) {\n      state.isShiftPressed = true;\n      updateCursor(state);\n    } else if (event.code === 'Delete' || event.code === 'Backspace') {\n      // Delete selected point in edit mode\n      if (state.mode === 'edit' && state.selectedSegment && state.path && state.paperCtx) {\n        // Only allow deletion if path has more than 2 segments\n        // (need at least 2 points to make a path)\n        if (state.path.segments.length > 2) {\n          state.selectedSegment.remove();\n          state.selectedSegment = null;\n          state.selectedHandle = null;\n\n          // Activate scope before calling onPathChanged\n          withPaper(state.paperCtx, 'PathEditor:deleteSegment', () => {\n            onPathChanged();\n          });\n        }\n      }\n      event.preventDefault();\n    }\n  };\n\n  keyUpHandler = (event: KeyboardEvent) => {\n    // Don't intercept keyboard events if user is typing in an input field\n    const target = event.target as HTMLElement;\n    if (target.tagName === 'INPUT' || target.tagName === 'WA-INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return;\n    }\n\n    if (event.code === 'Space') {\n      state.isSpacebarPressed = false;\n      updateCursor(state);\n      event.preventDefault();\n    } else if (event.key === 'Shift') {\n      state.isShiftPressed = false;\n      updateCursor(state);\n    }\n  };\n\n  // Set up wheel event listener for zooming\n  wheelHandler = (event: WheelEvent) => {\n    event.preventDefault();\n\n    if (!state.paperCtx) return;\n\n    const paperScope = state.paperCtx.scope;\n\n    // Calculate zoom delta (negative deltaY means zoom in)\n    const delta = -Math.sign(event.deltaY) * ZOOM_STEP;\n    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, state.zoom + delta));\n\n    if (newZoom !== state.zoom) {\n      // Get mouse position in view coordinates\n      const mousePos = new paperScope.Point(event.offsetX, event.offsetY);\n\n      // Zoom centered on mouse position\n      const viewPos = paperScope.view.viewToProject(mousePos);\n      const zoomFactor = newZoom / state.zoom;\n\n      paperScope.view.scale(zoomFactor, viewPos);\n      state.zoom = newZoom;\n\n      onZoomChanged();\n    }\n  };\n\n  // Set up raw mouse event listeners for panning (to avoid Paper.js coordinate feedback)\n  mouseDownHandler = (event: MouseEvent) => {\n    if (state.isSpacebarPressed) {\n      isPanningWithRawEvents = true;\n      lastPanPoint = { x: event.clientX, y: event.clientY };\n      updateCursor(state);\n      event.preventDefault();\n    }\n  };\n\n  mouseMoveHandler = (event: MouseEvent) => {\n    // Prevent default scroll behavior whenever spacebar is pressed\n    if (state.isSpacebarPressed) {\n      event.preventDefault();\n    }\n\n    if (isPanningWithRawEvents && lastPanPoint) {\n      if (!state.paperCtx) return;\n\n      const paperScope = state.paperCtx.scope;\n\n      const dx = event.clientX - lastPanPoint.x;\n      const dy = event.clientY - lastPanPoint.y;\n\n      // Scale delta by inverse of zoom to maintain 1:1 mouse tracking\n      // Paper.js translate() expects project coordinates, not view coordinates\n      const scaledDx = dx / state.zoom;\n      const scaledDy = dy / state.zoom;\n\n      // Pan by translating the view (move content with the mouse)\n      paperScope.view.translate(new paperScope.Point(scaledDx, scaledDy));\n\n      lastPanPoint = { x: event.clientX, y: event.clientY };\n    }\n  };\n\n  mouseUpHandler = () => {\n    if (isPanningWithRawEvents) {\n      isPanningWithRawEvents = false;\n      lastPanPoint = null;\n      updateCursor(state);\n    }\n  };\n\n  // Add event listeners\n  window.addEventListener('keydown', keyDownHandler);\n  window.addEventListener('keyup', keyUpHandler);\n  if (state.canvas) {\n    state.canvas.addEventListener('wheel', wheelHandler, { passive: false });\n    state.canvas.addEventListener('mousedown', mouseDownHandler);\n    state.canvas.addEventListener('mousemove', mouseMoveHandler);\n    state.canvas.addEventListener('mouseup', mouseUpHandler);\n    // Also handle mouse leaving canvas while panning\n    state.canvas.addEventListener('mouseleave', mouseUpHandler);\n  }\n\n  // Mouse down handler\n  tool.onMouseDown = (event: paper.ToolEvent) => {\n    // Skip Paper.js tool handling when panning with spacebar\n    if (state.isSpacebarPressed) {\n      return;\n    }\n\n    if (state.mode === 'draw') {\n      handleDrawModeDown(state, event, onPathChanged);\n    } else {\n      handleEditModeDown(state, event);\n    }\n  };\n\n  // Mouse drag handler\n  tool.onMouseDrag = (event: paper.ToolEvent) => {\n    // Skip Paper.js tool handling when panning with spacebar\n    if (state.isSpacebarPressed) {\n      return;\n    }\n\n    if (state.mode === 'draw') {\n      handleDrawModeDrag(state, event);\n    } else {\n      handleEditModeDrag(state, event);\n    }\n  };\n\n  // Mouse up handler\n  tool.onMouseUp = () => {\n    // Skip Paper.js tool handling when panning with spacebar\n    if (state.isSpacebarPressed) {\n      return;\n    }\n\n    if (state.mode === 'draw') {\n      // Finalize the pending point by adding it to the main path\n      if (state.pendingPoint && state.path && state.paperCtx) {\n        withPaper(state.paperCtx, 'PathEditor:onMouseUp', () => {\n          const paperScope = state.paperCtx!.scope;\n\n          if (state.isDraggingCurve && state.previewPath && state.previewPath.segments.length > 0) {\n            // User dragged - add the curve segment with handles from preview\n            const previewSegment = state.previewPath.lastSegment;\n            const newSegment = new paperScope.Segment(\n              state.pendingPoint!,\n              previewSegment.handleIn,\n              previewSegment.handleOut\n            );\n            state.path!.add(newSegment);\n\n            // Apply the handleOut from preview to the previous segment (if exists)\n            if (state.path!.segments.length > 1 && state.previewPath.segments.length > 1) {\n              const prevSegment = state.path!.segments[state.path!.segments.length - 2];\n              const previewPrevSegment = state.previewPath.segments[0];\n              prevSegment.handleOut = previewPrevSegment.handleOut;\n            }\n          } else {\n            // User just clicked (no drag) - add a straight line segment\n            state.path!.add(state.pendingPoint!);\n          }\n\n          // Clear pending state\n          state.pendingPoint = null;\n          state.isDraggingCurve = false;\n\n          // Hide preview path\n          if (state.previewPath) {\n            state.previewPath.removeSegments();\n            state.previewPath.visible = false;\n          }\n\n          // Notify of changes (within scope activation)\n          onPathChanged();\n        });\n\n        // Update cursor after changes\n        updateCursor(state);\n      }\n    } else {\n      // Edit mode - just notify of changes, keep selection\n      // (selection is managed by handleEditModeDown)\n      if (state.paperCtx) {\n        withPaper(state.paperCtx, 'PathEditor:onMouseUp-editMode', () => {\n          onPathChanged();\n        });\n      }\n    }\n  };\n\n  // Mouse move handler (for preview in draw mode and cursor updates)\n  tool.onMouseMove = (event: paper.ToolEvent) => {\n    if (state.isSpacebarPressed) {\n      // Skip when panning\n      return;\n    }\n\n    if (state.mode === 'draw') {\n      updatePreviewPath(state, event.point);\n      // Cursor is updated in updatePreviewPath based on snap state\n    } else if (state.mode === 'edit') {\n      // Update cursor based on what's under the mouse\n      updateCursor(state, event.point);\n    }\n  };\n\n  tool.activate();\n\n  return tool;\n}\n\n/**\n * Clean up event listeners for keyboard, wheel, and mouse\n */\nexport function cleanupMouseHandling(canvas: HTMLCanvasElement | null): void {\n  // Remove event listeners\n  if (keyDownHandler) {\n    window.removeEventListener('keydown', keyDownHandler);\n    keyDownHandler = null;\n  }\n  if (keyUpHandler) {\n    window.removeEventListener('keyup', keyUpHandler);\n    keyUpHandler = null;\n  }\n  if (canvas) {\n    if (wheelHandler) {\n      canvas.removeEventListener('wheel', wheelHandler);\n      wheelHandler = null;\n    }\n    if (mouseDownHandler) {\n      canvas.removeEventListener('mousedown', mouseDownHandler);\n      mouseDownHandler = null;\n    }\n    if (mouseMoveHandler) {\n      canvas.removeEventListener('mousemove', mouseMoveHandler);\n      mouseMoveHandler = null;\n    }\n    if (mouseUpHandler) {\n      canvas.removeEventListener('mouseup', mouseUpHandler);\n      canvas.removeEventListener('mouseleave', mouseUpHandler);\n      mouseUpHandler = null;\n    }\n  }\n\n  // Reset panning state\n  isPanningWithRawEvents = false;\n  lastPanPoint = null;\n}\n\n/* ========================================================= *\\\n *  Cursor Management                                        *\n\\* ========================================================= */\n\n/**\n * Update the cursor based on the current state and mouse position\n *\n * @param state - The PathEditor state object\n * @param point - The current mouse position (in view coordinates)\n */\nfunction updateCursor(state: PathEditorState, point?: paper.Point): void {\n  if (!state.canvas) return;\n\n  // Priority 1: Panning with spacebar\n  if (state.isSpacebarPressed) {\n    state.canvas.style.cursor = isPanningWithRawEvents ? 'grabbing' : 'grab';\n    return;\n  }\n\n  // Priority 2: Drawing mode\n  if (state.mode === 'draw') {\n    if (state.isNearFirstPoint) {\n      // Near first point - show close-loop indicator\n      // Using \"copy\" cursor as a placeholder for close-loop\n      // Could be customized with a custom cursor image\n      state.canvas.style.cursor = 'copy';\n    } else {\n      // Default drawing cursor\n      state.canvas.style.cursor = 'crosshair';\n    }\n    return;\n  }\n\n  // Priority 3: Edit mode - check what's under the cursor\n  if (state.mode === 'edit') {\n    // Shift held - insert point mode (takes priority)\n    if (state.isShiftPressed) {\n      state.canvas.style.cursor = 'crosshair';\n      return;\n    }\n\n    if (point && state.path) {\n      // Check if hovering over a handle (only if something is selected)\n      const hasSelection = state.selectedSegment !== null || state.path.fullySelected;\n\n      if (hasSelection) {\n        const handleHit = state.path.hitTest(point, {\n          handles: true,\n          tolerance: HIT_TOLERANCE,\n        });\n\n        if (handleHit?.type === 'handle-in' || handleHit?.type === 'handle-out') {\n          state.canvas.style.cursor = 'pointer';\n          return;\n        }\n      }\n\n      // Check if hovering over an anchor point\n      const segmentHit = state.path.hitTest(point, {\n        segments: true,\n        tolerance: HIT_TOLERANCE,\n      });\n\n      if (segmentHit?.segment) {\n        state.canvas.style.cursor = 'move';\n        return;\n      }\n\n      // Check if hovering over the path stroke\n      const strokeHit = state.path.hitTest(point, {\n        stroke: true,\n        tolerance: HIT_TOLERANCE,\n      });\n\n      if (strokeHit) {\n        state.canvas.style.cursor = 'pointer';\n        return;\n      }\n    }\n  }\n\n  // Default cursor\n  state.canvas.style.cursor = 'default';\n}\n\n/* ========================================================= *\\\n *  Draw Mode Handlers                                       *\n\\* ========================================================= */\n\n/**\n * Handle mouse down in draw mode - store the pending point or close path if snapping\n */\nfunction handleDrawModeDown(\n  state: PathEditorState,\n  event: paper.ToolEvent,\n  onPathChanged: () => void,\n): void {\n  if (!state.path || !state.paperCtx) return;\n\n  // Check if we're snapping to the first point to close the path\n  if (state.isNearFirstPoint && state.path.segments.length >= 2) {\n    // Close the path\n    state.path.closed = true;\n\n    // Hide snap indicator\n    if (state.snapIndicator) {\n      state.snapIndicator.visible = false;\n    }\n\n    // Switch to edit mode\n    state.mode = 'edit';\n    state.isNearFirstPoint = false;\n\n    // Hide preview path\n    if (state.previewPath) {\n      state.previewPath.removeSegments();\n      state.previewPath.visible = false;\n    }\n\n    // Notify parent that the path was closed\n    withPaper(state.paperCtx, 'PathEditor:closePathBySnapping', () => {\n      onPathChanged();\n    });\n\n    return;\n  }\n\n  // If there's a previous segment with a curve (has handleOut),\n  // clear it temporarily. If the user drags, onMouseDrag will set it again.\n  // If the user just clicks (no drag), this ensures a straight line.\n  if (state.path.segments.length > 0) {\n    withPaper(state.paperCtx, 'PathEditor:handleDrawModeDown', () => {\n      const paperScope = state.paperCtx!.scope;\n      const lastSegment = state.path!.lastSegment;\n      if (lastSegment.handleOut && lastSegment.handleOut.length > 0) {\n        lastSegment.handleOut = new paperScope.Point(0, 0);\n      }\n    });\n  }\n\n  // Store the pending point (don't add to main path yet)\n  state.pendingPoint = event.point.clone();\n  state.isDraggingCurve = false;\n\n  // Show the pending point as a straight line in the preview\n  updatePreviewPath(state, event.point);\n}\n\n/**\n * Handle mouse drag in draw mode - create smooth bezier curves in preview\n *\n * Nomenclature:\n * - A: Point before B (if it exists)\n * - B: End of current shape (last point in main path)\n * - C: Mouse down point (pending point, not yet added to main path)\n * - D: Current drag position (mouse position during drag)\n *\n * We're drawing a curve from BC, influenced by D:\n * - C's handles should be parallel to drag direction (CD)\n * - B's handleOut should ensure smooth connection based on whether AB was line or curve\n */\nfunction handleDrawModeDrag(\n  state: PathEditorState,\n  event: paper.ToolEvent,\n): void {\n  if (!state.path || !state.previewPath || !state.pendingPoint || !state.paperCtx) return;\n\n  withPaper(state.paperCtx, 'PathEditor:handleDrawModeDrag', () => {\n    const paperScope = state.paperCtx!.scope;\n\n    state.isDraggingCurve = true;\n\n    // C: The pending point (at mouse down position)\n    const pointC = state.pendingPoint!;\n\n    // Vector from C to D (drag direction)\n    const vectorCD = event.point.subtract(pointC);\n\n    // Calculate C's handles parallel to drag direction (CD)\n    const handleCOut = vectorCD.multiply(DRAG_HANDLE_MULTIPLIER);\n    const handleCIn = vectorCD.multiply(-DRAG_HANDLE_MULTIPLIER);\n\n    // Calculate B's handleOut based on the existing path\n    let handleBOut = new paperScope.Point(0, 0);\n\n    if (state.path!.segments.length > 0) {\n      // B: The last segment in the main path\n      const segmentB = state.path!.lastSegment;\n\n      // Vector from B to C\n      const vectorBC = pointC.subtract(segmentB.point);\n\n      if (state.path!.segments.length > 1) {\n        // Check if segment before B (AB) was a line or curve\n        const ABwasCurve = (segmentB.handleIn && segmentB.handleIn.length > 0);\n\n        if (ABwasCurve) {\n          // AB was a curve: Set B.handleOut tangent to B.handleIn for smooth flow\n          // Make them colinear (opposite directions) with length based on BC distance\n          const tangentDir = segmentB.handleIn.normalize();\n          const handleOutLength = vectorBC.length;\n          handleBOut = tangentDir.multiply(-handleOutLength);\n        } else {\n          // AB was a line: Set B.handleOut parallel to the line direction (AB)\n          if (state.path!.segments.length > 1) {\n            // A: The segment before B\n            const segmentA = state.path!.segments[state.path!.segments.length - 2];\n            // Vector from A to B (the line direction)\n            const vectorAB = segmentB.point.subtract(segmentA.point);\n            handleBOut = vectorAB.multiply(0.33);\n          } else {\n            // No A exists (B is first point), use BC direction\n            handleBOut = vectorBC.multiply(0.33);\n          }\n        }\n      }\n\n      // Render the curve in the preview path\n      state.previewPath!.removeSegments();\n\n      // Add first segment at B with its handleOut\n      const firstSeg = new paperScope.Segment(segmentB.point, new paperScope.Point(0, 0), handleBOut);\n      state.previewPath!.add(firstSeg);\n\n      // Add curve from B to C with calculated handles\n      const curveSegment = new paperScope.Segment(pointC, handleCIn, handleCOut);\n      state.previewPath!.add(curveSegment);\n\n      state.previewPath!.visible = true;\n    } else {\n      // First segment - just show the curve with symmetric handles\n      state.previewPath!.removeSegments();\n      const firstSegment = new paperScope.Segment(pointC, handleCIn, handleCOut);\n      state.previewPath!.add(firstSegment);\n      state.previewPath!.visible = true;\n    }\n    // Note: If this is the first segment (no B), C's handles are already set above\n  });\n}\n\n/**\n * Update the preview path showing the next segment\n */\nfunction updatePreviewPath(\n  state: PathEditorState,\n  point: paper.Point,\n): void {\n  if (!state.previewPath || !state.path || !state.paperCtx) return;\n\n  withPaper(state.paperCtx, 'PathEditor:updatePreviewPath', () => {\n    const paperScope = state.paperCtx!.scope;\n\n    // Clear previous preview\n    state.previewPath!.removeSegments();\n\n    // Reset snap state and hide indicator\n    state.isNearFirstPoint = false;\n    if (state.snapIndicator) {\n      state.snapIndicator.visible = false;\n    }\n\n    // Only show preview if there's at least one point in the path\n    if (state.path!.segments.length > 0) {\n      const lastPoint = state.path!.lastSegment.point;\n\n      // Check for snap to first point (need at least 2 points to close)\n      if (state.path!.segments.length >= 2) {\n        const firstPoint = state.path!.firstSegment.point;\n        const distance = point.getDistance(firstPoint);\n\n        if (distance < SNAP_THRESHOLD) {\n          // Snap to first point - show closed loop preview\n          state.isNearFirstPoint = true;\n          state.previewPath!.moveTo(lastPoint);\n          state.previewPath!.lineTo(firstPoint);\n          state.previewPath!.visible = true;\n\n          // Show snap indicator around first point\n          if (!state.snapIndicator) {\n            state.snapIndicator = new paperScope.Path.Circle({\n              center: firstPoint,\n              radius: SNAP_INDICATOR_RADIUS,\n              strokeColor: new paperScope.Color(SNAP_INDICATOR_COLOR),\n              strokeWidth: SNAP_INDICATOR_WIDTH,\n              fillColor: null,\n            });\n          } else {\n            state.snapIndicator.position = firstPoint;\n            state.snapIndicator.visible = true;\n          }\n\n          updateCursor(state);\n          return;\n        }\n      }\n\n      // Normal preview (not snapping)\n      state.previewPath!.moveTo(lastPoint);\n      state.previewPath!.lineTo(point);\n      state.previewPath!.visible = true;\n      updateCursor(state);\n    } else {\n      state.previewPath!.visible = false;\n      updateCursor(state);\n    }\n  });\n}\n\n/* ========================================================= *\\\n *  Edit Mode Handlers                                       *\n\\* ========================================================= */\n\n/**\n * Handle mouse down in edit mode - select path, anchor point, or handle\n */\nfunction handleEditModeDown(\n  state: PathEditorState,\n  event: paper.ToolEvent,\n): void {\n  if (!state.path) return;\n\n  // Priority 1: Shift+click to insert a new point on the path\n  if (state.isShiftPressed) {\n    const strokeHit = state.path.hitTest(event.point, {\n      stroke: true,\n      tolerance: HIT_TOLERANCE,\n    });\n\n    if (strokeHit?.location) {\n      const location = strokeHit.location;\n\n      // Insert a new segment at the clicked location on the path\n      const newSegment = state.path.insert(location.index + 1, location.point);\n\n      // Select the newly inserted segment\n      for (const segment of state.path.segments) {\n        segment.selected = false;\n      }\n      newSegment.selected = true;\n      state.selectedSegment = newSegment;\n      state.selectedHandle = null;\n      state.path.fullySelected = false;\n      return;\n    }\n\n    // If Shift is pressed but didn't click on the path, do nothing\n    return;\n  }\n\n  // Priority 2: try to hit test for handles (control points)\n  // Only check for handles if something is selected (handles are visible)\n  const hasSelection = state.selectedSegment !== null || state.path.fullySelected;\n\n  if (hasSelection) {\n    const handleHit = state.path.hitTest(event.point, {\n      handles: true,\n      tolerance: HIT_TOLERANCE,\n    });\n\n    if (handleHit?.type === 'handle-in' || handleHit?.type === 'handle-out') {\n      // Clicked on a handle - select it for dragging\n      state.selectedHandle = {\n        segment: handleHit.segment,\n        type: handleHit.type === 'handle-in' ? 'handleIn' : 'handleOut',\n      };\n      state.selectedSegment = null;\n      return;\n    }\n  }\n\n  // Priority 3: hit test for segments (anchor points)\n  const segmentHit = state.path.hitTest(event.point, {\n    segments: true,\n    tolerance: HIT_TOLERANCE,\n  });\n\n  if (segmentHit?.segment) {\n    // Clicked on a vertex - select only that segment\n    for (const segment of state.path.segments) {\n      segment.selected = false;\n    }\n    state.selectedSegment = segmentHit.segment;\n    state.selectedSegment.selected = true;\n    state.selectedHandle = null;\n    return;\n  }\n\n  // Priority 4: hit test for the stroke (anywhere on the path)\n  const strokeHit = state.path.hitTest(event.point, {\n    stroke: true,\n    tolerance: HIT_TOLERANCE,\n  });\n\n  if (strokeHit) {\n    // Clicked on the path stroke - select entire path (show all vertices)\n    state.path.fullySelected = true;\n    state.selectedSegment = null;\n    state.selectedHandle = null;\n    return;\n  }\n\n  // Clicked on empty space - deselect all (including path)\n  state.selectedSegment = null;\n  state.selectedHandle = null;\n  state.path.selected = false;\n  state.path.fullySelected = false;\n  for (const segment of state.path.segments) {\n    segment.selected = false;\n  }\n}\n\n/**\n * Handle mouse drag in edit mode - move the selected anchor point or handle\n */\nfunction handleEditModeDrag(\n  state: PathEditorState,\n  event: paper.ToolEvent,\n): void {\n  // Only allow dragging if we have a specific selection (not entire path)\n  if (state.selectedSegment) {\n    // Move the selected segment by the drag delta\n    state.selectedSegment.point = state.selectedSegment.point.add(event.delta);\n  } else if (state.selectedHandle) {\n    // Drag the selected handle\n    const { segment, type } = state.selectedHandle;\n\n    // Calculate the new handle position relative to the segment point\n    const delta = event.point.subtract(segment.point);\n\n    if (type === 'handleOut') {\n      segment.handleOut = delta;\n    } else {\n      segment.handleIn = delta;\n    }\n  }\n  // Note: If path.fullySelected is true but no specific segment/handle is selected,\n  // we don't move anything - user needs to click a specific vertex first\n}\n","/**\n * PathEditor component - Interactive path drawing and editing with Paper.js\n */\n\nimport m from 'mithril';\nimport type { PathCommand } from '../../geometry/types';\nimport type { PathEditorState } from './constants';\nimport {\n  DEFAULT_STROKE_COLOR,\n  DEFAULT_STROKE_WIDTH,\n  PREVIEW_STROKE_COLOR,\n  PREVIEW_STROKE_WIDTH,\n  PREVIEW_DASH_ARRAY,\n  DEFAULT_ZOOM,\n  PRESET_ZOOM_LEVELS,\n  PRESET_ZOOM_LABELS,\n} from './constants';\nimport { paperPathToPathCommands, pathCommandsToPaperPath } from './geometry';\nimport { setupMouseHandling, cleanupMouseHandling } from './interaction';\nimport type MithrilViewEvent from '../../utils/MithrilViewEvent';\nimport { createPaperContext, assertPaperReady, withPaper } from '../../utils/paperScope';\n\n// component level CSS\nimport './PathEditor.css';\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/dropdown/dropdown.js';\nimport '@awesome.me/webawesome/dist/components/dropdown-item/dropdown-item.js';\nimport type WaDropdownItem from '@awesome.me/webawesome/dist/components/dropdown-item/dropdown-item.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\nimport '@awesome.me/webawesome/dist/components/tooltip/tooltip.js';\n\n\n/* ========================================================= *\\\n *  Component Interface                                      *\n\\* ========================================================= */\n\n/**\n * Attributes for the PathEditor component.\n */\nexport interface PathEditorAttrs extends m.Attributes {\n  /**\n   * Optional initial path to load into the editor.\n   * If provided, the path will be displayed and made editable.\n   * If undefined, the editor starts with an empty canvas in draw mode.\n   */\n  initialPath?: PathCommand[];\n\n  /**\n   * Callback invoked when the path changes.\n   * Called after mouse up, point deletion, or other path modifications.\n   *\n   * @param path - The updated path as PathCommand array\n   */\n  onPathChanged: (path: PathCommand[]) => void;\n\n  /**\n   * Width of the editor canvas in pixels.\n   */\n  width: number;\n\n  /**\n   * Height of the editor canvas in pixels.\n   */\n  height: number;\n\n  /**\n   * Optional: Stroke color for the path.\n   * Default: '#2196F3' (blue)\n   */\n  strokeColor?: string;\n}\n\n/* ========================================================= *\\\n *  Component Implementation                                 *\n\\* ========================================================= */\n\n/**\n * PathEditor - A reusable path editing component using Paper.js\n */\nexport const PathEditor: m.ClosureComponent<PathEditorAttrs> = () => {\n  const state: PathEditorState = {\n    canvas: null,\n    paperCtx: null,\n    path: null,\n    previewPath: null,\n    mode: 'draw',\n    selectedSegment: null,\n    selectedHandle: null,\n    zoom: DEFAULT_ZOOM,\n    isSpacebarPressed: false,\n    isShiftPressed: false,\n    pendingPoint: null,\n    isDraggingCurve: false,\n    isNearFirstPoint: false,\n    snapIndicator: null,\n  };\n\n  let tool: paper.Tool | null = null;\n  let previousInitialPath: PathCommand[] | undefined = undefined;\n\n  /**\n   * Initialize Paper.js and set up the drawing environment\n   */\n  const initializePaper = (canvas: HTMLCanvasElement, attrs: PathEditorAttrs) => {\n    // Create isolated Paper.js scope for this editor\n    state.paperCtx = createPaperContext(canvas, attrs.width, attrs.height);\n    state.canvas = canvas;\n\n    if (!state.paperCtx) {\n      console.error('PathEditor: Failed to create Paper.js context');\n      return;\n    }\n\n    withPaper(state.paperCtx, 'PathEditor:initializePaper', () => {\n      const paperScope = state.paperCtx!.scope;\n\n      // Check if Paper.js is ready before creating objects\n      if (!assertPaperReady(paperScope, 'PathEditor:initializePaper')) {\n        console.error('PathEditor: Paper.js not ready - canvas may have been replaced');\n        return;\n      }\n\n      // Configure Paper.js settings for better visibility\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      paperScope.settings.handleSize = 8;\n\n      // Determine initial mode based on whether we have an initial path\n      const hasInitialPath = attrs.initialPath && attrs.initialPath.length > 0;\n      state.mode = hasInitialPath ? 'edit' : 'draw';\n\n      // Create the main path\n      state.path = new paperScope.Path();\n      state.path.strokeColor = new paperScope.Color(attrs.strokeColor ?? DEFAULT_STROKE_COLOR);\n      state.path.strokeWidth = DEFAULT_STROKE_WIDTH;\n\n      // Load initial path if provided\n      if (hasInitialPath && attrs.initialPath) {\n        const loadedPath = pathCommandsToPaperPath(attrs.initialPath, state.paperCtx!);\n        state.path.segments = loadedPath.segments;\n        state.path.strokeColor = new paperScope.Color(attrs.strokeColor ?? DEFAULT_STROKE_COLOR);\n        state.path.strokeWidth = DEFAULT_STROKE_WIDTH;\n      }\n\n      // Create preview path for draw mode\n      state.previewPath = new paperScope.Path();\n      state.previewPath.strokeColor = new paperScope.Color(PREVIEW_STROKE_COLOR);\n      state.previewPath.strokeWidth = PREVIEW_STROKE_WIDTH;\n      state.previewPath.dashArray = PREVIEW_DASH_ARRAY;\n      state.previewPath.visible = false;\n\n      // Set up mouse handling\n      tool = setupMouseHandling(\n        state,\n        () => {\n          notifyPathChanged(attrs);\n        },\n        () => {\n          // Zoom changed - trigger redraw to update zoom display\n          m.redraw();\n        },\n      );\n    });\n  };\n\n  /**\n   * Notify parent component that the path has changed\n   */\n  const notifyPathChanged = (attrs: PathEditorAttrs) => {\n    if (state.path) {\n      const commands = paperPathToPathCommands(state.path);\n      attrs.onPathChanged(commands);\n    }\n    m.redraw();\n  };\n\n  /**\n   * End drawing mode and switch to edit mode\n   */\n  const endDrawing = (attrs: PathEditorAttrs) => {\n    if (state.mode === 'draw') {\n      state.mode = 'edit';\n\n      // Clear any pending curve state\n      state.pendingPoint = null;\n      state.isDraggingCurve = false;\n      state.isNearFirstPoint = false;\n\n      // Don't select anything by default in edit mode\n      // Vertices will only be shown when clicked\n\n      // Hide preview path in edit mode\n      if (state.previewPath) {\n        state.previewPath.removeSegments();\n        state.previewPath.visible = false;\n      }\n\n      // Hide snap indicator\n      if (state.snapIndicator) {\n        state.snapIndicator.visible = false;\n      }\n\n      // Notify parent so validation can run\n      notifyPathChanged(attrs);\n    }\n  };\n\n  /**\n   * Clean up Paper.js resources\n   */\n  const cleanup = () => {\n    if (tool) {\n      tool.remove();\n      tool = null;\n    }\n    // Clean up event listeners\n    cleanupMouseHandling(state.canvas);\n    if (state.paperCtx) {\n      state.paperCtx.scope.project.remove();\n    }\n    state.canvas = null;\n    state.paperCtx = null;\n    state.path = null;\n    state.previewPath = null;\n    state.snapIndicator = null;\n    state.selectedSegment = null;\n    state.selectedHandle = null;\n  };\n\n  /**\n   * Set zoom level programmatically (from dropdown selection)\n   */\n  const setZoom = (newZoom: number) => {\n    if (newZoom === state.zoom || !state.paperCtx) return;\n\n    const paperScope = state.paperCtx.scope;\n    const zoomFactor = newZoom / state.zoom;\n    paperScope.view.scale(zoomFactor, paperScope.view.center);\n    state.zoom = newZoom;\n    m.redraw();\n  };\n\n  /**\n   * Get the current zoom as a percentage string\n   */\n  const getZoomPercentage = (): string => {\n    return `${Math.round(state.zoom * 100)}%`;\n  };\n\n  return {\n    oncreate: ({ dom, attrs }) => {\n      const canvas = dom.querySelector('canvas') as HTMLCanvasElement;\n      if (canvas) {\n        initializePaper(canvas, attrs);\n        // Track the initial path to detect changes in onupdate\n        previousInitialPath = attrs.initialPath;\n      }\n    },\n\n    onremove: () => {\n      cleanup();\n    },\n\n    onupdate: ({ attrs }) => {\n      if (!state.path || !state.paperCtx) return;\n\n      // Handle stroke color changes\n      if (attrs.strokeColor) {\n        state.path.strokeColor = new state.paperCtx.scope.Color(attrs.strokeColor);\n      }\n\n      // Only handle initialPath changes if it actually changed\n      // Compare by reference - if same reference, no change\n      if (attrs.initialPath === previousInitialPath) {\n        return;\n      }\n\n      const prevLength = previousInitialPath?.length ?? 0;\n      const currLength = attrs.initialPath?.length ?? 0;\n\n      // Update tracking\n      previousInitialPath = attrs.initialPath;\n\n      // Only act if the length actually changed\n      if (prevLength === currLength) {\n        return;\n      }\n\n      const hasInitialPath = attrs.initialPath && attrs.initialPath.length > 0;\n\n      // If initialPath is empty, clear the canvas\n      if (!hasInitialPath) {\n        state.path.removeSegments();\n        state.mode = 'draw';\n        state.selectedSegment = null;\n        state.selectedHandle = null;\n        state.pendingPoint = null;\n        state.isDraggingCurve = false;\n        state.isNearFirstPoint = false;\n        if (state.snapIndicator) {\n          state.snapIndicator.visible = false;\n        }\n        m.redraw();\n      }\n      // If initialPath has data, reload it\n      else if (attrs.initialPath && state.paperCtx) {\n        withPaper(state.paperCtx, 'PathEditor:onupdate-loadPath', () => {\n          const paperScope = state.paperCtx!.scope;\n\n          // Check if Paper.js is ready before creating objects\n          if (!assertPaperReady(paperScope, 'PathEditor:onupdate-loadPath')) {\n            console.error('PathEditor: Paper.js not ready during path reload - canvas may have been replaced');\n            return;\n          }\n\n          // Clear existing path\n          state.path!.removeSegments();\n\n          // Load new path\n          const loadedPath = pathCommandsToPaperPath(attrs.initialPath!, state.paperCtx!);\n          state.path!.segments = loadedPath.segments;\n          state.path!.strokeColor = new paperScope.Color(attrs.strokeColor ?? DEFAULT_STROKE_COLOR);\n\n          // Switch to edit mode\n          state.mode = 'edit';\n          state.selectedSegment = null;\n          state.selectedHandle = null;\n          state.pendingPoint = null;\n          state.isDraggingCurve = false;\n          state.isNearFirstPoint = false;\n          if (state.snapIndicator) {\n            state.snapIndicator.visible = false;\n          }\n          m.redraw();\n        });\n      }\n    },\n\n\n    view: ({ attrs }) => {\n      // Get current zoom as percentage string\n      const currentZoomStr = getZoomPercentage();\n\n      return m('.path-editor', [\n        m('canvas', {\n          key: 'path-editor-canvas', // Stable key to prevent Mithril from replacing the canvas\n          width: attrs.width,\n          height: attrs.height,\n          style: {\n            width: `${attrs.width}px`,\n            height: `${attrs.height}px`,\n          },\n        }),\n\n        // Controls row\n        m('.path-editor-controls', {\n          key: 'path-editor-controls', // Add key to all siblings\n        }, [\n\n          // Mode indicator\n          m('.mode-indicator', `Mode: ${state.mode === 'draw' ? 'Drawing' : 'Editing'}`),\n          // End Drawing button (only visible in draw mode)\n          state.mode === 'draw' && m('wa-button.end-drawing-button', {\n            variant: 'success',\n            size: 'small',\n            onclick: () => endDrawing(attrs),\n          }, 'End Drawing'),\n\n          // Zoom control\n          m('wa-dropdown.zoom-control', {\n            'onwa-select': (e: CustomEvent<{ item: WaDropdownItem }> & MithrilViewEvent) => {\n              e.redraw = false;\n              const selectedValue = e.detail.item.value;\n\n              if (selectedValue && typeof selectedValue === 'string') {\n                const newZoom = parseFloat(selectedValue);\n                if (!isNaN(newZoom)) {\n                  setZoom(newZoom);\n                }\n              }\n            },\n          }, [\n            m('wa-button', {\n              slot: 'trigger',\n              'with-caret': true,\n              size: 'small',\n              value: state.zoom,\n            }, currentZoomStr),\n            ...PRESET_ZOOM_LEVELS.map((level, index) =>\n              m('wa-dropdown-item', {\n                type: 'checkbox',\n                checked: state.zoom == level ? true : undefined,\n                value: level.toString(),\n              }, PRESET_ZOOM_LABELS[index])\n            ),\n          ]),\n\n          // Recenter button\n          m('wa-tooltip', { for: \"recenter-button\" }, \"Recenter view\"),\n          m('wa-button#recenter-button', {\n            appearance: 'plain',\n            size: 'large',\n            onclick: () => {\n              if (!state.paperCtx) return;\n\n              withPaper(state.paperCtx, 'PathEditor:recenter', () => {\n                const paperScope = state.paperCtx!.scope;\n\n                // reset zoom to 100%\n                const zoomFactor = DEFAULT_ZOOM / state.zoom;\n                paperScope.view.scale(zoomFactor, paperScope.view.center);\n                state.zoom = DEFAULT_ZOOM;\n\n                // pan to the middle of the view\n                paperScope.view.center = new paperScope.Point(\n                  paperScope.view.viewSize.width / 2,\n                  paperScope.view.viewSize.height / 2\n                );\n              });\n            },\n          }, m('wa-icon', {\n            library: 'material',\n            name: 'recenter',\n            label: 'Recenter view',\n          })),\n\n        ]),\n      ]);\n    },\n  };\n};\n\nexport default PathEditor;\n","import type { CustomPiece, CustomPieceTransform, Vec2, PathCommand, PuzzleTopology, Piece } from \"./types\";\nimport { polygonBounds, isPointInPolygon, doAABBsIntersect, createHalfEdgeLoop } from \"./utils\";\nimport * as martinez from 'martinez-polygon-clipping';\n\n/* ========================================================= *\\\n *  Custom Piece Helper Functions                           *\n\\* ========================================================= */\n\n/**\n * Applies a transform to a point relative to a center point.\n *\n * The transform is applied in the same way as Paper.js:\n * 1. Translate point relative to center (center becomes origin)\n * 2. Apply scale around origin\n * 3. Apply rotation around origin\n * 4. Translate to final position (position is absolute, not offset)\n *\n * @param point - The point to transform\n * @param center - The center point for scale and rotation\n * @param transform - The transformation to apply\n * @returns The transformed point\n */\nfunction applyTransformToPoint(point: Vec2, center: Vec2, transform: CustomPieceTransform): Vec2 {\n  const [x, y] = point;\n  const { position, rotation, scale } = transform;\n\n  // 1. Translate to origin (relative to center)\n  const centeredX = x - center[0];\n  const centeredY = y - center[1];\n\n  // 2. Apply scale around origin\n  const scaledX = centeredX * scale[0];\n  const scaledY = centeredY * scale[1];\n\n  // 3. Apply rotation around origin\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  const rotatedX = scaledX * cos - scaledY * sin;\n  const rotatedY = scaledX * sin + scaledY * cos;\n\n  // 4. Translate to final absolute position\n  // Note: position is the absolute final position of the center, not an offset\n  const translatedX = rotatedX + position[0];\n  const translatedY = rotatedY + position[1];\n\n  return [translatedX, translatedY];\n}\n\n/**\n * Flattens a path command array to a polygon (array of Vec2 points).\n * Bezier curves and arcs are approximated with line segments.\n *\n * @param path - The path commands to flatten\n * @param tolerance - Maximum distance between the curve and the approximation (default: 0.5)\n * @returns An array of points representing the flattened path\n */\nexport function flattenPath(path: PathCommand[], tolerance = 0.5): Vec2[] {\n  const points: Vec2[] = [];\n  let currentPoint: Vec2 = [0, 0];\n\n  for (const command of path) {\n    switch (command.type) {\n    case 'move':\n      currentPoint = command.p;\n      points.push(currentPoint);\n      break;\n\n    case 'line':\n      currentPoint = command.p;\n      points.push(currentPoint);\n      break;\n\n    case 'bezier': {\n      // Flatten bezier curve to line segments\n      // Using simple subdivision approach\n      const segments = Math.max(8, Math.ceil(Math.hypot(\n        command.p3[0] - currentPoint[0],\n        command.p3[1] - currentPoint[1]\n      ) / tolerance));\n\n      for (let i = 1; i <= segments; i++) {\n        const t = i / segments;\n        const t2 = t * t;\n        const t3 = t2 * t;\n        const mt = 1 - t;\n        const mt2 = mt * mt;\n        const mt3 = mt2 * mt;\n\n        const x = mt3 * currentPoint[0] +\n          3 * mt2 * t * command.p1[0] +\n          3 * mt * t2 * command.p2[0] +\n          t3 * command.p3[0];\n\n        const y = mt3 * currentPoint[1] +\n          3 * mt2 * t * command.p1[1] +\n          3 * mt * t2 * command.p2[1] +\n          t3 * command.p3[1];\n\n        points.push([x, y]);\n      }\n\n      currentPoint = command.p3;\n      break;\n    }\n\n    case 'arc': {\n      // Flatten arc to line segments\n      // This is a simplified approximation\n      const segments = Math.max(8, Math.ceil(Math.hypot(\n        command.p[0] - currentPoint[0],\n        command.p[1] - currentPoint[1]\n      ) / tolerance));\n\n      for (let i = 1; i <= segments; i++) {\n        const t = i / segments;\n        const x = currentPoint[0] + t * (command.p[0] - currentPoint[0]);\n        const y = currentPoint[1] + t * (command.p[1] - currentPoint[1]);\n        points.push([x, y]);\n      }\n\n      currentPoint = command.p;\n      break;\n    }\n    }\n  }\n\n  return points;\n}\n\n/**\n * Converts a custom piece to a polygon by applying its transform and flattening its path.\n *\n * @param piece - The custom piece to convert\n * @returns An array of points representing the transformed polygon\n */\nexport function customPieceToPolygon(piece: CustomPiece): Vec2[] {\n  // First, flatten the path to get the base polygon\n  const basePolygon = flattenPath(piece.path);\n\n  if (basePolygon.length === 0) {\n    return [];\n  }\n\n  // Calculate the center of the bounding box (same as Paper.js path.position)\n  // This matches how the rendering code applies transforms in PuzzleRenderer\n  const bounds = polygonBounds(basePolygon);\n  const center: Vec2 = [\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n  ];\n\n  // Apply the transform to each point, using the bounding box center as the transform origin\n  const transformedPolygon = basePolygon.map((point) =>\n    applyTransformToPoint(point, center, piece.transform)\n  );\n\n  return transformedPolygon;\n}\n\n/**\n * Checks if a cell (polygon) overlaps with any custom pieces.\n *\n * @param cell - The cell polygon to check\n * @param customPieces - Array of custom pieces to check against\n * @returns Array of custom pieces that overlap with the cell\n */\nexport function checkCustomPieceOverlap(\n  cell: Vec2[],\n  customPieces: CustomPiece[]\n): CustomPiece[] {\n  const overlapping: CustomPiece[] = [];\n  const cellBounds = polygonBounds(cell);\n\n  for (const customPiece of customPieces) {\n    const customPolygon = customPieceToPolygon(customPiece);\n    const customBounds = polygonBounds(customPolygon);\n\n    // Fast rejection: check if bounding boxes overlap\n    if (!doAABBsIntersect(cellBounds, customBounds)) {\n      continue;\n    }\n\n    // Check if any vertex of the cell is inside the custom piece\n    let hasOverlap = false;\n    for (const point of cell) {\n      if (isPointInPolygon(point, customPolygon)) {\n        hasOverlap = true;\n        break;\n      }\n    }\n\n    // If no cell vertices are inside, check if any custom piece vertices are inside the cell\n    if (!hasOverlap) {\n      for (const point of customPolygon) {\n        if (isPointInPolygon(point, cell)) {\n          hasOverlap = true;\n          break;\n        }\n      }\n    }\n\n    if (hasOverlap) {\n      overlapping.push(customPiece);\n    }\n  }\n\n  return overlapping;\n}\n\n/**\n * Subtracts custom pieces from a cell polygon using polygon clipping.\n *\n * @param cell - The cell polygon to clip\n * @param customPieces - Array of custom pieces to subtract from the cell\n * @returns Array of resulting polygons after subtraction, or null if the cell is fully contained\n */\nexport function subtractCustomPieces(\n  cell: Vec2[],\n  customPieces: CustomPiece[]\n): Vec2[][] | null {\n  // Start with the original cell\n  let result: martinez.Polygon | martinez.MultiPolygon = [cell.map((p) => [p[0], p[1]])];\n\n  // Subtract each custom piece from the result\n  for (const customPiece of customPieces) {\n    const customPolygon = customPieceToPolygon(customPiece);\n    const customMartinez: martinez.Polygon = [customPolygon.map((p) => [p[0], p[1]])];\n\n    // Perform difference operation: result - customPiece\n    const clipped = martinez.diff(result, customMartinez);\n\n    if (!clipped || clipped.length === 0) {\n      // Cell is fully contained in custom pieces\n      return null;\n    }\n\n    result = clipped;\n  }\n\n  // Convert back to Vec2[][] format\n  if (Array.isArray(result) && result.length > 0) {\n    // Martinez returns a MultiPolygon format: [[[x,y], ...], [[x,y], ...], ...]\n    // where each inner array is a polygon with its outer ring first\n    const polygons: Vec2[][] = [];\n\n    for (const polygon of result) {\n      if (Array.isArray(polygon) && polygon.length > 0) {\n        // Each polygon has rings (first is outer, rest are holes)\n        // We only take the outer ring (polygon[0])\n        const outerRing = polygon[0];\n        if (Array.isArray(outerRing)) {\n          const vertices: Vec2[] = outerRing.map((p) => {\n            // p should be [number, number] but TypeScript needs help\n            if (Array.isArray(p) && p.length >= 2) {\n              return [p[0], p[1]] as Vec2;\n            }\n            // Fallback for unexpected format\n            return [0, 0] as Vec2;\n          });\n          polygons.push(vertices);\n        }\n      }\n    }\n\n    return polygons.length > 0 ? polygons : null;\n  }\n\n  return null;\n}\n\n/**\n * Creates a Piece from a custom piece definition.\n * This converts the custom piece into the internal half-edge topology.\n *\n * @param custom - The custom piece to convert\n * @param pieceId - The unique identifier for this piece\n * @param topology - The puzzle topology to add the piece to\n * @returns The created Piece\n */\nexport function createPieceFromCustom(\n  custom: CustomPiece,\n  pieceId: number,\n  topology: PuzzleTopology\n): Piece {\n  // Convert the custom piece to a polygon with transforms applied\n  const vertices = customPieceToPolygon(custom);\n\n  // Calculate the centroid of the transformed polygon\n  const centroid = vertices.reduce(\n    (acc, v) => [acc[0] + v[0], acc[1] + v[1]] as Vec2,\n    [0, 0] as Vec2\n  );\n  const site: Vec2 = [\n    centroid[0] / vertices.length,\n    centroid[1] / vertices.length,\n  ];\n\n  // Create the piece object\n  const piece: Piece = {\n    id: pieceId,\n    site,\n    halfEdge: -1, // Will be set by createHalfEdgeLoop\n    bounds: polygonBounds(vertices),\n    isCustomPiece: true, // Mark this as a custom piece for tab placement\n  };\n\n  // Create the half-edge loop for the piece's vertices\n  const newHalfEdges = createHalfEdgeLoop(vertices, pieceId, topology);\n  if (newHalfEdges.length > 0) {\n    piece.halfEdge = newHalfEdges[0].id;\n  }\n\n  return piece;\n}\n\n/**\n * Computes the bounding box for a custom piece.\n *\n * @param piece - The custom piece\n * @returns The bounding box as [xmin, ymin, xmax, ymax]\n */\nexport function computeCustomPieceBounds(piece: CustomPiece): readonly [number, number, number, number] {\n  const polygon = customPieceToPolygon(piece);\n\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let xmin = polygon[0][0];\n  let ymin = polygon[0][1];\n  let xmax = polygon[0][0];\n  let ymax = polygon[0][1];\n\n  for (let i = 1; i < polygon.length; i++) {\n    const [x, y] = polygon[i];\n    if (x < xmin) xmin = x;\n    if (x > xmax) xmax = x;\n    if (y < ymin) ymin = y;\n    if (y > ymax) ymax = y;\n  }\n\n  return [xmin, ymin, xmax, ymax];\n}\n\n/**\n * Computes the bounding box for a path (without transforms applied).\n *\n * @param path - The path commands\n * @returns The bounding box as [xmin, ymin, xmax, ymax]\n */\nexport function computePathBounds(path: PathCommand[]): readonly [number, number, number, number] {\n  const polygon = flattenPath(path);\n\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let xmin = polygon[0][0];\n  let ymin = polygon[0][1];\n  let xmax = polygon[0][0];\n  let ymax = polygon[0][1];\n\n  for (let i = 1; i < polygon.length; i++) {\n    const [x, y] = polygon[i];\n    if (x < xmin) xmin = x;\n    if (x > xmax) xmax = x;\n    if (y < ymin) ymin = y;\n    if (y > ymax) ymax = y;\n  }\n\n  return [xmin, ymin, xmax, ymax];\n}\n\n/**\n * Creates an initial transform for a new custom piece.\n * Centers the piece on the puzzle and scales it so its largest dimension\n * matches the target piece size.\n *\n * @param path - The path commands for the piece\n * @param canvasWidth - Width of the puzzle canvas\n * @param canvasHeight - Height of the puzzle canvas\n * @param targetPieceSize - Target size for the piece's largest dimension\n * @returns The initial transform\n */\nexport function createInitialTransform(\n  path: PathCommand[],\n  canvasWidth: number,\n  canvasHeight: number,\n  targetPieceSize: number\n): CustomPieceTransform {\n  // Calculate bounds of the raw path\n  const [xmin, ymin, xmax, ymax] = computePathBounds(path);\n  const width = xmax - xmin;\n  const height = ymax - ymin;\n\n  // Find the largest dimension\n  const maxDimension = Math.max(width, height);\n\n  // Calculate scale factor to match target piece size\n  // Handle edge case of zero or very small paths\n  const scaleFactor = maxDimension > 0 ? targetPieceSize / maxDimension : 1;\n\n  return {\n    position: [canvasWidth / 2, canvasHeight / 2],\n    rotation: 0,\n    scale: [scaleFactor, scaleFactor],\n  };\n}\n","import type { PathCommand, Vec2 } from '../geometry/types';\nimport { flattenPath } from '../geometry/customPieces';\n\n/**\n * Result of validating a custom piece path.\n */\nexport interface ValidationResult {\n  /** Whether the path is valid for use as a custom piece */\n  isValid: boolean;\n  /** Array of error messages describing validation failures */\n  errors: string[];\n  /** Coordinates of self-intersections, if any */\n  intersections?: Vec2[];\n}\n\n/**\n * Checks if a path is closed (first point equals last point).\n *\n * @param path - The path to check\n * @param tolerance - Maximum distance to consider points equal (default: 0.01)\n * @returns true if the path is closed, false otherwise\n */\nexport function isPathClosed(path: PathCommand[], tolerance = 0.01): boolean {\n  if (path.length < 2) {\n    return false;\n  }\n\n  // Find the first MoveTo command\n  let firstPoint: Vec2 | null = null;\n  for (const command of path) {\n    if (command.type === 'move') {\n      firstPoint = command.p;\n      break;\n    }\n  }\n\n  if (!firstPoint) {\n    return false;\n  }\n\n  // Find the last point in the path\n  let lastPoint: Vec2 | null = null;\n  for (let i = path.length - 1; i >= 0; i--) {\n    const command = path[i];\n    switch (command.type) {\n    case 'move':\n    case 'line':\n      lastPoint = command.p;\n      break;\n    case 'bezier':\n      lastPoint = command.p3;\n      break;\n    case 'arc':\n      lastPoint = command.p;\n      break;\n    }\n    if (lastPoint) {\n      break;\n    }\n  }\n\n  if (!lastPoint) {\n    return false;\n  }\n\n  // Check if first and last points are within tolerance\n  const dx = firstPoint[0] - lastPoint[0];\n  const dy = firstPoint[1] - lastPoint[1];\n  const distance = Math.sqrt(dx * dx + dy * dy);\n\n  return distance <= tolerance;\n}\n\n/**\n * Checks if two line segments intersect.\n *\n * @param p1 - Start of first segment\n * @param p2 - End of first segment\n * @param p3 - Start of second segment\n * @param p4 - End of second segment\n * @returns The intersection point if segments intersect, null otherwise\n */\nfunction segmentIntersection(\n  p1: Vec2,\n  p2: Vec2,\n  p3: Vec2,\n  p4: Vec2\n): Vec2 | null {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n  const [x3, y3] = p3;\n  const [x4, y4] = p4;\n\n  // Calculate denominators for intersection formula\n  const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n  // Lines are parallel if denominator is zero\n  if (Math.abs(denom) < 1e-10) {\n    return null;\n  }\n\n  // Calculate intersection parameters\n  const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n  const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n  // Check if intersection is within both segments\n  // We exclude the endpoints by using > 0 and < 1 instead of >= 0 and <= 1\n  // to avoid reporting adjacent segments as intersecting\n  if (t > 0 && t < 1 && u > 0 && u < 1) {\n    const x = x1 + t * (x2 - x1);\n    const y = y1 + t * (y2 - y1);\n    return [x, y];\n  }\n\n  return null;\n}\n\n/**\n * Checks if two points are within a given tolerance.\n *\n * @param p1 - First point\n * @param p2 - Second point\n * @param tolerance - Maximum distance to consider points equal\n * @returns true if points are within tolerance, false otherwise\n */\nfunction arePointsClose(p1: Vec2, p2: Vec2, tolerance: number): boolean {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n  return Math.sqrt(dx * dx + dy * dy) <= tolerance;\n}\n\n/**\n * Checks if two segments share an endpoint.\n *\n * @param p1 - Start of first segment\n * @param p2 - End of first segment\n * @param p3 - Start of second segment\n * @param p4 - End of second segment\n * @param tolerance - Maximum distance to consider points equal\n * @returns true if segments share an endpoint, false otherwise\n */\nfunction segmentsShareEndpoint(\n  p1: Vec2,\n  p2: Vec2,\n  p3: Vec2,\n  p4: Vec2,\n  tolerance: number\n): boolean {\n  return (\n    arePointsClose(p1, p3, tolerance) ||\n    arePointsClose(p1, p4, tolerance) ||\n    arePointsClose(p2, p3, tolerance) ||\n    arePointsClose(p2, p4, tolerance)\n  );\n}\n\n/**\n * Finds all self-intersections in a path.\n *\n * @param path - The path to check for self-intersections\n * @returns Array of intersection points\n */\nexport function findSelfIntersections(path: PathCommand[]): Vec2[] {\n  // Flatten the path to line segments\n  const points = flattenPath(path);\n\n  if (points.length < 4) {\n    // Need at least 4 points to have a self-intersection\n    return [];\n  }\n\n  const intersections: Vec2[] = [];\n  // Use a tolerance that's slightly larger than the closing tolerance\n  // to account for floating point precision in flattened paths\n  const endpointTolerance = 1.0;\n\n  // Check all pairs of non-adjacent segments\n  for (let i = 0; i < points.length - 1; i++) {\n    for (let j = i + 2; j < points.length - 1; j++) {\n      const p1 = points[i];\n      const p2 = points[i + 1];\n      const p3 = points[j];\n      const p4 = points[j + 1];\n\n      // Skip segments that share an endpoint (including closing segments)\n      if (segmentsShareEndpoint(p1, p2, p3, p4, endpointTolerance)) {\n        continue;\n      }\n\n      const intersection = segmentIntersection(p1, p2, p3, p4);\n      if (intersection) {\n        intersections.push(intersection);\n      }\n    }\n  }\n\n  return intersections;\n}\n\n/**\n * Validates a path for use as a custom piece.\n * Checks if the path is closed and has no self-intersections.\n *\n * @param path - The path to validate\n * @returns Validation result with errors and intersection points\n */\nexport function validateCustomPiece(path: PathCommand[]): ValidationResult {\n  const errors: string[] = [];\n  let intersections: Vec2[] | undefined;\n\n  // Check if path is closed\n  if (!isPathClosed(path)) {\n    errors.push('Path must be closed (first point must equal last point)');\n  }\n\n  // Check for self-intersections\n  const foundIntersections = findSelfIntersections(path);\n  if (foundIntersections.length > 0) {\n    errors.push(`Path has ${foundIntersections.length} self-intersection${foundIntersections.length > 1 ? 's' : ''}`);\n    intersections = foundIntersections;\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    intersections,\n  };\n}\n","/**\n * SVG path parsing utilities\n * Converts SVG path data to PathCommand[] format\n */\n\nimport type { PathCommand } from './types';\n\n/**\n * Result of parsing an SVG file\n */\nexport interface SVGParseResult {\n  /** The parsed path commands */\n  commands: PathCommand[];\n  /** Optional warning message for the user if something went wrong during parsing */\n  warning?: string;\n}\n\n/**\n * Parse an SVG file and extract path commands from the first path element\n *\n * @param svgContent - The SVG file content as a string\n * @returns SVGParseResult with commands and optional warning, or null if parsing fails\n */\nexport function parseSVGFile(svgContent: string): SVGParseResult {\n  try {\n    // Parse the SVG content as XML\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(svgContent, 'image/svg+xml');\n\n    // Check for parsing errors\n    const parserError = doc.querySelector('parsererror');\n    if (parserError) {\n      console.error('[SVGParser] XML parsing error:', parserError.textContent);\n      return {\n        commands: [],\n        warning: 'Failed to parse SVG',\n      };\n    }\n\n    // Find the first path element\n    const pathElement = doc.querySelector('path');\n    if (!pathElement) {\n      console.error('[SVGParser] No path element found in SVG');\n      return {\n        commands: [],\n        warning: 'Failed to parse SVG: no path element',\n      };\n    }\n\n    // Get the d attribute\n    const dAttr = pathElement.getAttribute('d');\n    if (!dAttr) {\n      console.error('[SVGParser] Path element has no d attribute');\n      return {\n        commands: [],\n        warning: 'Failed to parse SVG: Path element has no d attribute',\n      };\n    }\n\n    // Parse the path data\n    return parseSVGPath(dAttr);\n  } catch (error) {\n    console.error('[SVGParser] Error parsing SVG:', error);\n    return {\n      commands: [],\n      warning: 'Failed to parse SVG',\n    };\n  }\n}\n\n/**\n * Parse an SVG path d attribute into PathCommand[] format\n *\n * Supports: M/m (moveto), L/l (lineto), C/c (cubic bezier), Q/q (quadratic bezier)\n * Note: H/h, V/v, S/s, T/t, A/a are converted to their equivalent forms\n *\n * If the path contains multiple subpaths (multiple M commands), only the first\n * subpath is processed and a warning is returned.\n *\n * @param d - The SVG path d attribute value\n * @returns SVGParseResult with commands and optional warning\n */\nexport function parseSVGPath(d: string): SVGParseResult {\n  const commands: PathCommand[] = [];\n  let hasMultipleSubpaths = false;\n\n  // Tokenize the path data\n  // Insert spaces before command letters and handle negative numbers\n  const normalized = d\n    .replace(/([MmLlHhVvCcSsQqTtAaZz])/g, ' $1 ')\n    .replace(/(\\d)-/g, '$1 -')  // Add space before minus when it follows a digit (e.g., \"280-400\" -> \"280 -400\")\n    .replace(/,/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\n  const tokens = normalized.split(' ').filter((t) => t.length > 0);\n\n  let i = 0;\n  let currentX = 0;\n  let currentY = 0;\n  let startX = 0;\n  let startY = 0;\n  let lastControlX = 0;\n  let lastControlY = 0;\n  let lastCommand = '';\n  let isFirstMoveTo = true;\n\n  const parseNumber = (): number => {\n    const num = parseFloat(tokens[i]);\n    i++;\n    return num;\n  };\n\n  while (i < tokens.length) {\n    let command = tokens[i];\n\n    // Handle implicit commands (coordinates following a command)\n    if (!isNaN(parseFloat(command))) {\n      // Numbers without a command - repeat the last command\n      if (lastCommand === 'M') {\n        command = 'L'; // After M, implicit coords are L\n      } else if (lastCommand === 'm') {\n        command = 'l';\n      } else {\n        command = lastCommand;\n      }\n    } else {\n      i++; // Move past the command letter\n    }\n\n    const isRelative = command === command.toLowerCase();\n    const commandUpper = command.toUpperCase();\n\n    switch (commandUpper) {\n    case 'M': { // MoveTo\n      // Check if this is a second MoveTo command (compound path with multiple subpaths)\n      if (!isFirstMoveTo) {\n        hasMultipleSubpaths = true;\n        // Stop parsing - we only want the first subpath\n        i = tokens.length; // Skip to end\n        break;\n      }\n      isFirstMoveTo = false;\n\n      const x = parseNumber();\n      const y = parseNumber();\n\n      if (isRelative) {\n        currentX += x;\n        currentY += y;\n      } else {\n        currentX = x;\n        currentY = y;\n      }\n\n      startX = currentX;\n      startY = currentY;\n\n      commands.push({\n        type: 'move',\n        p: [currentX, currentY],\n      });\n\n      lastCommand = command;\n      break;\n    }\n\n    case 'L': { // LineTo\n      const x = parseNumber();\n      const y = parseNumber();\n\n      if (isRelative) {\n        currentX += x;\n        currentY += y;\n      } else {\n        currentX = x;\n        currentY = y;\n      }\n\n      commands.push({\n        type: 'line',\n        p: [currentX, currentY],\n      });\n\n      lastControlX = currentX;\n      lastControlY = currentY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'H': { // Horizontal line\n      const x = parseNumber();\n\n      if (isRelative) {\n        currentX += x;\n      } else {\n        currentX = x;\n      }\n\n      commands.push({\n        type: 'line',\n        p: [currentX, currentY],\n      });\n\n      lastControlX = currentX;\n      lastControlY = currentY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'V': { // Vertical line\n      const y = parseNumber();\n\n      if (isRelative) {\n        currentY += y;\n      } else {\n        currentY = y;\n      }\n\n      commands.push({\n        type: 'line',\n        p: [currentX, currentY],\n      });\n\n      lastControlX = currentX;\n      lastControlY = currentY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'C': { // Cubic Bezier\n      const x1 = parseNumber();\n      const y1 = parseNumber();\n      const x2 = parseNumber();\n      const y2 = parseNumber();\n      const x = parseNumber();\n      const y = parseNumber();\n\n      let cp1x = x1;\n      let cp1y = y1;\n      let cp2x = x2;\n      let cp2y = y2;\n      let endX = x;\n      let endY = y;\n\n      if (isRelative) {\n        cp1x += currentX;\n        cp1y += currentY;\n        cp2x += currentX;\n        cp2y += currentY;\n        endX += currentX;\n        endY += currentY;\n      }\n\n      commands.push({\n        type: 'bezier',\n        p1: [cp1x, cp1y],\n        p2: [cp2x, cp2y],\n        p3: [endX, endY],\n      });\n\n      lastControlX = cp2x;\n      lastControlY = cp2y;\n      currentX = endX;\n      currentY = endY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'S': { // Smooth cubic Bezier\n      const x2 = parseNumber();\n      const y2 = parseNumber();\n      const x = parseNumber();\n      const y = parseNumber();\n\n      // Reflect the last control point\n      const cp1x = 2 * currentX - lastControlX;\n      const cp1y = 2 * currentY - lastControlY;\n\n      let cp2x = x2;\n      let cp2y = y2;\n      let endX = x;\n      let endY = y;\n\n      if (isRelative) {\n        cp2x += currentX;\n        cp2y += currentY;\n        endX += currentX;\n        endY += currentY;\n      }\n\n      commands.push({\n        type: 'bezier',\n        p1: [cp1x, cp1y],\n        p2: [cp2x, cp2y],\n        p3: [endX, endY],\n      });\n\n      lastControlX = cp2x;\n      lastControlY = cp2y;\n      currentX = endX;\n      currentY = endY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'Q': { // Quadratic Bezier\n      const x1 = parseNumber();\n      const y1 = parseNumber();\n      const x = parseNumber();\n      const y = parseNumber();\n\n      let cpx = x1;\n      let cpy = y1;\n      let endX = x;\n      let endY = y;\n\n      if (isRelative) {\n        cpx += currentX;\n        cpy += currentY;\n        endX += currentX;\n        endY += currentY;\n      }\n\n      // Convert quadratic to cubic bezier\n      // Cubic control points are 2/3 of the way from endpoints to quadratic control\n      const cp1x = currentX + (2 / 3) * (cpx - currentX);\n      const cp1y = currentY + (2 / 3) * (cpy - currentY);\n      const cp2x = endX + (2 / 3) * (cpx - endX);\n      const cp2y = endY + (2 / 3) * (cpy - endY);\n\n      commands.push({\n        type: 'bezier',\n        p1: [cp1x, cp1y],\n        p2: [cp2x, cp2y],\n        p3: [endX, endY],\n      });\n\n      lastControlX = cpx;\n      lastControlY = cpy;\n      currentX = endX;\n      currentY = endY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'T': { // Smooth quadratic Bezier\n      const x = parseNumber();\n      const y = parseNumber();\n\n      // Reflect the last control point\n      const cpx = 2 * currentX - lastControlX;\n      const cpy = 2 * currentY - lastControlY;\n\n      let endX = x;\n      let endY = y;\n\n      if (isRelative) {\n        endX += currentX;\n        endY += currentY;\n      }\n\n      // Convert quadratic to cubic bezier\n      const cp1x = currentX + (2 / 3) * (cpx - currentX);\n      const cp1y = currentY + (2 / 3) * (cpy - currentY);\n      const cp2x = endX + (2 / 3) * (cpx - endX);\n      const cp2y = endY + (2 / 3) * (cpy - endY);\n\n      commands.push({\n        type: 'bezier',\n        p1: [cp1x, cp1y],\n        p2: [cp2x, cp2y],\n        p3: [endX, endY],\n      });\n\n      lastControlX = cpx;\n      lastControlY = cpy;\n      currentX = endX;\n      currentY = endY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'A': {\n      // Arc command - simplified conversion to cubic bezier\n      // This is a complex conversion, so we'll use a basic approximation\n      // For now, convert to straight line\n\n      // Parse arc parameters (7 values)\n      const _rx = parseNumber();\n      const _ry = parseNumber();\n      const _xAxisRotation = parseNumber();\n      const _largeArcFlag = parseNumber();\n      const _sweepFlag = parseNumber();\n      const x = parseNumber();\n      const y = parseNumber();\n\n      let endX = x;\n      let endY = y;\n\n      if (isRelative) {\n        endX += currentX;\n        endY += currentY;\n      }\n\n      // For now, just draw a straight line\n      // TODO: Implement proper arc-to-bezier conversion\n      commands.push({\n        type: 'line',\n        p: [endX, endY],\n      });\n\n      currentX = endX;\n      currentY = endY;\n      lastControlX = endX;\n      lastControlY = endY;\n      lastCommand = command;\n      break;\n    }\n\n    case 'Z': { // Close path\n      // Add a line back to the start if needed\n      if (currentX !== startX || currentY !== startY) {\n        commands.push({\n          type: 'line',\n          p: [startX, startY],\n        });\n        currentX = startX;\n        currentY = startY;\n      }\n      lastCommand = command;\n      break;\n    }\n\n    default:\n      // Unknown command - skip it\n      break;\n    }\n  }\n\n  const result: SVGParseResult = { commands };\n  if (hasMultipleSubpaths) {\n    result.warning = 'This SVG contains a compound path. Only the first subpath was imported.';\n  }\n\n  return result;\n}\n","/**\n * Dialog - Wraps a Web Awesome Dialog component to play nicely with Mithril\n * lifecycle. Any children of this component are rendered as dialog contents.\n */\nimport m from 'mithril';\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/dialog/dialog.js';\nimport WaDialog from '@awesome.me/webawesome/dist/components/dialog/dialog.js';\n//import { WaHideEvent } from '@awesome.me/webawesome';\n\nexport interface DialogAttrs extends m.Attributes {\n  /** Optional element ID */\n  id?: string;\n  /** Optional class name(s) for this virtual element, as a space-separated list. */\n  className?: string;\n  /** Optional CSS width string, e.g. 50vh */\n  width?: string;\n  /** Current state of the dialog (open/closed) */\n  open: boolean;\n  /** Title displayed in the dialog window */\n  title: string;\n  /** Optional key to force-remount inner content (reset content) */\n  contentKey?: string | number;\n  /** Optional callback invoked whenever the dialog state changes */\n  onStateChanged?: (open: boolean) => void;\n}\n\nexport const Dialog: m.ClosureComponent<DialogAttrs> = ({ attrs }) => {\n\n  // component state\n  const state = {\n    el: null as WaDialog | null,\n    currentAttrs: null as DialogAttrs | null,\n    lastNotifiedOpen: attrs.open,\n    cleanup: () => { /* noop */ },\n  };\n\n  // Guard to avoid redundant churn\n  const syncOpenProp = (want: boolean) => {\n    if (!state.el) return;\n    if (state.el.open !== want) state.el.open = want; // set the *property* (reflects to attr)\n  };\n\n  // listen for dialog closing event, if we need to prevent closing\n  // const handleHide = (e: WaHideEvent) => {\n  //   const source = e.detail?.source; // element that triggerd the close request\n  //   // calling e.preventDefault() here would block the close\n  // };\n\n  const notify = (open: boolean) => {\n    if (state.lastNotifiedOpen !== open) {\n      state.lastNotifiedOpen = open;\n      state.currentAttrs?.onStateChanged?.(open);\n    }\n  };\n\n  // listen for dialog opening event\n  const handleAfterShow = () => notify(true);\n\n  // listen for dialog closed event\n  const handleAfterHide = () => notify(false);\n\n  return {\n\n    oncreate: ({ attrs, dom }) => {\n      state.el = dom as WaDialog;\n      state.currentAttrs = attrs;\n      syncOpenProp(attrs.open);\n\n      // attach listeners for WA Dialog\n      //state.el.addEventListener('wa-hide', handleHide);\n      state.el.addEventListener('wa-after-show', handleAfterShow);\n      state.el.addEventListener('wa-after-hide', handleAfterHide);\n\n      state.cleanup = () => {\n        //state.el?.removeEventListener('wa-hide', handleHide);\n        state.el?.removeEventListener('wa-after-show', handleAfterShow);\n        state.el?.removeEventListener('wa-after-hide', handleAfterHide);\n        state.el = null;\n        state.currentAttrs = null;\n      };\n    },\n\n    onupdate: ({ attrs }) => {\n      state.currentAttrs = attrs;\n      syncOpenProp(attrs.open);\n    },\n\n    onremove: () => {\n      state.cleanup();\n    },\n\n    view: ({ attrs, children }) => m('wa-dialog', {\n      id: attrs.id as unknown, // pass through element ID if present\n      label: attrs.title,\n      class: attrs.class ?? attrs.className, // pass through class names if present\n      style: { '--width': attrs.width }, // set width if requested\n      open: attrs.open,\n    }, attrs.contentKey != null ? m('div', { key: attrs.contentKey }, children) : children),\n  };\n};\n\nexport default Dialog;","/**\n * WhimsyEditor - Modal component for creating and editing whimsies (custom puzzle pieces)\n */\n\nimport m from 'mithril';\nimport type { PathCommand, CustomPiece } from '../geometry/types';\nimport { PathEditor } from './PathEditor';\nimport { validateCustomPiece, isPathClosed, type ValidationResult } from '../utils/pathValidation';\nimport { parseSVGFile } from '../geometry/svgUtils';\nimport { fitPathToCanvas } from '../geometry/utils';\nimport Dialog from './Dialog';\nimport StringInputControl from './inputs/StringInputControl';\nimport type MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\n\n// include our CSS\nimport './WhimsyEditor.css';\n\n/* ========================================================= *\\\n *  Component Interface                                      *\n\\* ========================================================= */\n\n/**\n * Attributes for the WhimsyEditor component.\n */\nexport interface WhimsyEditorAttrs extends m.Attributes {\n  /**\n   * Whether the editor dialog is currently open.\n   */\n  open: boolean;\n\n  /**\n   * Optional existing custom piece to edit.\n   * If undefined, creates a new custom piece.\n   */\n  piece?: CustomPiece;\n\n  /**\n   * Width of the PathEditor canvas in pixels.\n   * Default: 600\n   */\n  editorWidth?: number;\n\n  /**\n   * Height of the PathEditor canvas in pixels.\n   * Default: 600\n   */\n  editorHeight?: number;\n\n  /**\n   * Callback invoked when the user saves a custom piece.\n   * For new pieces, the id and created timestamp should be generated by the caller.\n   *\n   * @param piece - The saved custom piece (may be partial for caller to complete)\n   */\n  onSave: (path: PathCommand[], name?: string) => void;\n\n  /**\n   * Callback invoked when the user cancels editing.\n   */\n  onCancel: () => void;\n}\n\n/* ========================================================= *\\\n *  Component State                                          *\n\\* ========================================================= */\n\ninterface WhimsyEditorState {\n  /** Initial path passed to PathEditor (only set on dialog open) */\n  initialPath: PathCommand[];\n  /** Current path being edited (for validation) */\n  path: PathCommand[];\n  /** Current piece name */\n  name: string;\n  /** Current validation result */\n  validation: ValidationResult;\n  /** Whether SVG import dialog is open */\n  importDialogOpen: boolean;\n  /** Track previous open state from last view render */\n  prevOpen: boolean;\n  /** ID of the piece from last view render */\n  prevPieceId: string | null;\n  /** Unique key for the current editing session - forces content remount when changed */\n  contentKey: string;\n}\n\n/* ========================================================= *\\\n *  Component Implementation                                 *\n\\* ========================================================= */\n\n/**\n * WhimsyEditor - A modal dialog for creating/editing custom pieces\n */\nexport const WhimsyEditor: m.ClosureComponent<WhimsyEditorAttrs> = () => {\n  const state: WhimsyEditorState = {\n    initialPath: [],\n    path: [],\n    name: '',\n    validation: { isValid: false, errors: [] },\n    importDialogOpen: false,\n    prevOpen: false,\n    prevPieceId: null,\n    contentKey: 'initial',\n  };\n\n  // Reference to the file input element\n  let fileInputRef: HTMLInputElement | null = null;\n\n  /**\n   * Initialize state from attrs when dialog opens or piece changes\n   */\n  const initializeState = (attrs: WhimsyEditorAttrs) => {\n    if (attrs.piece) {\n      // Editing existing piece - use piece ID as content key\n      state.contentKey = attrs.piece.id;\n      state.initialPath = attrs.piece.path;\n      state.path = attrs.piece.path;\n      state.name = attrs.piece.name ?? '';\n      // Validate existing piece\n      state.validation = validateCustomPiece(state.path);\n    } else {\n      // Creating new piece - use timestamp as content key to force fresh remount\n      state.contentKey = `new-${Date.now()}`;\n      state.initialPath = [];\n      state.path = [];\n      state.name = '';\n      // Don't show validation errors for empty canvas\n      state.validation = { isValid: false, errors: [] };\n    }\n  };\n\n  /**\n   * Handle path changes from PathEditor\n   */\n  const handlePathChanged = (newPath: PathCommand[]) => {\n    state.path = newPath;\n\n    // Only validate if there's a path\n    if (newPath.length === 0) {\n      state.validation = { isValid: false, errors: [] };\n    } else {\n      // Always run validation to check if path is closed\n      const validationResult = validateCustomPiece(newPath);\n      state.validation = validationResult;\n    }\n\n    // Don't call m.redraw() here - it triggers a global redraw that can\n    // interfere with PuzzleRenderer's Paper.js state. PathEditor already\n    // handles its own redraws, and the validation status will update\n    // when the user completes the path.\n  };\n\n  /**\n   * Handle name input changes\n   */\n  const handleNameChanged = (newName: string) => {\n    state.name = newName;\n  };\n\n  /**\n   * Handle save button click\n   */\n  const handleSave = (attrs: WhimsyEditorAttrs) => {\n    if (!state.validation.isValid) {\n      return;\n    }\n    // Call the onSave callback with path and name\n    // The caller is responsible for generating id, transform, and timestamp\n    attrs.onSave(state.path, state.name.length > 0 ? state.name : undefined);\n  };\n\n  /**\n   * Handle SVG file upload\n   */\n  const handleSVGUpload = (files: FileList | null, editorWidth: number, editorHeight: number) => {\n    if (!files || files.length === 0) {\n      return;\n    }\n\n    const file = files[0];\n    if (!file.name.endsWith('.svg')) {\n      console.error('Please select an SVG file');\n      return;\n    }\n\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      const svgContent = e.target?.result as string;\n      if (svgContent) {\n        const parseResult = parseSVGFile(svgContent);\n\n        if (parseResult.warning) {\n          console.warn('SVG import warning:', parseResult.warning);\n        }\n\n        if (parseResult.commands.length > 0) {\n          // Fit the path to the canvas size\n          const fittedPath = fitPathToCanvas(\n            parseResult.commands,\n            editorWidth,\n            editorHeight\n          );\n\n          // Update both initialPath (to reload PathEditor) and path (for validation)\n          state.initialPath = fittedPath;\n          handlePathChanged(fittedPath);\n\n          // If the file name doesn't have a name yet, use the file name\n          if (!state.name) {\n            const nameWithoutExtension = file.name.replace(/\\.svg$/i, '');\n            handleNameChanged(nameWithoutExtension);\n          }\n\n          // Trigger redraw to show imported path\n          // This is safe here because it's a user-initiated action (file upload)\n          m.redraw();\n        } else {\n          console.error('Failed to parse SVG file');\n        }\n      }\n    };\n    reader.readAsText(file);\n  };\n\n  return {\n    view: ({ attrs }) => {\n      // Detect if dialog just opened or piece changed\n      const currentPieceId = attrs.piece?.id ?? null;\n      const dialogJustOpened = attrs.open && !state.prevOpen;\n      const pieceChanged = currentPieceId !== state.prevPieceId;\n\n      if (attrs.open && (dialogJustOpened || pieceChanged)) {\n        // Dialog opened or piece changed - reinitialize state immediately before rendering\n        initializeState(attrs);\n      }\n\n      // Update tracked state for next render\n      state.prevOpen = attrs.open;\n      state.prevPieceId = currentPieceId;\n\n      const editorWidth = attrs.editorWidth ?? 600;\n      const editorHeight = attrs.editorHeight ?? 600;\n\n      return m(Dialog, {\n        open: attrs.open,\n        title: attrs.piece ? 'Edit Whimsy' : 'Create Whimsy',\n        className: 'custom-piece-editor',\n        width: '50vw',\n        contentKey: state.contentKey,\n        onStateChanged: (open) => {\n          if (!open) {\n            attrs.onCancel();\n          }\n        },\n      }, [\n        // Dialog content\n        m('.editor-content', [\n          // Name input\n          m(StringInputControl, {\n            config: {\n              type: 'string',\n              name: 'name',\n              label: 'Piece Name (optional)',\n              optional: true,\n            },\n            value: state.name,\n            onChange: (newName: string | undefined) => {\n              state.name = newName ?? '';\n              m.redraw();\n            },\n\n          }),\n          // m('wa-input.name-field', {\n          //   label: 'Piece Name (optional)',\n          //   type: 'text',\n          //   size: 'small',\n          //   value: state.name,\n          //   placeholder: 'Enter a name for this piece',\n          //   oninput: (e: Event & MithrilViewEvent) => {\n          //     e.redraw = false;\n          //     const input = e.target as WaInput;\n          //     state.name = input.value ?? '';\n          //   },\n          // }),\n\n          // Validation status\n          // Show valid message only when path is closed and valid\n          // Show error messages whenever there's a path with validation errors\n          state.path.length > 0 && (\n            state.validation.isValid\n              ? (isPathClosed(state.path) && m('.validation-status', [\n                m('.valid', [\n                  m('wa-icon', {\n                    library: 'material',\n                    name: 'check_circle',\n                    style: 'color: green;',\n                  }),\n                  m('span', 'Valid piece'),\n                ]),\n              ]))\n              : (state.validation.errors.length > 0 && m('.validation-status', [\n                m('.invalid', [\n                  m('wa-icon', {\n                    library: 'material',\n                    name: 'error',\n                    style: 'color: red;',\n                  }),\n                  m('span', state.validation.errors.join(', ')),\n                ]),\n              ]))\n          ),\n\n          // PathEditor\n          m('.editor-canvas', [\n            m(PathEditor, {\n              initialPath: state.initialPath,\n              onPathChanged: handlePathChanged,\n              width: editorWidth,\n              height: editorHeight,\n              strokeColor: state.validation.isValid ? '#2196F3' : '#f44336',\n            }),\n          ]),\n\n          // SVG Import button\n          m('.import-controls', [\n            m('input', {\n              type: 'file',\n              accept: '.svg',\n              style: 'display: none;',\n              oncreate: (vnode: m.VnodeDOM) => {\n                fileInputRef = vnode.dom as HTMLInputElement;\n              },\n              onchange: (e: Event & MithrilViewEvent) => {\n                e.redraw = false;\n                const input = e.target as HTMLInputElement;\n                handleSVGUpload(input.files, editorWidth, editorHeight);\n                // Reset the input so the same file can be selected again\n                input.value = '';\n              },\n            }),\n            m('wa-button', {\n              variant: 'default',\n              size: 'small',\n              onclick: (e: Event & MithrilViewEvent) => {\n                e.redraw = false;\n                fileInputRef?.click();\n              },\n            }, 'Import SVG'),\n          ]),\n        ]),\n\n        // Dialog footer with action buttons\n        m('div', {\n          slot: 'footer',\n          style: 'display: flex; gap: 8px; justify-content: flex-end;',\n        }, [\n          m('wa-button', {\n            variant: 'default',\n            onclick: (e: Event & MithrilViewEvent) => {\n              e.redraw = false;\n              attrs.onCancel();\n            },\n          }, 'Cancel'),\n          m('wa-button', {\n            variant: 'primary',\n            disabled: !state.validation.isValid,\n            onclick: (e: Event & MithrilViewEvent) => {\n              e.redraw = false;\n              handleSave(attrs);\n            },\n          }, 'Save'),\n        ]),\n      ]);\n    },\n  };\n};\n\nexport default WhimsyEditor;\n","/**\n * Thumbnail generation utilities for custom pieces\n */\n\nimport type { PathCommand } from '../geometry/types';\n\n/**\n * Generates a thumbnail image for a custom piece path.\n *\n * @param path - The path commands defining the custom piece shape\n * @param width - Width of the thumbnail in pixels\n * @param height - Height of the thumbnail in pixels\n * @param color - Color for the outline (CSS color string)\n * @param padding - Padding around the shape in pixels (default: 10)\n * @returns Data URL of the thumbnail image\n */\nexport function generateCustomPieceThumbnail(\n  path: PathCommand[],\n  width: number,\n  height: number,\n  color: string,\n  padding: number = 10\n): string {\n  // Create off-screen canvas\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx || path.length === 0) {\n    return '';\n  }\n\n  // Clear canvas\n  ctx.clearRect(0, 0, width, height);\n\n  // Calculate bounding box of the path\n  const bounds = calculatePathBounds(path);\n  if (!bounds) {\n    return '';\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  const pathWidth = maxX - minX;\n  const pathHeight = maxY - minY;\n\n  // Calculate scale to fit path within thumbnail with padding\n  const availableWidth = width - (2 * padding);\n  const availableHeight = height - (2 * padding);\n  const scale = Math.min(\n    availableWidth / pathWidth,\n    availableHeight / pathHeight\n  );\n\n  // Calculate offset to center the path\n  const scaledWidth = pathWidth * scale;\n  const scaledHeight = pathHeight * scale;\n  const offsetX = padding + (availableWidth - scaledWidth) / 2 - (minX * scale);\n  const offsetY = padding + (availableHeight - scaledHeight) / 2 - (minY * scale);\n\n  // Transform function to map path coordinates to thumbnail coordinates\n  const transform = (x: number, y: number): [number, number] => {\n    return [\n      x * scale + offsetX,\n      y * scale + offsetY,\n    ];\n  };\n\n  // Draw the path\n  ctx.beginPath();\n\n  for (const cmd of path) {\n    switch (cmd.type) {\n    case 'move': {\n      const [x, y] = transform(cmd.p[0], cmd.p[1]);\n      ctx.moveTo(x, y);\n      break;\n    }\n    case 'line': {\n      const [x, y] = transform(cmd.p[0], cmd.p[1]);\n      ctx.lineTo(x, y);\n      break;\n    }\n    case 'bezier': {\n      const [cp1x, cp1y] = transform(cmd.p1[0], cmd.p1[1]);\n      const [cp2x, cp2y] = transform(cmd.p2[0], cmd.p2[1]);\n      const [x, y] = transform(cmd.p3[0], cmd.p3[1]);\n      ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n      break;\n    }\n    case 'arc': {\n      // For arcs, we'll use a simplified approach and just draw a line\n      // A full implementation would calculate the ellipse center and angles\n      const [x, y] = transform(cmd.p[0], cmd.p[1]);\n      ctx.lineTo(x, y);\n      break;\n    }\n    }\n  }\n\n  // Style the path - outline only, no fill\n  ctx.strokeStyle = color;\n  ctx.lineWidth = 2;\n  ctx.stroke();\n\n  // Convert to data URL\n  return canvas.toDataURL('image/png');\n}\n\n/**\n * Calculates the bounding box of a path.\n *\n * @param path - The path commands\n * @returns Bounding box as [minX, minY, maxX, maxY] or null if path is empty\n */\nfunction calculatePathBounds(path: PathCommand[]): [number, number, number, number] | null {\n  if (path.length === 0) {\n    return null;\n  }\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  const updateBounds = (x: number, y: number): void => {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  };\n\n  for (const cmd of path) {\n    switch (cmd.type) {\n    case 'move':\n    case 'line':\n    case 'arc':\n      updateBounds(cmd.p[0], cmd.p[1]);\n      break;\n    case 'bezier':\n      updateBounds(cmd.p1[0], cmd.p1[1]);\n      updateBounds(cmd.p2[0], cmd.p2[1]);\n      updateBounds(cmd.p3[0], cmd.p3[1]);\n      break;\n    }\n  }\n\n  if (minX === Infinity) {\n    return null;\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n","/**\n * CustomPieceTile - Individual tile component for displaying a custom piece in the manager\n */\n\nimport m from 'mithril';\nimport type { CustomPiece } from '../geometry/types';\nimport type MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\n\n/* ========================================================= *\\\n *  Component Interface                                      *\n\\* ========================================================= */\n\n/**\n * Attributes for the CustomPieceTile component.\n */\nexport interface CustomPieceTileAttrs extends m.Attributes {\n  /** The custom piece to display. */\n  piece: CustomPiece;\n\n  /** Whether this tile is currently selected. */\n  isSelected: boolean;\n\n  /** Data URL of the thumbnail image for this piece. */\n  thumbnail: string;\n\n  /** Called when the tile is clicked. Does not trigger a Mithril redraw. */\n  onClick: () => void;\n\n  /** Called when the tile is double-clicked. Does not trigger a Mithril redraw. */\n  onDoubleClick: () => void;\n}\n\n/* ========================================================= *\\\n *  Component Implementation                                 *\n\\* ========================================================= */\n\n/**\n * CustomPieceTile component for displaying an individual custom piece.\n */\nexport const CustomPieceTile: m.Component<CustomPieceTileAttrs> = {\n  view: ({ attrs }) => {\n    return m('.custom-piece-tile', {\n      key: attrs.piece.id,\n      class: attrs.isSelected ? 'selected' : '',\n      onclick: (e: Event & MithrilViewEvent) => {\n        e.redraw = false;\n        attrs.onClick();\n      },\n      ondblclick: (e: Event & MithrilViewEvent) => {\n        e.redraw = false;\n        attrs.onDoubleClick();\n      },\n    }, [\n      // Thumbnail\n      m('.custom-piece-tile-thumbnail',\n        attrs.thumbnail\n          ? m('img', { src: attrs.thumbnail, alt: attrs.piece.name ?? 'Custom piece' })\n          : m('.custom-piece-tile-placeholder', m('wa-icon', { name: 'puzzle-piece' }))\n      ),\n\n      // Name\n      m('.custom-piece-tile-name', attrs.piece.name ?? 'Unnamed'),\n\n      // Selection indicator\n      attrs.isSelected\n        ? m('.custom-piece-tile-selected-indicator', m('wa-icon', { name: 'check-circle' }))\n        : null,\n    ]);\n  },\n};\n\nexport default CustomPieceTile;\n","import m from 'mithril';\nimport { Dialog } from './Dialog';\nimport type MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\nexport interface ConfirmOptions {\n  /** Optional ID applied to element */\n  id?: string;\n  /** Title of dialog */\n  title: string;\n  /** Body of confirmation dialog. Default: \"Are you sure?\" */\n  body?: string | m.Children;\n  /** Optional label for confirm button */\n  confirmLabel?: string;\n  /** Optional label for cancel button */\n  cancelLabel?: string;\n  /** Optional width of dialog, e.g. 50vw */\n  width?: string;\n}\n\n\nexport function confirm(opts: ConfirmOptions): Promise<boolean> {\n  // scratch mount point\n  const host = document.createElement('div');\n  document.body.appendChild(host);\n\n  let resolved = false;\n  const resolveOnce = (v: boolean) => {\n    if (resolved) return;\n    resolved = true;\n    cleanup();\n    resolver(v);\n  };\n\n  const cleanup = () => {\n    try { m.mount(host, null); } catch(err) { console.warn('confirm(): unable to mount Mithril component: ', err); }\n    host.remove();\n  };\n\n  let resolver!: (v: boolean) => void;\n  const p = new Promise<boolean>((res) => { resolver = res; });\n\n  // Singleton-ish shell per call\n  const Shell: m.ClosureComponent = () => {\n    const state = {\n      open: true,                          // show immediately\n      contentKey: Math.random(),           // ensure fresh mount\n    };\n\n    const close = (v: boolean) => {\n      // flip open; wait for after-hide before resolving to avoid animation pop\n      state.open = false;\n      m.redraw();\n      pendingResolve = v;\n    };\n\n    let pendingResolve: boolean | null = null;\n\n    return {\n      view() {\n        return m(Dialog, {\n          id: opts.id,\n          title: opts.title,\n          width: opts.width,\n          open: state.open,\n          contentKey: state.contentKey,\n          onStateChanged: (open) => {\n            // When WA finishes closing (wa-after-hide), resolve exactly once\n            if (!open && pendingResolve !== null) resolveOnce(pendingResolve);\n            // If the user ESC/overlay-closed without us calling close(), treat as cancel\n            if (!open && pendingResolve === null && resolved === false) resolveOnce(false);\n          },\n        }, [\n          m('.confirm-body', opts.body ?? 'Are you sure?'),\n\n          m('.confirm-actions', { slot: 'footer' }, [\n            m('wa-button.btn-cancel', {\n              variant: 'neutral',\n              size: 'small',\n              'data-dialog': 'close',   // WA will close; well see onStateChanged(false)\n              onclick: (e: MouseEvent & MithrilViewEvent) => {\n                e.redraw = false;\n                close(false);\n              },\n            }, opts.cancelLabel ?? 'Cancel'),\n\n            m('wa-button.btn-confirm', {\n              variant: 'brand',\n              size: 'small',\n              'data-dialog': 'close',\n              onclick: (e: MouseEvent & MithrilViewEvent) => {\n                e.redraw = false;\n                close(true);\n              },\n            }, opts.confirmLabel ?? 'OK'),\n          ]),\n        ]);\n      },\n    };\n  };\n\n  m.mount(host, Shell);\n  return p;\n}\n","/**\n * WhimsyManager - Component for managing custom puzzle pieces (whimsies)\n */\n\nimport m from 'mithril';\nimport type { CustomPiece } from '../geometry/types';\nimport { generateCustomPieceThumbnail } from '../utils/thumbnails';\nimport type MithrilViewEvent from '../utils/MithrilViewEvent';\nimport CustomPieceTile from './CustomPieceTile';\nimport { confirm } from './Confirm';\n\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\nimport '@awesome.me/webawesome/dist/components/tooltip/tooltip.js';\n\n// Include our CSS\nimport './WhimsyManager.css';\n\n/* ========================================================= *\\\n *  Component Interface                                      *\n\\* ========================================================= */\n\n/**\n * Attributes for the WhimsyManager component.\n */\nexport interface WhimsyManagerAttrs extends m.Attributes {\n  /**\n   * Array of custom pieces to display.\n   */\n  pieces: CustomPiece[];\n\n  /**\n   * ID of the currently selected piece (if any).\n   */\n  selectedPieceId?: string | null;\n\n  /**\n   * Color to use for rendering piece thumbnails (CSS color string).\n   */\n  pieceColor: string;\n\n  /**\n   * Called when the user clicks the \"Add\" button to create a new custom piece.\n   */\n  onAdd: () => void;\n\n  /**\n   * Called when the user selects a custom piece tile.\n   * @param id - ID of the selected piece, or null to deselect\n   */\n  onSelect: (id: string | null) => void;\n\n  /**\n   * Called when the user clicks the \"Edit\" button or double-clicks a tile.\n   * @param id - ID of the piece to edit\n   */\n  onEdit: (id: string) => void;\n\n  /**\n   * Called when the user clicks the \"Duplicate\" button.\n   * @param id - ID of the piece to duplicate\n   */\n  onDuplicate: (id: string) => void;\n\n  /**\n   * Called when the user clicks the \"Delete\" button.\n   * @param id - ID of the piece to delete\n   */\n  onDelete: (id: string) => void;\n\n  /**\n   * Called when the user clicks the \"Position\" button.\n   * @param id - ID of the piece to position on the canvas\n   */\n  onPosition: (id: string) => void;\n}\n\n/* ========================================================= *\\\n *  Component Implementation                                 *\n\\* ========================================================= */\n\n/**\n * WhimsyManager component for managing custom pieces.\n */\nexport const WhimsyManager: m.ClosureComponent<WhimsyManagerAttrs> = () => {\n  // Cache thumbnails to avoid regenerating on every render\n  const thumbnailCache = new Map<string, string>();\n\n  /**\n   * Gets or generates a thumbnail for a custom piece.\n   */\n  const getThumbnail = (piece: CustomPiece, color: string): string => {\n    // Use piece ID + timestamp + color as cache key\n    // Use modified timestamp if available (for edited pieces), otherwise use created\n    const timestamp = piece.modified ?? piece.created;\n    const cacheKey = `${piece.id}-${timestamp}-${color}`;\n\n    if (!thumbnailCache.has(cacheKey)) {\n      const thumbnail = generateCustomPieceThumbnail(piece.path, 100, 100, color);\n      thumbnailCache.set(cacheKey, thumbnail);\n    }\n\n    return thumbnailCache.get(cacheKey) ?? '';\n  };\n\n\n  return {\n    view: ({ attrs }) => {\n      const hasSelection = attrs.selectedPieceId !== null && attrs.selectedPieceId !== undefined;\n      const selectedPiece = hasSelection\n        ? attrs.pieces.find((p) => p.id === attrs.selectedPieceId)\n        : null;\n\n      return m('.whimsy-manager', [\n        // Header with Add button\n        m('.whimsy-manager-header', [\n          m('h3', 'Whimsy Pieces'),\n          m('wa-button', {\n            variant: 'primary',\n            size: 'small',\n            onclick: (e: Event & MithrilViewEvent) => {\n              e.redraw = false;\n              attrs.onAdd();\n            },\n          }, [\n            m('wa-icon', { name: 'plus', slot: 'prefix' }),\n            'Add',\n          ]),\n        ]),\n\n        // Grid of custom piece tiles\n        m('.whimsy-grid',\n          attrs.pieces.length === 0\n            ? m('.whimsy-empty-state', [\n              m('wa-icon', { name: 'puzzle-piece', style: 'font-size: 48px; opacity: 0.3;' }),\n              m('p', 'No whimsy pieces yet'),\n              m('p.hint', 'Click \"Add\" to create one'),\n            ])\n            : attrs.pieces.map((piece) => {\n              const isSelected = piece.id === attrs.selectedPieceId;\n              const thumbnail = getThumbnail(piece, attrs.pieceColor);\n\n              return m(CustomPieceTile, {\n                key: piece.id,\n                piece,\n                isSelected,\n                thumbnail,\n                onClick: () => {\n                  // Toggle selection\n                  if (isSelected) {\n                    attrs.onSelect(null);\n                  } else {\n                    attrs.onSelect(piece.id);\n                  }\n                },\n                onDoubleClick: () => {\n                  attrs.onEdit(piece.id);\n                },\n              });\n            })\n        ),\n\n        // Action buttons\n        m('.whimsy-actions', [\n          m('wa-button', {\n            size: 'small',\n            disabled: !hasSelection,\n            onclick: (e: Event & MithrilViewEvent) => {\n              e.redraw = false;\n              if (selectedPiece) {\n                attrs.onEdit(selectedPiece.id);\n              }\n            },\n          }, [\n            m('wa-icon', { name: 'pencil', slot: 'prefix' }),\n            'Edit',\n          ]),\n\n          m('wa-button', {\n            size: 'small',\n            disabled: !hasSelection,\n            onclick: (e: Event & MithrilViewEvent) => {\n              e.redraw = false;\n              if (selectedPiece) {\n                attrs.onDuplicate(selectedPiece.id);\n              }\n            },\n          }, [\n            m('wa-icon', { name: 'copy', slot: 'prefix' }),\n            'Duplicate',\n          ]),\n\n          m('wa-button', {\n            size: 'small',\n            variant: 'danger',\n            disabled: !hasSelection,\n            onclick: async (e: Event & MithrilViewEvent) => {\n              e.redraw = false;\n              if (selectedPiece) {\n                const ok = await confirm({\n                  title: 'Delete piece?',\n                  body: `Are you sure you want to delete ${selectedPiece.name ?? 'this piece'}?`,\n                  confirmLabel: 'Delete',\n                });\n                if (ok) {\n                  attrs.onDelete(selectedPiece.id);\n                }\n              }\n            },\n          }, [\n            m('wa-icon', { name: 'trash', slot: 'start' }),\n            'Delete',\n          ]),\n\n          m('wa-button', {\n            size: 'small',\n            disabled: !hasSelection,\n            onclick: (e: Event & MithrilViewEvent) => {\n              e.redraw = false;\n              if (selectedPiece) {\n                attrs.onPosition(selectedPiece.id);\n              }\n            },\n          }, [\n            m('wa-icon', { name: 'arrows-up-down-left-right', slot: 'prefix' }),\n            'Position',\n          ]),\n        ]),\n      ]);\n    },\n  };\n};\n\nexport default WhimsyManager;\n","\"use strict\";\n\nfunction tinyNDArrayOfInteger (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        dimension;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    return {\n        stride: stride,\n        data: new Uint32Array(totalLength)\n    };\n}\n\nfunction tinyNDArrayOfArray (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        data = [],\n        dimension, index;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    for (index = 0; index < totalLength; index++) {\n        data.push([]);\n    }\n\n    return {\n        stride: stride,\n        data: data\n    };\n}\n\nmodule.exports = {\n    integer: tinyNDArrayOfInteger,\n    array: tinyNDArrayOfArray\n};","\"use strict\";\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n","module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n","\"use strict\";\n\nvar moore = require('moore');\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    // filter out neighbours who are too far from the center cell\n    // the impact of this, performance wise, is surprisingly small, even in 3d and higher dimensions\n    neighbourhood = neighbourhood.filter(function (n) {\n        var dist = 0;\n\n        for (var d = 0; d < dimensionNumber; d++) {\n            dist += Math.pow(Math.max(0, Math.abs(n[d]) - 1), 2);\n        }\n\n        return dist < dimensionNumber; // cellSize = Math.sqrt(this.dimension)\n    });\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0,\n            dimension;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n}\n\nvar neighbourhoodCache = {};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhoodMemoized (dimensionNumber) {\n    if (!neighbourhoodCache[dimensionNumber]) {\n        neighbourhoodCache[dimensionNumber] = getNeighbourhood(dimensionNumber);\n    }\n\n    return neighbourhoodCache[dimensionNumber];\n}\n\nmodule.exports = getNeighbourhoodMemoized;","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').integer,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nfunction squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n}\n\n/**\n * FixedDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction FixedDensityPDS (options, rng) {\n    if (typeof options.distanceFunction === 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.squaredMinDistance = this.minDistance * this.minDistance;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.minDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints\n}\n\nFixedDensityPDS.prototype.shape = null;\nFixedDensityPDS.prototype.dimension = null;\nFixedDensityPDS.prototype.minDistance = null;\nFixedDensityPDS.prototype.maxDistance = null;\nFixedDensityPDS.prototype.minDistancePlusEpsilon = null;\nFixedDensityPDS.prototype.squaredMinDistance = null;\nFixedDensityPDS.prototype.deltaDistance = null;\nFixedDensityPDS.prototype.cellSize = null;\nFixedDensityPDS.prototype.maxTries = null;\nFixedDensityPDS.prototype.rng = null;\nFixedDensityPDS.prototype.neighbourhood = null;\n\nFixedDensityPDS.prototype.currentPoint = null;\nFixedDensityPDS.prototype.processList = null;\nFixedDensityPDS.prototype.samplePoints = null;\nFixedDensityPDS.prototype.gridShape = null;\nFixedDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nFixedDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nFixedDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nFixedDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nFixedDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nFixedDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will always throw an error.\n */\nFixedDensityPDS.prototype.getAllPointsWithDistance = function () {\n    throw new Error('PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation');\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nFixedDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = FixedDensityPDS;\n","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').array,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Euclidean distance\n */\nfunction euclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return Math.sqrt(result);\n}\n\n/**\n * VariableDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function} options.distanceFunction Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {float} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} rng RNG function, defaults to Math.random\n * @constructor\n */\nfunction VariableDensityPDS (options, rng) {\n    if (typeof options.distanceFunction !== 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n    this.distanceFunction = options.distanceFunction;\n    this.bias = Math.max(0, Math.min(1, options.bias || 0));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.maxDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.currentDistance = 0;\n    this.processList = [];\n    this.samplePoints = [];\n    this.sampleDistance = []; // used to store the distance for a given point\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints and sampleDistance\n}\n\nVariableDensityPDS.prototype.shape = null;\nVariableDensityPDS.prototype.dimension = null;\nVariableDensityPDS.prototype.minDistance = null;\nVariableDensityPDS.prototype.maxDistance = null;\nVariableDensityPDS.prototype.minDistancePlusEpsilon = null;\nVariableDensityPDS.prototype.deltaDistance = null;\nVariableDensityPDS.prototype.cellSize = null;\nVariableDensityPDS.prototype.maxTries = null;\nVariableDensityPDS.prototype.distanceFunction = null;\nVariableDensityPDS.prototype.bias = null;\nVariableDensityPDS.prototype.rng = null;\nVariableDensityPDS.prototype.neighbourhood = null;\n\nVariableDensityPDS.prototype.currentPoint = null;\nVariableDensityPDS.prototype.currentDistance = null;\nVariableDensityPDS.prototype.processList = null;\nVariableDensityPDS.prototype.samplePoints = null;\nVariableDensityPDS.prototype.sampleDistance = null;\nVariableDensityPDS.prototype.gridShape = null;\nVariableDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nVariableDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nVariableDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nVariableDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        pointIndex = this.samplePoints.length,\n        dimension;\n\n    this.processList.push(pointIndex);\n    this.samplePoints.push(point);\n    this.sampleDistance.push(this.distanceFunction(point));\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex].push(pointIndex); // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nVariableDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint,\n        existingPointDistance;\n\n    var pointDistance = this.distanceFunction(point);\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex].length > 0) {\n            for (var i = 0; i < this.grid.data[internalArrayIndex].length; i++) {\n                existingPoint = this.samplePoints[this.grid.data[internalArrayIndex][i]];\n                existingPointDistance = this.sampleDistance[this.grid.data[internalArrayIndex][i]];\n\n                var minDistance = Math.min(existingPointDistance, pointDistance);\n                var maxDistance = Math.max(existingPointDistance, pointDistance);\n                var dist = minDistance + (maxDistance - minDistance) * this.bias;\n\n                if (euclideanDistance(point, existingPoint) < this.minDistance + this.deltaDistance * dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nVariableDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        currentDistance,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            var sampleIndex = this.processList.shift();\n            this.currentPoint = this.samplePoints[sampleIndex];\n            this.currentDistance = this.sampleDistance[sampleIndex];\n        }\n\n        currentPoint = this.currentPoint;\n        currentDistance = this.currentDistance;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * (currentDistance + (1 - currentDistance) * this.bias);\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @returns {Array[]} Sample points with their distance function result\n */\nVariableDensityPDS.prototype.getAllPointsWithDistance = function () {\n    var result = new Array(this.samplePoints.length),\n        i = 0,\n        dimension = 0,\n        point;\n\n    for (i = 0; i < this.samplePoints.length; i++) {\n        point = new Array(this.dimension + 1);\n\n        for (dimension = 0; dimension < this.dimension; dimension++) {\n            point[dimension] = this.samplePoints[i][dimension];\n        }\n\n        point[this.dimension] = this.sampleDistance[i];\n\n        result[i] = point;\n    }\n\n    return result;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nVariableDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = [];\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = VariableDensityPDS;\n","\"use strict\";\n\nvar FixedDensityPDS = require('./implementations/fixed-density');\nvar VariableDensityPDS = require('./implementations/variable-density');\n\n/**\n * PoissonDiskSampling constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [options.distanceFunction] Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {function|null} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction PoissonDiskSampling (options, rng) {\n    this.shape = options.shape;\n\n    if (typeof options.distanceFunction === 'function') {\n        this.implementation = new VariableDensityPDS(options, rng);\n    } else {\n        this.implementation = new FixedDensityPDS(options, rng);\n    }\n}\n\nPoissonDiskSampling.prototype.implementation = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    return this.implementation.addRandomPoint();\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    return this.implementation.addPoint(point);\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    return this.implementation.next();\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    return this.implementation.fill();\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.implementation.getAllPoints();\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will throw an error if a distance function was not provided to the constructor.\n * @returns {Array[]} Sample points with their distance function result\n */\nPoissonDiskSampling.prototype.getAllPointsWithDistance = function () {\n    return this.implementation.getAllPointsWithDistance();\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    this.implementation.reset();\n};\n\nmodule.exports = PoissonDiskSampling;\n","import PoissonDiskSampling from 'poisson-disk-sampling';\nimport type { Vec2, PathCommand } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\nimport { isPointInBoundary } from '../../utils';\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype PoissonPointGeneratorName = \"PoissonPointGenerator\";\nexport const Name: PoissonPointGeneratorName = \"PoissonPointGenerator\";\n\n/** Required config for this generator */\nexport interface PoissonPointGeneratorConfig extends GeneratorConfig {\n  name: PoissonPointGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const PoissonPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Poisson\",\n  description: \"Generate seed points using Poisson disk sampling. \" +\n    \"The algorithm produces points that are tightly-packed, but no closer to \" +\n    \"each other than a specified minimum distance (the piece size), resulting \" +\n    \"in a natural, organic look.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A point generator that uses Poisson disk sampling to create a more organic\n * distribution of random points. `pieceSize` is interpreted as the minimum\n * distance between generated points.\n */\nexport const PoissonPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, _config: PoissonPointGeneratorConfig) => {\n  const PoissonPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random, border } = runtimeOpts;\n\n      // generate points randomly in a Poisson disk sampling within rectangular bounds\n      const poisson = new PoissonDiskSampling(\n        {\n          shape: [width, height], // clamps generated points within bounds\n          minDistance: pieceSize,\n          tries: 20,\n        },\n        random\n      );\n\n      // have to cast because @types/PoissonDiskSampling is not correct for fill()\n      const allPoints = poisson.fill() as unknown as Vec2[];\n\n      // Filter points to only include those inside the custom boundary\n      const filteredPoints = allPoints.filter((point) => isPointInBoundary(point, border));\n\n      return filteredPoints;\n    },\n  };\n  return PoissonPointGenerator;\n};\nexport default PoissonPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, PoissonPointGeneratorFactory, PoissonPointUIMetadata);\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const {delaunay: {points, hull, triangles}, vectors} = this;\n    let bx, by; // lazily computed barycenter of the hull\n\n    // Compute circumcenters.\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const ex = x3 - x1;\n      const ey = y3 - y1;\n      const ab = (dx * ey - dy * ex) * 2;\n\n      if (Math.abs(ab) < 1e-9) {\n        // For a degenerate triangle, the circumcenter is at the infinity, in a\n        // direction orthogonal to the halfedge and away from the center of\n        // the diagram <bx, by>, defined as the hulls barycenter.\n        if (bx === undefined) {\n          bx = by = 0;\n          for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];\n          bx /= hull.length, by /= hull.length;\n        }\n        const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);\n        x = (x1 + x3) / 2 - a * ey;\n        y = (y1 + y3) / 2 + a * ex;\n      } else {\n        const d = 1 / ab;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x = x1 + (ey * bl - dy * cl) * d;\n        y = y1 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x;\n      circumcenters[j + 1] = y;\n    }\n\n    // Compute exterior cell rays.\n    let h = hull[hull.length - 1];\n    let p0, p1 = h * 4;\n    let x0, x1 = points[2 * h];\n    let y0, y1 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull.length; ++i) {\n      h = hull[i];\n      p0 = p1, x0 = x1, y0 = y1;\n      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;\n    if (hull.length <= 1) return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull[hull.length - 1];\n    for (let i = 0; i < hull.length; ++i) {\n      h0 = h1, h1 = hull[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = h0 * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null || !points.length) return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;\n    for (let i = 2; i < n; i += 2) {\n      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])\n        context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) cell.index = i, yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci) for (const j of this.delaunay.neighbors(i)) {\n      const cj = this._clip(j);\n      // find the common edge\n      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n          if (ci[ai] === cj[aj]\n              && ci[ai + 1] === cj[aj + 1]\n              && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]\n              && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {\n            yield j;\n            break loop;\n          }\n        }\n      }\n    }\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    // degenerate case (1 valid point: return the box)\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return this._simplify(V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points));\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    // for more robustness, always consider the segment in the same order\n    const flip = c0 < c1;\n    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];\n    while (true) {\n      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n      // undefined, the conditional statement will be executed.\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n  _simplify(P) {\n    if (P && P.length > 4) {\n      for (let i = 0; i < P.length; i+= 2) {\n        const j = (i + 2) % P.length, k = (i + 4) % P.length;\n        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n          P.splice(j, 2), i -= 2;\n        }\n      }\n      if (!P.length) P = null;\n    }\n    return P;\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n","/**\n * Reusable helper functions for piece generators that work with custom boundaries.\n *\n * These utilities extract common patterns from piece generators to avoid code\n * duplication and ensure consistent behavior across different generation strategies.\n */\n\nimport type { PathCommand, Vec2, Piece, PieceID, PuzzleTopology } from '../../types';\nimport {\n  flattenBoundary,\n  isPointInBoundary,\n  clipPolygonAgainstBoundary,\n  createHalfEdgeLoop,\n  polygonBounds,\n} from '../../utils';\n\n/**\n * Pre-computed boundary data that can be reused across multiple operations.\n * Computing the flattened polygon is expensive, so we cache it at factory creation time.\n */\nexport interface BoundaryContext {\n  /** The original boundary path */\n  originalBorder: PathCommand[];\n  /** The boundary converted to a simple polygon for clipping operations */\n  flattenedPolygon: Vec2[];\n}\n\n/**\n * Creates a boundary context from a path command array.\n * This should be called once when the generator factory is created.\n *\n * @param border - The boundary path to process\n * @returns A boundary context containing both original and flattened representations\n */\nexport function createBoundaryContext(border: PathCommand[]): BoundaryContext {\n  return {\n    originalBorder: border,\n    flattenedPolygon: flattenBoundary(border)[0],\n  };\n}\n\n/**\n * Calculates the centroid (geometric center) of a polygon.\n *\n * @param vertices - The vertices of the polygon\n * @returns The centroid as a 2D point\n */\nexport function calculateCentroid(vertices: Vec2[]): Vec2 {\n  if (vertices.length === 0) {\n    return [0, 0];\n  }\n\n  const sum = vertices.reduce(\n    (acc, v) => [acc[0] + v[0], acc[1] + v[1]],\n    [0, 0]\n  );\n  return [sum[0] / vertices.length, sum[1] / vertices.length];\n}\n\n/**\n * Creates a puzzle piece from a polygon by constructing the piece object,\n * creating its half-edge loop, and adding it to the topology.\n *\n * @param pieceId - The unique identifier for this piece\n * @param vertices - The vertices of the polygon defining the piece boundary\n * @param topology - The puzzle topology to add the piece to (mutated in place)\n * @returns The created piece object\n */\nexport function createPieceFromPolygon(\n  pieceId: PieceID,\n  vertices: Vec2[],\n  topology: PuzzleTopology\n): Piece {\n  const piece: Piece = {\n    id: pieceId,\n    site: calculateCentroid(vertices),\n    halfEdge: -1, // Will be set by createHalfEdgeLoop\n    bounds: polygonBounds(vertices),\n  };\n\n  // Create the half-edge loop for the piece's vertices\n  const newHalfEdges = createHalfEdgeLoop(vertices, pieceId, topology);\n  if (newHalfEdges.length > 0) {\n    piece.halfEdge = newHalfEdges[0].id;\n  }\n\n  return piece;\n}\n\n/**\n * Clips a cell polygon against the puzzle boundary.\n *\n * This function determines whether a cell is fully inside, fully outside, or\n * partially overlapping the boundary, and returns the appropriate clipped polygon.\n *\n * @param cellPolygon - The polygon to clip (e.g., a grid cell or Voronoi cell)\n * @param boundaryContext - Pre-computed boundary data\n * @returns The clipped polygon vertices, or null if the cell is completely outside\n */\nexport function clipCellToBoundary(\n  cellPolygon: Vec2[],\n  boundaryContext: BoundaryContext\n): Vec2[] | null {\n  // Test how many corners of the cell are inside the boundary\n  const cornerInside = cellPolygon.map((corner) =>\n    isPointInBoundary(corner, boundaryContext.originalBorder)\n  );\n  const insideCount = cornerInside.filter(Boolean).length;\n\n  if (insideCount === 0) {\n    // Cell is completely outside the boundary\n    return null;\n  }\n\n  if (insideCount === cellPolygon.length) {\n    // Cell is fully inside the boundary, no clipping needed\n    return cellPolygon;\n  }\n\n  // Partial overlap - clip the cell against the boundary\n  const clipped = clipPolygonAgainstBoundary(\n    cellPolygon,\n    boundaryContext.flattenedPolygon\n  );\n\n  return clipped?.[0] ?? null;\n}\n","import { Delaunay } from 'd3-delaunay';\nimport { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  CustomPiece,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  PathCommand,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport {\n  linkAndCreateEdges,\n  isPointInPolygon,\n  polygonArea,\n  mergeFragmentsIntoNeighbors,\n} from '../../utils';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\nimport {\n  createBoundaryContext,\n  createPieceFromPolygon,\n  clipCellToBoundary,\n  type BoundaryContext,\n} from \"./PieceGeneratorHelpers\";\nimport {\n  checkCustomPieceOverlap,\n  subtractCustomPieces,\n  createPieceFromCustom,\n  customPieceToPolygon,\n} from '../../customPieces';\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\nexport const Name: VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\n\n/** Required config for this generator */\nexport interface VoronoiPieceGeneratorConfig extends GeneratorConfig {\n  name: VoronoiPieceGeneratorName;\n  /** Algorithm to use when integrating whimsies into the Voronoi diagram */\n  whimsyMode?: 'simple' | 'simple+merge' | 'flow' | 'adaptive';\n  /** Distance from whimsy boundary to eliminate seed points (pixels) - for flow and adaptive modes */\n  eliminationThreshold?: number;\n  /** Minimum fragment size as ratio of average piece size - for adaptive and simple+merge modes */\n  minFragmentSizeRatio?: number;\n  /** Maximum iterations for fragment filtering - only for adaptive mode */\n  maxIterations?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const VoronoiPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Voronoi\",\n  description: \"Construct pieces by building a Voronoi diagram from the seed points. \" +\n    \"Each piece consists of all area of the plane closer to its seed point than \" +\n    \"any other seed point. In practice, this creates irregular polygons with 3-8 \" +\n    \"sides.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'choice',\n      name: 'whimsyMode',\n      label: 'Whimsy Mode',\n      defaultValue: 'simple+merge',\n      choices: [\n        ['simple', 'Simple', 'Cuts each whimsy out of the generated pieces.'],\n        ['simple+merge', 'Simple+Merge', 'Cuts out whimsies, then merges small fragments into neighbors. Best balance of quality and uniform density.'],\n        ['flow', 'Flow', 'Eliminates seed points near whimsies. Works best with convex shapes.'],\n        ['adaptive', 'Adaptive', 'Eliminates seed points near whimsies and filters out undersized fragments. Best for complex whimsies.'],\n      ],\n    },\n    {\n      type: 'number',\n      name: 'eliminationThreshold',\n      label: 'Elimination Threshold',\n      defaultValue: 20,\n      min: 0,\n      max: 60,\n      helpText: 'Distance (in pixels) from whimsy boundaries where seed points are eliminated. Higher values remove more seeds near whimsies.',\n      dependsOn: [\n        { config: 'whimsyMode', value: 'flow' },\n        { config: 'whimsyMode', value: 'adaptive' },\n      ],\n    },\n    {\n      type: 'number',\n      name: 'minFragmentSizeRatio',\n      label: 'Min Fragment Size Ratio',\n      defaultValue: 0.3,\n      min: 0.1,\n      max: 0.8,\n      helpText: 'Minimum acceptable piece size as a fraction of average piece size. Pieces smaller than this are eliminated or merged. (e.g., 0.3 = 30% of average)',\n      dependsOn: [\n        { config: 'whimsyMode', value: 'adaptive' },\n        { config: 'whimsyMode', value: 'simple+merge' },\n      ],\n    },\n    {\n      type: 'number',\n      name: 'maxIterations',\n      label: 'Max Iterations',\n      defaultValue: 3,\n      min: 1,\n      max: 5,\n      helpText: 'Number of filtering passes to remove seed points that create undersized pieces. More iterations = more thorough filtering.',\n      dependsOn: [\n        { config: 'whimsyMode', value: 'adaptive' },\n      ],\n    },\n  ],\n};\n\n/**\n * Creates a consistent string key for a point, handling floating point inaccuracies.\n * @param p The point.\n * @returns A string key.\n */\nfunction pointToKey(p: Vec2): string {\n  return `${p[0].toPrecision(7)},${p[1].toPrecision(7)}`;\n}\n\n/**\n * Checks if a point is near the boundary polygon (within a small tolerance).\n * Used to determine if an edge lies on the puzzle's outer boundary.\n * @param point The point to check.\n * @param boundaryContext The boundary context with flattened polygon.\n * @returns True if the point is close to any edge of the boundary polygon.\n */\nfunction isPointNearBoundary(point: Vec2, boundaryContext: BoundaryContext): boolean {\n  const tolerance = 1e-3; // Small tolerance for floating point comparisons\n  const polygon = boundaryContext.flattenedPolygon;\n\n  // Check if point is close to any edge of the boundary polygon\n  for (let i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n\n    // Calculate distance from point to line segment\n    const dist = distanceToSegment(point, p1, p2);\n    if (dist < tolerance) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Calculates the minimum distance from a point to a line segment.\n * @param point The point.\n * @param segStart Start of the line segment.\n * @param segEnd End of the line segment.\n * @returns The minimum distance.\n */\nfunction distanceToSegment(point: Vec2, segStart: Vec2, segEnd: Vec2): number {\n  const [px, py] = point;\n  const [x1, y1] = segStart;\n  const [x2, y2] = segEnd;\n\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lengthSq = dx * dx + dy * dy;\n\n  if (lengthSq === 0) {\n    // Degenerate segment (point)\n    return Math.hypot(px - x1, py - y1);\n  }\n\n  // Project point onto line, clamped to segment\n  let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;\n  t = Math.max(0, Math.min(1, t));\n\n  const projX = x1 + t * dx;\n  const projY = y1 + t * dy;\n\n  return Math.hypot(px - projX, py - projY);\n}\n\n/**\n * Calculates the minimum distance from a point to a polygon boundary.\n * @param point The point.\n * @param polygon The polygon boundary.\n * @returns The minimum distance to any edge of the polygon.\n */\nfunction distanceToPolygon(point: Vec2, polygon: Vec2[]): number {\n  let minDistance = Infinity;\n\n  for (let i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n    const dist = distanceToSegment(point, p1, p2);\n    minDistance = Math.min(minDistance, dist);\n  }\n\n  return minDistance;\n}\n\n/**\n * Adjusts seed points for the flow whimsy mode by eliminating points near custom pieces.\n * This creates larger Voronoi cells around the whimsies, allowing them to fit more naturally.\n * @param points The original seed points.\n * @param customPieces The custom pieces to flow around.\n * @param eliminationThreshold Distance from whimsy boundary to eliminate seed points.\n * @returns The adjusted seed points.\n */\nfunction adjustSeedPointsForWhimsies(\n  points: Vec2[],\n  customPieces: CustomPiece[],\n  eliminationThreshold: number\n): Vec2[] {\n  const adjustedPoints: Vec2[] = [];\n\n  // Convert custom pieces to polygons once\n  const customPolygons = customPieces.map((piece) => customPieceToPolygon(piece));\n\n  // Filter out seed points that are inside or too close to custom pieces\n  for (const point of points) {\n    let shouldKeep = true;\n\n    for (const polygon of customPolygons) {\n      // Check if point is inside the custom piece\n      if (isPointInPolygon(point, polygon)) {\n        shouldKeep = false;\n        break;\n      }\n\n      // Check if point is within threshold distance of the custom piece boundary\n      const distance = distanceToPolygon(point, polygon);\n      if (distance < eliminationThreshold) {\n        shouldKeep = false;\n        break;\n      }\n    }\n\n    if (shouldKeep) {\n      adjustedPoints.push(point);\n    }\n  }\n\n  return adjustedPoints;\n}\n\n/**\n * Converts a Voronoi cell to a polygon (Vec2 array).\n * @param voronoi The Voronoi diagram.\n * @param cellIndex The index of the cell to convert.\n * @returns The cell polygon as an array of Vec2 points.\n */\nfunction voronoiCellToPolygon(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  voronoi: any,\n  cellIndex: number\n): Vec2[] | null {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  const cell = voronoi.cellPolygon(cellIndex);\n  if (!cell) return null;\n\n  // Convert from [x, y][] to Vec2[]\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  return Array.from(cell).map((point: unknown) => {\n    const [x, y] = point as [number, number];\n    return [x, y] as Vec2;\n  });\n}\n\n\n/**\n * Eliminates seed points that would create undersized fragments after clipping against\n * custom pieces. Uses iterative refinement to converge on a valid set of seed points.\n * This is Algorithm 5 from the custom pieces documentation.\n * @param seedPoints The seed points after initial elimination (Algorithm 1).\n * @param customPieces The custom pieces to check against.\n * @param bounds The puzzle bounds.\n * @param boundaryContext The boundary context for clipping.\n * @param options Configuration options for fragment filtering.\n * @returns The filtered seed points.\n */\nfunction eliminateSeedsCausingSmallFragments(\n  seedPoints: Vec2[],\n  customPieces: CustomPiece[],\n  bounds: { width: number; height: number },\n  boundaryContext: BoundaryContext,\n  options: {\n    minFragmentSizeRatio: number;\n    maxIterations: number;\n  }\n): Vec2[] {\n  const { minFragmentSizeRatio, maxIterations } = options;\n\n  // Calculate minimum area threshold\n  const averagePieceArea = (bounds.width * bounds.height) / seedPoints.length;\n  const minFragmentArea = Math.max(500, averagePieceArea * minFragmentSizeRatio);\n\n  console.log(`Fragment filtering: min area = ${minFragmentArea.toFixed(0)}px (${(minFragmentSizeRatio * 100).toFixed(0)}% of avg ${averagePieceArea.toFixed(0)}px)`);\n\n  let currentSeeds = seedPoints;\n  let totalEliminated = 0;\n\n  for (let iteration = 0; iteration < maxIterations; iteration++) {\n    if (currentSeeds.length === 0) {\n      console.warn(`Fragment filtering: All seeds eliminated after ${iteration} iterations`);\n      break;\n    }\n\n    // Generate Voronoi diagram from current seeds\n    const delaunay = Delaunay.from(currentSeeds);\n    const voronoi = delaunay.voronoi([0, 0, bounds.width, bounds.height]);\n\n    const validSeeds: Vec2[] = [];\n    let eliminatedCount = 0;\n\n    for (let i = 0; i < currentSeeds.length; i++) {\n      // Get the Voronoi cell\n      const cellPolygon = voronoiCellToPolygon(voronoi, i);\n      if (!cellPolygon) {\n        eliminatedCount++;\n        continue;\n      }\n\n      // Clip against puzzle boundary\n      const clippedCell = clipCellToBoundary(cellPolygon, boundaryContext);\n      if (!clippedCell) {\n        eliminatedCount++;\n        continue;\n      }\n\n      // Subtract custom pieces from the cell\n      if (customPieces.length > 0) {\n        const overlappingPieces = checkCustomPieceOverlap(clippedCell, customPieces);\n\n        if (overlappingPieces.length > 0) {\n          const fragments = subtractCustomPieces(clippedCell, overlappingPieces);\n\n          // Check if all fragments meet minimum size\n          if (!fragments || fragments.length === 0) {\n            // Cell fully contained in custom pieces\n            eliminatedCount++;\n            continue;\n          }\n\n          // Check if any fragment is too small\n          const hasSmallFragment = fragments.some((frag) => {\n            const area = polygonArea(frag);\n            return area < minFragmentArea;\n          });\n\n          if (hasSmallFragment) {\n            eliminatedCount++;\n            continue;\n          }\n        }\n      }\n\n      // This seed is valid, keep it\n      validSeeds.push(currentSeeds[i]);\n    }\n\n    totalEliminated += eliminatedCount;\n\n    // Log iteration results\n    if (eliminatedCount > 0) {\n      console.log(`Fragment filtering iteration ${iteration + 1}: eliminated ${eliminatedCount} seeds (${validSeeds.length} remaining)`);\n    }\n\n    // If no seeds eliminated this iteration, we're done\n    if (eliminatedCount === 0) {\n      console.log(`Fragment filtering converged after ${iteration + 1} iteration(s) (total eliminated: ${totalEliminated})`);\n      break;\n    }\n\n    currentSeeds = validSeeds;\n  }\n\n  return currentSeeds;\n}\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const VoronoiPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (border: PathCommand[], bounds: { width: number; height: number }, config: VoronoiPieceGeneratorConfig) => {\n  const { width, height } = bounds;\n  const whimsyMode = config.whimsyMode ?? 'adaptive';\n  const eliminationThreshold = config.eliminationThreshold ?? 20;\n  const minFragmentSizeRatio = config.minFragmentSizeRatio ?? 0.3;\n  const maxIterations = config.maxIterations ?? 3;\n\n  // Pre-compute boundary data once for reuse across all cells\n  const boundaryContext: BoundaryContext = createBoundaryContext(border);\n\n  const VoronoiPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param points The seed points for the centers of the puzzle pieces.\n     * @param _runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(points: Vec2[], runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n      const { border, customPieces = [] } = runtimeOpts;\n\n      // Note: Lloyd's relaxation could be performed here to create more uniform\n      // piece shapes. This would involve creating the Voronoi diagram, calculating\n      // the centroid of each cell, moving the input point to that centroid, and\n      // repeating for a number of iterations before proceeding.\n\n      console.log(`VoronoiPieceGenerator using dimensions ${width}x${height}`);\n\n      // Adjust seed points based on whimsy mode\n      let adjustedPoints = points;\n      if (customPieces.length > 0 && (whimsyMode === 'flow' || whimsyMode === 'adaptive')) {\n        // Step 1: Apply Algorithm 1 (seed point elimination near whimsies)\n        console.log(`${whimsyMode === 'adaptive' ? 'Adaptive' : 'Flow'} mode: adjusting ${points.length} seed points for ${customPieces.length} custom pieces (threshold: ${eliminationThreshold}px)`);\n        adjustedPoints = adjustSeedPointsForWhimsies(\n          points,\n          customPieces,\n          eliminationThreshold\n        );\n        const eliminated = points.length - adjustedPoints.length;\n        const eliminatedPercent = ((eliminated / points.length) * 100).toFixed(1);\n        console.log(`Seed elimination: ${adjustedPoints.length} seed points remaining (eliminated ${eliminated} / ${eliminatedPercent}%)`);\n\n        // Step 2: Apply Algorithm 5 (fragment filtering) for adaptive mode\n        if (whimsyMode === 'adaptive') {\n          console.log(`Adaptive mode: filtering seeds that would create small fragments`);\n          adjustedPoints = eliminateSeedsCausingSmallFragments(\n            adjustedPoints,\n            customPieces,\n            bounds,\n            boundaryContext,\n            {\n              minFragmentSizeRatio,\n              maxIterations,\n            }\n          );\n          const totalEliminated = points.length - adjustedPoints.length;\n          const totalEliminatedPercent = ((totalEliminated / points.length) * 100).toFixed(1);\n          console.log(`Adaptive mode: ${adjustedPoints.length} seed points remaining after all filtering (total eliminated ${totalEliminated} / ${totalEliminatedPercent}%)`);\n        }\n      }\n\n      // 1. Generate Voronoi diagram from points, clipped to the rectangular bounds.\n      const delaunay = Delaunay.from(adjustedPoints);\n      const voronoi = delaunay.voronoi([0, 0, width, height]);\n\n      // 2. Initialize data structures for the topology.\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n        borderPath: border,\n      };\n\n      // Map to find twin half-edges\n      const halfEdgeTwinMap = new Map<string, HalfEdgeID>();\n\n      // 3. For each Voronoi cell, clip it against the puzzle boundary and create a piece\n      let pieceIdCounter = 0;\n      for (let i = 0; i < adjustedPoints.length; i++) {\n        const site = adjustedPoints[i];\n        const cellPolygon = voronoi.cellPolygon(i);\n\n        if (!cellPolygon) continue;\n\n        // Clip the Voronoi cell against the custom puzzle boundary\n        const clippedVertices = clipCellToBoundary(cellPolygon, boundaryContext);\n\n        if (!clippedVertices) {\n          // Cell is completely outside the boundary, skip it\n          continue;\n        }\n\n        // Handle custom piece integration\n        // Both simple and flow modes clip Voronoi cells against custom piece boundaries\n        if (customPieces.length > 0) {\n          // Check if this cell overlaps with any custom pieces\n          const overlappingCustomPieces = checkCustomPieceOverlap(clippedVertices, customPieces);\n\n          if (overlappingCustomPieces.length > 0) {\n            // Subtract the custom pieces from this cell\n            const remainingPolygons = subtractCustomPieces(clippedVertices, overlappingCustomPieces);\n\n            if (!remainingPolygons || remainingPolygons.length === 0) {\n              // Cell is fully contained in custom pieces, skip it\n              continue;\n            }\n\n            // The cell may have been split into multiple polygons\n            // Create a piece for each resulting polygon\n            for (const polygon of remainingPolygons) {\n              if (polygon.length < 3) continue; // Skip degenerate polygons\n\n              const pieceId = pieceIdCounter++;\n              const piece = createPieceFromPolygon(pieceId, polygon, topology);\n\n              // Override the site to use the original seed point instead of centroid\n              piece.site = site;\n\n              topology.pieces.set(pieceId, piece);\n\n              // Collect the half-edges for this piece to link them with neighbors\n              const pieceHalfEdges: HalfEdge[] = [];\n              let currentHeId = piece.halfEdge;\n              if (currentHeId !== -1) {\n                const startHeId = currentHeId;\n                do {\n                  const he = topology.halfEdges.get(currentHeId)!;\n                  pieceHalfEdges.push(he);\n                  currentHeId = he.next;\n                } while (currentHeId !== startHeId);\n              }\n\n              // Link edges to neighbors or mark them as part of the boundary\n              linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n                const onBoundary = isPointNearBoundary(p1, boundaryContext) &&\n                  isPointNearBoundary(p2, boundaryContext);\n                return onBoundary;\n              });\n            }\n            // Skip the normal piece creation below since we handled it with clipping\n            continue;\n          }\n          // Fall through to create piece normally if no overlap\n        }\n\n        // No overlap with custom pieces: create piece normally from Voronoi cell\n        const pieceId = pieceIdCounter++;\n        const piece = createPieceFromPolygon(pieceId, clippedVertices, topology);\n\n        // Override the site to use the original seed point instead of centroid\n        piece.site = site;\n\n        topology.pieces.set(pieceId, piece);\n\n        // Collect the half-edges for this piece to link them with neighbors\n        const pieceHalfEdges: HalfEdge[] = [];\n        let currentHeId = piece.halfEdge;\n        if (currentHeId !== -1) {\n          const startHeId = currentHeId;\n          do {\n            const he = topology.halfEdges.get(currentHeId)!;\n            pieceHalfEdges.push(he);\n            currentHeId = he.next;\n          } while (currentHeId !== startHeId);\n        }\n\n        // Link edges to neighbors or mark them as part of the boundary\n        linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n          const onBoundary = isPointNearBoundary(p1, boundaryContext) &&\n            isPointNearBoundary(p2, boundaryContext);\n          return onBoundary;\n        });\n      }\n\n      // 4. Add custom pieces as their own pieces in the topology\n      for (const customPiece of customPieces) {\n        const pieceId = pieceIdCounter++;\n        const piece = createPieceFromCustom(customPiece, pieceId, topology);\n\n        topology.pieces.set(pieceId, piece);\n\n        // Collect the half-edges for this piece to link them with neighbors\n        const pieceHalfEdges: HalfEdge[] = [];\n        let currentHeId = piece.halfEdge;\n        if (currentHeId !== -1) {\n          const startHeId = currentHeId;\n          do {\n            const he = topology.halfEdges.get(currentHeId)!;\n            pieceHalfEdges.push(he);\n            currentHeId = he.next;\n          } while (currentHeId !== startHeId);\n        }\n\n        // Link edges to neighbors or mark them as part of the boundary\n        // Custom piece edges that touch procedural pieces should link to them\n        // Custom piece edges that don't touch anything are treated as boundary edges\n        linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n          // Check if this edge is on the puzzle boundary\n          const onBoundary = isPointNearBoundary(p1, boundaryContext) &&\n            isPointNearBoundary(p2, boundaryContext);\n          return onBoundary;\n        });\n      }\n\n      // 5. Post-processing: Merge fragments for simple+merge mode\n      if (customPieces.length > 0 && whimsyMode === 'simple+merge') {\n        const averagePieceArea = (bounds.width * bounds.height) / adjustedPoints.length;\n        const minFragmentArea = Math.max(500, averagePieceArea * minFragmentSizeRatio);\n\n        console.log(`Simple+merge mode: post-processing to merge fragments (threshold: ${minFragmentArea.toFixed(0)}px)`);\n\n        mergeFragmentsIntoNeighbors(\n          topology,\n          minFragmentArea,\n          halfEdgeTwinMap,\n          (p1, p2) => {\n            const onBoundary = isPointNearBoundary(p1, boundaryContext) &&\n              isPointNearBoundary(p2, boundaryContext);\n            return onBoundary;\n          }\n        );\n      }\n\n      // 6. Final step: Collect all unique vertices.\n      const vertexSet = new Map<string, Vec2>();\n      for (const he of topology.halfEdges.values()) {\n        const key = pointToKey(he.origin);\n        if (!vertexSet.has(key)) {\n          vertexSet.set(key, he.origin);\n        }\n      }\n      topology.vertices = Array.from(vertexSet.values());\n\n      return topology;\n    },\n  };\n  return VoronoiPieceGenerator;\n};\nexport default VoronoiPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, VoronoiPieceGeneratorFactory, VoronoiPieceGeneratorUIMetadata);\n","import type { PuzzleTopology, Edge, PathCommand, RandomFn, TabPlacement } from \"../../types\";\nimport type { TabPlacementStrategy, TabPlacementStrategyRuntimeOptions } from \"./TabPlacementStrategy\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabPlacementStrategyRegistry } from \"../Generator\";\n\n// Name of this strategy, uniquely identifies from all other TabPlacementStrategies\ntype SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\nexport const Name: SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\n\n/** Custom config for this strategy */\nexport interface SimpleTabPlacementStrategyConfig extends GeneratorConfig {\n  name: SimpleTabPlacementStrategyName;\n  /** The default size of the tab as a fraction (0-1) of the edge length. */\n  tabSize?: number;\n  /** Edges shorter than this value will not have a tab. */\n  minEdgeLength?: number;\n  /** The maximum absolute width that a tab can have. Wide tabs will get clamped to this value. */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this strategy */\nexport const SimpleTabPlacementStrategyUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Simple\",\n  description: \"Creates a single tab in the center of each edge with a random orientation.\",\n  sortHint: 1,\n  // these have to match the config above\n  controls: [\n    {\n      type: 'range',\n      name: 'tabSize',\n      label: 'Tab Size',\n      optional: true,\n      min: 0.01,\n      max: 1.0,\n      step: 0.01,\n      defaultValue: 0.5,\n      helpText: 'The width of the tab as a fraction of the edge length',\n    },\n    {\n      type: 'number',\n      name: 'minEdgeLength',\n      label: 'Minimum Edge Length',\n      optional: true,\n      defaultValue: 15,\n      helpText: 'Edges shorter than this value will not have a tab',\n    },\n    {\n      type: 'number',\n      name: 'maxTabSize',\n      label: 'Maximum Tab Size',\n      helpText: 'Maximum width of a generated tab',\n    },\n  ],\n};\n\n// helper function to do the actual placement work\nfunction placeTabOnEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  config: { tabSize: number, minEdgeLength: number, maxTabSize?: number },\n  random: RandomFn\n): void {\n  // clear any existing tabs in case we're re-evaluating\n  edge.tabs = undefined;\n\n  // we only place on internal edges\n  const isInternal = edge.heRight !== -1;\n  if (!isInternal) { return; }\n\n  const he1 = topology.halfEdges.get(edge.heLeft);\n  const he2 = topology.halfEdges.get(edge.heRight);\n  if (!he1 || !he2) return;\n\n  // Skip edges that touch custom pieces (whimsies) - they should remain smooth\n  const piece1 = topology.pieces.get(he1.piece);\n  const piece2 = topology.pieces.get(he2.piece);\n  if (piece1?.isCustomPiece || piece2?.isCustomPiece) {\n    return;\n  }\n\n  const p1 = he1.origin;\n  const p2 = he2.origin;\n  const edgeLength = Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);\n\n  // add a tab, if the edge is long enough\n  if (edgeLength >= config.minEdgeLength) {\n    let tabSize = config.tabSize;\n\n    // clamp tab width if requested\n    if (config.maxTabSize && (edgeLength * tabSize) > config.maxTabSize) {\n      tabSize = config.maxTabSize / edgeLength;\n    }\n\n    const tab: TabPlacement = {\n      position: 0.5, // center of the edge\n      size: tabSize,\n      convex: random() > 0.5, // tab is \"innie\" or \"outie\"\n    };\n    edge.tabs = [tab];\n  }\n}\n\n/**\n * A straightforward tab placement strategy that adds a single tab to the\n * center of each internal edge of the puzzle.\n */\nexport const SimpleTabPlacementStrategyFactory: GeneratorFactory<TabPlacementStrategy> = (\n  _border: PathCommand[],\n  _bounds: { width: number; height: number },\n  config: SimpleTabPlacementStrategyConfig,\n): TabPlacementStrategy => {\n  const { tabSize = 0.5, minEdgeLength = 0, maxTabSize } = config;\n  const placementConfig = { tabSize, minEdgeLength, maxTabSize };\n\n  return {\n    placeTabs(runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of topology.edges.values()) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n    updateTabPlacements(edges: Edge[], runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of edges) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n  };\n};\nexport default SimpleTabPlacementStrategyFactory;\n\n// register the strategy\nTabPlacementStrategyRegistry.register(Name, SimpleTabPlacementStrategyFactory, SimpleTabPlacementStrategyUIMetadata);","import type { TabGenerator } from \"./TabGenerator\";\nimport type { CurveTo, EdgeSegment, PathCommand, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\nexport const Name: TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TraditionalTabGeneratorConfig extends GeneratorConfig {\n  name: TraditionalTabGeneratorName;\n  /** Amount of randomness to apply to each tab (0-100) */\n  jitter?: number;\n  /** The height of the tab's nub as a fraction of its width. Default: 50% */\n  heightToWidthRatio?: number;\n  /** If provided, the width of a tab's features will be clamped to this value */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TraditionalTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Traditional\",\n  description: \"Creates a traditional rounded tab for each (internal) piece edge.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      defaultValue: 8,\n      min: 0,\n      max: 100,\n      step: 1,\n      helpText: 'Adds randomness to the tab shape. 0 means completely uniform tabs',\n    },\n    {\n      type: 'range',\n      name: 'heightToWidthRatio',\n      label: 'Tab Height',\n      defaultValue: 50,\n      min: 5,\n      max: 100,\n      step: 5,\n      helpText: 'The height of the tab as a percent of its width',\n    },\n  ],\n};\n\n\n/**\n * Build a puzzle nub using three cubic Bzier segments that replace a straight\n * edge AB. Curve 1 is a gentle S-curve up to the nub edge, Curve 2 is the arch\n * across the top of the nub, Curve 3 is the mirror of curve 1 back to the baseline.\n *   - the edge is parameterised from 0.0  1.0 along its length;\n *   - the nub is centred roughly at s = 0.5 and spans  4  t of the edge;\n *   - the peak of the nub reaches  3  t away from the baseline.\n *\n * @param a         Edge start point.\n * @param b         Edge end point.\n * @param jitterPct Jitter slider value (0100 %).\n * @param heightToWidthRatio Ratio of tab height to segment length\n * @param random    Seeded RNG so callers can reproduce shapes.\n * @param inward    If true the nub is an **indent**; otherwise a **bump**.\n * @param maxTabSize Optional maximum absolute width for the tab.\n *\n * @returns Three cubic Bzier segments, ordered from ab.\n */\nfunction createTraditionalTab(\n  a: Vec2,\n  b: Vec2,\n  jitterPct: number,\n  heightToWidthRatio: number,\n  random: RandomFn,\n  inward = false\n): EdgeSegment[] {\n  /* --- 1.  Work in a local (u,v) coordinate frame ---------------------- */\n\n  const ux = b[0] - a[0];\n  const uy = b[1] - a[1];\n  const len = Math.hypot(ux, uy);\n  if (len === 0) {\n    console.warn(\"Edge has zero length\");\n    return [];\n  }\n\n  // Basis vectors:  u along the edge, v = +90 (right-hand rule).\n  const u: Vec2 = [ux / len, uy / len];\n  const v: Vec2 = [-u[1], u[0]]; // perpendicular\n\n  /** Convert (s,w)  world coordinates.  Both s and w are normalised by len. */\n  const P = (s: number, w: number): Vec2 => [\n    a[0] + (u[0] * s + v[0] * w) * len,\n    a[1] + (u[1] * s + v[1] * w) * len,\n  ];\n\n  /* --- 2.  Derive the five random perturbations ae -------------------- */\n\n  const j = jitterPct / 100;\n  const rng = () => (random() * 2 - 1) * j; // uniform(-j, +j)\n\n  const A = rng(); // entry handle offset\n  const B = rng(); // l-shift of whole nub\n  const C = rng(); // vertical wobble of apex\n  const D = rng(); // anti-sym tweak\n  const E = rng(); // exit handle offset\n\n  /* --- 3.  Fixed shape constants -------------------------------------- */\n\n  // 't' is a fixed constant that defines the tab's internal proportions.\n  // A value of 0.2 means the central arch of the tab will span 80% (4 * 0.2)\n  const t = 0.1625; // 65%\n\n  // if (maxTabSize) {\n  //   const absoluteTabWidth = 4 * t * len;\n  //   if (absoluteTabWidth > maxTabSize) {\n  //     // recalculate t so that the tab width equals the max size, clamping it\n  //     t = maxTabSize / (4 * len);\n  //   }\n  // }\n\n  const dir = inward ? -1 : 1; // bump (+) or hole (-)\n  const nubHeight = heightToWidthRatio;\n  const shoulder_height = nubHeight / 3;\n\n  /* --- 4.  Anchor & control points in (s,w) ---------------------------- */\n\n  const pointsSW: Vec2[] = [\n    [0.0               ,           0],\n    [0.2               ,           A * shoulder_height],\n    [0.5 + B + D       , dir * (-shoulder_height + C * nubHeight)],\n    [0.5 - t + B       , dir * ( shoulder_height + C * nubHeight)],\n    [0.5 - 2*t + B - D , dir * (nubHeight + C * nubHeight)],\n    [0.5 + 2*t + B - D , dir * (nubHeight + C * nubHeight)],\n    [0.5 + t + B       , dir * ( shoulder_height + C * nubHeight)],\n    [0.5 + B + D       , dir * (-shoulder_height + C * nubHeight)],\n    [0.8               ,           E * shoulder_height],\n    [1.0               ,           0],\n  ];\n\n  /* --- 5.  Map to world coords and split into 3 Bziers ---------------- */\n\n  const points: Vec2[] = pointsSW.map(([s, w]) => P(s, w));\n\n  const bez1: CurveTo = { type: 'bezier', p1: points[1], p2: points[2], p3: points[3] };\n  const bez2: CurveTo = { type: 'bezier', p1: points[4], p2: points[5], p3: points[6] };\n  const bez3: CurveTo = { type: 'bezier', p1: points[7], p2: points[8], p3: points[9] };\n\n  return [bez1, bez2, bez3];\n}\n\n/**\n * A factory that creates a TabGenerator for creating traditional, smoothly curved\n * puzzle piece tabs using a provided geometry function. The nub is built using\n * three cubic Bzier segments that replace a straight edge AB. Curve 1 is a\n * gentle S-curve up to the nub edge, Curve 2 is the arch across the top of the\n * nub, Curve 3 is the mirror of curve 1 back to the baseline.\n */\nexport const TraditionalTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, config: TraditionalTabGeneratorConfig): TabGenerator => {\n  const { jitter = 8, heightToWidthRatio = 50 } = config;\n\n  const TraditionalTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, random: RandomFn): EdgeSegment[] {\n      const inward = !tab.convex;\n      return createTraditionalTab(start, end, jitter, heightToWidthRatio/100, random, inward);\n    },\n  };\n  return TraditionalTabGenerator;\n};\nexport default TraditionalTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TraditionalTabGeneratorFactory, TraditionalTabUIMetadata);\n","import type {\n  AABB,\n  EdgeSegment,\n  LineTo,\n  Piece,\n  PuzzleTopology,\n  Vec2,\n} from \"./types\";\nimport {\n  distanceSq,\n  calculateSegmentsBounds,\n  serializeTopology,\n  doAABBsIntersect,\n  isPointInBoundary,\n} from \"./utils\";\nimport type { CheckGeometryWorkerInput, CheckGeometryWorkerOutput } from '../workers/CheckGeometryWorker';\nimport { Bezier } from 'bezier-js';\n\n// import the worker script\nimport CheckGeometryWorker from '../workers/CheckGeometryWorker?worker';\n\n/** An internal structure to hold a segment and its pre-calculated properties. */\ninterface BoundarySegment {\n  /** The geometric definition of the segment. */\n  segment: EdgeSegment;\n  /** The starting point of this segment. */\n  startPoint: Vec2;\n  /** The pre-calculated bounding box for this segment. */\n  bbox: AABB;\n}\n\n// helper to gets the end point of a segment.\nfunction getEndPoint(s: EdgeSegment): Vec2 {\n  return s.type === 'line' ? s.p : s.p3;\n}\n\n// helper to get a Bezier object for use with bezier-js\nfunction boundaryToBezier(boundary: BoundarySegment): Bezier {\n  if (boundary.segment.type !== 'bezier') {\n    throw new Error('Boundary segment is not a Bezier curve');\n  }\n  const { startPoint } = boundary;\n  const { p1, p2, p3 } = boundary.segment;\n  return new Bezier(\n    { x: startPoint[0], y: startPoint[1] },\n    { x: p1[0], y: p1[1] },\n    { x: p2[0], y: p2[1] },\n    { x: p3[0], y: p3[1] }\n  );\n}\n\n/**\n * Traverses a piece's boundary and collects all its geometric segments.\n * @param piece - The piece to process.\n * @param puzzle - The full puzzle geometry, for half-edge lookups.\n * @returns An ordered array of BoundarySegment objects.\n */\nfunction getPieceBoundary(piece: Piece, puzzle: PuzzleTopology): BoundarySegment[] {\n  const boundary: BoundarySegment[] = [];\n  const startHeId = piece.halfEdge;\n  let currentHeId = startHeId;\n\n  do {\n    const he = puzzle.halfEdges.get(currentHeId);\n    if (!he) {\n      console.error(`Could not find half-edge with ID: ${currentHeId}`);\n      break;\n    }\n\n    let startPoint = he.origin;\n\n    if (he.segments && he.segments.length > 0) {\n      // Add segments from the half-edge definition\n      for (const segment of he.segments) {\n        boundary.push({\n          segment,\n          startPoint,\n          bbox: calculateSegmentsBounds(startPoint, [segment]),\n        });\n        // The next segment starts where the current one ends\n        startPoint = segment.type === 'line' ? segment.p : segment.p3;\n      }\n    } else {\n      // If no segments, it's a straight line to the next half-edge's origin\n      const nextHe = puzzle.halfEdges.get(he.next);\n      if (!nextHe) {\n        console.error(`Could not find next half-edge for ID: ${he.next}`);\n        continue;\n      }\n      const lineSegment: LineTo = { type: 'line', p: nextHe.origin };\n      boundary.push({\n        segment: lineSegment,\n        startPoint: startPoint,\n        bbox: calculateSegmentsBounds(startPoint, [lineSegment]),\n      });\n    }\n\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId);\n\n  return boundary;\n}\n\n/**\n * Performs precise intersection detection between two geometric segments.\n * This function handles Line/Line, Line/Curve, and Curve/Curve cases.\n *\n * @param s1 - The first boundary segment.\n * @param s2 - The second boundary segment.\n * @param adjacent - True of the segments are next to each other on the boundary.\n * @returns An array of Vec2 points representing all found intersections.\n */\nfunction narrowPhaseDetection(s1: BoundarySegment, s2: BoundarySegment, adjacent: boolean): Promise<Vec2[]> {\n  return new Promise<Vec2[]>((resolve) => {\n\n    const intersections: Vec2[] = [];\n    const type1 = s1.segment.type;\n    const type2 = s2.segment.type;\n    const tolerance = 0.01; // values this close to the beginning or end of a curve are effectively at the ends\n\n\n    // Bezier vs. Bezier\n    if (type1 === 'bezier' && type2 === 'bezier') {\n      const bezier1 = boundaryToBezier(s1);\n      const bezier2 = boundaryToBezier(s2);\n\n      // intersects() returns an array of strings that look like \"float/float\"\n      const pairs = bezier1.intersects(bezier2) as string[];\n\n      pairs.forEach((pair) => {\n        const tValues = pair.split('/');\n        const t1 = parseFloat(tValues[0]);\n        const t2 = parseFloat(tValues[1]);\n\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t1 > (1.0 - tolerance) && t2 < tolerance || t1 < tolerance && t2 > (1.0 - tolerance);\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n\n        // extract the intersection point\n        const p = bezier1.get(t1);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Bezier vs. Line\n    else if (type1 === 'bezier' || type2 === 'bezier') {\n      const curveBoundary = type1 === 'bezier' ? s1 : s2;\n      const lineBoundary = type1 === 'line' ? s1 : s2;\n\n      const curve = boundaryToBezier(curveBoundary);\n      const line = {\n        p1: { x: lineBoundary.startPoint[0], y: lineBoundary.startPoint[1] },\n        p2: { x: (lineBoundary.segment as LineTo).p[0], y: (lineBoundary.segment as LineTo).p[1] },\n      };\n\n      // intersects() returns an array of t-values on the curve\n      const tValues = curve.intersects(line) as number[]; // always numbers when comparing to line\n      tValues.forEach((t) => {\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t > (1.0 - tolerance) || t < tolerance;\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n        const p = curve.get(t);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Line vs. Line\n    else {\n      // only non-adjacent line segments need to be compared\n      if (!adjacent) {\n        return resolve(intersections);\n      }\n\n      const p1 = s1.startPoint;\n      const p2 = s1.segment.p;\n      const p3 = s2.startPoint;\n      const p4 = s2.segment.p;\n\n      const [x1, y1] = p1;\n      const [x2, y2] = p2;\n      const [x3, y3] = p3;\n      const [x4, y4] = p4;\n\n      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n      if (den !== 0) { // Ensure lines are not parallel or collinear\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n\n        // If an intersection exists on both line segments\n        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n          const intersectX = x1 + t * (x2 - x1);\n          const intersectY = y1 + t * (y2 - y1);\n          intersections.push([intersectX, intersectY]);\n        }\n      }\n    }\n\n    resolve(intersections);\n  });\n}\n\n/**\n * Detects self-intersections within each piece of a puzzle geometry.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @param onProgress - Optional callback invoked to report progress.\n * @returns An array of Vec2 points, where each point is an overlap.\n */\nasync function detectIntersections(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  const intersections: Vec2[] = [];\n  const EPSILON_SQUARED = 1e-8; // Tolerance for floating point comparisons\n\n  const pieces = Array.from(puzzle.pieces.values());\n  const totalPieces = pieces.length;\n  let processedCount = 0;\n\n  // 1. Iterate through each piece\n  for (const piece of puzzle.pieces.values()) {\n\n    // report progress\n    onProgress?.(processedCount, totalPieces);\n\n    const boundary = getPieceBoundary(piece, puzzle);\n    const numSegments = boundary.length;\n    if (numSegments < 2) {\n      processedCount++;\n      continue;\n    }\n\n    // 2. Compare every segment with every other segment that comes after it\n    for (let i = 0; i < numSegments; i++) {\n      for (let j = i + 1; j < numSegments; j++) {\n        const seg1 = boundary[i];\n        const seg2 = boundary[j];\n\n        // 3. Broad-phase detection using bounding boxes\n        if (!doAABBsIntersect(seg1.bbox, seg2.bbox)) {\n          // no intersections\n          continue;\n        }\n\n        // 4. Distinguish between adjacent and non-adjacent intersections\n        const areAdjacent = (j === i + 1) || (i === 0 && j === numSegments - 1);\n\n        // 5. Narrow-phase detection (using a bezier library)\n        const potentialPoints = await narrowPhaseDetection(seg1, seg2, areAdjacent);\n\n        if (potentialPoints.length === 0) {\n          // no intersections\n          continue;\n        }\n\n        if (areAdjacent) {\n          const connectionPoint = (i === 0 && j === numSegments - 1)\n            ? seg1.startPoint // we're comparing the final segment with the first segment\n            : getEndPoint(seg1.segment); // we're comparing adjacent segments\n\n          for (const point of potentialPoints) {\n            // An intersection is only an error if it's NOT at the connection point.\n            if (distanceSq(point, connectionPoint) > EPSILON_SQUARED) {\n              intersections.push(point);\n            }\n          }\n        } else {\n          // For non-adjacent segments, ANY intersection is an error.\n          intersections.push(...potentialPoints);\n        }\n      }\n    }\n    processedCount++;\n  }\n\n  // final call to signify completion\n  onProgress?.(totalPieces, totalPieces);\n\n  console.log(`detected ${intersections.length} intersections in ${puzzle.pieces.size} pieces`);\n  return intersections;\n}\n\n\n/**\n * Detects vertices that lie outside the puzzle boundary.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @returns An array of Vec2 points representing vertices outside the boundary.\n */\nfunction detectVerticesOutsideBoundary(puzzle: PuzzleTopology): Vec2[] {\n  const outsideVertices: Vec2[] = [];\n\n  // Collect all boundary edge vertices (vertices on half-edges with twin === -1)\n  // These should be excluded from the check due to floating point precision issues\n  const boundaryEdgeVertices = new Set<Vec2>();\n  for (const halfEdge of puzzle.halfEdges.values()) {\n    if (halfEdge.twin === -1) {\n      boundaryEdgeVertices.add(halfEdge.origin);\n    }\n  }\n\n  // Check each vertex to see if it's inside the boundary\n  for (const vertex of puzzle.vertices) {\n    if (!isPointInBoundary(vertex, puzzle.borderPath, boundaryEdgeVertices)) {\n      outsideVertices.push(vertex);\n    }\n  }\n\n  if (outsideVertices.length > 0) {\n    console.log(`detected ${outsideVertices.length} vertices outside the boundary`);\n  }\n\n  return outsideVertices;\n}\n\n/**\n * Checks a puzzle for geometry issues such as intersecting pieces or too narrow geometry.\n * @param puzzle - Geometry to check\n * @param onProgress - Optional callpack for managing a progress bar\n * @returns A Promise for coordinates that have problem geometry\n */\nexport async function checkGeometry(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  // find points where pieces intersect/overlap\n  const intersections = await detectIntersections(puzzle, onProgress);\n\n  // find vertices outside the boundary\n  const outsideVertices = detectVerticesOutsideBoundary(puzzle);\n\n  // combine both types of problems\n  const allProblems = [...intersections, ...outsideVertices];\n\n  if (allProblems.length < 2) {\n    return allProblems;\n  }\n\n  // Note: the intersection algorithm can return multiple points clustered very\n  // closely, which is confusing for the user, so here we filter them out\n  const MIN_DISTANCE = 1;\n  const filtered: Vec2[] = [allProblems[0]];\n\n  for (let i = 1; i < allProblems.length; i++) {\n    const current = allProblems[i];\n    const last = filtered[filtered.length - 1];\n    if (distanceSq(current, last) > MIN_DISTANCE * MIN_DISTANCE) {\n      filtered.push(current);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Wraps the `checkGeometry` function in a web worker to run it off the main thread,\n * preventing the UI from freezing during intensive calculations.\n *\n * @param puzzle - The puzzle topology to check.\n * @param onProgress - An optional callback to receive progress updates.\n * @returns A promise that resolves with an array of intersection points or rejects on error.\n */\nexport function checkGeometryInWorker(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n  return new Promise((resolve, reject) => {\n    const worker = new CheckGeometryWorker();\n\n    // Handle messages received from the worker\n    worker.onmessage = (event: MessageEvent<CheckGeometryWorkerOutput>) => {\n      const data = event.data;\n\n      switch (data.type) {\n      case 'progress':\n        onProgress?.(data.processed, data.total);\n        break;\n      case 'done':\n        resolve(data.results);\n        worker.terminate();\n        break;\n      case 'error':\n        reject(new Error(data.message));\n        worker.terminate();\n        break;\n      }\n    };\n\n    // Handle any critical errors with the worker itself\n    worker.onerror = (error: ErrorEvent) => {\n      reject(new Error(error.message));\n      worker.terminate();\n    };\n\n    // serialize the puzzle topology and send it to the worker to kick off the process\n    const message: CheckGeometryWorkerInput = {\n      topology: serializeTopology(puzzle),\n    };\n    worker.postMessage(message);\n  });\n}","import type { Vec2, PathCommand } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\nimport { isPointInBoundary } from '../../utils';\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\nexport const Name: GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\n\n/** Required config for this generator */\nexport interface GridJitterPointGeneratorConfig extends GeneratorConfig {\n  name: GridJitterPointGeneratorName;\n  /** Amount of random jitter (0 to 100) */\n  jitter: number;\n}\n\n/** UI metadata needed for this generator */\nexport const GridJitterPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Grid\",\n  description: \"Generate seed points using a grid with optional random jitter. \" +\n    \"Has a uniform, regular look, especially with low randomness values.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n      helpText: 'Amount of jitter to apply to each grid point (0 to 100%)',\n    },\n  ],\n};\n\n/**\n * A point generator that uses grid + random jitter. `jitter` represents the\n * strength of jitter applied to each point, from 0 (straight grid) to 1\n * (completely random).\n */\nexport const GridJitterPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, config: GridJitterPointGeneratorConfig) => {\n  const { jitter = 50 } = config;\n\n  const GridJitterPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random, border } = runtimeOpts;\n\n      const points: Vec2[] = [];\n      // assemble a grid\n      for (let x = 0; x < width; x += pieceSize) {\n        for (let y = 0; y < height; y += pieceSize) {\n          // initial position is the center of each grid cell\n          const point: Vec2 = [x + pieceSize / 2, y + pieceSize / 2];\n          // add random jitter\n          if (jitter > 0) {\n            point[0] += (random() - 0.5) * (jitter / 100) * pieceSize;\n            point[1] += (random() - 0.5) * (jitter / 100)  * pieceSize;\n          }\n\n          // Only include points that are inside the custom boundary\n          if (isPointInBoundary(point, border)) {\n            points.push(point);\n          }\n        }\n      }\n      return points;\n    },\n  };\n  return GridJitterPointGenerator;\n};\nexport default GridJitterPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, GridJitterPointGeneratorFactory, GridJitterPointUIMetadata);\n","import { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  CustomPiece,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  PathCommand,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport {\n  linkAndCreateEdges,\n  mergeFragmentsIntoNeighbors,\n  polygonBounds,\n  isPointInPolygon,\n  doAABBsIntersect,\n} from \"../../utils\";\nimport {\n  createBoundaryContext,\n  createPieceFromPolygon,\n  clipCellToBoundary,\n  type BoundaryContext,\n} from \"./PieceGeneratorHelpers\";\nimport {\n  customPieceToPolygon,\n} from '../../customPieces';\nimport * as martinez from 'martinez-polygon-clipping';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\nexport const Name: RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\n\n/** Required config for this generator */\nexport interface RectangularPieceGeneratorConfig extends GeneratorConfig {\n  name: RectangularPieceGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const RectangularPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Rectangular\",\n  description: \"Construct pieces from a regular grid. All pieces have 4 sides \" +\n    \"and are the same size (except when the border is irregular). This generator \" +\n    \"ignores seed points.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A `PieceGenerator` that uses a grid to create the puzzle's topology. It\n * builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const RectangularPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (border: PathCommand[], bounds: { width: number; height: number }, _config: RectangularPieceGeneratorConfig) => {\n\n  const { width, height } = bounds;\n\n  // Pre-compute boundary data once for reuse across all cells\n  const boundaryContext: BoundaryContext = createBoundaryContext(border);\n\n  const RectangularPieceGenerator: PieceGenerator = {\n    /**\n     * Builds a puzzle topology based on a grid, ignores seed points.\n     * @param _points The seed points. Ignored by this generator.\n     * @param runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(_points: Vec2[], runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n      const { pieceSize, border, customPieces = [] } = runtimeOpts;\n\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n        borderPath: border,\n      };\n\n      // --- 1. Calculate Grid Dimensions ---\n      // Determine the number of rows and columns based on the desired piece size.\n      const cols = Math.ceil(width / pieceSize);\n      const rows = Math.ceil(height / pieceSize);\n\n      // Calculate the actual width and height of each cell\n      const cellWidth = Math.round(width / cols);\n      const cellHeight = Math.round(height / rows);\n\n      // --- 2. Create Vertices ---\n      // A 2D array to hold all vertex points for easy lookup by grid index.\n      const gridVertices: Vec2[][] = [];\n      for (let r = 0; r <= rows; r++) {\n        const rowVertices: Vec2[] = [];\n        for (let c = 0; c <= cols; c++) {\n          const x = c * cellWidth;\n          const y = r * cellHeight;\n          rowVertices.push([x, y]);\n        }\n        gridVertices.push(rowVertices);\n      }\n      // Flatten the 2D array into the final list for the topology.\n      topology.vertices = gridVertices.flat();\n\n      // --- 3. Create Pieces and Half-Edges ---\n      // This map will help us find the twin of a half-edge. The key is a string\n      // representing the start and end vertices of an edge, e.g., \"x1,y1-x2,y2\".\n      const halfEdgeTwinMap = new Map<string, HalfEdgeID>();\n\n      // NOTE: Using a string key based on floating point coordinates can be very\n      // fragile. Tiny precision errors can cause lookups to fail. This approach\n      // is safe here because the grid coordinates are normalized to integers.\n\n      // Counter for piece IDs (will be incremented when cells split into multiple fragments)\n      let pieceIdCounter = 0;\n\n      // Helper to split polygon edges at grid line intersections\n      const splitAtGridLines = (polygon: Vec2[]): Vec2[] => {\n        const result: Vec2[] = [];\n\n        for (let i = 0; i < polygon.length; i++) {\n          const p1 = polygon[i];\n          const p2 = polygon[(i + 1) % polygon.length];\n          result.push(p1);\n\n          const intersections: { t: number; point: Vec2 }[] = [];\n\n          // Check vertical grid lines\n          for (let c = 0; c <= cols; c++) {\n            const x = c * cellWidth;\n            if ((p1[0] < x && p2[0] > x) || (p1[0] > x && p2[0] < x)) {\n              // Edge crosses grid line in interior\n              const t = (x - p1[0]) / (p2[0] - p1[0]);\n              const y = p1[1] + t * (p2[1] - p1[1]);\n              intersections.push({ t, point: [x, y] });\n            }\n          }\n\n          // Check horizontal grid lines\n          for (let r = 0; r <= rows; r++) {\n            const y = r * cellHeight;\n            if ((p1[1] < y && p2[1] > y) || (p1[1] > y && p2[1] < y)) {\n              // Edge crosses grid line in interior\n              const t = (y - p1[1]) / (p2[1] - p1[1]);\n              const x = p1[0] + t * (p2[0] - p1[0]);\n              intersections.push({ t, point: [x, y] });\n            }\n          }\n\n          intersections.sort((a, b) => a.t - b.t);\n          for (const int of intersections) {\n            result.push(int.point);\n          }\n        }\n\n        return result;\n      };\n\n      // Helper to calculate distance from point to line segment\n      const distanceToSegment = (point: Vec2, segStart: Vec2, segEnd: Vec2): number => {\n        const [px, py] = point;\n        const [x1, y1] = segStart;\n        const [x2, y2] = segEnd;\n\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const lengthSq = dx * dx + dy * dy;\n\n        if (lengthSq === 0) {\n          return Math.hypot(px - x1, py - y1);\n        }\n\n        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;\n        t = Math.max(0, Math.min(1, t));\n\n        const projX = x1 + t * dx;\n        const projY = y1 + t * dy;\n\n        return Math.hypot(px - projX, py - projY);\n      };\n\n      // Helper to check if a point is near the puzzle boundary\n      const isPointNearBoundary = (point: Vec2): boolean => {\n        const tolerance = 1e-3;\n        const polygon = boundaryContext.flattenedPolygon;\n\n        for (let i = 0; i < polygon.length; i++) {\n          const p1 = polygon[i];\n          const p2 = polygon[(i + 1) % polygon.length];\n          const dist = distanceToSegment(point, p1, p2);\n          if (dist < tolerance) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      // Pre-split custom pieces at grid lines once for reuse\n      const gridSplitCustomPieces: { original: CustomPiece; polygon: Vec2[] }[] = customPieces.map((cp) => {\n        const cpPolygon = customPieceToPolygon(cp);\n        const cpSplit = splitAtGridLines(cpPolygon);\n        return { original: cp, polygon: cpSplit };\n      });\n\n      // build each piece\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n\n          // Get the four corner vertices for the current grid cell.\n          const topLeft = gridVertices[r][c];\n          const topRight = gridVertices[r][c + 1];\n          const bottomLeft = gridVertices[r + 1][c];\n          const bottomRight = gridVertices[r + 1][c + 1];\n\n          // Clip the grid cell against the puzzle boundary\n          const cellPolygon = [topLeft, topRight, bottomRight, bottomLeft];\n          const pieceVertices = clipCellToBoundary(cellPolygon, boundaryContext);\n\n          if (!pieceVertices) {\n            // Cell is completely outside the boundary, skip it\n            continue;\n          }\n\n          // Handle custom piece integration\n          // Clip grid cells against custom piece boundaries\n          if (gridSplitCustomPieces.length > 0) {\n            // Check overlap using pre-split custom pieces\n            const overlappingPolygons: Vec2[][] = [];\n            const cellBounds = polygonBounds(pieceVertices);\n\n            for (const { polygon: cpSplit } of gridSplitCustomPieces) {\n              const customBounds = polygonBounds(cpSplit);\n\n              // Fast rejection: check if bounding boxes overlap\n              if (!doAABBsIntersect(cellBounds, customBounds)) {\n                continue;\n              }\n\n              // Check if any vertex of the cell is inside the custom piece\n              let hasOverlap = false;\n              for (const point of pieceVertices) {\n                if (isPointInPolygon(point, cpSplit)) {\n                  hasOverlap = true;\n                  break;\n                }\n              }\n\n              // If no cell vertices are inside, check if any custom piece vertices are inside the cell\n              if (!hasOverlap) {\n                for (const point of cpSplit) {\n                  if (isPointInPolygon(point, pieceVertices)) {\n                    hasOverlap = true;\n                    break;\n                  }\n                }\n              }\n\n              if (hasOverlap) {\n                overlappingPolygons.push(cpSplit);\n              }\n            }\n\n            if (overlappingPolygons.length > 0) {\n              // Subtract the grid-split custom piece polygons from this cell\n              let result: martinez.Polygon | martinez.MultiPolygon = [pieceVertices.map((p) => [p[0], p[1]])];\n\n              for (const cpSplit of overlappingPolygons) {\n                const customMartinez: martinez.Polygon = [cpSplit.map((p) => [p[0], p[1]])];\n                const clipped = martinez.diff(result, customMartinez);\n\n                if (!clipped || clipped.length === 0) {\n                  result = [];\n                  break;\n                }\n                result = clipped;\n              }\n\n              // Convert back to Vec2[][] format\n              const remainingPolygons: Vec2[][] = [];\n              if (Array.isArray(result) && result.length > 0) {\n                for (const polygon of result) {\n                  if (Array.isArray(polygon) && polygon.length > 0) {\n                    const outerRing = polygon[0];\n                    if (Array.isArray(outerRing)) {\n                      const vertices: Vec2[] = outerRing.map((p) => {\n                        if (Array.isArray(p) && p.length >= 2) {\n                          return [p[0], p[1]] as Vec2;\n                        }\n                        return [0, 0] as Vec2;\n                      });\n                      remainingPolygons.push(vertices);\n                    }\n                  }\n                }\n              }\n\n              if (!remainingPolygons || remainingPolygons.length === 0) {\n                // Cell is fully contained in custom pieces, skip it\n                continue;\n              }\n\n              // The cell may have been split into multiple polygons\n              // Create a piece for each resulting polygon\n              for (const polygon of remainingPolygons) {\n                if (polygon.length < 3) continue; // Skip degenerate polygons\n\n                const fragmentId = pieceIdCounter++;\n                const piece = createPieceFromPolygon(fragmentId, polygon, topology);\n                topology.pieces.set(fragmentId, piece);\n\n                // Collect the half-edges for this piece to link them with neighbors\n                const pieceHalfEdges: HalfEdge[] = [];\n                let currentHeId = piece.halfEdge;\n                if (currentHeId !== -1) {\n                  const startHeId = currentHeId;\n                  do {\n                    const he = topology.halfEdges.get(currentHeId)!;\n                    pieceHalfEdges.push(he);\n                    currentHeId = he.next;\n                  } while (currentHeId !== startHeId);\n                }\n\n                // Link edges to neighbors or mark them as part of the boundary\n                linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n                  const onBoundary = isPointNearBoundary(p1) && isPointNearBoundary(p2);\n                  return onBoundary;\n                });\n              }\n              // Skip the normal piece creation below since we handled it with clipping\n              continue;\n            }\n            // Fall through to create piece normally if no overlap\n          }\n\n          // No overlap with custom pieces: create piece normally from grid cell\n          const pieceId = pieceIdCounter++;\n          const piece = createPieceFromPolygon(pieceId, pieceVertices, topology);\n          topology.pieces.set(pieceId, piece);\n\n          // Collect the half-edges for this piece to link them with neighbors\n          const pieceHalfEdges: HalfEdge[] = [];\n          let currentHeId = piece.halfEdge;\n          if (currentHeId !== -1) {\n            const startHeId = currentHeId;\n            do {\n              const he = topology.halfEdges.get(currentHeId)!;\n              pieceHalfEdges.push(he);\n              currentHeId = he.next;\n            } while (currentHeId !== startHeId);\n          }\n\n          // link edges to neighbors or mark them as part of the boundary\n          linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n            const onBoundary = isPointNearBoundary(p1) && isPointNearBoundary(p2);\n            return onBoundary;\n          });\n\n        }\n      }\n\n      // --- 4. Add custom pieces as their own pieces in the topology ---\n      for (const { polygon: splitPolygon } of gridSplitCustomPieces) {\n        const pieceId = pieceIdCounter++;\n\n        const piece = createPieceFromPolygon(pieceId, splitPolygon, topology);\n        topology.pieces.set(pieceId, piece);\n\n        // Collect the half-edges for this piece to link them with neighbors\n        const pieceHalfEdges: HalfEdge[] = [];\n        let currentHeId = piece.halfEdge;\n        if (currentHeId !== -1) {\n          const startHeId = currentHeId;\n          do {\n            const he = topology.halfEdges.get(currentHeId)!;\n            pieceHalfEdges.push(he);\n            currentHeId = he.next;\n          } while (currentHeId !== startHeId);\n        }\n\n        // Link edges to neighbors or mark them as part of the boundary\n        linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n          const onBoundary = isPointNearBoundary(p1) && isPointNearBoundary(p2);\n          return onBoundary;\n        });\n      }\n\n      // --- 5. Post-processing: Merge fragments ---\n      if (customPieces.length > 0) {\n        // Calculate minimum fragment area threshold\n        const totalPoints = rows * cols;\n        const averagePieceArea = (bounds.width * bounds.height) / totalPoints;\n        const minFragmentSizeRatio = 0.3; // Same default as VoronoiPieceGenerator\n        const minFragmentArea = Math.max(500, averagePieceArea * minFragmentSizeRatio);\n\n        console.log(`RectangularPieceGenerator: post-processing to merge fragments (threshold: ${minFragmentArea.toFixed(0)}px)`);\n\n        mergeFragmentsIntoNeighbors(\n          topology,\n          minFragmentArea,\n          halfEdgeTwinMap,\n          (p1, p2) => {\n            const onBoundary = isPointNearBoundary(p1) && isPointNearBoundary(p2);\n            return onBoundary;\n          }\n        );\n      }\n\n      return topology;\n    },\n  };\n  return RectangularPieceGenerator;\n};\nexport default RectangularPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, RectangularPieceGeneratorFactory, RectangularPieceGeneratorUIMetadata);\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, PathCommand, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other TabGenerators\ntype NullTabGeneratorName = \"NullTabGenerator\";\nexport const Name: NullTabGeneratorName = \"NullTabGenerator\";\n\n/** This generator doesn't take any special config */\nexport interface NullTabGeneratorConfig extends GeneratorConfig {\n  name: NullTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const NullTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"None\",\n  description: \"Do not generate tabs. All pieces have straight edges.\",\n  sortHint: 3,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/** Tab generator that does nothing, piece edges remain straight lines */\nexport const NullTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, _config: NullTabGeneratorConfig) => {\n  const NullTabGenerator: TabGenerator = {\n    createTabSegments(_start: Vec2, _end: Vec2, _tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      return []; // does nothing\n    },\n  };\n  return NullTabGenerator;\n};\nexport default NullTabGeneratorFactory;\n\n// register the generator\nTabGeneratorRegistry.register(Name, NullTabGeneratorFactory, NullTabUIMetadata);\n\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, PathCommand, TabPlacement, RandomFn, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TriangleTabGeneratorName = \"TriangleTabGenerator\";\nexport const Name: TriangleTabGeneratorName = \"TriangleTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TriangleTabGeneratorConfig extends GeneratorConfig {\n  name: TriangleTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const TriangleTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Triangle\",\n  description: \"Creates a simple triangle between each (internal) piece edge.\",\n  sortHint: 2,\n  // these have to match the config above\n  controls: [],\n};\n\n/**\n * A simple TabGenerator that adds a triangular \"nub\" to an edge.\n *\n * This generator serves as a straightforward example of how to implement the\n * TabGenerator interface. It generates a three line segment that forms a\n * triangular tab.\n */\nexport const TriangleTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, _config: TriangleTabGeneratorConfig) => {\n\n  const TriangleTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      // 1. Calculate edge vectors from the provided start and end points.\n      const edgeVector: Vec2 = [end[0] - start[0], end[1] - start[1]];\n      const edgeLength = Math.hypot(edgeVector[0], edgeVector[1]);\n\n      // Return nothing for zero-length edges.\n      if (edgeLength < 1e-6) {\n        return [];\n      }\n\n      // Calculate a perpendicular vector (normal) to the edge.\n      const edgeDir: Vec2 = [edgeVector[0] / edgeLength, edgeVector[1] / edgeLength];\n      const normalDir: Vec2 = [-edgeDir[1], edgeDir[0]];\n\n      // 2. Calculate the position of the tab's peak.\n      // Find the midpoint of the edge segment this tab occupies.\n      const midPoint: Vec2 = [start[0] + edgeVector[0] / 2, start[1] + edgeVector[1] / 2];\n\n      // Determine the tab's direction from the `convex` property.\n      // `true` (outward) is a positive direction, `false` (inward) is negative.\n      const direction = tab.convex ? 1 : -1;\n\n      // The tab's height is defined by its `size` property (a fraction of the edge length).\n      const tabHeight = edgeLength * tab.size * direction;\n\n      // Calculate the nub point by moving from the midpoint along the normal.\n      const nubPoint: Vec2 = [\n        midPoint[0] + normalDir[0] * tabHeight,\n        midPoint[1] + normalDir[1] * tabHeight,\n      ];\n\n      // 3. Create the segments for the tab.\n      const result: EdgeSegment[] = [];\n      result.push({ type: 'line', p: start });\n      result.push({ type: 'line', p: nubPoint });\n      result.push({ type: 'line', p: end });\n\n      return result;\n    },\n  };\n  return TriangleTabGenerator;\n};\nexport default TriangleTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TriangleTabGeneratorFactory, TriangleTabUIMetadata);\n","// Main puzzle generator page component\nimport m from 'mithril';\n\n// UI parts\nimport PuzzleRenderer from '../ui/PuzzleRenderer';\nimport DownloadPuzzleButton from '../ui/DownloadPuzzleButton';\nimport GeometryCheckIndicator from '../ui/GeometryCheckIndicator';\nimport UploadImageButton from '../ui/UploadImageButton';\nimport GeneratorPicker from '../ui/GeneratorPicker';\nimport NumberInputControl from '../ui/inputs/NumberInputControl';\nimport BooleanInputControl from '../ui/inputs/BooleanInputControl';\nimport AspectRatioPicker from '../ui/AspectRatioPicker';\nimport ColorPicker from '../ui/ColorPicker';\nimport BorderShapePicker, { type BorderShapeType } from '../ui/BorderShapePicker';\nimport WhimsyEditor from '../ui/WhimsyEditor';\nimport WhimsyManager from '../ui/WhimsyManager';\n\n// geometry parts\nimport type { CustomPiece, PuzzleGeometry, PathCommand } from '../geometry/types';\nimport type { GeneratorConfig, GeneratorName, GeneratorRegistry } from '../geometry/generators/Generator';\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabPlacementStrategyRegistry, TabGeneratorRegistry } from '../geometry/generators/Generator';\nimport { Name as PoissonGeneratorName } from '../geometry/generators/point/PoissonPointGenerator';\nimport { Name as VoronoiGeneratorName } from '../geometry/generators/piece/VoronoiPieceGenerator';\nimport { Name as SimpleTabPlacementStrategyName } from '../geometry/generators/tab_placement/SimpleTabPlacementStrategy';\nimport { Name as TraditionalTabGeneratorName } from '../geometry/generators/tab/TraditionalTabGenerator';\nimport { buildPuzzle, rebuildPuzzleWithUpdatedSeedPoint } from '../geometry/PuzzleMaker';\nimport { checkGeometryInWorker } from '../geometry/GeometryChecker';\nimport { createRectangleBorder, createCircleBorder, createEllipseBorder, createRoundedRectBorder } from '../geometry/borderShapes';\nimport { createInitialTransform } from '../geometry/customPieces';\n\n// register generators (side-effect imports)\nimport \"../geometry/generators/point/GridJitterPointGenerator\";\nimport \"../geometry/generators/point/PoissonPointGenerator\";\nimport \"../geometry/generators/piece/VoronoiPieceGenerator\";\nimport \"../geometry/generators/piece/RectangularPieceGenerator\";\nimport \"../geometry/generators/tab_placement/SimpleTabPlacementStrategy\";\nimport \"../geometry/generators/tab/NullTabGenerator\";\nimport \"../geometry/generators/tab/TriangleTabGenerator\";\nimport \"../geometry/generators/tab/TraditionalTabGenerator\";\n\n// Web Awesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\n// CSS for this page\nimport './PuzzlePage.css';\n\n// detect light/dark mode\nlet isDarkMode = false;\nconst darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\nif (darkModeQuery.matches) {\n  isDarkMode = true;\n}\n\n// component that draws the puzzle generator page\nexport const PuzzlePage: m.ClosureComponent<unknown> = () => {\n\n  const defaultWidth = 800;\n  const defaultHeight = 600;\n\n  const defaultPointGenerator = PoissonGeneratorName;\n  const defaultPieceGenerator = VoronoiGeneratorName;\n  const defaultTabGenerator = TraditionalTabGeneratorName;\n\n  /** State tracked for each type of generator */\n  interface GeneratorState<C extends GeneratorConfig = GeneratorConfig> {\n    label: string;\n    registry: GeneratorRegistry<unknown>;\n    name : GeneratorName;\n    config: C;\n  }\n\n  interface PageState {\n    /** Random seed */\n    seed: number;\n    /** Width of canvas in pixels */\n    canvasWidth: number;\n    /** Height of canvas in pixels */\n    canvasHeight: number;\n    /** Aspect ratio of canvas, width/height */\n    aspectRatio: number;\n    /** Minimum distance between control points (pixels) */\n    distance: number;\n    /** Color of pieces */\n    color: string;\n    /** Should we draw the seed points? */\n    drawPoints: boolean;\n    /** Color of seed points */\n    pointColor: string;\n    /** Selected border shape */\n    borderShape: BorderShapeType;\n    /** Corner radius for rounded rectangle (pixels) */\n    borderCornerRadius: number;\n    /** Problems found by the geometry check algorithms */\n    geometryProblems: {\n      /** If true, the geometry will be re-checked whenever a new puzzle is generated */\n      autoCheck: boolean;\n      /** Count of problems found in the last check */\n      problems?: number;\n      /** Percent complete of in-progress geometry check */\n      progress?: number;\n    },\n    /** Dirty flag that keeps us from hitting the puzzle generation function too hard */\n    dirty: boolean;\n    /** Currently selected and configured generators for each part of puzzle generation */\n    generators: Record<string, GeneratorState>;\n    /** Generated puzzle geometry */\n    puzzle?: PuzzleGeometry;\n    /** User uploaded image */\n    backgroundImageUrl?: string;\n    /** Name of uploaded image */\n    backgroundImageName: string;\n    /** Custom pieces defined for this puzzle */\n    customPieces: CustomPiece[];\n    /** ID of the currently selected custom piece in the manager */\n    selectedCustomPieceId?: string | null;\n    /** Whether the custom piece editor is currently open */\n    customPieceEditorOpen: boolean;\n    /** ID of the custom piece being edited, or undefined if creating new */\n    editingCustomPieceId?: string;\n  };\n\n  // component state\n  const state: PageState = {\n    seed: new Date().getTime() % 10240,\n    canvasWidth: defaultWidth,\n    canvasHeight: defaultHeight,\n    aspectRatio: defaultWidth / defaultHeight,\n    distance: 40,\n    color: isDarkMode ? \"#DDDDDD\" : \"#333333\",\n    drawPoints: false,\n    pointColor: isDarkMode ? \"#FF0000\" : \"#0000FF\",\n    borderShape: 'rectangle',\n    borderCornerRadius: 50,\n    geometryProblems: {\n      autoCheck: false,\n      problems: undefined,\n      progress: undefined,\n    },\n    dirty: true,\n    generators: {\n      /** Strategy for creating points (which influences piece generation) */\n      point: {\n        label: \"Seed Points\",\n        registry: PointGeneratorRegistry,\n        name: defaultPointGenerator,\n        config: PointGeneratorRegistry.getDefaultConfig(defaultPointGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for turning points into puzzle pieces */\n      piece: {\n        label: \"Piece Generation\",\n        registry: PieceGeneratorRegistry,\n        name: defaultPieceGenerator,\n        config: PieceGeneratorRegistry.getDefaultConfig(defaultPieceGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for placing tabs on piece edges */\n      placement: {\n        label: \"Tab Placement\",\n        registry: TabPlacementStrategyRegistry,\n        name: SimpleTabPlacementStrategyName,\n        config: TabPlacementStrategyRegistry.getDefaultConfig(SimpleTabPlacementStrategyName, defaultWidth, defaultHeight),\n      },\n      /** Style of tabs to generate */\n      tab: {\n        label: \"Tabs\",\n        registry: TabGeneratorRegistry,\n        name: defaultTabGenerator,\n        config: TabGeneratorRegistry.getDefaultConfig(defaultTabGenerator, defaultWidth, defaultHeight),\n      },\n    },\n    puzzle: undefined,\n    backgroundImageUrl: undefined,\n    backgroundImageName: '',\n    customPieces: [],\n    selectedCustomPieceId: null,\n    customPieceEditorOpen: false,\n    editingCustomPieceId: undefined,\n  };\n\n  // utility to create border based on selected shape\n  function createBorder(): import('../geometry/types').PathCommand[] {\n    const { canvasWidth, canvasHeight, borderShape, borderCornerRadius } = state;\n\n    switch (borderShape) {\n    case 'rectangle':\n      return createRectangleBorder(canvasWidth, canvasHeight);\n    case 'circle':\n      // Use the smaller dimension to ensure the circle fits\n      return createCircleBorder(Math.min(canvasWidth, canvasHeight));\n    case 'ellipse':\n      return createEllipseBorder(canvasWidth, canvasHeight);\n    case 'rounded-rect':\n      return createRoundedRectBorder(canvasWidth, canvasHeight, borderCornerRadius);\n    default:\n      return createRectangleBorder(canvasWidth, canvasHeight);\n    }\n  }\n\n  // utility to open the custom piece editor\n  function handleOpenCustomPieceEditor() {\n    state.customPieceEditorOpen = true;\n    state.editingCustomPieceId = undefined;\n    m.redraw();\n  }\n\n  // utility to handle saving a custom piece\n  function handleSaveCustomPiece(path: PathCommand[], name?: string) {\n    const now = new Date().toISOString();\n\n    // Check if we're editing an existing piece\n    if (state.editingCustomPieceId) {\n      // Update existing piece\n      state.customPieces = state.customPieces.map((piece) => {\n        if (piece.id === state.editingCustomPieceId) {\n          return {\n            ...piece,\n            name,\n            path,\n            modified: now,\n          };\n        }\n        return piece;\n      });\n    } else {\n      // Create new piece with initial transform that centers and scales it\n      const newPiece: CustomPiece = {\n        id: `custom-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        name,\n        path,\n        transform: createInitialTransform(\n          path,\n          state.canvasWidth,\n          state.canvasHeight,\n          state.distance // target piece size\n        ),\n        created: now,\n      };\n\n      state.customPieces = [...state.customPieces, newPiece];\n    }\n\n    state.customPieceEditorOpen = false;\n    state.editingCustomPieceId = undefined;\n    state.dirty = true;\n    m.redraw();\n  }\n\n  // utility to handle canceling custom piece editor\n  function handleCancelCustomPieceEditor() {\n    state.customPieceEditorOpen = false;\n    state.editingCustomPieceId = undefined;\n    m.redraw();\n  }\n\n  // WhimseyManager callbacks\n  function handleSelectCustomPiece(id: string | null) {\n    state.selectedCustomPieceId = id;\n    m.redraw();\n  }\n\n  function handleEditCustomPiece(id: string) {\n    const piece = state.customPieces.find((p) => p.id === id);\n    if (piece) {\n      state.editingCustomPieceId = id;\n      state.customPieceEditorOpen = true;\n      m.redraw();\n    }\n  }\n\n  function handleDuplicateCustomPiece(id: string) {\n    const piece = state.customPieces.find((p) => p.id === id);\n    if (piece) {\n      const now = new Date().toISOString();\n      const duplicateName = piece.name\n        ? ((): string => {\n          // If name already ends with \" (N)\", increment N\n          const copyPattern = /^(.*?)\\s*\\((\\d+)\\)$/;\n          const match = piece.name.match(copyPattern);\n          if (match) {\n            const baseName = match[1];\n            const number = parseInt(match[2], 10);\n            return `${baseName} (${number + 1})`;\n          }\n          // Otherwise, add \" (2)\"\n          return `${piece.name} (2)`;\n        })()\n        : undefined;\n\n      const duplicatedPiece: CustomPiece = {\n        id: `custom-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n        name: duplicateName,\n        path: [...piece.path],\n        transform: {\n          position: [piece.transform.position[0] + 20, piece.transform.position[1] + 20],\n          rotation: piece.transform.rotation,\n          scale: [...piece.transform.scale],\n        },\n        created: now,\n      };\n\n      state.customPieces = [...state.customPieces, duplicatedPiece];\n      state.selectedCustomPieceId = duplicatedPiece.id;\n      state.dirty = true;\n      m.redraw();\n    }\n  }\n\n  function handleDeleteCustomPiece(id: string) {\n    state.customPieces = state.customPieces.filter((p) => p.id !== id);\n    if (state.selectedCustomPieceId === id) {\n      state.selectedCustomPieceId = null;\n    }\n    state.dirty = true;\n    m.redraw();\n  }\n\n  function handlePositionCustomPiece(id: string) {\n    // TODO: This will be implemented in Phase 5\n    // For now, just show a message\n    console.log(`Position custom piece: ${id}`);\n    alert('Whimsy positioning functionality will be available in Phase 5');\n  }\n\n  // utility to invoke the geometry checks\n  function handleCheckGeometry() {\n    if (!state.puzzle) return;\n\n    state.geometryProblems.progress = 0;\n    m.redraw();\n\n    // this uses a web worker to not block the main thread\n    checkGeometryInWorker(state.puzzle, (processed, total) => {\n      state.geometryProblems.progress = (processed / total) * 100;\n      m.redraw();\n    }).then((problems) => {\n      state.geometryProblems.problems = problems.length;\n      state.geometryProblems.progress = undefined;\n      if (state.puzzle) {\n        state.puzzle.problems = problems;\n      }\n      m.redraw();\n    }).catch((err) => {\n      state.geometryProblems.progress = undefined;\n      console.error(err);\n      m.redraw();\n    });\n  }\n\n  // Mithril component\n  return {\n\n    oncreate: () => {\n      buildPuzzle({\n        bounds: {\n          width: state.canvasWidth,\n          height: state.canvasHeight,\n        },\n        border: createBorder(),\n        pieceSize: state.distance,\n        pointConfig: state.generators.point.config,\n        pieceConfig: state.generators.piece.config,\n        placementConfig: state.generators.placement.config,\n        tabConfig: state.generators.tab.config,\n        seed: state.seed,\n        customPieces: state.customPieces,\n      }).then((puzzle) => {\n        state.puzzle = puzzle;\n        m.redraw();\n        if (state.geometryProblems.autoCheck) {\n          handleCheckGeometry();\n        }\n      }).catch((err) => {\n        console.error(err);\n      });\n    },\n\n    onupdate: () => {\n      if (state.dirty) {\n        state.dirty = false;\n        // rebuild the puzzle geometry\n        buildPuzzle({\n          bounds: {\n            width: state.canvasWidth,\n            height: state.canvasHeight,\n          },\n          border: createBorder(),\n          pieceSize: state.distance,\n          pointConfig: state.generators.point.config,\n          pieceConfig: state.generators.piece.config,\n          placementConfig: state.generators.placement.config,\n          tabConfig: state.generators.tab.config,\n          seed: state.seed,\n          customPieces: state.customPieces,\n        }).then((puzzle) => {\n          state.geometryProblems.problems = undefined;\n          state.geometryProblems.progress = undefined;\n          state.puzzle = puzzle;\n          m.redraw();\n          if (state.geometryProblems.autoCheck) {\n            handleCheckGeometry();\n          }\n        }).catch((err) => {\n          console.error(err);\n        });\n      }\n    },\n\n    onremove: () => {\n      if (state.backgroundImageUrl) {\n        // clean up memory\n        URL.revokeObjectURL(state.backgroundImageUrl);\n        state.backgroundImageUrl = undefined;\n      }\n    },\n\n    // component lifecycle: render our output\n    view: () => {\n\n      return m(\".page\", [\n        m(\"h1\", \"Puzzle Generator\"),\n        m(\".container\", [\n\n          state.puzzle && m('.puzzle-stack', [\n\n            // main puzzle display\n            m(PuzzleRenderer, {\n              width: state.canvasWidth,\n              height: state.canvasHeight,\n              color: state.color,\n              imageUrl: state.backgroundImageUrl,\n              puzzle: state.puzzle,\n              isDirty: state.dirty,\n              pointColor: state.drawPoints ? state.pointColor : undefined,\n              customPieces: state.customPieces,\n              selectedCustomPieceId: state.selectedCustomPieceId,\n              onPuzzleChanged: (puzzle) => {\n                // user dragged a vertex to tweak the puzzle\n                state.puzzle = puzzle;\n                m.redraw();\n              },\n              onCustomPieceSelected: (id) => {\n                state.selectedCustomPieceId = id;\n                m.redraw();\n              },\n              onCustomPieceTransformed: (id, transform) => {\n                // Update the custom piece's transform\n                state.customPieces = state.customPieces.map((piece) =>\n                  piece.id === id ? { ...piece, transform } : piece\n                );\n\n                // Trigger puzzle regeneration with updated custom pieces\n                state.dirty = true;\n                m.redraw();\n\n                buildPuzzle({\n                  bounds: {\n                    width: state.canvasWidth,\n                    height: state.canvasHeight,\n                  },\n                  border: createBorder(),\n                  seed: state.seed,\n                  pieceSize: state.distance,\n                  pointConfig: state.generators.point.config,\n                  pieceConfig: state.generators.piece.config,\n                  placementConfig: state.generators.placement.config,\n                  tabConfig: state.generators.tab.config,\n                  customPieces: state.customPieces,\n                }).then((puzzle) => {\n                  state.geometryProblems.problems = undefined;\n                  state.geometryProblems.progress = undefined;\n                  state.puzzle = puzzle;\n                  state.dirty = false;\n                  m.redraw();\n\n                  if (state.geometryProblems.autoCheck) {\n                    handleCheckGeometry();\n                  }\n                })\n                  .catch((err) => {\n                    console.error('Failed to rebuild puzzle with custom pieces:', err);\n                    state.dirty = false;\n                    m.redraw();\n                  });\n              },\n              onSeedPointMoved: (pieceId, newPosition) => {\n                // user dragged a seed point to a new position\n                state.dirty = false; // Prevent double-regeneration\n\n                if (!state.puzzle) return;\n\n                rebuildPuzzleWithUpdatedSeedPoint(state.puzzle, pieceId, newPosition)\n                  .then((puzzle) => {\n                    state.geometryProblems.problems = undefined;\n                    state.geometryProblems.progress = undefined;\n                    state.puzzle = puzzle;\n                    m.redraw();\n\n                    if (state.geometryProblems.autoCheck) {\n                      handleCheckGeometry();\n                    }\n                  })\n                  .catch((err) => {\n                    console.error('Failed to rebuild puzzle with updated seed point:', err);\n                  });\n              },\n            }),\n\n            m('.actions', [\n\n              // SVG download button\n              m(DownloadPuzzleButton, {\n                puzzle: state.puzzle,\n                width: state.canvasWidth,\n                height: state.canvasHeight,\n                color: state.color,\n              }),\n\n              // Geometry check display\n              m(GeometryCheckIndicator, {\n                autoCheck: state.geometryProblems.autoCheck,\n                problems: state.geometryProblems.problems,\n                progressPercent: state.geometryProblems.progress,\n                onCheckRequested: () => {\n                  if (!state.dirty) {\n                    handleCheckGeometry();\n                  }\n                  m.redraw();\n                },\n                onAutocheckChanged: (autocheck) => {\n                  if (autocheck !== state.geometryProblems.autoCheck) {\n                    state.geometryProblems.autoCheck = autocheck;\n                    m.redraw();\n                  }\n                },\n              }),\n\n            ]),\n          ]),\n\n          // puzzle generation controls\n          m(\".controls\", [\n\n            // background image\n            m('.background-image', [\n              m(UploadImageButton, {\n                label: \"Background Image\",\n                onUpload: (imageUrl, filename, width, height) => {\n                  // clear any previous image\n                  if (state.backgroundImageUrl) {\n                    URL.revokeObjectURL(state.backgroundImageUrl);\n                  }\n                  state.canvasWidth = width;\n                  state.canvasHeight = height;\n                  state.aspectRatio = width / height;\n                  state.backgroundImageUrl = imageUrl;\n                  state.backgroundImageName = filename;\n                  state.dirty = true;\n                  m.redraw();\n                },\n                onClear: () => {\n                  // clear any previous image\n                  if (state.backgroundImageUrl) {\n                    URL.revokeObjectURL(state.backgroundImageUrl);\n                  }\n                  state.backgroundImageUrl = undefined;\n                  state.backgroundImageName = '';\n                  state.dirty = true;\n                  m.redraw();\n                },\n              }),\n            ]),\n\n            // Puzzle aspect ratio\n            m(AspectRatioPicker, {\n              ratio: state.aspectRatio,\n              disabled: state.backgroundImageUrl !== undefined,\n              onChange: (ratio) => {\n                state.aspectRatio = ratio;\n                state.canvasWidth = state.canvasHeight * ratio;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Border shape\n            m(BorderShapePicker, {\n              shape: state.borderShape,\n              disabled: state.backgroundImageUrl !== undefined,\n              onChange: (shape) => {\n                state.borderShape = shape;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Corner radius for rounded rectangle\n            state.borderShape === 'rounded-rect' && m(NumberInputControl, {\n              config: {\n                name: 'cornerRadius',\n                label: 'Corner Radius',\n                type: 'number',\n              },\n              value: state.borderCornerRadius,\n              onChange: (value) => {\n                state.borderCornerRadius = value ?? 50;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Random number seed\n            m(NumberInputControl, {\n              config: {\n                name: 'seed',\n                label: 'Seed',\n                type: 'number',\n              },\n              value: state.seed,\n              onChange: (value) => {\n                state.seed = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece size\n            m(NumberInputControl, {\n              config: {\n                name: 'pieceSize',\n                label: 'Piece size',\n                type: 'number',\n              },\n              value: state.distance,\n              onChange: (value) => {\n                state.distance = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece color\n            m(ColorPicker, {\n              label: 'Piece color',\n              color: state.color,\n              size: \"small\",\n              onUpdate: (newColor) => {\n                state.color = newColor;\n                m.redraw();\n              },\n            }),\n\n            // draw seed points?\n            m('.draw-points', [\n              m(BooleanInputControl, {\n                config: {\n                  name: 'drawPoints',\n                  label: 'Draw seed points',\n                  type: 'boolean',\n                },\n                value: state.drawPoints,\n                onChange: (value) => {\n                  state.drawPoints = value;\n                  m.redraw();\n                },\n              }),\n              state.drawPoints && m(ColorPicker, {\n                label: 'Seed points color',\n                color: state.pointColor,\n                size: \"small\",\n                onUpdate: (newColor) => {\n                  state.pointColor = newColor;\n                  m.redraw();\n                },\n              }),\n            ]),\n\n            // Whimsies section\n            m(WhimsyManager, {\n              pieces: state.customPieces,\n              selectedPieceId: state.selectedCustomPieceId,\n              pieceColor: state.color,\n              onAdd: handleOpenCustomPieceEditor,\n              onSelect: handleSelectCustomPiece,\n              onEdit: handleEditCustomPiece,\n              onDuplicate: handleDuplicateCustomPiece,\n              onDelete: handleDeleteCustomPiece,\n              onPosition: handlePositionCustomPiece,\n            }),\n\n            // render a generator picker for each type of generator\n            ...Object.entries(state.generators).map(([type, generator]) => {\n              return m(\"label\", [\n                generator.label + ':',\n                m(GeneratorPicker, {\n                  generator: generator.name,\n                  registry: generator.registry,\n                  config: generator.config,\n                  onGeneratorChange: (generatorName) => {\n                    if (generatorName != generator.name) {\n                      console.log(`${type} generator changed to ${generatorName}`);\n                      generator.name = generatorName;\n                      // generator changed, we need a new blank config\n                      state.generators[type].config = generator.registry.getDefaultConfig(generatorName, state.canvasWidth, state.canvasHeight);\n                      state.dirty = true;\n                      m.redraw();\n                    }\n                  },\n                  onConfigChange: (key, value) => {\n                    console.log(`${type} generator config \"${key}\" changed to ${String(value)}`);\n                    generator.config[key] = value;\n                    state.dirty = true;\n                    m.redraw();\n                  },\n                }),\n              ]);\n            }),\n\n          ]), // .controls\n\n        ]), // .container\n\n        // Custom Piece Editor Modal\n        m(WhimsyEditor, {\n          open: state.customPieceEditorOpen,\n          piece: state.editingCustomPieceId\n            ? state.customPieces.find((p) => p.id === state.editingCustomPieceId)\n            : undefined,\n          onSave: handleSaveCustomPiece,\n          onCancel: handleCancelCustomPieceEditor,\n        }),\n\n      ]);\n    }, // view()\n  };\n};\n\nexport default PuzzlePage;\n","// Application entry point with routing\nimport m from 'mithril';\n\n// UI parts\nimport GitHubCorner from './ui/GitHubCorner';\n\n// Pages\nimport PuzzlePage from './pages/PuzzlePage';\n\n// Webawesome components\nimport { registerIconLibrary } from '@awesome.me/webawesome/dist/webawesome.js';\nimport \"@awesome.me/webawesome/dist/styles/themes/default.css\";\n\n// CSS for this component\nimport './index.css';\n\n// Lit (used by Web Awesome components) generates spurious update warnings in development mode only\n// this does not affect production builds\nif (import.meta.env.DEV) {\n  console.log('silencing lit update warnings');\n  const { LitElement } = await import('lit');\n  LitElement.disableWarning?.('change-in-update');\n}\n\n\n// detect light/dark mode\nfunction configureDarkLightTheme() {\n  const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n  function manageDarkLightTheme() {\n    if (darkModeQuery.matches) {\n      document.documentElement.classList.add('wa-dark');\n    } else {\n      document.documentElement.classList.remove('wa-dark');\n    }\n  }\n  manageDarkLightTheme();\n  darkModeQuery.addEventListener('change', manageDarkLightTheme);\n}\nconfigureDarkLightTheme();\n\n// Layout component that wraps all pages with navigation and GitHub corner\nconst Layout: m.Component = {\n  view: () => {\n    return [\n      m(GitHubCorner, {\n        link: \"https://github.com/weevilgenius/puzzle-generator\",\n      }),\n      // m(Navigation),\n      // vnode.children,\n      m(PuzzlePage),\n    ];\n  },\n};\n\n// Configure Webawesome icons to use Material Symbols\nregisterIconLibrary('material', {\n  resolver: (name) => {\n    const match = name.match(/^(.*?)(_(rounded|sharp))?$/);\n    if (match) {\n      return `https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${match[3] ?? 'outlined'}/${match[1]}.svg`;\n    }\n    return '';\n  },\n  mutator: (svg) => svg.setAttribute('fill', 'currentColor'),\n});\n\n// Ask Mithril to render the page, our componet gets placed into the root element.\n// Mithril will rerender automatically after DOM event handlers defined in component\n// views and also whenever m.redraw() is called.\nm.mount(document.body, Layout);\n\n// optional routing for multiple pages\n// m.route(document.body, \"/\", {\n//   \"/\": {\n//     render: () => m(Layout, m(PuzzlePage)),\n//   },\n//   \"/test\": {\n//     render: () => m(Layout, m(TestPage)),\n//   },\n// });\n"],"names":["GitHubCorner","attrs","m","REGENERATION_THROTTLE_MS","HOVER_DISTANCE","HOVER_DISTANCE_SQ","MIN_ZOOM","MAX_ZOOM","DEFAULT_ZOOM","ZOOM_STEP","PRESET_ZOOM_LEVELS","PRESET_ZOOM_LABELS","assertPaperReady","scope","tag","ok","withPaper","S","label","fn","e","createPaperContext","canvas","width","height","PaperCore","paperPathToPathCommands","path","commands","firstSegment","moveTo","i","prevSegment","segment","p1","p2","curveTo","lineTo","lastSegment","pathCommandsToPaperPath","ctx","paperScope","currentPoint","command","x","y","cp1x","cp1y","cp2x","cp2y","endPoint","cp1","cp2","handleIn","handleOut","drawPuzzleWithPaper","puzzle","strokeColor","group","borderPath","piece","piecePath","createPiecePath","currentHe","startHeId","addSegmentToPaperPath","nextHe","drawSeedPoints","color","circle","drawProblems","problemPoint","measureSync","measureAsync","initializePaper","state","renderPuzzle","pointColor","createVertexItems","createPaperLayers","updateBackgroundImage","imageUrl","raster","scaleX","scaleY","getBoundaryEdgeVertexIds","boundaryVertexIds","halfEdge","vertexIndex","v","pathCommandsToPath","renderCustomPieces","customPieces","selectedCustomPieceId","customPiece","position","rotation","scale","matrix","renderCustomPieceHandles","tempPath","baseBounds","transformedCorners","corner","scaledX","scaledY","cos","sin","rotatedX","rotatedY","bbox","handleRadius","cornerTypes","index","handle","rotationHandleDistance","centerTop","scaledCenterTopX","scaledCenterTopY","rotatedCenterTopX","rotatedCenterTopY","rotationHandleBase","offsetX","offsetY","rotatedOffsetX","rotatedOffsetY","rotationHandlePos","rotationLine","rotationHandle","clearCustomPieceHandles","cleanupPaper","GeneratorRegistry","name","factory","uiMetadata","border","bounds","config","generator","a","b","g","newConfig","metadata","control","PointGeneratorRegistry","PieceGeneratorRegistry","TabPlacementStrategyRegistry","TabGeneratorRegistry","id","getUniqueId","abs","acos","atan2","sqrt","pow","crt","pi","tau","quart","epsilon","nMax","nMin","ZERO","utils","t","derivativeFn","d","l","points","_3d","order","mt","p","ret","mt2","t2","c","dCpts","ratios","r","f1","f2","f3","f4","dpoints","list","j","dpt","M","precision","len","sum","ds","de","ts","te","d1","d2","v2","v1","s","obj","o","dx1","dy1","dx2","dy2","cross","dot","pos","dx","dy","LUT","point","mdist","mpos","idx","bottom","top","x1","y1","x2","y2","x3","y3","x4","y4","nx","ny","p3","p4","Bezier","sections","mx","my","MX","MY","s1","bbox1","s2","bbox2","curveIntersectionThreshold","intersections","a1","a2","l1","l2","iss","forward","back","bpl","fpl","start","end","shape","curve","min","max","line","tx","ty","aligned","reduce","m1","m2","pa","pb","pc","pd","q","q2","discriminant","u1","mp3","mp33","cosphi","phi","crtr","t1","sd","kOnly","num","dnm","adk","dk","k","dd","qdsum","pk","nk","v3","trm","sq","b1","b2","dims","dim","_bbox","c1","c2","c1b","c2b","threshold","cc1","cc2","pairs","pair","results","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","_","PolyBezier","curves","offset","coords","args","coordlen","newargs","higher","step","baselength","abc","B","E","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","A","nc1","nc2","last","print","angle","u","um","C","steps","error","lut","hits","closest","ft","np","pim","r1","r2","q1","R","_p","pt","result","roots","mfn","extrema","lbbox","tbbox","n","nv","n1","n2","pass1","pass2","distanceFn","clockwise","ov","rc","d3","d4","mid","fline","bline","ls","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","fs","fe","bs","be","outline","shapes","left","right","errorThreshold","np1","ref","circles","t_s","t_e","safety","np2","np3","prev_arc","curr_good","prev_good","done","t_m","prev_e","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_i","_s","err","TAU","mapToEllipse","_ref","rx","ry","sinphi","centerx","centery","xp","yp","approxUnitArc","ang1","ang2","vectorAngle","ux","uy","vx","vy","sign","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","_ref2","_ref2$xAxisRotation","xAxisRotation","_ref2$largeArcFlag","_ref2$sweepFlag","lambda","_getArcCenter","_getArcCenter2","ratio","_mapToEllipse","_mapToEllipse2","_mapToEllipse3","DEFAULT_COMPARE","SplayTree","compare","noDuplicates","gp","ggp","key","data","z","comp","cmp","node","comparator","sMax","returnValue","successor","predecessor","callback","current","low","high","Q","keys","values","presort","size","sort","loadRecursive","parent","middle","pivot","tmp","NORMAL","NON_CONTRIBUTING","SAME_TRANSITION","DIFFERENT_TRANSITION","INTERSECTION","UNION","DIFFERENCE","XOR","computeFields","event","prev","operation","inResult","determineResultTransition","thisIn","thatIn","isIn","SweepEvent","otherEvent","isSubject","edgeType","p0","copy","equals","splitter","resulterrbound","elen","flen","f","h","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","C1","C2","D","orient2dadapt","ax","ay","bx","by","detsum","acxtail","acytail","bcxtail","bcytail","ahi","alo","bhi","blo","_j","_0","s0","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","signedArea","res","compareEvents","specialCases","divideSegment","se","queue","crossProduct","dotProduct","intersection$1","noEndpointTouch","va","vb","toPoint","kross","sqrKross","sqrLenA","sa","sb","smin","smax","possibleIntersection","se1","se2","inter","intersection","nintersections","events","leftCoincide","rightCoincide","compareSegments","le1","le2","subdivide","eventQueue","subject","clipping","sbbox","cbbox","sweepLine","Tree","sortedEvents","rightbound","next","begin","prevEvent","prevprevEvent","prevprev","Contour","orderEvents","resultEvents","sorted","nextPos","processed","origPos","newPos","length","initializeContourFromContext","contours","contourId","contour","prevInResult","lowerContourId","lowerContour","parentContourId","connectEdges","markAsProcessed","initial","tinyqueueModule","TinyQueue","defaultCompare","item","halfLength","best","processPolygon","contourOrHole","depth","isExteriorRing","fillQueue","Queue","polygonSet","ii","jj","EMPTY","trivialOperation","compareBBoxes","boolean","trivial","subdivideSegments","polygons","rings","holeId","union","diff","distanceSq","serializeTopology","topology","doAABBsIntersect","calculateSegmentsBounds","startPoint","xmin","ymin","xmax","ymax","updateBounds","getPieceBounds","minX","minY","maxX","maxY","startingEdgeId","currentEdge","segmentBounds","polygonBounds","polygon","arePointsEqual","polygonArea","area","calculateCentroid","acc","extractPiecePolygon","vertices","currentHeId","he","collectPieceHalfEdges","halfEdges","getPieceNeighbors","proximityThreshold","neighbors","twin","neighborPiece","edgeLength","currentLength","piecePolygon","pieceBounds","candidateId","candidate","candidatePolygon","sharedEdgeLength","vertex","distanceToSegment","edgeLen","isAdjacentToCustomPiece","customPolygon","segStart","segEnd","lengthSq","projX","projY","mergePieces","pieceAId","pieceBId","halfEdgeTwinMap","isBoundaryEdgeFn","pieceA","pieceB","polyA","polyB","martinezA","martinezB","martinez.union","mergedPolygon","isMartinezPolygon","firstPolygon","halfEdgesToRemove","selfKey","nextOfTwin","edgeKey","edgeId","edge","boundaryIndex","newHalfEdges","createHalfEdgeLoop","linkAndCreateEdges","mergeFragmentsIntoNeighbors","minFragmentArea","fragmentsToMerge","mergedCount","fragment","areaA","areaB","targetPieceId","generateSegmentsForEdge","tabGenerator","random","heLeft","heRight","edgeStart","edgeEnd","heLeftSegments","currentPos","tab","tabStartPos","tabStartPoint","tabEndPoint","tabSegments","invertSegments","originalStart","inverted","segmentStart","arcToBeziers","radii","largeArc","sweep","startX","startY","endX","endY","flattenBoundary","boundary","currentPolygon","beziers","arcStartPoint","isPointInBoundary","excludeVertices","insideCount","poly","isPointInPolygon","geometry","clipPolygonAgainstBoundary","clipper","clipped","martinez.intersection","isInside","xi","yi","xj","yj","pieceId","numEdges","nextIndex","prevIndex","PROXIMITY_THRESHOLD","twinKey","twinId","mapKey","candidateHe","twinHe","fitPathToCanvas","canvasWidth","canvasHeight","padding","cmd","pathWidth","pathHeight","availableWidth","availableHeight","scaledWidth","scaledHeight","transformedCommands","mulberry32","seed","buildPuzzle","options","pieceSize","pointConfig","pieceConfig","placementConfig","tabConfig","pointGenerator","pieceGenerator","placementStrategy","rebuildPuzzleWithUpdatedSeedPoint","originalPuzzle","newSeedPosition","updatedPoints","pointIndex","createRectangleBorder","createCircleBorder","diameter","radius","center","createEllipseBorder","radiusX","radiusY","createRoundedRectBorder","cornerRadius","maxRadius","moveVertex","oldPos","departingEdges","affectedPieceIDs","delta","departingEdge","predecessorEdge","regenerateAffectedTabs","affectedEdges","movedVertexPos","halfEdgeToEdgeMap","destinationVertex","parentEdge","affectedPieces","he1","he2","keyDownHandler","keyUpHandler","wheelHandler","panMouseDownHandler","panMouseMoveHandler","panMouseUpHandler","isPanningWithRawEvents","lastPanPoint","setupPanZoomHandling","onZoomChanged","target","updateCursor","newZoom","mousePos","viewPos","zoomFactor","scaledDx","scaledDy","cleanupPanZoomHandling","findVertexCircle","vertexItems","vertexId","child","getViewPoint","rect","clientX","clientY","touch","pointToVec2","regeneratePuzzleWithoutTabs","newPosition","previewPuzzle","handleMouseMove","viewPoint","isNearItem","closestVertexId","closestDistSq","distSq","prevCircle","newCircle","handleCustomPieceDragMove","deltaX","deltaY","newTransform","angleDelta","initialDistance","scaleFactor","updatedPieces","updatedPiece","handleDragStart","handleHit","handleType","docEvent","mithrilEvent","handleDragMove","handleDragEnd","customPieceHit","clickedPieceId","seedHit","vertexHit","now","wasDraggingCustomPiece","wasDraggingVertex","wasDraggingSeedPoint","finalTransform","finalPosition","PuzzleRenderer","setZoom","recenter","getZoomPercentage","previousImageUrl","dom","selectedPiece","currentZoomStr","selectedValue","level","createSVG","pieceColor","pathData","destination","pathD","downloadSvg","svg","filename","blob","url","DownloadPuzzleButton","GeometryCheckIndicator","showProgress","showOKBadge","showProblemBadge","checkbox","calculateDisplayDimensions","originalWidth","originalHeight","maxWidth","aspectRatio","UploadImageButton","file","bitmap","uploadUrl","BooleanInputControl","newValue","ChoiceInputControl","selectOptions","value","currentValue","selectedChoiceHelpText","NumberInputControl","input","RangeInputControl","StringInputControl","shouldShowControl","dep","GeneratorPicker","generators","newSelected","panel","commonAspectRatios","AspectRatioPicker","isCustom","ratioStr","range","ColorPicker","borderShapes","BorderShapePicker","HIT_TOLERANCE","DEFAULT_STROKE_COLOR","DEFAULT_STROKE_WIDTH","PREVIEW_STROKE_COLOR","PREVIEW_STROKE_WIDTH","PREVIEW_DASH_ARRAY","DRAG_HANDLE_MULTIPLIER","SNAP_THRESHOLD","SNAP_INDICATOR_RADIUS","SNAP_INDICATOR_COLOR","SNAP_INDICATOR_WIDTH","mouseDownHandler","mouseMoveHandler","mouseUpHandler","setupMouseHandling","onPathChanged","tool","handleDrawModeDown","handleEditModeDown","handleDrawModeDrag","handleEditModeDrag","previewSegment","newSegment","previewPrevSegment","updatePreviewPath","cleanupMouseHandling","pointC","vectorCD","handleCOut","handleCIn","handleBOut","segmentB","vectorBC","tangentDir","handleOutLength","segmentA","firstSeg","curveSegment","lastPoint","firstPoint","strokeHit","location","segmentHit","type","PathEditor","previousInitialPath","hasInitialPath","loadedPath","notifyPathChanged","endDrawing","cleanup","prevLength","currLength","applyTransformToPoint","transform","centeredX","centeredY","translatedX","translatedY","flattenPath","tolerance","t3","mt3","customPieceToPolygon","basePolygon","checkCustomPieceOverlap","cell","overlapping","cellBounds","customBounds","hasOverlap","subtractCustomPieces","customMartinez","martinez.diff","outerRing","createPieceFromCustom","custom","centroid","site","computePathBounds","createInitialTransform","targetPieceSize","maxDimension","isPathClosed","segmentIntersection","denom","arePointsClose","segmentsShareEndpoint","findSelfIntersections","endpointTolerance","validateCustomPiece","errors","foundIntersections","parseSVGFile","svgContent","doc","parserError","pathElement","dAttr","parseSVGPath","hasMultipleSubpaths","tokens","currentX","currentY","lastControlX","lastControlY","lastCommand","isFirstMoveTo","parseNumber","isRelative","cpx","cpy","Dialog","syncOpenProp","want","notify","open","handleAfterShow","handleAfterHide","children","WhimsyEditor","fileInputRef","initializeState","handlePathChanged","newPath","validationResult","handleNameChanged","newName","handleSave","handleSVGUpload","files","editorWidth","editorHeight","reader","parseResult","fittedPath","nameWithoutExtension","currentPieceId","dialogJustOpened","pieceChanged","vnode","generateCustomPieceThumbnail","calculatePathBounds","CustomPieceTile","confirm","opts","host","resolved","resolveOnce","resolver","Shell","close","pendingResolve","WhimsyManager","thumbnailCache","getThumbnail","timestamp","cacheKey","thumbnail","hasSelection","isSelected","tinyNDArrayOfInteger","gridShape","dimensions","totalLength","stride","dimension","tinyNDArrayOfArray","tinyNdarray","sphereRandom","sampleSphere","rng","rr","theta","moore","neighbor","require$$0","getNeighbourhood","dimensionNumber","neighbourhood","origin","dist","squareDist1","squareDist2","neighbourhoodCache","getNeighbourhoodMemoized","tinyNDArray","require$$1","require$$2","squaredEuclideanDistance","point1","point2","FixedDensityPDS","maxShape","floatPrecisionMitigation","epsilonDistance","valid","internalArrayIndex","neighbourIndex","currentDimensionValue","existingPoint","tries","distance","newPoint","inShape","gridData","fixedDensity","euclideanDistance","VariableDensityPDS","existingPointDistance","pointDistance","minDistance","maxDistance","currentDistance","sampleIndex","variableDensity","PoissonDiskSampling","poissonDiskSampling","Name","PoissonPointUIMetadata","PoissonPointGeneratorFactory","_border","_bounds","_config","runtimeOpts","EPSILON","EDGE_STACK","Delaunator","getX","defaultGetX","getY","defaultGetY","maxTriangles","hullPrev","hullNext","hullTri","hullHash","i0","i1","i2","minDist","i0x","i0y","i1x","i1y","minRadius","circumradius","i2x","i2y","quicksort","hull","d0","circumcenter","hullSize","pseudoAngle","triangles","halfedges","ar","a0","b0","al","bl","pr","pl","inCircle","hbl","br","ex","ey","fx","fy","ap","bp","cp","cl","ids","dists","temp","tempDist","median","swap","Path","x0","y0","w","Polygon","Voronoi","delaunay","vectors","circumcenters","ab","context","buffer","inedges","ti","tj","h0","h1","c0","ci","cj","loop","ai","li","aj","lj","e0","V","P","sx0","sy0","sx1","sy1","flip","vx0","vy0","vxn","vyn","pointX","pointY","collinear","jitter","Delaunay","that","flatArray","flatIterable","hullIndex","_hullIndex","dc","dt","array","createBoundaryContext","createPieceFromPolygon","clipCellToBoundary","cellPolygon","boundaryContext","VoronoiPieceGeneratorUIMetadata","pointToKey","isPointNearBoundary","distanceToPolygon","adjustSeedPointsForWhimsies","eliminationThreshold","adjustedPoints","customPolygons","shouldKeep","voronoiCellToPolygon","voronoi","cellIndex","eliminateSeedsCausingSmallFragments","seedPoints","minFragmentSizeRatio","maxIterations","averagePieceArea","currentSeeds","totalEliminated","iteration","validSeeds","eliminatedCount","clippedCell","overlappingPieces","fragments","frag","VoronoiPieceGeneratorFactory","whimsyMode","eliminated","eliminatedPercent","totalEliminatedPercent","pieceIdCounter","clippedVertices","overlappingCustomPieces","remainingPolygons","pieceHalfEdges","vertexSet","SimpleTabPlacementStrategyUIMetadata","placeTabOnEdge","piece1","piece2","tabSize","SimpleTabPlacementStrategyFactory","minEdgeLength","maxTabSize","edges","TraditionalTabUIMetadata","createTraditionalTab","jitterPct","heightToWidthRatio","inward","dir","nubHeight","shoulder_height","bez1","bez2","bez3","TraditionalTabGeneratorFactory","checkGeometryInWorker","onProgress","resolve","reject","worker","CheckGeometryWorker","message","GridJitterPointUIMetadata","GridJitterPointGeneratorFactory","RectangularPieceGeneratorUIMetadata","RectangularPieceGeneratorFactory","_points","cols","rows","cellWidth","cellHeight","gridVertices","rowVertices","splitAtGridLines","int","gridSplitCustomPieces","cpPolygon","cpSplit","topLeft","topRight","bottomLeft","bottomRight","pieceVertices","overlappingPolygons","fragmentId","splitPolygon","totalPoints","NullTabUIMetadata","NullTabGeneratorFactory","_start","_end","_tab","_random","TriangleTabUIMetadata","TriangleTabGeneratorFactory","edgeVector","edgeDir","normalDir","midPoint","direction","tabHeight","nubPoint","isDarkMode","darkModeQuery","PuzzlePage","defaultPointGenerator","PoissonGeneratorName","defaultPieceGenerator","VoronoiGeneratorName","defaultTabGenerator","TraditionalTabGeneratorName","SimpleTabPlacementStrategyName","createBorder","borderShape","borderCornerRadius","handleOpenCustomPieceEditor","handleSaveCustomPiece","newPiece","handleCancelCustomPieceEditor","handleSelectCustomPiece","handleEditCustomPiece","handleDuplicateCustomPiece","duplicateName","copyPattern","match","baseName","number","duplicatedPiece","handleDeleteCustomPiece","handlePositionCustomPiece","handleCheckGeometry","total","problems","autocheck","newColor","generatorName","configureDarkLightTheme","manageDarkLightTheme","Layout","registerIconLibrary"],"mappings":"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","x_google_ignoreList":[9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,66,67,68,69,70,71,72,74,75,76,77,78,79,80]}