{"version":3,"file":"CheckGeometryWorker-B-2izMXZ.js","sources":["../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/utils.js","../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/poly-bezier.js","../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js","../node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js","../node_modules/.pnpm/tinyqueue@1.2.3/node_modules/tinyqueue/index.js","../src/geometry/utils.ts","../src/geometry/GeometryChecker.ts","../src/workers/CheckGeometryWorker.ts"],"sourcesContent":["import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexport default arcToBezier;","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","// this file contains various geometry-related utilities\nimport type {\n  AABB,\n  ArcTo,\n  CurveTo,\n  Edge,\n  EdgeID,\n  EdgeSegment,\n  HalfEdge,\n  HalfEdgeID,\n  PathCommand,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  RandomFn,\n  Vec2,\n  Vertex,\n  VertexID,\n} from \"./types\";\nimport { getUniqueId } from \"../utils/UniqueId\";\nimport { Bezier } from \"bezier-js\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\nimport * as martinez from 'martinez-polygon-clipping';\nimport type { TabGenerator } from \"./generators/tab/TabGenerator\";\n\n/**\n * Calculates the squared Euclidean distance between two points.\n * Used for efficient distance comparisons without the need for Math.sqrt().\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns The squared distance between the points.\n */\nexport function distanceSq(p1: Vec2, p2: Vec2): number {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\n\n/** Serializable version of PuzzleTopology */\nexport interface PuzzleTopologySerializable {\n  vertices: Vertex[];\n  pieces: [PieceID, Piece][];\n  edges: [EdgeID, Edge][];\n  halfEdges: [HalfEdgeID, HalfEdge][];\n  boundary: EdgeID[];\n  borderPath: PathCommand[];\n}\n\n/**\n * Converts a PuzzleTopology with Maps to a plain object representation. Note that\n * modern browsers support Map with structuredClone(), but older browsers do not,\n * so it is safer to manually serialize.\n */\nexport function serializeTopology(topology: PuzzleTopology): PuzzleTopologySerializable {\n  return {\n    vertices: topology.vertices,\n    pieces: Array.from(topology.pieces.entries()),\n    edges: Array.from(topology.edges.entries()),\n    halfEdges: Array.from(topology.halfEdges.entries()),\n    boundary: topology.boundary,\n    borderPath: topology.borderPath,\n  };\n}\n\n/** Revives a serialized topology back into a PuzzleTopology with Maps. */\nexport function deserializeTopology(serialized: PuzzleTopologySerializable): PuzzleTopology {\n  return {\n    vertices: serialized.vertices,\n    pieces: new Map(serialized.pieces),\n    edges: new Map(serialized.edges),\n    halfEdges: new Map(serialized.halfEdges),\n    boundary: serialized.boundary,\n    borderPath: serialized.borderPath,\n  };\n}\n\n\n/**\n * Checks if two Axis-Aligned Bounding Boxes intersect.\n * @param a - The first AABB.\n * @param b - The second AABB.\n * @returns `true` if they overlap, `false` otherwise.\n */\nexport function doAABBsIntersect(a: AABB, b: AABB): boolean {\n  // x-axis check\n  if (a[2] < b[0] || a[0] > b[2]) {\n    return false;\n  }\n  // y-axis check\n  if (a[3] < b[1] || a[1] > b[3]) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a path.\n *\n * @param startPoint The starting point of the path.\n * @param segments The array of segments defining the rest of the path.\n * @returns Bounding box for the entire set of segments\n */\nexport function calculateSegmentsBounds(startPoint: Vec2, segments: EdgeSegment[]): AABB {\n  let [xmin, ymin] = startPoint;\n  let [xmax, ymax] = startPoint;\n\n  const updateBounds = (p: Vec2) => {\n    xmin = Math.min(xmin, p[0]);\n    ymin = Math.min(ymin, p[1]);\n    xmax = Math.max(xmax, p[0]);\n    ymax = Math.max(ymax, p[1]);\n  };\n\n  for (const segment of segments) {\n    if (segment.type === 'line') {\n      updateBounds(segment.p);\n    } else { // 'bezier'\n      // For a robust bounding box, we must check the control points,\n      // as the curve can extend beyond its endpoint.\n      updateBounds(segment.p1);\n      updateBounds(segment.p2);\n      updateBounds(segment.p3);\n    }\n  }\n\n  return [xmin, ymin, xmax, ymax];\n}\n\n/**\n * Calculates the precise bounding box for a single puzzle piece by traversing\n * its boundary and finding the extremities of all its geometric segments.\n *\n * @param piece The piece whose bounding box needs to be recalculated.\n * @param topology The full puzzle topology, used to access half-edge data.\n * @returns A new AABB for the piece.\n */\nexport function getPieceBounds(piece: Piece, topology: PuzzleTopology): AABB {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  const startingEdgeId = piece.halfEdge;\n  let currentEdge = topology.halfEdges.get(startingEdgeId);\n\n  if (!currentEdge) {\n    // Should not happen in a valid topology\n    return piece.bounds;\n  }\n\n  // helper function expands the bounding box to include a given point.\n  const updateBounds = (p: Vec2) => {\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  };\n\n  // Traverse the entire boundary of the piece, one half-edge at a time.\n  do {\n    // account for the starting point of the current edge\n    updateBounds(currentEdge.origin);\n\n    // account for all points within the edge's segments (if any)\n    if (currentEdge.segments) {\n      const segmentBounds = calculateSegmentsBounds(currentEdge.origin, currentEdge.segments);\n      updateBounds([segmentBounds[0], segmentBounds[1]]);\n      updateBounds([segmentBounds[2], segmentBounds[3]]);\n    }\n\n    // move to the next half-edge around the piece\n    currentEdge = topology.halfEdges.get(currentEdge.next);\n\n  } while (currentEdge && currentEdge.id !== startingEdgeId);\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n// The maximum distance (in pixels) from a click to a vertex to consider it a \"hit\".\nconst MAX_CLICK_DISTANCE = 100;\nconst MAX_CLICK_DISTANCE_SQ = MAX_CLICK_DISTANCE * MAX_CLICK_DISTANCE;\n\n/**\n * Finds the index of the vertex closest to a given point.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The index of the closest vertex in the `topology.vertices` array,\n * or `null` if no vertex is within the click threshold.\n */\nexport function findClosestVertex(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): VertexID | null {\n  let closestVertexIndex = -1;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (let i = 0; i < puzzle.vertices.length; i++) {\n    const distSq = distanceSq(puzzle.vertices[i], clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestVertexIndex = i;\n    }\n  }\n\n  return closestVertexIndex === -1 ? null : closestVertexIndex;\n}\n\n/**\n * Finds the piece ID of the seed point closest to a given position.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The PieceID whose seed point is closest, or null if none within threshold.\n */\nexport function findClosestSeedPoint(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): PieceID | null {\n  let closestPieceId: PieceID | null = null;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (const piece of puzzle.pieces.values()) {\n    const distSq = distanceSq(piece.site, clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestPieceId = piece.id;\n    }\n  }\n\n  return closestPieceId;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a given polygon.\n * @param polygon - An array of vertices representing the polygon.\n * @returns The AABB or a zero-area box at the origin if the polygon is empty.\n */\nexport function polygonBounds(polygon: Vec2[]): AABB {\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = polygon[0][0];\n  let minY = polygon[0][1];\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 1; i < polygon.length; i++) {\n    const p = polygon[i];\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n/**\n * Checks if two points are effectively at the same location.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns `true` if points are equal.\n */\nexport function arePointsEqual(p1: Vec2, p2: Vec2): boolean {\n  return Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6;\n}\n\n/**\n * Generates the full segment path for an edge based on its TabPlacements.\n * This function modifies the half-edges of the provided edge in place.\n */\nexport function generateSegmentsForEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  tabGenerator: TabGenerator,\n  random: RandomFn\n): void {\n  if (!edge.tabs) { return; }\n  const heLeft = topology.halfEdges.get(edge.heLeft)!;\n  const heRight = topology.halfEdges.get(edge.heRight)!;\n\n  const edgeStart = heLeft.origin;\n  const edgeEnd = heRight.origin;\n  //const edgeLength = Math.hypot(edgeEnd[0] - edgeStart[0], edgeEnd[1] - edgeStart[1]);\n\n  const heLeftSegments: EdgeSegment[] = [];\n  let currentPos = edgeStart;\n\n  // Sort tabs by their position to process them in order\n  edge.tabs.sort((a, b) => a.position - b.position);\n\n  for (const tab of edge.tabs) {\n    //const tabWidth = edgeLength * tab.size;\n    // Calculate the start point of this tab's region\n    const tabStartPos = tab.position - tab.size / 2;\n    const tabStartPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * tabStartPos,\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * tabStartPos,\n    ];\n\n    // Add a straight line from the last position to the start of this tab\n    if (Math.hypot(tabStartPoint[0] - currentPos[0], tabStartPoint[1] - currentPos[1]) > 1e-6) {\n      heLeftSegments.push({ type: 'line', p: tabStartPoint });\n    }\n\n    // Generate segments for the tab itself\n    const tabEndPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * (tabStartPos + tab.size),\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * (tabStartPos + tab.size),\n    ];\n    const tabSegments = tabGenerator.createTabSegments(tabStartPoint, tabEndPoint, tab, random);\n    heLeftSegments.push(...tabSegments);\n\n    currentPos = tabEndPoint;\n  }\n\n  // Add a final line segment to the end of the edge\n  if (Math.hypot(edgeEnd[0] - currentPos[0], edgeEnd[1] - currentPos[1]) > 1e-6) {\n    heLeftSegments.push({ type: 'line', p: edgeEnd });\n  }\n\n  // Assign the generated segments and create the inverse for the twin\n  heLeft.segments = heLeftSegments;\n  heRight.segments = invertSegments(heLeftSegments, edgeStart);\n\n  // update the edge bounding box\n  edge.bounds = calculateSegmentsBounds(edgeStart, heLeftSegments);\n}\n\n/**\n * Creates an inverted copy of an array of edge segments.\n */\nexport function invertSegments(segments: EdgeSegment[], originalStart: Vec2): EdgeSegment[] {\n  const inverted: EdgeSegment[] = [];\n\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const segment = segments[i];\n    let segmentStart = originalStart;\n    if (i > 0) {\n      const prevSegment = segments[i-1];\n      segmentStart = (prevSegment.type === 'line') ? prevSegment.p : prevSegment.p3;\n    }\n\n    if (segment.type === 'line') {\n      inverted.push({ type: 'line', p: segmentStart });\n    } else { // 'bezier'\n      inverted.push({\n        type: 'bezier',\n        p1: segment.p2,\n        p2: segment.p1,\n        p3: segmentStart,\n      });\n    }\n  }\n  return inverted;\n}\n\n\n/**\n * Helper function to reverse a single Bézier curve segment.\n * The new curve starts where the old one ended and vice-versa.\n */\nexport function invertCurve(segment: CurveTo, newEndPoint: Vec2): CurveTo {\n  return {\n    type: 'bezier',\n    p1: segment.p2, // Control points are swapped\n    p2: segment.p1,\n    p3: newEndPoint, // The new end point is the start point of the original\n  };\n}\n\n/**\n * Converts an arc segment into an array of cubic Bézier curves.\n * @param start - The starting point of the arc.\n * @param arc - The ArcTo segment.\n * @returns An array of Bézier curve definitions.\n */\nfunction arcToBeziers(start: Vec2, arc: ArcTo): CurveTo[] {\n  const { p, radii, rotation, largeArc, sweep } = arc;\n  const [startX, startY] = start;\n  const [endX, endY] = p;\n  const [rx, ry] = radii;\n\n  const cubicBeziers = arcToBezier({\n    px: startX,\n    py: startY,\n    cx: endX,\n    cy: endY,\n    rx,\n    ry,\n    xAxisRotation: rotation,\n    largeArcFlag: largeArc ? 1 : 0,\n    sweepFlag: sweep ? 1 : 0,\n  });\n\n\n  // convert output to CurveTo\n  const curves: CurveTo[] = cubicBeziers.map((curve) => {\n    return {\n      type: 'bezier',\n      p1: [ curve.x1, curve.y1 ],\n      p2: [ curve.x2, curve.y2 ],\n      p3: [ curve.x, curve.y ],\n    };\n  });\n  return curves;\n}\n\n/**\n * Flattens a complex boundary path into an array of simple polygons.\n * This is used to prepare the boundary for geometric clipping operations.\n * @param boundary The boundary path to flatten.\n * @returns An array of polygons, where each polygon is an array of vertices.\n * The first polygon is the outer boundary, and subsequent ones are holes.\n */\nexport function flattenBoundary(boundary: PathCommand[]): Vec2[][] {\n  const polygons: Vec2[][] = [];\n  let currentPolygon: Vec2[] = [];\n\n  if (boundary.length === 0 || boundary[0].type !== 'move') {\n    // Return an empty array if the boundary is malformed or empty\n    return [];\n  }\n\n  let currentPoint: Vec2 = [0, 0];\n  for (const command of boundary) {\n    switch (command.type) {\n    case 'move':\n      if (currentPolygon.length > 0) {\n        polygons.push(currentPolygon);\n      }\n      currentPoint = command.p;\n      currentPolygon = [currentPoint];\n      break;\n\n    case 'line':\n      currentPolygon.push(command.p);\n      currentPoint = command.p;\n      break;\n\n    case 'bezier': {\n      // use bezier-js to create a Look-Up Table (LUT) of points\n      const { p1, p2, p3 } = command;\n      const curve = new Bezier([...currentPoint, ...p1, ...p2, ...p3]);\n      const points = curve.getLUT(100);\n      currentPolygon.push(...points.slice(1).map((p) => [p.x, p.y] as Vec2));\n      currentPoint = p3;\n      break;\n    }\n\n    case 'arc': {\n      // Convert the arc into one or more Bézier curves.\n      const beziers = arcToBeziers(currentPoint, command);\n      let arcStartPoint = currentPoint;\n      for (const b of beziers) {\n        // convert each Bézier as above\n        const curve = new Bezier([...arcStartPoint, ...b.p1, ...b.p2, ...b.p3]);\n        const points = curve.getLUT(100); // 100 points is a good approximation\n        currentPolygon.push(...points.slice(1).map((p) => [p.x, p.y] as Vec2));\n        arcStartPoint = b.p3;\n      }\n      currentPoint = command.p;\n      break;\n    }}\n  }\n  if (currentPolygon.length > 0) {\n    polygons.push(currentPolygon);\n  }\n\n  return polygons;\n}\n\n/**\n * Determines if a point is inside a complex boundary path.\n *\n * This function uses the ray casting (even-odd) algorithm. It handles complex\n * paths by first flattening them into a series of simple polygons. It also correctly\n * handles \"holes\" created by sub-paths (via `MoveTo`), assuming standard winding\n * rules.\n *\n * @param point The point to check.\n * @param boundary The boundary path defining the shape.\n * @param excludeVertices Optional set of vertices to exclude from the check.\n *                        If the point matches one of these vertices, it's considered inside\n *                        (useful for boundary edge vertices that may have floating point precision issues).\n * @returns `true` if the point is inside the boundary, `false` otherwise.\n */\nexport function isPointInBoundary(\n  point: Vec2,\n  boundary: PathCommand[],\n  excludeVertices?: Set<Vec2>\n): boolean {\n\n  // If this point should be excluded (e.g., it's a boundary vertex), treat it as inside\n  if (excludeVertices) {\n    for (const excludeVertex of excludeVertices) {\n      if (point[0] === excludeVertex[0] && point[1] === excludeVertex[1]) {\n        return true;\n      }\n    }\n  }\n\n  if (boundary.length > 0 && boundary[0].type !== 'move') {\n    throw new Error(\"Boundary path must start with a 'move' command.\");\n  }\n\n  // flatten the entire path into simple polygons\n  const polygons = flattenBoundary(boundary);\n\n  // use the even-odd rule to determine inclusion\n  let insideCount = 0;\n  for (const poly of polygons) {\n    if (isPointInPolygon(point, poly)) {\n      insideCount++;\n    }\n  }\n  return insideCount % 2 === 1;\n}\n\n// type guard for Martinez library return values\nfunction isMartinezPolygon(geometry: martinez.Geometry): geometry is martinez.Polygon {\n  return Array.isArray(geometry[0]) && Array.isArray(geometry[0][0]) && typeof geometry[0][0][0] === 'number';\n}\n\n/**\n * Clips a polygon against the puzzle boundary.\n *\n * @param polygon The polygon to be clipped (e.g., a grid cell). This should be a simple array of vertices.\n * @param boundary The pre-flattened boundary to clip against.\n * @returns An array of resulting polygons, or null if there is no intersection.\n * Each resulting polygon is an array of vertices.\n */\nexport function clipPolygonAgainstBoundary(polygon: Vec2[], boundary: Vec2[]): Vec2[][] | null {\n\n  // use the martinez-polygon-clipping library to handle clipping\n  // It expects input in a specific GeoJSON-like format, so we must wrap our\n  // simple polygons in arrays to match.\n  const subject = [polygon.map((p) => ([p[0], p[1]]))];\n  const clipper = [boundary.map((p) => ([p[0], p[1]]))];\n\n  const clipped = martinez.intersection(subject, clipper);\n\n  if (!clipped || clipped.length === 0) {\n    return null; // No intersection found.\n  }\n\n  if (isMartinezPolygon(clipped)) {\n    return clipped as Vec2[][];\n  }\n\n  // unwrap the result back to our Vec2[][] format.\n  return clipped.map((poly) =>\n    poly[0].map((p) => ([p[0], p[1]] as Vec2))\n  );\n}\n\n/**\n * Checks if a point is inside a simple polygon using the ray casting algorithm.\n * @param point The point to check.\n * @param polygon An array of vertices defining the polygon.\n * @returns `true` if the point is inside.\n */\nexport function isPointInPolygon(point: Vec2, polygon: Vec2[]): boolean {\n  const [x, y] = point;\n  let isInside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [xi, yi] = polygon[i];\n    const [xj, yj] = polygon[j];\n\n    // This condition checks if the horizontal ray from the point intersects the edge.\n    const intersect = ((yi > y) !== (yj > y)) &&\n      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n\n  return isInside;\n}\n\n/**\n * Creates a closed, doubly-linked loop of half-edges from an ordered list of vertices.\n * @param vertices - An array of vertices in counter-clockwise order.\n * @param pieceId - The ID of the piece this half-edge loop belongs to.\n * @param topology - The main puzzle topology object, which will be mutated.\n * @returns The array of newly created HalfEdge objects.\n */\nexport function createHalfEdgeLoop(\n  vertices: Vec2[],\n  pieceId: PieceID,\n  topology: PuzzleTopology,\n): HalfEdge[] {\n  const newHalfEdges: HalfEdge[] = [];\n\n  // 1. Add any new, unique vertices to the main list\n  for (const vertex of vertices) {\n    if (!topology.vertices.find((v) => arePointsEqual(v, vertex))) {\n      topology.vertices.push(vertex);\n    }\n  }\n\n  // 2. Create a half-edge for each vertex\n  for (const vertex of vertices) {\n    const he: HalfEdge = {\n      id: getUniqueId(),\n      origin: vertex,\n      twin: -1,\n      next: -1,\n      prev: -1,\n      piece: pieceId,\n    };\n    newHalfEdges.push(he);\n  }\n\n  // 3. Link the created half-edges into a circular doubly-linked list\n  const numEdges = newHalfEdges.length;\n  for (let i = 0; i < numEdges; i++) {\n    const nextIndex = (i + 1) % numEdges;\n    const prevIndex = (i + numEdges - 1) % numEdges;\n    newHalfEdges[i].next = newHalfEdges[nextIndex].id;\n    newHalfEdges[i].prev = newHalfEdges[prevIndex].id;\n  }\n\n  // 4. Add all new half-edges to the topology\n  newHalfEdges.forEach((he) => topology.halfEdges.set(he.id, he));\n\n  return newHalfEdges;\n}\n\n/**\n * Links a set of half-edges to their twins or creates new boundary edges.\n * @param halfEdges - The list of half-edges to process.\n * @param topology - The main puzzle topology object, which will be mutated.\n * @param halfEdgeTwinMap - The map used to look up twin half-edges.\n * @param isBoundaryEdgeFn - A callback function that returns true if a given edge should be treated as part of the puzzle's outer boundary.\n */\nexport function linkAndCreateEdges(\n  halfEdges: HalfEdge[],\n  topology: PuzzleTopology,\n  halfEdgeTwinMap: Map<string, HalfEdgeID>,\n  isBoundaryEdgeFn: (p1: Vec2, p2: Vec2) => boolean,\n): void {\n  const key = (p1: Vec2, p2: Vec2) => `${p1[0]},${p1[1]}-${p2[0]},${p2[1]}`;\n  const numEdges = halfEdges.length;\n\n  for (let i = 0; i < numEdges; i++) {\n    const he = halfEdges[i];\n    const p1 = he.origin;\n    const p2 = topology.halfEdges.get(he.next)!.origin;\n\n    const twinKey = key(p2, p1);\n    const twinId = halfEdgeTwinMap.get(twinKey);\n    const edgeId = getUniqueId();\n    let edge: Edge;\n\n    if (twinId !== undefined) {\n      // Found a twin! This is an internal edge.\n      const twinHe = topology.halfEdges.get(twinId)!;\n      he.twin = twinHe.id;\n      twinHe.twin = he.id;\n      edge = { id: edgeId, heLeft: twinHe.id, heRight: he.id, bounds: polygonBounds([p1, p2]) };\n      halfEdgeTwinMap.delete(twinKey);\n    } else {\n      // No twin found.\n      const selfKey = key(p1, p2);\n      halfEdgeTwinMap.set(selfKey, he.id);\n\n      if (isBoundaryEdgeFn(p1, p2)) {\n        // This is a new edge on the puzzle's custom boundary.\n        edge = { id: edgeId, heLeft: he.id, heRight: -1, bounds: polygonBounds([p1, p2]) };\n        topology.boundary.push(edgeId);\n      } else {\n        // It's an internal grid edge, wait for its neighbor to find it.\n        continue;\n      }\n    }\n    topology.edges.set(edgeId, edge);\n  }\n}\n","import type {\n  AABB,\n  EdgeSegment,\n  LineTo,\n  Piece,\n  PuzzleTopology,\n  Vec2,\n} from \"./types\";\nimport {\n  distanceSq,\n  calculateSegmentsBounds,\n  serializeTopology,\n  doAABBsIntersect,\n  isPointInBoundary,\n} from \"./utils\";\nimport type { CheckGeometryWorkerInput, CheckGeometryWorkerOutput } from '../workers/CheckGeometryWorker';\nimport { Bezier } from 'bezier-js';\n\n// import the worker script\nimport CheckGeometryWorker from '../workers/CheckGeometryWorker?worker';\n\n/** An internal structure to hold a segment and its pre-calculated properties. */\ninterface BoundarySegment {\n  /** The geometric definition of the segment. */\n  segment: EdgeSegment;\n  /** The starting point of this segment. */\n  startPoint: Vec2;\n  /** The pre-calculated bounding box for this segment. */\n  bbox: AABB;\n}\n\n// helper to gets the end point of a segment.\nfunction getEndPoint(s: EdgeSegment): Vec2 {\n  return s.type === 'line' ? s.p : s.p3;\n}\n\n// helper to get a Bezier object for use with bezier-js\nfunction boundaryToBezier(boundary: BoundarySegment): Bezier {\n  if (boundary.segment.type !== 'bezier') {\n    throw new Error('Boundary segment is not a Bezier curve');\n  }\n  const { startPoint } = boundary;\n  const { p1, p2, p3 } = boundary.segment;\n  return new Bezier(\n    { x: startPoint[0], y: startPoint[1] },\n    { x: p1[0], y: p1[1] },\n    { x: p2[0], y: p2[1] },\n    { x: p3[0], y: p3[1] }\n  );\n}\n\n/**\n * Traverses a piece's boundary and collects all its geometric segments.\n * @param piece - The piece to process.\n * @param puzzle - The full puzzle geometry, for half-edge lookups.\n * @returns An ordered array of BoundarySegment objects.\n */\nfunction getPieceBoundary(piece: Piece, puzzle: PuzzleTopology): BoundarySegment[] {\n  const boundary: BoundarySegment[] = [];\n  const startHeId = piece.halfEdge;\n  let currentHeId = startHeId;\n\n  do {\n    const he = puzzle.halfEdges.get(currentHeId);\n    if (!he) {\n      console.error(`Could not find half-edge with ID: ${currentHeId}`);\n      break;\n    }\n\n    let startPoint = he.origin;\n\n    if (he.segments && he.segments.length > 0) {\n      // Add segments from the half-edge definition\n      for (const segment of he.segments) {\n        boundary.push({\n          segment,\n          startPoint,\n          bbox: calculateSegmentsBounds(startPoint, [segment]),\n        });\n        // The next segment starts where the current one ends\n        startPoint = segment.type === 'line' ? segment.p : segment.p3;\n      }\n    } else {\n      // If no segments, it's a straight line to the next half-edge's origin\n      const nextHe = puzzle.halfEdges.get(he.next);\n      if (!nextHe) {\n        console.error(`Could not find next half-edge for ID: ${he.next}`);\n        continue;\n      }\n      const lineSegment: LineTo = { type: 'line', p: nextHe.origin };\n      boundary.push({\n        segment: lineSegment,\n        startPoint: startPoint,\n        bbox: calculateSegmentsBounds(startPoint, [lineSegment]),\n      });\n    }\n\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId);\n\n  return boundary;\n}\n\n/**\n * Performs precise intersection detection between two geometric segments.\n * This function handles Line/Line, Line/Curve, and Curve/Curve cases.\n *\n * @param s1 - The first boundary segment.\n * @param s2 - The second boundary segment.\n * @param adjacent - True of the segments are next to each other on the boundary.\n * @returns An array of Vec2 points representing all found intersections.\n */\nfunction narrowPhaseDetection(s1: BoundarySegment, s2: BoundarySegment, adjacent: boolean): Promise<Vec2[]> {\n  return new Promise<Vec2[]>((resolve) => {\n\n    const intersections: Vec2[] = [];\n    const type1 = s1.segment.type;\n    const type2 = s2.segment.type;\n    const tolerance = 0.01; // values this close to the beginning or end of a curve are effectively at the ends\n\n\n    // Bezier vs. Bezier\n    if (type1 === 'bezier' && type2 === 'bezier') {\n      const bezier1 = boundaryToBezier(s1);\n      const bezier2 = boundaryToBezier(s2);\n\n      // intersects() returns an array of strings that look like \"float/float\"\n      const pairs = bezier1.intersects(bezier2) as string[];\n\n      pairs.forEach((pair) => {\n        const tValues = pair.split('/');\n        const t1 = parseFloat(tValues[0]);\n        const t2 = parseFloat(tValues[1]);\n\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t1 > (1.0 - tolerance) && t2 < tolerance || t1 < tolerance && t2 > (1.0 - tolerance);\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n\n        // extract the intersection point\n        const p = bezier1.get(t1);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Bezier vs. Line\n    else if (type1 === 'bezier' || type2 === 'bezier') {\n      const curveBoundary = type1 === 'bezier' ? s1 : s2;\n      const lineBoundary = type1 === 'line' ? s1 : s2;\n\n      const curve = boundaryToBezier(curveBoundary);\n      const line = {\n        p1: { x: lineBoundary.startPoint[0], y: lineBoundary.startPoint[1] },\n        p2: { x: (lineBoundary.segment as LineTo).p[0], y: (lineBoundary.segment as LineTo).p[1] },\n      };\n\n      // intersects() returns an array of t-values on the curve\n      const tValues = curve.intersects(line) as number[]; // always numbers when comparing to line\n      tValues.forEach((t) => {\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t > (1.0 - tolerance) || t < tolerance;\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n        const p = curve.get(t);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Line vs. Line\n    else {\n      // only non-adjacent line segments need to be compared\n      if (!adjacent) {\n        return resolve(intersections);\n      }\n\n      const p1 = s1.startPoint;\n      const p2 = s1.segment.p;\n      const p3 = s2.startPoint;\n      const p4 = s2.segment.p;\n\n      const [x1, y1] = p1;\n      const [x2, y2] = p2;\n      const [x3, y3] = p3;\n      const [x4, y4] = p4;\n\n      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n      if (den !== 0) { // Ensure lines are not parallel or collinear\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n\n        // If an intersection exists on both line segments\n        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n          const intersectX = x1 + t * (x2 - x1);\n          const intersectY = y1 + t * (y2 - y1);\n          intersections.push([intersectX, intersectY]);\n        }\n      }\n    }\n\n    resolve(intersections);\n  });\n}\n\n/**\n * Detects self-intersections within each piece of a puzzle geometry.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @param onProgress - Optional callback invoked to report progress.\n * @returns An array of Vec2 points, where each point is an overlap.\n */\nasync function detectIntersections(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  const intersections: Vec2[] = [];\n  const EPSILON_SQUARED = 1e-8; // Tolerance for floating point comparisons\n\n  const pieces = Array.from(puzzle.pieces.values());\n  const totalPieces = pieces.length;\n  let processedCount = 0;\n\n  // 1. Iterate through each piece\n  for (const piece of puzzle.pieces.values()) {\n\n    // report progress\n    onProgress?.(processedCount, totalPieces);\n\n    const boundary = getPieceBoundary(piece, puzzle);\n    const numSegments = boundary.length;\n    if (numSegments < 2) {\n      processedCount++;\n      continue;\n    }\n\n    // 2. Compare every segment with every other segment that comes after it\n    for (let i = 0; i < numSegments; i++) {\n      for (let j = i + 1; j < numSegments; j++) {\n        const seg1 = boundary[i];\n        const seg2 = boundary[j];\n\n        // 3. Broad-phase detection using bounding boxes\n        if (!doAABBsIntersect(seg1.bbox, seg2.bbox)) {\n          // no intersections\n          continue;\n        }\n\n        // 4. Distinguish between adjacent and non-adjacent intersections\n        const areAdjacent = (j === i + 1) || (i === 0 && j === numSegments - 1);\n\n        // 5. Narrow-phase detection (using a bezier library)\n        const potentialPoints = await narrowPhaseDetection(seg1, seg2, areAdjacent);\n\n        if (potentialPoints.length === 0) {\n          // no intersections\n          continue;\n        }\n\n        if (areAdjacent) {\n          const connectionPoint = (i === 0 && j === numSegments - 1)\n            ? seg1.startPoint // we're comparing the final segment with the first segment\n            : getEndPoint(seg1.segment); // we're comparing adjacent segments\n\n          for (const point of potentialPoints) {\n            // An intersection is only an error if it's NOT at the connection point.\n            if (distanceSq(point, connectionPoint) > EPSILON_SQUARED) {\n              intersections.push(point);\n            }\n          }\n        } else {\n          // For non-adjacent segments, ANY intersection is an error.\n          intersections.push(...potentialPoints);\n        }\n      }\n    }\n    processedCount++;\n  }\n\n  // final call to signify completion\n  onProgress?.(totalPieces, totalPieces);\n\n  console.log(`detected ${intersections.length} intersections in ${puzzle.pieces.size} pieces`);\n  return intersections;\n}\n\n\n/**\n * Detects vertices that lie outside the puzzle boundary.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @returns An array of Vec2 points representing vertices outside the boundary.\n */\nfunction detectVerticesOutsideBoundary(puzzle: PuzzleTopology): Vec2[] {\n  const outsideVertices: Vec2[] = [];\n\n  // Collect all boundary edge vertices (vertices on half-edges with twin === -1)\n  // These should be excluded from the check due to floating point precision issues\n  const boundaryEdgeVertices = new Set<Vec2>();\n  for (const halfEdge of puzzle.halfEdges.values()) {\n    if (halfEdge.twin === -1) {\n      boundaryEdgeVertices.add(halfEdge.origin);\n    }\n  }\n\n  // Check each vertex to see if it's inside the boundary\n  for (const vertex of puzzle.vertices) {\n    if (!isPointInBoundary(vertex, puzzle.borderPath, boundaryEdgeVertices)) {\n      outsideVertices.push(vertex);\n    }\n  }\n\n  if (outsideVertices.length > 0) {\n    console.log(`detected ${outsideVertices.length} vertices outside the boundary`);\n  }\n\n  return outsideVertices;\n}\n\n/**\n * Checks a puzzle for geometry issues such as intersecting pieces or too narrow geometry.\n * @param puzzle - Geometry to check\n * @param onProgress - Optional callpack for managing a progress bar\n * @returns A Promise for coordinates that have problem geometry\n */\nexport async function checkGeometry(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  // find points where pieces intersect/overlap\n  const intersections = await detectIntersections(puzzle, onProgress);\n\n  // find vertices outside the boundary\n  const outsideVertices = detectVerticesOutsideBoundary(puzzle);\n\n  // combine both types of problems\n  const allProblems = [...intersections, ...outsideVertices];\n\n  if (allProblems.length < 2) {\n    return allProblems;\n  }\n\n  // Note: the intersection algorithm can return multiple points clustered very\n  // closely, which is confusing for the user, so here we filter them out\n  const MIN_DISTANCE = 1;\n  const filtered: Vec2[] = [allProblems[0]];\n\n  for (let i = 1; i < allProblems.length; i++) {\n    const current = allProblems[i];\n    const last = filtered[filtered.length - 1];\n    if (distanceSq(current, last) > MIN_DISTANCE * MIN_DISTANCE) {\n      filtered.push(current);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Wraps the `checkGeometry` function in a web worker to run it off the main thread,\n * preventing the UI from freezing during intensive calculations.\n *\n * @param puzzle - The puzzle topology to check.\n * @param onProgress - An optional callback to receive progress updates.\n * @returns A promise that resolves with an array of intersection points or rejects on error.\n */\nexport function checkGeometryInWorker(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n  return new Promise((resolve, reject) => {\n    const worker = new CheckGeometryWorker();\n\n    // Handle messages received from the worker\n    worker.onmessage = (event: MessageEvent<CheckGeometryWorkerOutput>) => {\n      const data = event.data;\n\n      switch (data.type) {\n      case 'progress':\n        onProgress?.(data.processed, data.total);\n        break;\n      case 'done':\n        resolve(data.results);\n        worker.terminate();\n        break;\n      case 'error':\n        reject(new Error(data.message));\n        worker.terminate();\n        break;\n      }\n    };\n\n    // Handle any critical errors with the worker itself\n    worker.onerror = (error: ErrorEvent) => {\n      reject(new Error(error.message));\n      worker.terminate();\n    };\n\n    // serialize the puzzle topology and send it to the worker to kick off the process\n    const message: CheckGeometryWorkerInput = {\n      topology: serializeTopology(puzzle),\n    };\n    worker.postMessage(message);\n  });\n}","// wraps GeometryChecker in a web worker\nimport { checkGeometry } from '../geometry/GeometryChecker';\nimport { deserializeTopology, type PuzzleTopologySerializable } from '../geometry/utils';\nimport type { Vec2 } from '../geometry/types';\n\n// Define the message format the worker expects to receive\nexport interface CheckGeometryWorkerInput {\n  topology: PuzzleTopologySerializable;\n}\n\n// Define the discriminated union for messages the worker sends back\nexport type CheckGeometryWorkerOutput =\n  | { type: 'progress'; processed: number; total: number }\n  | { type: 'done'; results: Vec2[] }\n  | { type: 'error'; message: string };\n\n// Listen for messages from the main thread\nself.onmessage = async (event: MessageEvent<CheckGeometryWorkerInput>) => {\n  try {\n    const { topology: serializableTopology } = event.data;\n\n    // 1. Reconstruct the PuzzleTopology object with its Maps\n    const topology = deserializeTopology(serializableTopology);\n\n    // 2. Create a progress callback to post updates back to the main thread\n    const onProgress = (processed: number, total: number) => {\n      const progressMessage: CheckGeometryWorkerOutput = { type: 'progress', processed, total };\n      self.postMessage(progressMessage);\n    };\n\n    // 3. Execute the geometry check\n    const intersections = await checkGeometry(topology, onProgress);\n\n    // 4. Post the final results when complete\n    const doneMessage: CheckGeometryWorkerOutput = { type: 'done', results: intersections };\n    self.postMessage(doneMessage);\n\n  } catch (e) {\n    // notify the main thread\n    const errorMessage: CheckGeometryWorkerOutput = {\n      type: 'error',\n      message: e instanceof Error ? e.message : `An error occurred in the CheckGeometryWorker: ${String(e)}.`,\n    };\n    self.postMessage(errorMessage);\n  } finally {\n    // Close the worker to free up resources once its job is done\n    self.close();\n  }\n};\n\n\n"],"names":["abs","cos","sin","acos","atan2","sqrt","pow","crt","v","pi","tau","quart","epsilon","nMax","nMin","ZERO","utils","t","derivativeFn","d","l","points","_3d","order","mt","p","ret","mt2","t2","a","b","c","dCpts","i","ratios","r","f1","f2","f3","f4","dpoints","list","j","dpt","m","M","precision","len","sum","ds","de","ts","te","d1","d2","v2","v1","s","obj","dx1","dy1","dx2","dy2","cross","dot","pos","p1","p2","dx","dy","LUT","point","mdist","mpos","idx","n","bottom","top","x1","y1","x2","y2","x3","y3","x4","y4","nx","ny","p3","p4","Bezier","sections","mx","my","MX","MY","bbox","s1","bbox1","s2","bbox2","curveIntersectionThreshold","intersections","a1","a2","l1","l2","iss","forward","back","bpl","fpl","start","end","shape","curve","min","max","line","tx","ty","aligned","reduce","m1","m2","pa","pb","pc","pd","q","q2","discriminant","u1","mp3","mp33","cosphi","phi","crtr","t1","sd","kOnly","num","dnm","adk","dk","k","dd","qdsum","pk","nk","v3","trm","sq","b1","b2","dims","dim","_bbox","c1","c2","c1b","c2b","threshold","cc1","cc2","pairs","pair","results","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","e","_","PolyBezier","curves","offset","coords","args","coordlen","newargs","higher","step","baselength","abc","S","B","E","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","A","nc1","nc2","x","y","last","print","angle","u","um","C","steps","error","lut","hits","closest","ft","np","pim","r1","r2","q1","R","_p","pt","result","roots","mfn","extrema","lbbox","tbbox","nv","n1","n2","segment","pass1","pass2","o","distanceFn","clockwise","ov","rc","d3","d4","mid","fline","bline","ls","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","fs","fe","bs","be","outline","shapes","left","right","errorThreshold","np1","ref","circles","t_s","t_e","safety","np2","np3","prev_arc","curr_good","prev_good","done","t_m","prev_e","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_i","_s","err","TAU","mapToEllipse","_ref","rx","ry","sinphi","centerx","centery","xp","yp","approxUnitArc","ang1","ang2","vectorAngle","ux","uy","vx","vy","sign","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","_ref2","_ref2$xAxisRotation","xAxisRotation","_ref2$largeArcFlag","_ref2$sweepFlag","lambda","_getArcCenter","_getArcCenter2","ratio","_mapToEllipse","_mapToEllipse2","_mapToEllipse3","tinyqueueModule","TinyQueue","data","compare","defaultCompare","item","parent","current","halfLength","best","distanceSq","deserializeTopology","serialized","doAABBsIntersect","calculateSegmentsBounds","startPoint","xmin","ymin","xmax","ymax","updateBounds","arcToBeziers","radii","rotation","largeArc","sweep","startX","startY","endX","endY","flattenBoundary","boundary","polygons","currentPolygon","currentPoint","command","beziers","arcStartPoint","isPointInBoundary","excludeVertices","excludeVertex","insideCount","poly","isPointInPolygon","polygon","isInside","xi","yi","xj","yj","getEndPoint","boundaryToBezier","getPieceBoundary","piece","puzzle","startHeId","currentHeId","he","nextHe","lineSegment","narrowPhaseDetection","adjacent","resolve","type1","type2","tolerance","bezier1","bezier2","tValues","curveBoundary","lineBoundary","den","intersectX","intersectY","detectIntersections","onProgress","totalPieces","processedCount","numSegments","seg1","seg2","areAdjacent","potentialPoints","connectionPoint","detectVerticesOutsideBoundary","outsideVertices","boundaryEdgeVertices","halfEdge","vertex","checkGeometry","allProblems","MIN_DISTANCE","filtered","event","serializableTopology","topology","doneMessage","processed","total","progressMessage","errorMessage"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}