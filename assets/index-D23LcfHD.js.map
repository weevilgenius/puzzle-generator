{"version":3,"file":"index-D23LcfHD.js","sources":["../../src/ui/GitHubCorner.ts","../../src/geometry/generators/Generator.ts","../../src/geometry/utils.ts","../../src/utils/mulberry.ts","../../src/geometry/PuzzleMaker.ts","../../src/geometry/modifiers.ts","../../src/ui/Puzzle.ts","../../src/utils/svg.ts","../../src/ui/DownloadPuzzleButton.ts","../../src/ui/GeometryCheckIndicator.ts","../../src/ui/UploadImageButton.ts","../../src/ui/inputs/BooleanInputControl.ts","../../src/ui/inputs/NumberInputControl.ts","../../src/ui/inputs/RangeInputControl.ts","../../src/ui/inputs/StringInputControl.ts","../../src/ui/GeneratorPicker.ts","../../src/ui/AspectRatioPicker.ts","../../src/ui/ColorPicker.ts","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/tiny-ndarray.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/sphere-random.js","../../node_modules/.pnpm/moore@1.0.0/node_modules/moore/index.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/neighbourhood.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/fixed-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/variable-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js","../../src/geometry/generators/point/PoissonPointGenerator.ts","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/delaunator@5.0.1/node_modules/delaunator/index.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/path.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/polygon.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/voronoi.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/delaunay.js","../../src/utils/UniqueId.ts","../../src/geometry/generators/piece/VoronoiPieceGenerator.ts","../../src/geometry/generators/tab_placement/SimpleTabPlacementStrategy.ts","../../src/geometry/generators/tab/TraditionalTabGenerator.ts","../../src/geometry/GeometryChecker.ts","../../src/geometry/generators/point/GridJitterPointGenerator.ts","../../src/geometry/generators/piece/RectangularPieceGenerator.ts","../../src/geometry/generators/tab/NullTabGenerator.ts","../../src/geometry/generators/tab/TriangleTabGenerator.ts","../../src/index.ts"],"sourcesContent":["// SVG rendering the GitHub Octocat in a corner with a link\n// adapted from https://github.com/tholman/github-corners/\nimport m from 'mithril';\n\n// include our CSS\nimport './GitHubCorner.css';\n\n// component attributes\nexport interface GitHubCornerAttrs extends m.Attributes {\n  /** Url to use when clicked */\n  link: string;\n}\n\n// Mithril component\nexport const GitHubCorner: m.Component<GitHubCornerAttrs, unknown> = {\n\n  view: ({ attrs }) => {\n\n    return m(\"a.github-corner\", {\n      href: attrs.link,\n      \"aria-label\": \"View source on GitHub\",\n      title: \"View source on GitHub\",\n      target: \"_blank\",\n    }, m(\"svg\", {\n      width: 80,\n      height: 80,\n      viewBox: \"0 0 250 250\",\n      \"aria-hidden\": \"true\",\n    }, [\n      m('path', {\n        d: \"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\",\n      }),\n      m('path.octo-arm', {\n        fill: \"currentColor\",\n        style: \"transform-origin: 130px 106px;\",\n        d: \"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\",\n      }),\n      m('path.octo-body', {\n        fill: \"currentColor\",\n        d: \"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\",\n      }),\n    ]));\n  },\n\n};\nexport default GitHubCorner;\n","import type { GeneratorUIMetadata } from '../ui_types';\n\n/** The name of a particular generator implementation. Must be unique. */\nexport type GeneratorName = string;\n\n/** Base configuration for any generator */\nexport interface GeneratorConfig {\n  /** The name of the generator to which this config belongs */\n  name: GeneratorName;\n  // additional fields specific to this generator\n  [key: string]: unknown;\n}\n\n/**\n * A generic interface for a function that creates a configured generator instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type GeneratorFactory<T> = (width: number, height: number, options: any) => T;\n\n\ninterface RegisteredGenerator<T> {\n  factory: GeneratorFactory<T>;\n  uiMetadata: GeneratorUIMetadata;\n}\n\n/**\n * A generic registry for creating instances of generates from configurations.\n * This allows for a pluggable system where generators can be added dynamically.\n *\n * @template T The base interface for this type of generator, e.g. `TabGenerator`\n */\nexport class GeneratorRegistry<T> {\n  private generators = new Map<GeneratorName, RegisteredGenerator<T>>();\n\n  /**\n   * Registers a new generator factory associated with a specific generator type.\n   * Intended to be called from within each generator's implementation file.\n   * @param name The unique string identifier for the generator, e.g. \"TraditionalTabGenerator\"\n   * @param factory A function that takes an options object and returns a generator\n   * @param uiMetadata A description of the UI needed to configure the generator\n   */\n  public register(name: GeneratorName, factory: GeneratorFactory<T>, uiMetadata: GeneratorUIMetadata): void {\n    if (this.generators.has(name)) {\n      console.warn(`Generator \"${name}\" is already registered, overwriting`);\n    }\n    this.generators.set(name, { factory, uiMetadata });\n  }\n\n  /**\n   * Creates an instance of a generator based on the provided configuration object.\n   * It looks up the correct factory using the `name` property from the config.\n   * @param config A configuration object for the generator\n   * @returns A configured instance of the requested generator\n   */\n  public create(width: number, height: number, config: GeneratorConfig): T {\n    const generator = this.generators.get(config.name);\n    if (!generator) {\n      throw new Error(`Unknown generator \"${config.name}\". Is it registered?`);\n    }\n    return generator.factory(width, height, config);\n  }\n\n  /**\n   * Returns a list of all available generators for populating a selector UI.\n   * @returns An array of objects with the name and human-readable display name.\n   */\n  public getAvailableGenerators(): { name: GeneratorName, displayName: string }[] {\n    return Array.from(this.generators.values())\n      .sort((a, b) => a.uiMetadata.sortHint - b.uiMetadata.sortHint)\n      .map((g) => ({\n        name: g.uiMetadata.name,\n        displayName: g.uiMetadata.displayName,\n      }));\n  }\n\n  /**\n   * Retrieves the full UI metadata for a single generator.\n   * @param name The name of the generator.\n   * @returns The UI metadata object, or undefined if not found.\n   */\n  public getUIMetadata(name: GeneratorName): GeneratorUIMetadata | undefined {\n    return this.generators.get(name)?.uiMetadata;\n  }\n\n  /**\n   * Builds a default (empty) config object for a given generator.\n   * @param name The name of the generator.\n   * @param width The width of the puzzle\n   * @param height The height of the puzzle\n   * @returns Default config object for the given generator\n   */\n  public getDefaultConfig(name: GeneratorName, width: number, height: number): GeneratorConfig {\n    const newConfig: GeneratorConfig = {\n      name: name,\n      width: width,\n      height: height,\n    };\n\n    const metadata = this.getUIMetadata(name);\n    if (metadata) {\n      for (const control of metadata.controls) {\n        newConfig[control.name] = control.defaultValue;\n      }\n    }\n\n    return newConfig;\n  }\n}\n\n/* ========================================================= *\\\n *  Public registeries                                       *\n\\* ========================================================= */\n\n// Public registry for PointGenerators\nimport type { PointGenerator } from \"./point/PointGenerator\";\nexport const PointGeneratorRegistry = new GeneratorRegistry<PointGenerator>();\n\n// Public registry for PieceGenerators\nimport type { PieceGenerator } from \"./piece/PieceGenerator\";\nexport const PieceGeneratorRegistry = new GeneratorRegistry<PieceGenerator>();\n\n// Public registry for TabPlacementStrategies\nimport type { TabPlacementStrategy } from \"./tab_placement/TabPlacementStrategy\";\nexport const TabPlacementStrategyRegistry = new GeneratorRegistry<TabPlacementStrategy>();\n\n// Public registry for TabGenerators\nimport type { TabGenerator } from \"./tab/TabGenerator\";\nexport const TabGeneratorRegistry = new GeneratorRegistry<TabGenerator>();\n","// this file contains various geometry-related utilities\nimport type {\n  Vec2,\n  PuzzleTopology,\n  Vertex,\n  Piece,\n  PieceID,\n  CurveTo,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  AABB,\n  EdgeSegment,\n  RandomFn,\n  VertexID,\n} from \"./types\";\nimport type { TabGenerator } from \"./generators/tab/TabGenerator\";\n\n/**\n * Calculates the squared Euclidean distance between two points.\n * Used for efficient distance comparisons without the need for Math.sqrt().\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns The squared distance between the points.\n */\nexport function distanceSq(p1: Vec2, p2: Vec2): number {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\n\n/** Serializable version of PuzzleTopology */\nexport interface PuzzleTopologySerializable {\n  vertices: Vertex[];\n  pieces: [PieceID, Piece][];\n  edges: [EdgeID, Edge][];\n  halfEdges: [HalfEdgeID, HalfEdge][];\n  boundary: EdgeID[];\n}\n\n/**\n * Converts a PuzzleTopology with Maps to a plain object representation. Note that\n * modern browsers support Map with structuredClone(), but older browsers do not,\n * so it is safer to manually serialize.\n */\nexport function serializeTopology(topology: PuzzleTopology): PuzzleTopologySerializable {\n  return {\n    vertices: topology.vertices,\n    pieces: Array.from(topology.pieces.entries()),\n    edges: Array.from(topology.edges.entries()),\n    halfEdges: Array.from(topology.halfEdges.entries()),\n    boundary: topology.boundary,\n  };\n}\n\n/** Revives a serialized topology back into a PuzzleTopology with Maps. */\nexport function deserializeTopology(serialized: PuzzleTopologySerializable): PuzzleTopology {\n  return {\n    vertices: serialized.vertices,\n    pieces: new Map(serialized.pieces),\n    edges: new Map(serialized.edges),\n    halfEdges: new Map(serialized.halfEdges),\n    boundary: serialized.boundary,\n  };\n}\n\n\n/**\n * Checks if two Axis-Aligned Bounding Boxes intersect.\n * @param a - The first AABB.\n * @param b - The second AABB.\n * @returns `true` if they overlap, `false` otherwise.\n */\nexport function doAABBsIntersect(a: AABB, b: AABB): boolean {\n  // x-axis check\n  if (a[2] < b[0] || a[0] > b[2]) {\n    return false;\n  }\n  // y-axis check\n  if (a[3] < b[1] || a[1] > b[3]) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a path.\n *\n * @param startPoint The starting point of the path.\n * @param segments The array of segments defining the rest of the path.\n * @returns Bounding box for the entire set of segments\n */\nexport function calculateSegmentsBounds(startPoint: Vec2, segments: EdgeSegment[]): AABB {\n  let [xmin, ymin] = startPoint;\n  let [xmax, ymax] = startPoint;\n\n  const updateBounds = (p: Vec2) => {\n    xmin = Math.min(xmin, p[0]);\n    ymin = Math.min(ymin, p[1]);\n    xmax = Math.max(xmax, p[0]);\n    ymax = Math.max(ymax, p[1]);\n  };\n\n  for (const segment of segments) {\n    if (segment.type === 'line') {\n      updateBounds(segment.p);\n    } else { // 'bezier'\n      // For a robust bounding box, we must check the control points,\n      // as the curve can extend beyond its endpoint.\n      updateBounds(segment.p1);\n      updateBounds(segment.p2);\n      updateBounds(segment.p3);\n    }\n  }\n\n  return [xmin, ymin, xmax, ymax];\n}\n\n/**\n * Calculates the precise bounding box for a single puzzle piece by traversing\n * its boundary and finding the extremities of all its geometric segments.\n *\n * @param piece The piece whose bounding box needs to be recalculated.\n * @param topology The full puzzle topology, used to access half-edge data.\n * @returns A new AABB for the piece.\n */\nexport function getPieceBounds(piece: Piece, topology: PuzzleTopology): AABB {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  const startingEdgeId = piece.halfEdge;\n  let currentEdge = topology.halfEdges.get(startingEdgeId);\n\n  if (!currentEdge) {\n    // Should not happen in a valid topology\n    return piece.bounds;\n  }\n\n  // helper function expands the bounding box to include a given point.\n  const updateBounds = (p: Vec2) => {\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  };\n\n  // Traverse the entire boundary of the piece, one half-edge at a time.\n  do {\n    // account for the starting point of the current edge\n    updateBounds(currentEdge.origin);\n\n    // account for all points within the edge's segments (if any)\n    if (currentEdge.segments) {\n      const segmentBounds = calculateSegmentsBounds(currentEdge.origin, currentEdge.segments);\n      updateBounds([segmentBounds[0], segmentBounds[1]]);\n      updateBounds([segmentBounds[2], segmentBounds[3]]);\n    }\n\n    // move to the next half-edge around the piece\n    currentEdge = topology.halfEdges.get(currentEdge.next);\n\n  } while (currentEdge && currentEdge.id !== startingEdgeId);\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n// The maximum distance (in pixels) from a click to a vertex to consider it a \"hit\".\nconst MAX_CLICK_DISTANCE = 100;\nconst MAX_CLICK_DISTANCE_SQ = MAX_CLICK_DISTANCE * MAX_CLICK_DISTANCE;\n\n/**\n * Finds the index of the vertex closest to a given point.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The index of the closest vertex in the `topology.vertices` array,\n * or `null` if no vertex is within the click threshold.\n */\nexport function findClosestVertex(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): VertexID | null {\n  let closestVertexIndex = -1;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (let i = 0; i < puzzle.vertices.length; i++) {\n    const distSq = distanceSq(puzzle.vertices[i], clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestVertexIndex = i;\n    }\n  }\n\n  return closestVertexIndex === -1 ? null : closestVertexIndex;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a given polygon.\n * @param polygon - An array of vertices representing the polygon.\n * @returns The AABB or a zero-area box at the origin if the polygon is empty.\n */\nexport function polygonBounds(polygon: Vec2[]): AABB {\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = polygon[0][0];\n  let minY = polygon[0][1];\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 1; i < polygon.length; i++) {\n    const p = polygon[i];\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n/**\n * Checks if two points are effectively at the same location.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns `true` if points are equal.\n */\nexport function arePointsEqual(p1: Vec2, p2: Vec2): boolean {\n  return Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6;\n}\n\n/**\n * Generates the full segment path for an edge based on its TabPlacements.\n * This function modifies the half-edges of the provided edge in place.\n */\nexport function generateSegmentsForEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  tabGenerator: TabGenerator,\n  random: RandomFn\n): void {\n  if (!edge.tabs) { return; }\n  const heLeft = topology.halfEdges.get(edge.heLeft)!;\n  const heRight = topology.halfEdges.get(edge.heRight)!;\n\n  const edgeStart = heLeft.origin;\n  const edgeEnd = heRight.origin;\n  //const edgeLength = Math.hypot(edgeEnd[0] - edgeStart[0], edgeEnd[1] - edgeStart[1]);\n\n  const heLeftSegments: EdgeSegment[] = [];\n  let currentPos = edgeStart;\n\n  // Sort tabs by their position to process them in order\n  edge.tabs.sort((a, b) => a.position - b.position);\n\n  for (const tab of edge.tabs) {\n    //const tabWidth = edgeLength * tab.size;\n    // Calculate the start point of this tab's region\n    const tabStartPos = tab.position - tab.size / 2;\n    const tabStartPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * tabStartPos,\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * tabStartPos,\n    ];\n\n    // Add a straight line from the last position to the start of this tab\n    if (Math.hypot(tabStartPoint[0] - currentPos[0], tabStartPoint[1] - currentPos[1]) > 1e-6) {\n      heLeftSegments.push({ type: 'line', p: tabStartPoint });\n    }\n\n    // Generate segments for the tab itself\n    const tabEndPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * (tabStartPos + tab.size),\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * (tabStartPos + tab.size),\n    ];\n    const tabSegments = tabGenerator.createTabSegments(tabStartPoint, tabEndPoint, tab, random);\n    heLeftSegments.push(...tabSegments);\n\n    currentPos = tabEndPoint;\n  }\n\n  // Add a final line segment to the end of the edge\n  if (Math.hypot(edgeEnd[0] - currentPos[0], edgeEnd[1] - currentPos[1]) > 1e-6) {\n    heLeftSegments.push({ type: 'line', p: edgeEnd });\n  }\n\n  // Assign the generated segments and create the inverse for the twin\n  heLeft.segments = heLeftSegments;\n  heRight.segments = invertSegments(heLeftSegments, edgeStart);\n\n  // update the edge bounding box\n  edge.bounds = calculateSegmentsBounds(edgeStart, heLeftSegments);\n}\n\n/**\n * Creates an inverted copy of an array of edge segments.\n */\nexport function invertSegments(segments: EdgeSegment[], originalStart: Vec2): EdgeSegment[] {\n  const inverted: EdgeSegment[] = [];\n\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const segment = segments[i];\n    let segmentStart = originalStart;\n    if (i > 0) {\n      const prevSegment = segments[i-1];\n      segmentStart = (prevSegment.type === 'line') ? prevSegment.p : prevSegment.p3;\n    }\n\n    if (segment.type === 'line') {\n      inverted.push({ type: 'line', p: segmentStart });\n    } else { // 'bezier'\n      inverted.push({\n        type: 'bezier',\n        p1: segment.p2,\n        p2: segment.p1,\n        p3: segmentStart,\n      });\n    }\n  }\n  return inverted;\n}\n\n\n/**\n * Helper function to reverse a single Bézier curve segment.\n * The new curve starts where the old one ended and vice-versa.\n */\nexport function invertCurve(segment: CurveTo, newEndPoint: Vec2): CurveTo {\n  return {\n    type: 'bezier',\n    p1: segment.p2, // Control points are swapped\n    p2: segment.p1,\n    p3: newEndPoint, // The new end point is the start point of the original\n  };\n}\n","\n/**\n * Simple seeded PRNG. The state space is 32 bits, so the period (the point at\n * which random numbers repeat for the same seed) is 2^32.\n * See https://github.com/cprosche/mulberry32 for more details.\n * @param seed seed number\n * @returns function which returns a random number each time it is called\n */\nexport function mulberry32(seed: number) {\n  return function() {\n    let t = seed += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nexport default mulberry32;\n","import type { PuzzleGeometry, Vec2 } from \"./types\";\nimport {\n  PointGeneratorRegistry,\n  PieceGeneratorRegistry,\n  TabPlacementStrategyRegistry,\n  TabGeneratorRegistry,\n  type GeneratorConfig,\n} from \"./generators/Generator\";\nimport { generateSegmentsForEdge } from \"./utils\";\nimport mulberry32 from \"../utils/mulberry\";\n\n/**\n * Configuration options for the entire puzzle generation process.\n */\nexport interface PuzzleGenerationOptions {\n  /** Width of the puzzle */\n  width: number;\n  /** Height of the puzzle */\n  height: number;\n  /** A rough guide for piece size */\n  pieceSize: number;\n  /** Random seed to produce repeatable puzzles */\n  seed?: number;\n  /** How should the points that control the pieces get generated? */\n  pointConfig: GeneratorConfig;\n  /** How should the pieces get built? */\n  pieceConfig: GeneratorConfig;\n  /** How should tabs get placed on piece edges? */\n  placementConfig: GeneratorConfig;\n  /** How should tabs get constructed? */\n  tabConfig: GeneratorConfig;\n}\n\n/**\n * Orchestrates the procedural generation of a jigsaw puzzle\n * by coordinating various pluggable generators.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function buildPuzzle(options: PuzzleGenerationOptions): Promise<PuzzleGeometry> {\n  const { width, height, pieceSize } = options;\n  const { pointConfig, pieceConfig, placementConfig, tabConfig } = options;\n\n  console.log(`rebuilding puzzle with dimensions ${width}x${height}, piece size ${pieceSize}`);\n\n  // get and configure the necessary generators\n  const pointGenerator = PointGeneratorRegistry.create(width, height, pointConfig);\n  const pieceGenerator = PieceGeneratorRegistry.create(width, height, pieceConfig);\n  const placementStrategy = TabPlacementStrategyRegistry.create(width, height, placementConfig);\n  const tabGenerator = TabGeneratorRegistry.create(width, height, tabConfig);\n\n  // seeded PRNG used to generate repeatable random numbers\n  const seed = options.seed ?? new Date().getTime();\n  const random = mulberry32(seed);\n\n  // 1. Generate seed points for the pieces\n  const points = pointGenerator.generatePoints({ width, height, pieceSize, random });\n  console.log(`Generated ${points.length} points`);\n\n  // 2. Convert points to a puzzle topology (pieces and edges)\n  const topology = pieceGenerator.generatePieces(points, { random, pieceSize });\n  console.log(`Generated ${topology.pieces.size} pieces`);\n\n  // 3. Place tabs on internal edges\n  placementStrategy.placeTabs({ topology, random });\n\n  // 4. Generate geometry for placed tabs\n  for (const edge of topology.edges.values()) {\n    // only internal edges can accept tabs\n    const isInternal = edge.heRight !== -1;\n    if (isInternal && edge.tabs && edge.tabs.length > 0) {\n      // use the tab generator to create the segment path for an edge based on its TabPlacements\n      generateSegmentsForEdge(edge, topology, tabGenerator, random);\n    }\n  }\n\n  // 5. Assemble the final puzzle data structure\n  const puzzle: PuzzleGeometry = {\n    created: new Date().toISOString(),\n    seed,\n    width,\n    height,\n    pieceSize,\n    pointConfig,\n    pieceConfig,\n    placementConfig,\n    tabConfig,\n    vertices: topology.vertices,\n    boundary: topology.boundary,\n    pieces: topology.pieces,\n    edges: topology.edges,\n    halfEdges: topology.halfEdges,\n  };\n\n  return puzzle;\n}\n\n/** Draws puzzle geometry onto a canvas */\nexport function drawPuzzle(puzzle: PuzzleGeometry, canvas: HTMLCanvasElement, pieceColor: string, pointColor?: string) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error(\"Could not get 2D context from canvas\");\n    return;\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // In debug mode, we draw each piece's full boundary in a different color.\n  // This helps visualize the ownership of each edge.\n  const debugMode = false;\n\n  if (debugMode) {\n    const debugColors = [\n      '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',\n      '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff',\n      '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',\n    ];\n    ctx.lineWidth = 2; // Use a thicker line for better visibility\n\n    let pieceIndex = 0;\n    for (const piece of puzzle.pieces.values()) {\n      const pieceColor = debugColors[pieceIndex % debugColors.length];\n      ctx.strokeStyle = pieceColor;\n      ctx.beginPath();\n      ctx.setLineDash([5, 5]); // use dashed lines\n\n      // Get the starting half-edge for this piece's boundary\n      let currentHe = puzzle.halfEdges.get(piece.halfEdge);\n      if (!currentHe) continue;\n\n      const startHeId = currentHe.id;\n      ctx.moveTo(currentHe.origin[0], currentHe.origin[1]);\n\n      // Traverse the boundary of the piece by following the 'next' pointers\n      // until we get back to the starting half-edge.\n      do {\n        if (currentHe.segments) {\n          // If the edge has a custom tab, draw its segments\n          for (const segment of currentHe.segments) {\n            switch (segment.type) {\n            case 'bezier':\n              ctx.bezierCurveTo(segment.p1[0], segment.p1[1], segment.p2[0], segment.p2[1], segment.p3[0], segment.p3[1]);\n              break;\n            case 'line':\n              ctx.lineTo(segment.p[0], segment.p[1]);\n              break;\n            }\n          }\n        } else {\n          // Otherwise, draw a straight line to the start of the next half-edge\n          const nextHe = puzzle.halfEdges.get(currentHe.next)!;\n          ctx.lineTo(nextHe.origin[0], nextHe.origin[1]);\n        }\n        // Move to the next half-edge in the loop\n        currentHe = puzzle.halfEdges.get(currentHe.next)!;\n      } while (currentHe.id !== startHeId);\n\n      ctx.stroke();\n      pieceIndex++;\n    }\n\n    // Reset line dash for subsequent drawing operations.\n    ctx.setLineDash([]);\n\n  } else {\n    // normal mode drawing, optimized for efficiency\n\n    // Style for piece boundaries\n    ctx.strokeStyle = pieceColor;\n    ctx.lineWidth = 1;\n\n    // it's more efficient to batch all paths together\n    ctx.beginPath();\n\n    // By iterating through all unique edges and drawing the curve for one of\n    // its half-edges, we ensure every cut is defined exactly once.\n    for (const edge of puzzle.edges.values()) {\n      // We consistently choose heLeft. The tab generator puts the \"outie\"\n      // or \"innie\" on this half-edge, and the twin gets the inverse.\n      const he = puzzle.halfEdges.get(edge.heLeft);\n      if (!he) continue; // should not happen\n\n      // move to the start of this edge segment\n      ctx.moveTo(he.origin[0], he.origin[1]);\n\n      if (he.segments && he.segments.length > 0) {\n        // if a custom tab is defined, draw each segment in order\n        for (const segment of he.segments) {\n          switch (segment.type) {\n          case 'bezier':\n            ctx.bezierCurveTo(\n              segment.p1[0], segment.p1[1],\n              segment.p2[0], segment.p2[1],\n              segment.p3[0], segment.p3[1]\n            );\n            break;\n          case 'line':\n            ctx.lineTo(segment.p[0], segment.p[1]);\n            break;\n          }\n        }\n      } else {\n        // no tab, draw a straight line to the edge's endpoint.\n        // The end point of a half-edge is the origin of its twin.\n        // For boundary edges, the twin is -1, so we find the end point\n        // by looking at the start of the next half-edge around the piece.\n        let destination: Vec2;\n        // For an internal edge, the destination is the origin of the twin half-edge.\n        if (he.twin !== -1) {\n          const twinHe = puzzle.halfEdges.get(he.twin)!;\n          destination = twinHe.origin;\n        } else {\n          // For a boundary edge, the destination is the origin of the next half-edge in the loop.\n          const nextHe = puzzle.halfEdges.get(he.next)!;\n          destination = nextHe.origin;\n        }\n        ctx.lineTo(destination[0], destination[1]);\n      }\n    }\n\n    // stroke the entire path containing all the unique puzzle edges\n    ctx.stroke();\n  }\n\n  // if the puzzle has problems like intersecting/overlapping pieces, highlight them\n  if (puzzle.problems && puzzle.problems.length > 0) {\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = 'red';\n    for (const problemPoint of puzzle.problems) {\n      const [x, y] = problemPoint;\n      ctx.beginPath();\n      ctx.arc(x, y, 8, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }\n\n  // draw the piece sites (original Voronoi points) for reference\n  if (pointColor) {\n    ctx.fillStyle = pointColor;\n    for (const piece of puzzle.pieces.values()) {\n      const [x, y] = piece.site;\n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n}\n","import type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  Piece,\n  PieceID,\n  PuzzleGeometry,\n  Vec2,\n  VertexID,\n} from './types';\nimport { TabPlacementStrategyRegistry, TabGeneratorRegistry } from './generators/Generator';\nimport { generateSegmentsForEdge, getPieceBounds } from './utils';\nimport mulberry32 from \"../utils/mulberry\";\n\n\n/**\n * Finds the closest vertex to a click position and moves it to a new position,\n * updating all connected edges and pieces. This function directly modifies the\n * provided puzzle object.\n *\n * @param puzzle The puzzle data structure to modify.\n * @param vertexIndex The index of the vertex to move in the `puzzle.vertices` array\n * @param newPos The new [x, y] coordinates to move the vertex to.\n */\nexport function moveVertex(\n  puzzle: PuzzleGeometry,\n  vertexIndex: VertexID,\n  newPos: Vec2\n): void {\n  // --- 1. Get the vertex's original position ---\n  if (vertexIndex < 0 || vertexIndex >= puzzle.vertices.length) {\n    console.warn(\"moveVertex called with invalid vertex index:\", vertexIndex);\n    return;\n  }\n  const oldPos = puzzle.vertices[vertexIndex];\n\n  // --- 2. Update the master vertex in the vertices array ---\n  puzzle.vertices[vertexIndex] = newPos;\n\n  // --- 3. Identify all half-edges that are affected by this move ---\n  const departingEdges: HalfEdge[] = [];\n  for (const he of puzzle.halfEdges.values()) {\n    // A half-edge \"departs\" from the vertex if its origin is at the old position.\n    if (he.origin[0] === oldPos[0] && he.origin[1] === oldPos[1]) {\n      departingEdges.push(he);\n    }\n  }\n\n  const affectedPieceIDs = new Set<PieceID>();\n  const delta: Vec2 = [newPos[0] - oldPos[0], newPos[1] - oldPos[1]];\n\n  // --- 4. Update the geometry of all affected half-edges ---\n  for (const departingEdge of departingEdges) {\n    // The origin of the departing edge is now the new position.\n    departingEdge.origin = newPos;\n    affectedPieceIDs.add(departingEdge.piece);\n\n    // Now we must update the half-edge that *flows into* this vertex.\n    // This is the predecessor in the piece's boundary loop.\n    const predecessorEdge = puzzle.halfEdges.get(departingEdge.prev);\n\n    if (predecessorEdge?.segments) {\n      const lastSegment = predecessorEdge.segments[predecessorEdge.segments.length - 1];\n\n      // Update the endpoint of the predecessor's final segment.\n      if (lastSegment.type === 'line') {\n        lastSegment.p = newPos;\n      } else { // 'bezier'\n        lastSegment.p3 = newPos;\n        // For a smooth transition, we translate the control points by the same\n        // amount as the endpoint. More sophisticated logic could be used here\n        // for better curve preservation.\n        lastSegment.p1 = [lastSegment.p1[0] + delta[0], lastSegment.p1[1] + delta[1]];\n        lastSegment.p2 = [lastSegment.p2[0] + delta[0], lastSegment.p2[1] + delta[1]];\n      }\n      affectedPieceIDs.add(predecessorEdge.piece);\n    }\n  }\n\n  // --- 5. Rebuild any tabs affected by the vertex move ---\n  regenerateAffectedTabs(puzzle, vertexIndex);\n\n  // --- 6. Recalculate the bounding boxes for all affected pieces ---\n  for (const pieceId of affectedPieceIDs) {\n    const piece = puzzle.pieces.get(pieceId);\n    if (piece) {\n      piece.bounds = getPieceBounds(piece, puzzle);\n    }\n  }\n}\n\n\n/**\n * Finds all full (interior) edges connected to a given vertex and regenerates their tabs.\n *\n * @param puzzle The puzzle and its topology.\n * @param vertex The the vertex that was modified.\n */\nexport function regenerateAffectedTabs(\n  puzzle: PuzzleGeometry,\n  vertex: VertexID\n): void {\n\n  const { seed, width, height, placementConfig, tabConfig } = puzzle;\n  const random = mulberry32(seed);\n\n  // recreate the placement strategy and tab generator that were used for this puzzle\n  const placementStrategy = TabPlacementStrategyRegistry.create(width, height, placementConfig);\n  const tabGenerator = TabGeneratorRegistry.create(width, height, tabConfig);\n\n  const affectedEdges = new Set<Edge>();\n  const movedVertexPos = puzzle.vertices[vertex];\n\n  // To efficiently find the parent Edge of a HalfEdge, we can build a lookup map.\n  // This is much faster than iterating through all edges every time.\n  const halfEdgeToEdgeMap = new Map<EdgeID, Edge>();\n  for (const edge of puzzle.edges.values()) {\n    halfEdgeToEdgeMap.set(edge.heLeft, edge);\n    // heRight can be -1 for boundary edges, so check first.\n    if (edge.heRight !== -1) {\n      halfEdgeToEdgeMap.set(edge.heRight, edge);\n    }\n  }\n\n  // Find all half-edges that either start or end at the moved vertex.\n  for (const he of puzzle.halfEdges.values()) {\n    const destinationVertex = puzzle.halfEdges.get(he.next)?.origin;\n\n    // Is this half-edge starting at the moved vertex?\n    const startsAtVertex = he.origin === movedVertexPos;\n    // Is this half-edge ending at the moved vertex?\n    const endsAtVertex = destinationVertex === movedVertexPos;\n\n    if (startsAtVertex || endsAtVertex) {\n      const parentEdge = halfEdgeToEdgeMap.get(he.id);\n      if (parentEdge) {\n        affectedEdges.add(parentEdge);\n      }\n    }\n  }\n\n  // re-run the placement strategy in case it needs to make a change\n  placementStrategy.updateTabPlacements(Array.from(affectedEdges), { topology: puzzle, random });\n\n  const affectedPieces = new Set<Piece>();\n\n  // Now, regenerate the tabs for the unique set of affected edges.\n  for (const edge of affectedEdges) {\n    // only add tabs to internal edges\n    const isInternal = edge.heRight !== -1;\n    if (isInternal) {\n      // remove any existing segments\n      const he1 = puzzle.halfEdges.get(edge.heLeft);\n      if (he1) {\n        he1.segments = undefined;\n        affectedPieces.add(puzzle.pieces.get(he1.piece)!);\n      }\n      const he2 = puzzle.halfEdges.get(edge.heRight);\n      if (he2) {\n        he2.segments = undefined;\n        affectedPieces.add(puzzle.pieces.get(he2.piece)!);\n      }\n\n      // regenerate segments\n      generateSegmentsForEdge(edge, puzzle, tabGenerator, random);\n    }\n  }\n\n  // recalculate boundaries for affected pieces\n  for (const piece of affectedPieces) {\n    piece.bounds = getPieceBounds(piece, puzzle);\n  }\n\n}","import m from 'mithril';\nimport { drawPuzzle } from \"../geometry/PuzzleMaker\";\nimport { moveVertex } from '../geometry/modifiers';\nimport { findClosestVertex } from '../geometry/utils';\nimport type { VertexID } from '../geometry/types';\nimport type { PuzzleGeometry, Vec2 } from '../geometry/types';\nimport type MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// include our CSS\nimport './Puzzle.css';\n\n// component attributes\nexport interface PuzzleAttrs extends m.Attributes {\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Generated puzzle geometry */\n  puzzle: PuzzleGeometry,\n  /** If true, geometry is being regenerated */\n  isDirty: boolean;\n  /** If set, draw the seed points in this color */\n  pointColor?: string;\n  /** User uploaded image */\n  imageUrl?: string;\n  /** Callback indicating user modified the puzzle geometry */\n  onPuzzleChanged: (puzzle: PuzzleGeometry) => void;\n}\n\n// Mithril component\nexport const Puzzle: m.ClosureComponent<PuzzleAttrs> = () => {\n\n  // component state\n  const state = {\n    /** Canvas HTML element */\n    canvas: null as HTMLCanvasElement | null,\n    /** Is the user currently dragging a vertex? */\n    isDragging: false,\n    /** The index of the vertex being dragged. */\n    draggedVertexId: -1 as VertexID,\n  };\n\n  // helper function to normalize coordinates between mouse clicks and mobile touches\n  const getEventCoords = (e: MouseEvent | TouchEvent): Vec2 => {\n    if (!state.canvas) return [0, 0];\n    const rect = state.canvas.getBoundingClientRect();\n\n    if (e instanceof TouchEvent) {\n      // TouchEvent\n      if (e.changedTouches.length > 0) {\n        const touch = e.changedTouches[0];\n        return [touch.clientX - rect.left, touch.clientY - rect.top];\n      }\n    } else {\n      // MouseEvent\n      return [e.clientX - rect.left, e.clientY - rect.top];\n    }\n    return [0, 0];\n  };\n\n  // handles the start of a drag operation (mouse or mobile)\n  const handleDragStart = (e: (MouseEvent | TouchEvent) & MithrilViewEvent, attrs: PuzzleAttrs) => {\n    e.redraw = false;\n\n    // for touch events, ignore multiple touches (like pinch zoom)\n    if (e instanceof TouchEvent) {\n      if (e.touches.length > 1) {\n        state.isDragging = false;\n        state.draggedVertexId = -1;\n        return;\n      }\n    }\n\n    // for mouse events, only handle the primary button.\n    if (e instanceof MouseEvent && e.button !== 0) return;\n\n    //e.preventDefault();\n    const coords = getEventCoords(e);\n\n    // find the nearest vertex and store it as a potential drag target\n    const vertexIndex = findClosestVertex(attrs.puzzle, coords);\n    if (vertexIndex !== null) {\n      state.draggedVertexId = vertexIndex;\n    }\n  };\n\n  // handles drag movement (mouse or mobile)\n  const handleDragMove = (e: (MouseEvent | TouchEvent) & MithrilViewEvent, attrs: PuzzleAttrs) => {\n    e.redraw = false;\n\n    // if the user didn't target a vertex, do nothing\n    if (state.draggedVertexId < 0 ) return;\n\n    state.isDragging = true;\n\n    e.preventDefault();\n    const coords = getEventCoords(e);\n\n    // move the dragged vertex and redraw\n    moveVertex(attrs.puzzle, state.draggedVertexId, coords);\n    drawPuzzle(attrs.puzzle, state.canvas!, attrs.color);\n  };\n\n  // handles the end of a drag (mouse or mobile)\n  const handleDragEnd = (e: (MouseEvent | TouchEvent) & MithrilViewEvent, attrs: PuzzleAttrs) => {\n    e.redraw = false;\n    if (state.draggedVertexId < 0) return;\n    e.preventDefault();\n\n    // we only care about the end of a drag, not a click\n    if (state.isDragging) {\n      attrs.onPuzzleChanged(attrs.puzzle);\n    }\n\n    state.isDragging = false;\n    state.draggedVertexId = -1;\n  };\n\n  return {\n    // component lifecycle: called after our DOM element is created and attached\n    oncreate: ({ dom, attrs }) => {\n      state.canvas = dom.querySelector<HTMLCanvasElement>(\"canvas.puzzle\");\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color, attrs.pointColor);\n      }\n    },\n\n    onupdate: ({ attrs }) => {\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color, attrs.pointColor);\n      }\n    },\n\n    // component lifecycle: render our output\n    view: ({ attrs }) => {\n\n      return m(\".puzzle-stack\", [\n\n        // user uploaded image\n        m(\"img.background\", {\n          width: attrs.width,\n          height: attrs.height,\n          src: attrs.imageUrl,\n        }),\n\n        // canvas for rendering the current puzzle\n        m('canvas.puzzle', {\n          width: attrs.width,\n          height: attrs.height,\n          style: {\n            width: `${attrs.width}px`,\n            height: `${attrs.height}px`,\n            touchAction: 'manipulation',\n          },\n\n          // mouse events\n          onmousedown: (e: MouseEvent & MithrilViewEvent) => handleDragStart(e, attrs),\n          onmousemove: (e: MouseEvent & MithrilViewEvent) => handleDragMove(e, attrs),\n          onmouseup: (e: MouseEvent & MithrilViewEvent) => handleDragEnd(e, attrs),\n          onmouseleave: (e: MouseEvent & MithrilViewEvent) => handleDragEnd(e, attrs),\n\n          // touch events\n          ontouchstart: (e: TouchEvent & MithrilViewEvent) => handleDragStart(e, attrs),\n          ontouchmove: (e: TouchEvent & MithrilViewEvent) => handleDragMove(e, attrs),\n          ontouchend: (e: TouchEvent & MithrilViewEvent) => handleDragEnd(e, attrs),\n          ontouchcancel: (e: TouchEvent & MithrilViewEvent) => handleDragEnd(e, attrs),\n        }),\n      ]);\n    },\n\n  };\n};\nexport default Puzzle;\n\n","import { PuzzleTopology, Vec2 } from \"../geometry/types\";\n\n/**\n * Generates an SVG string representation of the puzzle's cut lines.\n *\n * @param topology - The puzzle topology containing the geometric data.\n * @param width - The width of the SVG viewport.\n * @param height - The height of the SVG viewport.\n * @param pieceColor - Optional color to draw the pieces (default black)\n * @returns A string containing the complete SVG markup.\n */\nexport function createSVG(topology: PuzzleTopology, width: number, height: number, pieceColor = \"black\"): string {\n  // how many digits to preserve when converting decimal numbers to SVG string\n  const precisionDigits = 3;\n\n  // Array to hold the individual path commands (e.g., \"M 10 10\", \"L 100 100\").\n  const pathData: string[] = [];\n\n  // Iterate over each unique edge, ensuring each cut is only defined once.\n  for (const edge of topology.edges.values()) {\n    const he = topology.halfEdges.get(edge.heLeft);\n    if (!he) continue;\n\n    // SVG Path Command: \"M\" - move to the starting point of the half-edge.\n    pathData.push(`M ${he.origin[0].toFixed(precisionDigits)} ${he.origin[1].toFixed(precisionDigits)}`);\n\n    if (he.segments) {\n      // if a custom tab is defined, draw each segment in order\n      for (const segment of he.segments) {\n        switch (segment.type) {\n        case 'bezier':\n          // SVG Path Command: \"C\" - draw a cubic Bézier curve.\n          pathData.push(\n            `C ${segment.p1[0].toFixed(precisionDigits)} ${segment.p1[1].toFixed(precisionDigits)}, ` +\n            `${segment.p2[0].toFixed(precisionDigits)} ${segment.p2[1].toFixed(precisionDigits)}, ` +\n            `${segment.p3[0].toFixed(precisionDigits)} ${segment.p3[1].toFixed(precisionDigits)}`\n          );\n          break;\n        case 'line':\n          // SVG Path Command: \"L\" - draw a straight line to the destination.\n          pathData.push(`L ${segment.p[0].toFixed(precisionDigits)} ${segment.p[1].toFixed(precisionDigits)}`);\n          break;\n        }\n      }\n    } else {\n      // SVG Path Command: \"L\" - draw a straight line to the destination.\n      let destination: Vec2;\n      if (he.twin !== -1) {\n        // Internal edge: destination is the start of the twin half-edge.\n        const twinHe = topology.halfEdges.get(he.twin)!;\n        destination = twinHe.origin;\n      } else {\n        // Boundary edge: destination is the start of the next half-edge.\n        const nextHe = topology.halfEdges.get(he.next)!;\n        destination = nextHe.origin;\n      }\n      pathData.push(`L ${destination[0].toFixed(precisionDigits)} ${destination[1].toFixed(precisionDigits)}`);\n    }\n  }\n\n  // Join all path commands into a single string for the 'd' attribute.\n  const pathD = pathData.join(' ');\n\n  // Construct the final SVG markup.\n  // The <path> element uses vector-effect=\"non-scaling-stroke\" which is a best\n  // practice for laser cutting files, as it ensures the line width remains\n  // constant regardless of scaling.\n  const svgString = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg\n  width=\"${width}\"\n  height=\"${height}\"\n  viewBox=\"0 0 ${width} ${height}\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  version=\"1.1\"\n>\n  <path\n    d=\"${pathD}\"\n    fill=\"none\"\n    stroke=\"${pieceColor}\"\n    stroke-width=\"1\"\n    vector-effect=\"non-scaling-stroke\"\n  />\n</svg>`\n    .trim() // strip leading and trailing whitespace\n    .replace(/\\r\\n/g, '\\n'); // use unix line endings for max compatibility\n\n  return svgString;\n}\n\n\n/**\n * Offers a SVG file for download\n * @param svg SVG string as generated by drawSVG()\n * @param filename Optional name of file for download\n */\nexport function downloadSvg(svg: string, filename = \"puzzle.svg\") {\n  // create a blob from the SVG string\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n\n  // create a temporary object URL for the blob\n  const url = URL.createObjectURL(blob);\n\n  // create a hidden <a> element with the download attribute\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  a.hidden = true;\n\n  // click it\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n\n  // clean up\n  setTimeout(() => URL.revokeObjectURL(url), 100);\n}\n","// UI component that offers a SVG download when clicked\nimport m from 'mithril';\nimport { createSVG, downloadSvg } from '../utils/svg';\nimport type { PuzzleTopology } from '../geometry/types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\nexport interface DownloadPuzzleButtonAttrs extends m.Attributes {\n  /** Generated puzzle geometry */\n  puzzle: PuzzleTopology;\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Optional filename for the download */\n  filename?: string;\n}\n\nexport const DownloadPuzzleButton: m.Component<DownloadPuzzleButtonAttrs> = {\n  view: ({ attrs }) => {\n    return m('wa-button.download-svg', {\n      size: 'small',\n      onclick: () => {\n        // convert the puzzle geometry into a SVG string\n        const svg = createSVG(attrs.puzzle, attrs.width, attrs.height, attrs.color);\n        // offer it as a download\n        downloadSvg(svg, attrs.filename ?? 'puzzle.svg');\n      },\n    }, 'Download SVG');\n  },\n};\nexport default DownloadPuzzleButton;\n","// UI component to initiate and display geometry checks\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/badge/badge.js';\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\nimport '@awesome.me/webawesome/dist/components/progress-bar/progress-bar.js';\nimport '@awesome.me/webawesome/dist/components/tooltip/tooltip.js';\n\n// component CSS\nimport './GeometryCheckIndicator.css';\n\n// component attributes\nexport interface GeometryCheckIndicatorAttrs extends m.Attributes {\n  /** If true, the auto check box is checked */\n  autoCheck: boolean;\n  /** If present, represents the number of geometry problems found in the most recent check */\n  problems?: number;\n  /** If present represents the percent complete of the current geometry check */\n  progressPercent?: number;\n  /** Handler called when user clicks the check now button */\n  onCheckRequested?: () => void;\n  /** Called when the user toggles the auto check on or off */\n  onAutocheckChanged?: (autocheck: boolean) => void;\n};\n\n// component\nexport const GeometryCheckIndicator: m.Component<GeometryCheckIndicatorAttrs> = {\n  view: ({ attrs }) => {\n    const showProgress = attrs.progressPercent !== undefined && attrs.progressPercent < 100;\n    const showOKBadge = !showProgress && attrs.problems !== undefined && attrs.problems == 0;\n    const showProblemBadge = !showProgress && attrs.problems !== undefined && attrs.problems > 0;\n\n    return m('.geometry-check-indicator', [\n\n      // label\n      m('.label', \"Geometry Check:\"),\n\n      // run now button\n      m('wa-tooltip', { for: 'check-geometry-now'}, 'Check geometry now'),\n      m('wa-button#check-geometry-now', {\n        variant: 'neutral',\n        appearance: 'plain',\n        size: 'small',\n        disabled: showProgress,\n        onclick: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          attrs.onCheckRequested?.();\n        },\n      }, m('wa-icon', {\n        library: 'material',\n        name: 'editor_choice',\n        label: 'Check geometry now',\n      })),\n\n      // auto check checkbox\n      m('wa-tooltip', { for: 'auto-check-geometry' }, 'Check geometry after every change'),\n      m('wa-checkbox#auto-check-geometry', {\n        checked: attrs.autoCheck,\n        disabled: showProgress,\n        size: 'small',\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const checkbox = e.target as WaCheckbox;\n          attrs.onAutocheckChanged?.(checkbox.checked);\n        },\n      }, 'auto check'),\n\n      // progress indicator\n      showProgress && m('wa-progress-bar', {\n        label: 'Geometry check progress',\n        value: attrs.progressPercent ?? 0,\n      }),\n\n      // OK badge\n      showOKBadge && m('wa-badge', {\n        variant: 'success',\n        pill: true,\n      }, 'OK'),\n\n      // Problems badge\n      showProblemBadge && m('wa-badge', {\n        variant: 'danger',\n        pill: true,\n      }, `${attrs.problems} issue${attrs.problems === 1 ? '' : 's'}`),\n\n    ]);\n  },\n};\nexport default GeometryCheckIndicator;\n","// UI component that allows the user to select an image to upload when clicked\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\n// component attributes\nexport interface UploadImageAttrs extends m.Attributes {\n  /** Optional label for the button, default \"Upload Image\" */\n  label?: string;\n  /** If true, the button will be disabled */\n  disabled?: boolean;\n  /**\n   * Called when the user uploads an image. The caller is responsible for\n   * cleaning up the returned image URL.\n   */\n  onUpload: (imageUrl: string, filename: string, width: number, height: number) => void;\n};\n\n// utility to determine display dimensions that are the same aspect ratio\nfunction calculateDisplayDimensions(originalWidth: number, originalHeight: number, maxWidth = 800): {\n  width: number;\n  height: number;\n} {\n  if (originalWidth <= maxWidth) {\n    return {\n      width: originalWidth,\n      height: originalHeight,\n    };\n  }\n\n  const aspectRatio = originalHeight / originalWidth;\n  return {\n    width: maxWidth,\n    height: Math.round(maxWidth * aspectRatio),\n  };\n}\n\n// component\nexport const UploadImageButton: m.ClosureComponent<UploadImageAttrs> = () => {\n\n  // component state\n  const state = {\n    inputElement: undefined as HTMLInputElement | undefined,\n  };\n\n  return {\n\n    view: ({ attrs }) => {\n      return [\n\n        // button for display\n        m('wa-button.upload-button', {\n          size: 'small',\n          disabled: attrs.disabled === true,\n          onclick: () => {\n            if (state.inputElement) {\n              state.inputElement.click();\n            }\n          },\n        }, attrs.label ?? 'Upload Image'),\n\n        // hidden file input that does the work\n        m('input[type=file]', {\n          style: { display: 'none' },\n          accept: 'image/*',\n          oncreate: ({ dom }) => {\n            state.inputElement = dom as HTMLInputElement;\n          },\n          onchange: (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            if (state.inputElement) {\n              const file = state.inputElement.files?.[0];\n              if (file?.type.startsWith('image/')) {\n                createImageBitmap(file)\n                  .then((bitmap) => {\n                    // get the image dimensions, scaled to fit in the display area\n                    const { width, height } = calculateDisplayDimensions(bitmap.width, bitmap.height);\n                    const uploadUrl = URL.createObjectURL(file);\n                    bitmap.close();\n                    attrs.onUpload(uploadUrl, file.name, width, height);\n                  })\n                  .catch((err) => {\n                    console.error('could not create a bitmap image: ', err);\n                  });\n              }\n            }\n          },\n        }),\n      ];\n    },\n  };\n};\nexport default UploadImageButton;\n","// UI component to take boolean input\nimport m from 'mithril';\nimport type { BooleanUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\n\n// component attributes\nexport interface BooleanInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: BooleanUIControl;\n  /** Current value */\n  value: boolean;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: boolean) => void;\n}\n\n// component\nexport const BooleanInputControl: m.ClosureComponent<BooleanInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-checkbox.boolean-input', {\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        checked: attrs.value,\n        onchange: (e: Event) => {\n          const input = e.target as WaCheckbox;\n          const newValue = input.checked;\n          attrs.onChange(newValue);\n        },\n      }, attrs.config.label);\n    },\n  };\n};\nexport default BooleanInputControl;\n","// UI component to take a number input\nimport m from 'mithril';\nimport type { NumberUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface NumberInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: NumberUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const NumberInputControl: m.ClosureComponent<NumberInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.number-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"number\",\n        inputmode: \"numeric\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        onchange: (e: Event) => {\n          const input = e.target as WaInput;\n          const newValue = parseFloat(input.value ?? '');\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default NumberInputControl;\n","// UI component to take number input from a slider\nimport m from 'mithril';\nimport type { RangeUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// component attributes\nexport interface RangeInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: RangeUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const RangeInputControl: m.ClosureComponent<RangeInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-slider.range-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        step: attrs.config.step,\n        'with-tooltip': true,\n        onchange: (e: Event) => {\n          const input = e.target as WaSlider;\n          const newValue = input.value;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default RangeInputControl;\n","// UI component to take string input\nimport m from 'mithril';\nimport type { StringUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface StringInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: StringUIControl;\n  /** Current value */\n  value?: string;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: string | undefined) => void;\n}\n\n// component\nexport const StringInputControl: m.ClosureComponent<StringInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.string-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"text\",\n        inputmode: \"text\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        onchange: (e: Event) => {\n          const input = e.target as WaInput;\n          const newValue = input.value ?? '';\n          attrs.onChange(newValue.length > 0 ? newValue : undefined);\n        },\n      });\n    },\n  };\n};\nexport default StringInputControl;\n","// UI component that lets the user pick and configure a generator\nimport m from 'mithril';\nimport type { GeneratorRegistry, GeneratorConfig, GeneratorName } from '../geometry/generators/Generator';\nimport BooleanInputControl from './inputs/BooleanInputControl';\nimport NumberInputControl from './inputs/NumberInputControl';\nimport RangeInputControl from './inputs/RangeInputControl';\nimport StringInputControl from './inputs/StringInputControl';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/tab/tab.js';\nimport '@awesome.me/webawesome/dist/components/tab-group/tab-group.js';\nimport '@awesome.me/webawesome/dist/components/tab-panel/tab-panel.js';\nimport type { WaTabShowEvent } from '@awesome.me/webawesome';\n\n\n// include our CSS\nimport './GeneratorPicker.css';\n\n// component attributes\nexport interface GeneratorPickerAttrs<C extends GeneratorConfig = GeneratorConfig> extends m.Attributes {\n  /** Currently selected generator for this type */\n  generator: GeneratorName;\n  /** All the registered generators for this type */\n  registry: GeneratorRegistry<unknown>;\n  /** Current configuration for the selected generator */\n  config: C;\n  /** Called when the selected generator changes */\n  onGeneratorChange: (generatorName: string) => void;\n  /** Called when any config value changes */\n  onConfigChange: <K extends keyof C>(key: K, value: C[K]) => void;\n}\n\n// component\nexport const GeneratorPicker: m.ClosureComponent<GeneratorPickerAttrs> = () => {\n\n  // no component state\n\n  // component\n  return {\n\n    view: ({ attrs }) => {\n\n      const generators = attrs.registry.getAvailableGenerators();\n\n      return m(\".generator-picker\",\n        m('wa-tab-group', {\n          active: attrs.generator,\n          // custom Webawesome event triggered when a new tab panel is shown\n          'onwa-tab-show': (e: WaTabShowEvent) => {\n            const newSelected = e.detail.name;\n            if (attrs.generator !== newSelected) {\n              attrs.onGeneratorChange(newSelected);\n            }\n          },\n        }, [\n          ...generators.map((generator) => {\n            // get the UI metadata associated with this generator\n            const uiMetadata = attrs.registry.getUIMetadata(generator.name);\n\n            // tab contains name of generator\n            const tab = m('wa-tab', { panel: generator.name }, generator.displayName);\n\n            // matching panel contains controls specific to that generator\n            const panel = m('wa-tab-panel', { name: generator.name }, m('.controls',\n              [\n                // detailed description of the generator if available\n                uiMetadata?.description ? m('p', uiMetadata.description) : null,\n\n                // UI controls defined by the generator\n                ...uiMetadata?.controls.map((control) => {\n                  switch(control.type) {\n                  case \"range\":\n                    return m(RangeInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"boolean\":\n                    return m(BooleanInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) === true,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"number\":\n                    return m(NumberInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"string\":\n                    return m(StringInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as string | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  }\n                }) ?? [],\n\n                // no controls message when appropriate\n                (!uiMetadata?.description && uiMetadata?.controls.length == 0) ? m('p', 'No controls for this strategy.') : null,\n              ])\n            );\n            return [tab, panel];\n          }),\n        ])\n      );\n    },\n  };\n};\nexport default GeneratorPicker;\n","// UI component to let the user select an aspect ratio\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/option/option.js';\nimport '@awesome.me/webawesome/dist/components/select/select.js';\nimport WaSelect from '@awesome.me/webawesome/dist/components/select/select.js';\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// this component's CSS\nimport './AspectRatioPicker.css';\n\n// component attributes\nexport interface AspectRatioPickerAttr extends m.Attributes {\n  /** Current ratio */\n  ratio: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current ratio */\n  onChange: (ratio: number) => void;\n}\n\n// data\nconst commonAspectRatios: [string, string, number][] = [\n  [\"Square\",           \"1:1\",    1],\n\n  // --- Landscape ---\n  [\"Classic Photo\",    \"5:4\",    5/4],\n  [\"Standard Photo\",   \"4:3\",    4/3],\n  [\"35mm/DSLR\",        \"3:2\",    3/2],\n  [\"Widescreen\",       \"16:9\",   16/9],\n  [\"UltraWide\",        \"21:9\",   21/9],\n  [\"Panorama\",         \"2:1\",    2/1],\n\n  // --- Portrait ---\n  [\"Instagram Portrait\",       \"4:5\",    4/5],\n  [\"Classic Portrait\",         \"3:4\",    3/4],\n  [\"DSLR Portrait\",            \"2:3\",    2/3],\n  [\"Phone Portrait\",           \"9:16\",   9/16],\n  [\"Tall Poster\",              \"9:21\",   9/21],\n  [\"Tall Panorama\",            \"1:2\",    1/2],\n];\n\n// component\nexport const AspectRatioPicker: m.Component<AspectRatioPickerAttr> = {\n  view: ({ attrs }) => {\n\n    // Determine if the current ratio is a custom value (not in our predefined list)\n    const isCustom = !commonAspectRatios.some(([, , value]) => value === attrs.ratio);\n\n    // Generate the list of <wa-option> elements\n    const selectOptions = commonAspectRatios.map(([name, ratioStr, value]) =>\n      m('wa-option', {\n        value: String(value), // select values are strings\n      }, `${name} [${ratioStr}]`)\n    );\n\n    // If the ratio is custom, add a temporary \"Custom\" option to the start of the list\n    if (isCustom) {\n      selectOptions.unshift(m('wa-option', { value: 'custom' }, 'Custom'));\n    }\n\n    return m('.aspect-ratio-picker', [\n\n      // drop down with common ratios\n      m('wa-select', {\n        label: 'Aspect Ratio',\n        size: 'small',\n        disabled: attrs.disabled,\n        value: isCustom ? 'custom' : String(attrs.ratio),\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const select = e.target as WaSelect;\n          const selectedValue = select.value as string;\n\n          // 'custom' is a placeholder, so we only trigger onChange for actual numeric values.\n          if (selectedValue && selectedValue !== 'custom') {\n            attrs.onChange(Number(selectedValue));\n          }\n        },\n      }, selectOptions),\n\n      // slider for any ratio\n      m('wa-slider', {\n        // allow ratios from 1:4 (0.25) to 4:1 (4.0)\n        min: 0.25,\n        max: 4,\n        step: 0.01,\n        'with-tooltip': true,\n        size: 'small',\n        disabled: attrs.disabled,\n        value: attrs.ratio,\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const range = e.target as WaSlider;\n          attrs.onChange(range.value);\n        },\n      }),\n    ]);\n  },\n};\nexport default AspectRatioPicker;\n","// UI component to let the user select a color\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\nimport WaColorPicker from '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\n\n// this component's CSS\nimport './ColorPicker.css';\n\n// component attributes\nexport interface ColorPickerAttrs extends m.Attributes {\n  /** Label to display next to the color picker */\n  label: string;\n  /** Current color */\n  color: string;\n  /** Optional size of picker trigger area */\n  size?: \"small\" | \"medium\" | \"large\";\n  /** Called when the user changes the color */\n  onUpdate: (newColor: string) => void;\n};\n\n// component with no state\nexport const ColorPicker: m.Component<ColorPickerAttrs> = {\n  view: ({ attrs }) => {\n    return m('wa-color-picker', {\n      label: attrs.label,\n      value: attrs.color,\n      size: attrs.size ?? \"medium\",\n      format: 'rgb',\n      onchange: (e: Event & MithrilViewEvent) => {\n        e.redraw = false;\n        const input = e.target as WaColorPicker;\n        attrs.onUpdate(input.value ?? '');\n      },\n    });\n  },\n};\nexport default ColorPicker;\n","\"use strict\";\n\nfunction tinyNDArrayOfInteger (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        dimension;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    return {\n        stride: stride,\n        data: new Uint32Array(totalLength)\n    };\n}\n\nfunction tinyNDArrayOfArray (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        data = [],\n        dimension, index;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    for (index = 0; index < totalLength; index++) {\n        data.push([]);\n    }\n\n    return {\n        stride: stride,\n        data: data\n    };\n}\n\nmodule.exports = {\n    integer: tinyNDArrayOfInteger,\n    array: tinyNDArrayOfArray\n};","\"use strict\";\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n","module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n","\"use strict\";\n\nvar moore = require('moore');\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    // filter out neighbours who are too far from the center cell\n    // the impact of this, performance wise, is surprisingly small, even in 3d and higher dimensions\n    neighbourhood = neighbourhood.filter(function (n) {\n        var dist = 0;\n\n        for (var d = 0; d < dimensionNumber; d++) {\n            dist += Math.pow(Math.max(0, Math.abs(n[d]) - 1), 2);\n        }\n\n        return dist < dimensionNumber; // cellSize = Math.sqrt(this.dimension)\n    });\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0,\n            dimension;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n}\n\nvar neighbourhoodCache = {};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhoodMemoized (dimensionNumber) {\n    if (!neighbourhoodCache[dimensionNumber]) {\n        neighbourhoodCache[dimensionNumber] = getNeighbourhood(dimensionNumber);\n    }\n\n    return neighbourhoodCache[dimensionNumber];\n}\n\nmodule.exports = getNeighbourhoodMemoized;","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').integer,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nfunction squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n}\n\n/**\n * FixedDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction FixedDensityPDS (options, rng) {\n    if (typeof options.distanceFunction === 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.squaredMinDistance = this.minDistance * this.minDistance;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.minDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints\n}\n\nFixedDensityPDS.prototype.shape = null;\nFixedDensityPDS.prototype.dimension = null;\nFixedDensityPDS.prototype.minDistance = null;\nFixedDensityPDS.prototype.maxDistance = null;\nFixedDensityPDS.prototype.minDistancePlusEpsilon = null;\nFixedDensityPDS.prototype.squaredMinDistance = null;\nFixedDensityPDS.prototype.deltaDistance = null;\nFixedDensityPDS.prototype.cellSize = null;\nFixedDensityPDS.prototype.maxTries = null;\nFixedDensityPDS.prototype.rng = null;\nFixedDensityPDS.prototype.neighbourhood = null;\n\nFixedDensityPDS.prototype.currentPoint = null;\nFixedDensityPDS.prototype.processList = null;\nFixedDensityPDS.prototype.samplePoints = null;\nFixedDensityPDS.prototype.gridShape = null;\nFixedDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nFixedDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nFixedDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nFixedDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nFixedDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nFixedDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will always throw an error.\n */\nFixedDensityPDS.prototype.getAllPointsWithDistance = function () {\n    throw new Error('PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation');\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nFixedDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = FixedDensityPDS;\n","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').array,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Euclidean distance\n */\nfunction euclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return Math.sqrt(result);\n}\n\n/**\n * VariableDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function} options.distanceFunction Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {float} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} rng RNG function, defaults to Math.random\n * @constructor\n */\nfunction VariableDensityPDS (options, rng) {\n    if (typeof options.distanceFunction !== 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n    this.distanceFunction = options.distanceFunction;\n    this.bias = Math.max(0, Math.min(1, options.bias || 0));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.maxDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.currentDistance = 0;\n    this.processList = [];\n    this.samplePoints = [];\n    this.sampleDistance = []; // used to store the distance for a given point\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints and sampleDistance\n}\n\nVariableDensityPDS.prototype.shape = null;\nVariableDensityPDS.prototype.dimension = null;\nVariableDensityPDS.prototype.minDistance = null;\nVariableDensityPDS.prototype.maxDistance = null;\nVariableDensityPDS.prototype.minDistancePlusEpsilon = null;\nVariableDensityPDS.prototype.deltaDistance = null;\nVariableDensityPDS.prototype.cellSize = null;\nVariableDensityPDS.prototype.maxTries = null;\nVariableDensityPDS.prototype.distanceFunction = null;\nVariableDensityPDS.prototype.bias = null;\nVariableDensityPDS.prototype.rng = null;\nVariableDensityPDS.prototype.neighbourhood = null;\n\nVariableDensityPDS.prototype.currentPoint = null;\nVariableDensityPDS.prototype.currentDistance = null;\nVariableDensityPDS.prototype.processList = null;\nVariableDensityPDS.prototype.samplePoints = null;\nVariableDensityPDS.prototype.sampleDistance = null;\nVariableDensityPDS.prototype.gridShape = null;\nVariableDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nVariableDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nVariableDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nVariableDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        pointIndex = this.samplePoints.length,\n        dimension;\n\n    this.processList.push(pointIndex);\n    this.samplePoints.push(point);\n    this.sampleDistance.push(this.distanceFunction(point));\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex].push(pointIndex); // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nVariableDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint,\n        existingPointDistance;\n\n    var pointDistance = this.distanceFunction(point);\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex].length > 0) {\n            for (var i = 0; i < this.grid.data[internalArrayIndex].length; i++) {\n                existingPoint = this.samplePoints[this.grid.data[internalArrayIndex][i]];\n                existingPointDistance = this.sampleDistance[this.grid.data[internalArrayIndex][i]];\n\n                var minDistance = Math.min(existingPointDistance, pointDistance);\n                var maxDistance = Math.max(existingPointDistance, pointDistance);\n                var dist = minDistance + (maxDistance - minDistance) * this.bias;\n\n                if (euclideanDistance(point, existingPoint) < this.minDistance + this.deltaDistance * dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nVariableDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        currentDistance,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            var sampleIndex = this.processList.shift();\n            this.currentPoint = this.samplePoints[sampleIndex];\n            this.currentDistance = this.sampleDistance[sampleIndex];\n        }\n\n        currentPoint = this.currentPoint;\n        currentDistance = this.currentDistance;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * (currentDistance + (1 - currentDistance) * this.bias);\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @returns {Array[]} Sample points with their distance function result\n */\nVariableDensityPDS.prototype.getAllPointsWithDistance = function () {\n    var result = new Array(this.samplePoints.length),\n        i = 0,\n        dimension = 0,\n        point;\n\n    for (i = 0; i < this.samplePoints.length; i++) {\n        point = new Array(this.dimension + 1);\n\n        for (dimension = 0; dimension < this.dimension; dimension++) {\n            point[dimension] = this.samplePoints[i][dimension];\n        }\n\n        point[this.dimension] = this.sampleDistance[i];\n\n        result[i] = point;\n    }\n\n    return result;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nVariableDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = [];\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = VariableDensityPDS;\n","\"use strict\";\n\nvar FixedDensityPDS = require('./implementations/fixed-density');\nvar VariableDensityPDS = require('./implementations/variable-density');\n\n/**\n * PoissonDiskSampling constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [options.distanceFunction] Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {function|null} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction PoissonDiskSampling (options, rng) {\n    this.shape = options.shape;\n\n    if (typeof options.distanceFunction === 'function') {\n        this.implementation = new VariableDensityPDS(options, rng);\n    } else {\n        this.implementation = new FixedDensityPDS(options, rng);\n    }\n}\n\nPoissonDiskSampling.prototype.implementation = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    return this.implementation.addRandomPoint();\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    return this.implementation.addPoint(point);\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    return this.implementation.next();\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    return this.implementation.fill();\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.implementation.getAllPoints();\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will throw an error if a distance function was not provided to the constructor.\n * @returns {Array[]} Sample points with their distance function result\n */\nPoissonDiskSampling.prototype.getAllPointsWithDistance = function () {\n    return this.implementation.getAllPointsWithDistance();\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    this.implementation.reset();\n};\n\nmodule.exports = PoissonDiskSampling;\n","import PoissonDiskSampling from 'poisson-disk-sampling';\nimport type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype PoissonPointGeneratorName = \"PoissonPointGenerator\";\nexport const Name: PoissonPointGeneratorName = \"PoissonPointGenerator\";\n\n/** Required config for this generator */\nexport interface PoissonPointGeneratorConfig extends GeneratorConfig {\n  name: PoissonPointGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const PoissonPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Poisson\",\n  description: \"Generate seed points using Poisson disk sampling. \" +\n    \"The algorithm produces points that are tightly-packed, but no closer to \" +\n    \"each other than a specified minimum distance (the piece size), resulting \" +\n    \"in a natural, organic look.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A point generator that uses Poisson disk sampling to create a more organic\n * distribution of random points. `pieceSize` is interpreted as the minimum\n * distance between generated points.\n */\nexport const PoissonPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_width: number, _height: number, _config: PoissonPointGeneratorConfig) => {\n  const PoissonPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      // generate points randomly in a Poisson disk sampling\n      const poisson = new PoissonDiskSampling(\n        {\n          shape: [width, height], // clamps generated points within bounds\n          minDistance: pieceSize,\n          tries: 20,\n        },\n        random\n      );\n\n      // have to cast because @types/PoissonDiskSampling is not correct for fill()\n      const points = poisson.fill() as unknown as Vec2[];\n      return points;\n    },\n  };\n  return PoissonPointGenerator;\n};\nexport default PoissonPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, PoissonPointGeneratorFactory, PoissonPointUIMetadata);\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const {delaunay: {points, hull, triangles}, vectors} = this;\n    let bx, by; // lazily computed barycenter of the hull\n\n    // Compute circumcenters.\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const ex = x3 - x1;\n      const ey = y3 - y1;\n      const ab = (dx * ey - dy * ex) * 2;\n\n      if (Math.abs(ab) < 1e-9) {\n        // For a degenerate triangle, the circumcenter is at the infinity, in a\n        // direction orthogonal to the halfedge and away from the “center” of\n        // the diagram <bx, by>, defined as the hull’s barycenter.\n        if (bx === undefined) {\n          bx = by = 0;\n          for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];\n          bx /= hull.length, by /= hull.length;\n        }\n        const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);\n        x = (x1 + x3) / 2 - a * ey;\n        y = (y1 + y3) / 2 + a * ex;\n      } else {\n        const d = 1 / ab;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x = x1 + (ey * bl - dy * cl) * d;\n        y = y1 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x;\n      circumcenters[j + 1] = y;\n    }\n\n    // Compute exterior cell rays.\n    let h = hull[hull.length - 1];\n    let p0, p1 = h * 4;\n    let x0, x1 = points[2 * h];\n    let y0, y1 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull.length; ++i) {\n      h = hull[i];\n      p0 = p1, x0 = x1, y0 = y1;\n      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;\n    if (hull.length <= 1) return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull[hull.length - 1];\n    for (let i = 0; i < hull.length; ++i) {\n      h0 = h1, h1 = hull[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = h0 * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null || !points.length) return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;\n    for (let i = 2; i < n; i += 2) {\n      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])\n        context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) cell.index = i, yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci) for (const j of this.delaunay.neighbors(i)) {\n      const cj = this._clip(j);\n      // find the common edge\n      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n          if (ci[ai] === cj[aj]\n              && ci[ai + 1] === cj[aj + 1]\n              && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]\n              && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {\n            yield j;\n            break loop;\n          }\n        }\n      }\n    }\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    // degenerate case (1 valid point: return the box)\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return this._simplify(V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points));\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    // for more robustness, always consider the segment in the same order\n    const flip = c0 < c1;\n    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];\n    while (true) {\n      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n      // undefined, the conditional statement will be executed.\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n  _simplify(P) {\n    if (P && P.length > 4) {\n      for (let i = 0; i < P.length; i+= 2) {\n        const j = (i + 2) % P.length, k = (i + 4) % P.length;\n        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n          P.splice(j, 2), i -= 2;\n        }\n      }\n      if (!P.length) P = null;\n    }\n    return P;\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n","\nexport type UniqueId = number;\n\nlet id = 0;\nexport function getUniqueId(): UniqueId {\n  return id++;\n}\n","import { Delaunay } from 'd3-delaunay';\nimport { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { polygonBounds, arePointsEqual } from '../../utils';\nimport { getUniqueId } from '../../../utils/UniqueId';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\nexport const Name: VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\n\n/** Required config for this generator */\nexport interface VoronoiPieceGeneratorConfig extends GeneratorConfig {\n  name: VoronoiPieceGeneratorName;\n  // no special config\n}\n\n/** UI metadata needed for this generator */\nexport const VoronoiPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Voronoi\",\n  description: \"Construct pieces by building a Voronoi diagram from the seed points. \" +\n    \"Each piece consists of all area of the plane closer to its seed point than \" +\n    \"any other seed point. In practice, this creates irregular polygons with 3-8 \" +\n    \"sides.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * Links the `next` and `prev` properties of a circular list of half-edges for a single piece.\n * @param ids The array of half-edge IDs belonging to a piece.\n * @param map The map containing all half-edge objects.\n */\nfunction linkPieceHalfEdges(ids: HalfEdgeID[], map: Map<HalfEdgeID, HalfEdge>): void {\n  const len = ids.length;\n  for (let i = 0; i < len; i++) {\n    const he = map.get(ids[i])!;\n    he.next = ids[(i + 1) % len];\n    he.prev = ids[(i - 1 + len) % len];\n  }\n}\n\n/**\n * Creates a consistent string key for a point, handling floating point inaccuracies.\n * @param p The point.\n * @returns A string key.\n */\nfunction pointToKey(p: Vec2): string {\n  return `${p[0].toPrecision(7)},${p[1].toPrecision(7)}`;\n}\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const VoronoiPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (width: number, height: number, _config: VoronoiPieceGeneratorConfig) => {\n  const VoronoiPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param points The seed points for the centers of the puzzle pieces.\n     * @param _runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(points: Vec2[], _runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n\n      // Note: Lloyd's relaxation could be performed here to create more uniform\n      // piece shapes. This would involve creating the Voronoi diagram, calculating\n      // the centroid of each cell, moving the input point to that centroid, and\n      // repeating for a number of iterations before proceeding.\n\n      console.log(`VoronoiPieceGenerator using dimensions ${width}x${height}`);\n      // 1. Generate Voronoi diagram from points, clipped to the puzzle bounds.\n      const delaunay = Delaunay.from(points);\n      const voronoi = delaunay.voronoi([0, 0, width, height]);\n\n      // 2. Initialize data structures for the topology.\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n      };\n\n      // A map to find a half-edge's twin, keyed by its start and end vertex coordinates.\n      const halfEdgeEndpointMap = new Map<string, HalfEdgeID>();\n\n      // 3. First pass: Create Piece and HalfEdge objects for each cell.\n      // At this stage, the half-edges are not yet linked (next, prev, twin).\n      for (let i = 0; i < points.length; i++) {\n        const site = points[i];\n        const polygon = voronoi.cellPolygon(i);\n\n        if (!polygon) continue;\n\n        const piece: Piece = {\n          id: i,\n          site,\n          halfEdge: -1, // Placeholder, will be set after creating half-edges.\n          bounds: polygonBounds(polygon),\n        };\n\n        const pieceHalfEdgeIds: HalfEdgeID[] = [];\n\n        // Create a half-edge for each segment of the piece's polygon boundary.\n        for (let j = 0; j < polygon.length - 1; j++) {\n          const p1 = polygon[j];\n          const p2 = polygon[j + 1];\n\n          // Skip zero-length edges that can sometimes occur at the boundary.\n          if (arePointsEqual(p1, p2)) continue;\n\n          const he: HalfEdge = {\n            id: getUniqueId(),\n            origin: p1,\n            twin: -1, // To be linked in the second pass.\n            next: -1, // To be linked next.\n            prev: -1, // To be linked next.\n            piece: i,\n          };\n\n          topology.halfEdges.set(he.id, he);\n          pieceHalfEdgeIds.push(he.id);\n\n          // Store the half-edge in a map to easily find its twin later.\n          // The key is a string representation of its start and end points.\n          const key = `${pointToKey(p1)}-${pointToKey(p2)}`;\n          halfEdgeEndpointMap.set(key, he.id);\n        }\n\n        if (pieceHalfEdgeIds.length === 0) continue;\n\n        // Link the `next` and `prev` pointers for the half-edges of the current piece.\n        linkPieceHalfEdges(pieceHalfEdgeIds, topology.halfEdges);\n\n        // Set a starting half-edge for the piece and save it.\n        piece.halfEdge = pieceHalfEdgeIds[0];\n        topology.pieces.set(i, piece);\n      }\n\n      // 4. Second pass: Link twins and create the undirected Edge objects.\n      for (const he1 of topology.halfEdges.values()) {\n        // If twin is already set, it was handled when we processed its pair.\n        if (he1.twin !== -1) continue;\n\n        const he1_next = topology.halfEdges.get(he1.next)!;\n        const p1 = he1.origin;\n        const p2 = he1_next.origin;\n\n        const keyForTwin = `${pointToKey(p2)}-${pointToKey(p1)}`;\n        const twinId = halfEdgeEndpointMap.get(keyForTwin);\n\n        const edgeId = getUniqueId();\n        let edge: Edge;\n\n        if (twinId !== undefined) {\n          // This is an internal edge with a twin.\n          const he2 = topology.halfEdges.get(twinId)!;\n          he1.twin = he2.id;\n          he2.twin = he1.id;\n\n          // he1 is the \"left\" half-edge when looking from p1 to p2.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id,\n            heRight: he2.id,\n            bounds: polygonBounds([p1, p2]), // no tabs yet\n          };\n        } else {\n          // This is a boundary edge with no twin.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id, // The one existing half-edge.\n            heRight: -1,     // Sentinel for no half-edge.\n            bounds: polygonBounds([p1, p2]), // no tabs yet\n          };\n          topology.boundary.push(edgeId);\n        }\n\n        topology.edges.set(edgeId, edge);\n      }\n\n      // 5. Final step: Collect all unique vertices.\n      const vertexSet = new Map<string, Vec2>();\n      for (const he of topology.halfEdges.values()) {\n        const key = pointToKey(he.origin);\n        if (!vertexSet.has(key)) {\n          vertexSet.set(key, he.origin);\n        }\n      }\n      topology.vertices = Array.from(vertexSet.values());\n\n      return topology;\n    },\n  };\n  return VoronoiPieceGenerator;\n};\nexport default VoronoiPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, VoronoiPieceGeneratorFactory, VoronoiPieceGeneratorUIMetadata);\n","import type { PuzzleTopology, Edge, RandomFn, TabPlacement } from \"../../types\";\nimport type { TabPlacementStrategy, TabPlacementStrategyRuntimeOptions } from \"./TabPlacementStrategy\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabPlacementStrategyRegistry } from \"../Generator\";\n\n// Name of this strategy, uniquely identifies from all other TabPlacementStrategies\ntype SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\nexport const Name: SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\n\n/** Custom config for this strategy */\nexport interface SimpleTabPlacementStrategyConfig extends GeneratorConfig {\n  name: SimpleTabPlacementStrategyName;\n  /** The default size of the tab as a fraction (0-1) of the edge length. */\n  tabSize?: number;\n  /** Edges shorter than this value will not have a tab. */\n  minEdgeLength?: number;\n  /** The maximum absolute width that a tab can have. Wide tabs will get clamped to this value. */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this strategy */\nexport const SimpleTabPlacementStrategyUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Simple\",\n  description: \"Creates a single tab in the center of each edge with a random orientation.\",\n  sortHint: 1,\n  // these have to match the config above\n  controls: [\n    {\n      type: 'range',\n      name: 'tabSize',\n      label: 'Tab Size',\n      optional: true,\n      min: 0.01,\n      max: 1.0,\n      step: 0.01,\n      defaultValue: 0.5,\n      helpText: 'The width of the tab as a fraction of the edge length',\n    },\n    {\n      type: 'number',\n      name: 'minEdgeLength',\n      label: 'Minimum Edge Length',\n      optional: true,\n      defaultValue: 15,\n      helpText: 'Edges shorter than this value will not have a tab',\n    },\n    {\n      type: 'number',\n      name: 'maxTabSize',\n      label: 'Maximum Tab Size',\n      helpText: 'Maximum width of a generated tab',\n    },\n  ],\n};\n\n// helper function to do the actual placement work\nfunction placeTabOnEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  config: { tabSize: number, minEdgeLength: number, maxTabSize?: number },\n  random: RandomFn\n): void {\n  // clear any existing tabs in case we're re-evaluating\n  edge.tabs = undefined;\n\n  // we only place on internal edges\n  const isInternal = edge.heRight !== -1;\n  if (!isInternal) { return; }\n\n  const he1 = topology.halfEdges.get(edge.heLeft);\n  const he2 = topology.halfEdges.get(edge.heRight);\n  if (!he1 || !he2) return;\n\n  const p1 = he1.origin;\n  const p2 = he2.origin;\n  const edgeLength = Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);\n\n  // add a tab, if the edge is long enough\n  if (edgeLength >= config.minEdgeLength) {\n    let tabSize = config.tabSize;\n\n    // clamp tab width if requested\n    if (config.maxTabSize && (edgeLength * tabSize) > config.maxTabSize) {\n      tabSize = config.maxTabSize / edgeLength;\n    }\n\n    const tab: TabPlacement = {\n      position: 0.5, // center of the edge\n      size: tabSize,\n      convex: random() > 0.5, // tab is \"innie\" or \"outie\"\n    };\n    edge.tabs = [tab];\n  }\n}\n\n/**\n * A straightforward tab placement strategy that adds a single tab to the\n * center of each internal edge of the puzzle.\n */\nexport const SimpleTabPlacementStrategyFactory: GeneratorFactory<TabPlacementStrategy> = (\n  _width: number,\n  _height: number,\n  config: SimpleTabPlacementStrategyConfig,\n): TabPlacementStrategy => {\n  const { tabSize = 0.5, minEdgeLength = 0, maxTabSize } = config;\n  const placementConfig = { tabSize, minEdgeLength, maxTabSize };\n\n  return {\n    placeTabs(runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of topology.edges.values()) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n    updateTabPlacements(edges: Edge[], runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of edges) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n  };\n};\nexport default SimpleTabPlacementStrategyFactory;\n\n// register the strategy\nTabPlacementStrategyRegistry.register(Name, SimpleTabPlacementStrategyFactory, SimpleTabPlacementStrategyUIMetadata);","import type { TabGenerator } from \"./TabGenerator\";\nimport type { CurveTo, EdgeSegment, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\nexport const Name: TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TraditionalTabGeneratorConfig extends GeneratorConfig {\n  name: TraditionalTabGeneratorName;\n  /** Amount of randomness to apply to each tab (0-100) */\n  jitter?: number;\n  /** The height of the tab's nub as a fraction of its width. Default: 50% */\n  heightToWidthRatio?: number;\n  /** If provided, the width of a tab's features will be clamped to this value */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TraditionalTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Traditional\",\n  description: \"Creates a traditional rounded tab for each (internal) piece edge.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      defaultValue: 8,\n      min: 0,\n      max: 100,\n      step: 1,\n      helpText: 'Adds randomness to the tab shape. 0 means completely uniform tabs',\n    },\n    {\n      type: 'range',\n      name: 'heightToWidthRatio',\n      label: 'Tab Height',\n      defaultValue: 50,\n      min: 5,\n      max: 100,\n      step: 5,\n      helpText: 'The height of the tab as a percent of its width',\n    },\n  ],\n};\n\n\n/**\n * Build a puzzle nub using three cubic Bézier segments that replace a straight\n * edge AB. Curve 1 is a gentle S-curve up to the nub edge, Curve 2 is the arch\n * across the top of the nub, Curve 3 is the mirror of curve 1 back to the baseline.\n *   - the edge is parameterised from 0.0 → 1.0 along its length;\n *   - the nub is centred roughly at s = 0.5 and spans ≈ 4 · t of the edge;\n *   - the peak of the nub reaches ± 3 · t away from the baseline.\n *\n * @param a         Edge start point.\n * @param b         Edge end point.\n * @param jitterPct “Jitter” slider value (0–100 %).\n * @param heightToWidthRatio Ratio of tab height to segment length\n * @param random    Seeded RNG so callers can reproduce shapes.\n * @param inward    If true the nub is an **indent**; otherwise a **bump**.\n * @param maxTabSize Optional maximum absolute width for the tab.\n *\n * @returns Three cubic Bézier segments, ordered from a→b.\n */\nfunction createTraditionalTab(\n  a: Vec2,\n  b: Vec2,\n  jitterPct: number,\n  heightToWidthRatio: number,\n  random: RandomFn,\n  inward = false\n): EdgeSegment[] {\n  /* --- 1.  Work in a local (u,v) coordinate frame ---------------------- */\n\n  const ux = b[0] - a[0];\n  const uy = b[1] - a[1];\n  const len = Math.hypot(ux, uy);\n  if (len === 0) {\n    console.warn(\"Edge has zero length\");\n    return [];\n  }\n\n  // Basis vectors:  u along the edge, v = +90° (right-hand rule).\n  const u: Vec2 = [ux / len, uy / len];\n  const v: Vec2 = [-u[1], u[0]]; // perpendicular\n\n  /** Convert (s,w) → world coordinates.  Both s and w are normalised by len. */\n  const P = (s: number, w: number): Vec2 => [\n    a[0] + (u[0] * s + v[0] * w) * len,\n    a[1] + (u[1] * s + v[1] * w) * len,\n  ];\n\n  /* --- 2.  Derive the five random perturbations a…e -------------------- */\n\n  const j = jitterPct / 100;\n  const rng = () => (random() * 2 - 1) * j; // uniform(-j, +j)\n\n  const A = rng(); // entry handle offset\n  const B = rng(); // l-shift of whole nub\n  const C = rng(); // vertical wobble of apex\n  const D = rng(); // anti-sym tweak\n  const E = rng(); // exit handle offset\n\n  /* --- 3.  Fixed shape constants -------------------------------------- */\n\n  // 't' is a fixed constant that defines the tab's internal proportions.\n  // A value of 0.2 means the central arch of the tab will span 80% (4 * 0.2)\n  const t = 0.1625; // 65%\n\n  // if (maxTabSize) {\n  //   const absoluteTabWidth = 4 * t * len;\n  //   if (absoluteTabWidth > maxTabSize) {\n  //     // recalculate t so that the tab width equals the max size, clamping it\n  //     t = maxTabSize / (4 * len);\n  //   }\n  // }\n\n  const dir = inward ? -1 : 1; // bump (+) or hole (-)\n  const nubHeight = heightToWidthRatio;\n  const shoulder_height = nubHeight / 3;\n\n  /* --- 4.  Anchor & control points in (s,w) ---------------------------- */\n\n  const pointsSW: Vec2[] = [\n    [0.0               ,           0],\n    [0.2               ,           A * shoulder_height],\n    [0.5 + B + D       , dir * (-shoulder_height + C * nubHeight)],\n    [0.5 - t + B       , dir * ( shoulder_height + C * nubHeight)],\n    [0.5 - 2*t + B - D , dir * (nubHeight + C * nubHeight)],\n    [0.5 + 2*t + B - D , dir * (nubHeight + C * nubHeight)],\n    [0.5 + t + B       , dir * ( shoulder_height + C * nubHeight)],\n    [0.5 + B + D       , dir * (-shoulder_height + C * nubHeight)],\n    [0.8               ,           E * shoulder_height],\n    [1.0               ,           0],\n  ];\n\n  /* --- 5.  Map to world coords and split into 3 Béziers ---------------- */\n\n  const points: Vec2[] = pointsSW.map(([s, w]) => P(s, w));\n\n  const bez1: CurveTo = { type: 'bezier', p1: points[1], p2: points[2], p3: points[3] };\n  const bez2: CurveTo = { type: 'bezier', p1: points[4], p2: points[5], p3: points[6] };\n  const bez3: CurveTo = { type: 'bezier', p1: points[7], p2: points[8], p3: points[9] };\n\n  return [bez1, bez2, bez3];\n}\n\n/**\n * A factory that creates a TabGenerator for creating traditional, smoothly curved\n * puzzle piece tabs using a provided geometry function. The nub is built using\n * three cubic Bézier segments that replace a straight edge AB. Curve 1 is a\n * gentle S-curve up to the nub edge, Curve 2 is the arch across the top of the\n * nub, Curve 3 is the mirror of curve 1 back to the baseline.\n */\nexport const TraditionalTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number, config: TraditionalTabGeneratorConfig): TabGenerator => {\n  const { jitter = 8, heightToWidthRatio = 50 } = config;\n\n  const TraditionalTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, random: RandomFn): EdgeSegment[] {\n      const inward = !tab.convex;\n      return createTraditionalTab(start, end, jitter, heightToWidthRatio/100, random, inward);\n    },\n  };\n  return TraditionalTabGenerator;\n};\nexport default TraditionalTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TraditionalTabGeneratorFactory, TraditionalTabUIMetadata);\n","import type {\n  AABB,\n  EdgeSegment,\n  LineTo,\n  Piece,\n  PuzzleTopology,\n  Vec2,\n} from \"./types\";\nimport {\n  distanceSq,\n  calculateSegmentsBounds,\n  serializeTopology,\n  doAABBsIntersect,\n} from \"./utils\";\nimport type { CheckGeometryWorkerInput, CheckGeometryWorkerOutput } from '../workers/CheckGeometryWorker';\nimport { Bezier } from 'bezier-js';\n\n// import the worker script\nimport CheckGeometryWorker from '../workers/CheckGeometryWorker?worker';\n\n/** An internal structure to hold a segment and its pre-calculated properties. */\ninterface BoundarySegment {\n  /** The geometric definition of the segment. */\n  segment: EdgeSegment;\n  /** The starting point of this segment. */\n  startPoint: Vec2;\n  /** The pre-calculated bounding box for this segment. */\n  bbox: AABB;\n}\n\n// helper to gets the end point of a segment.\nfunction getEndPoint(s: EdgeSegment): Vec2 {\n  return s.type === 'line' ? s.p : s.p3;\n}\n\n// helper to get a Bezier object for use with bezier-js\nfunction boundaryToBezier(boundary: BoundarySegment): Bezier {\n  if (boundary.segment.type !== 'bezier') {\n    throw new Error('Boundary segment is not a Bezier curve');\n  }\n  const { startPoint } = boundary;\n  const { p1, p2, p3 } = boundary.segment;\n  return new Bezier(\n    { x: startPoint[0], y: startPoint[1] },\n    { x: p1[0], y: p1[1] },\n    { x: p2[0], y: p2[1] },\n    { x: p3[0], y: p3[1] }\n  );\n}\n\n/**\n * Traverses a piece's boundary and collects all its geometric segments.\n * @param piece - The piece to process.\n * @param puzzle - The full puzzle geometry, for half-edge lookups.\n * @returns An ordered array of BoundarySegment objects.\n */\nfunction getPieceBoundary(piece: Piece, puzzle: PuzzleTopology): BoundarySegment[] {\n  const boundary: BoundarySegment[] = [];\n  const startHeId = piece.halfEdge;\n  let currentHeId = startHeId;\n\n  do {\n    const he = puzzle.halfEdges.get(currentHeId);\n    if (!he) {\n      console.error(`Could not find half-edge with ID: ${currentHeId}`);\n      break;\n    }\n\n    let startPoint = he.origin;\n\n    if (he.segments && he.segments.length > 0) {\n      // Add segments from the half-edge definition\n      for (const segment of he.segments) {\n        boundary.push({\n          segment,\n          startPoint,\n          bbox: calculateSegmentsBounds(startPoint, [segment]),\n        });\n        // The next segment starts where the current one ends\n        startPoint = segment.type === 'line' ? segment.p : segment.p3;\n      }\n    } else {\n      // If no segments, it's a straight line to the next half-edge's origin\n      const nextHe = puzzle.halfEdges.get(he.next);\n      if (!nextHe) {\n        console.error(`Could not find next half-edge for ID: ${he.next}`);\n        continue;\n      }\n      const lineSegment: LineTo = { type: 'line', p: nextHe.origin };\n      boundary.push({\n        segment: lineSegment,\n        startPoint: startPoint,\n        bbox: calculateSegmentsBounds(startPoint, [lineSegment]),\n      });\n    }\n\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId);\n\n  return boundary;\n}\n\n/**\n * Performs precise intersection detection between two geometric segments.\n * This function handles Line/Line, Line/Curve, and Curve/Curve cases.\n *\n * @param s1 - The first boundary segment.\n * @param s2 - The second boundary segment.\n * @param adjacent - True of the segments are next to each other on the boundary.\n * @returns An array of Vec2 points representing all found intersections.\n */\nfunction narrowPhaseDetection(s1: BoundarySegment, s2: BoundarySegment, adjacent: boolean): Promise<Vec2[]> {\n  return new Promise<Vec2[]>((resolve) => {\n\n    const intersections: Vec2[] = [];\n    const type1 = s1.segment.type;\n    const type2 = s2.segment.type;\n    const tolerance = 0.01; // values this close to the beginning or end of a curve are effectively at the ends\n\n\n    // Bezier vs. Bezier\n    if (type1 === 'bezier' && type2 === 'bezier') {\n      const bezier1 = boundaryToBezier(s1);\n      const bezier2 = boundaryToBezier(s2);\n\n      // intersects() returns an array of strings that look like \"float/float\"\n      const pairs = bezier1.intersects(bezier2) as string[];\n\n      pairs.forEach((pair) => {\n        const tValues = pair.split('/');\n        const t1 = parseFloat(tValues[0]);\n        const t2 = parseFloat(tValues[1]);\n\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t1 > (1.0 - tolerance) && t2 < tolerance || t1 < tolerance && t2 > (1.0 - tolerance);\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n\n        // extract the intersection point\n        const p = bezier1.get(t1);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Bezier vs. Line\n    else if (type1 === 'bezier' || type2 === 'bezier') {\n      const curveBoundary = type1 === 'bezier' ? s1 : s2;\n      const lineBoundary = type1 === 'line' ? s1 : s2;\n\n      const curve = boundaryToBezier(curveBoundary);\n      const line = {\n        p1: { x: lineBoundary.startPoint[0], y: lineBoundary.startPoint[1] },\n        p2: { x: (lineBoundary.segment as LineTo).p[0], y: (lineBoundary.segment as LineTo).p[1] },\n      };\n\n      // intersects() returns an array of t-values on the curve\n      const tValues = curve.intersects(line) as number[]; // always numbers when comparing to line\n      tValues.forEach((t) => {\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t > (1.0 - tolerance) || t < tolerance;\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n        const p = curve.get(t);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Line vs. Line\n    else {\n      // only non-adjacent line segments need to be compared\n      if (!adjacent) {\n        return resolve(intersections);\n      }\n\n      const p1 = s1.startPoint;\n      const p2 = s1.segment.p;\n      const p3 = s2.startPoint;\n      const p4 = s2.segment.p;\n\n      const [x1, y1] = p1;\n      const [x2, y2] = p2;\n      const [x3, y3] = p3;\n      const [x4, y4] = p4;\n\n      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n      if (den !== 0) { // Ensure lines are not parallel or collinear\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n\n        // If an intersection exists on both line segments\n        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n          const intersectX = x1 + t * (x2 - x1);\n          const intersectY = y1 + t * (y2 - y1);\n          intersections.push([intersectX, intersectY]);\n        }\n      }\n    }\n\n    resolve(intersections);\n  });\n}\n\n/**\n * Detects self-intersections within each piece of a puzzle geometry.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @param onProgress - Optional callback invoked to report progress.\n * @returns An array of Vec2 points, where each point is an overlap.\n */\nasync function detectIntersections(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  const intersections: Vec2[] = [];\n  const EPSILON_SQUARED = 1e-8; // Tolerance for floating point comparisons\n\n  const pieces = Array.from(puzzle.pieces.values());\n  const totalPieces = pieces.length;\n  let processedCount = 0;\n\n  // 1. Iterate through each piece\n  for (const piece of puzzle.pieces.values()) {\n\n    // report progress\n    onProgress?.(processedCount, totalPieces);\n\n    const boundary = getPieceBoundary(piece, puzzle);\n    const numSegments = boundary.length;\n    if (numSegments < 2) {\n      processedCount++;\n      continue;\n    }\n\n    // 2. Compare every segment with every other segment that comes after it\n    for (let i = 0; i < numSegments; i++) {\n      for (let j = i + 1; j < numSegments; j++) {\n        const seg1 = boundary[i];\n        const seg2 = boundary[j];\n\n        // 3. Broad-phase detection using bounding boxes\n        if (!doAABBsIntersect(seg1.bbox, seg2.bbox)) {\n          // no intersections\n          continue;\n        }\n\n        // 4. Distinguish between adjacent and non-adjacent intersections\n        const areAdjacent = (j === i + 1) || (i === 0 && j === numSegments - 1);\n\n        // 5. Narrow-phase detection (using a bezier library)\n        const potentialPoints = await narrowPhaseDetection(seg1, seg2, areAdjacent);\n\n        if (potentialPoints.length === 0) {\n          // no intersections\n          continue;\n        }\n\n        if (areAdjacent) {\n          const connectionPoint = (i === 0 && j === numSegments - 1)\n            ? seg1.startPoint // we're comparing the final segment with the first segment\n            : getEndPoint(seg1.segment); // we're comparing adjacent segments\n\n          for (const point of potentialPoints) {\n            // An intersection is only an error if it's NOT at the connection point.\n            if (distanceSq(point, connectionPoint) > EPSILON_SQUARED) {\n              intersections.push(point);\n            }\n          }\n        } else {\n          // For non-adjacent segments, ANY intersection is an error.\n          intersections.push(...potentialPoints);\n        }\n      }\n    }\n    processedCount++;\n  }\n\n  // final call to signify completion\n  onProgress?.(totalPieces, totalPieces);\n\n  console.log(`detected ${intersections.length} intersections in ${puzzle.pieces.size} pieces`);\n  return intersections;\n}\n\n\n/**\n * Checks a puzzle for geometry issues such as intersecting pieces or too narrow geometry.\n * @param puzzle - Geometry to check\n * @param onProgress - Optional callpack for managing a progress bar\n * @returns A Promise for coordinates that have problem geometry\n */\nexport async function checkGeometry(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  // find points where pieces intersect/overlap\n  const intersections = await detectIntersections(puzzle, onProgress);\n\n  if (intersections.length < 2) {\n    return intersections;\n  }\n\n  // Note: the intersection algorithm can return multiple points clustered very\n  // closely, which is confusing for the user, so here we filter them out\n  const MIN_DISTANCE = 1;\n  const filtered: Vec2[] = [intersections[0]];\n\n  for (let i = 1; i < intersections.length; i++) {\n    const current = intersections[i];\n    const last = filtered[filtered.length - 1];\n    if (distanceSq(current, last) > MIN_DISTANCE * MIN_DISTANCE) {\n      filtered.push(current);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Wraps the `checkGeometry` function in a web worker to run it off the main thread,\n * preventing the UI from freezing during intensive calculations.\n *\n * @param puzzle - The puzzle topology to check.\n * @param onProgress - An optional callback to receive progress updates.\n * @returns A promise that resolves with an array of intersection points or rejects on error.\n */\nexport function checkGeometryInWorker(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n  return new Promise((resolve, reject) => {\n    const worker = new CheckGeometryWorker();\n\n    // Handle messages received from the worker\n    worker.onmessage = (event: MessageEvent<CheckGeometryWorkerOutput>) => {\n      const data = event.data;\n\n      switch (data.type) {\n      case 'progress':\n        onProgress?.(data.processed, data.total);\n        break;\n      case 'done':\n        resolve(data.results);\n        worker.terminate();\n        break;\n      case 'error':\n        reject(new Error(data.message));\n        worker.terminate();\n        break;\n      }\n    };\n\n    // Handle any critical errors with the worker itself\n    worker.onerror = (error: ErrorEvent) => {\n      reject(new Error(error.message));\n      worker.terminate();\n    };\n\n    // serialize the puzzle topology and send it to the worker to kick off the process\n    const message: CheckGeometryWorkerInput = {\n      topology: serializeTopology(puzzle),\n    };\n    worker.postMessage(message);\n  });\n}","import type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\nexport const Name: GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\n\n/** Required config for this generator */\nexport interface GridJitterPointGeneratorConfig extends GeneratorConfig {\n  name: GridJitterPointGeneratorName;\n  /** Amount of random jitter (0 to 100) */\n  jitter: number;\n}\n\n/** UI metadata needed for this generator */\nexport const GridJitterPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Grid\",\n  description: \"Generate seed points using a grid with optional random jitter. \" +\n    \"Has a uniform, regular look, especially with low randomness values.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n      helpText: 'Amount of jitter to apply to each grid point (0 to 100%)',\n    },\n  ],\n};\n\n/**\n * A point generator that uses grid + random jitter. `jitter` represents the\n * strength of jitter applied to each point, from 0 (straight grid) to 1\n * (completely random).\n */\nexport const GridJitterPointGeneratorFactory: GeneratorFactory<PointGenerator> = (width: number, height: number, config: GridJitterPointGeneratorConfig) => {\n  const { jitter = 50 } = config;\n\n  const GridJitterPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      const points: Vec2[] = [];\n      // assemble a grid\n      for (let x = 0; x < width; x += pieceSize) {\n        for (let y = 0; y < height; y += pieceSize) {\n          // initial position is the center of each grid cell\n          const point: Vec2 = [x + pieceSize / 2, y + pieceSize / 2];\n          // add random jitter\n          if (jitter > 0) {\n            point[0] += (random() - 0.5) * (jitter / 100) * pieceSize;\n            point[1] += (random() - 0.5) * (jitter / 100)  * pieceSize;\n          }\n          points.push(point);\n        }\n      }\n      return points;\n    },\n  };\n  return GridJitterPointGenerator;\n};\nexport default GridJitterPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, GridJitterPointGeneratorFactory, GridJitterPointUIMetadata);\n","import { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  AABB,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { polygonBounds } from \"../../utils\";\nimport { getUniqueId } from '../../../utils/UniqueId';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\nexport const Name: RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\n\n/** Required config for this generator */\nexport interface RectangularPieceGeneratorConfig extends GeneratorConfig {\n  name: RectangularPieceGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const RectangularPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Rectangular\",\n  description: \"Construct pieces from a regular grid. All pieces have 4 sides \" +\n    \"and are the same size. This generator ignores seed points.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const RectangularPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (width: number, height: number, _config: RectangularPieceGeneratorConfig) => {\n\n  const RectangularPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param _points The seed points. Ignored by this generator.\n     * @param runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(_points: Vec2[], runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n      const { pieceSize } = runtimeOpts;\n\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n      };\n\n      // --- 1. Calculate Grid Dimensions ---\n      // Determine the number of rows and columns based on the desired piece size.\n      const cols = Math.ceil(width / pieceSize);\n      const rows = Math.ceil(height / pieceSize);\n\n      // Calculate the actual width and height of each cell\n      const cellWidth = Math.round(width / cols);\n      const cellHeight = Math.round(height / rows);\n\n      // --- 2. Create Vertices ---\n      // A 2D array to hold all vertex points for easy lookup by grid index.\n      const gridVertices: Vec2[][] = [];\n      for (let r = 0; r <= rows; r++) {\n        const rowVertices: Vec2[] = [];\n        for (let c = 0; c <= cols; c++) {\n          const x = c * cellWidth;\n          const y = r * cellHeight;\n          rowVertices.push([x, y]);\n        }\n        gridVertices.push(rowVertices);\n      }\n      // Flatten the 2D array into the final list for the topology.\n      topology.vertices = gridVertices.flat();\n\n      // --- 3. Create Pieces and Half-Edges ---\n      // This map will help us find the twin of a half-edge. The key is a string\n      // representing the start and end vertices of an edge, e.g., \"x1,y1-x2,y2\".\n      const halfEdgeTwinMap = new Map<string, HalfEdgeID>();\n\n      // NOTE: Using a string key based on floating point coordinates can be very\n      // fragile. Tiny precision errors can cause lookups to fail. This approach\n      // is safe here because the grid coordinates are normalized to integers.\n      // For a generator with less regular vertex points it is more robust to\n      // assign a unique ID to each vertex and use those IDs to build the key,\n      // or to use a helper function to perform an approximate \"epsilon\" comparison.\n\n      // build each piece\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          const pieceId = r * cols + c;\n\n          // Get the four corner vertices for the current piece.\n          const topLeft = gridVertices[r][c];\n          const topRight = gridVertices[r][c + 1];\n          const bottomLeft = gridVertices[r + 1][c];\n          const bottomRight = gridVertices[r + 1][c + 1];\n\n          // Define the four half-edges for this piece in counter-clockwise (CCW) order.\n          const he_top: HalfEdge =    { id: getUniqueId(), origin: topLeft,     twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_right: HalfEdge =  { id: getUniqueId(), origin: topRight,    twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_bottom: HalfEdge = { id: getUniqueId(), origin: bottomRight, twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_left: HalfEdge =   { id: getUniqueId(), origin: bottomLeft,  twin: -1, next: -1, prev: -1, piece: pieceId };\n\n          // Link the half-edges for this piece in a circular loop.\n          he_top.next = he_right.id;\n          he_right.next = he_bottom.id;\n          he_bottom.next = he_left.id;\n          he_left.next = he_top.id;\n\n          he_top.prev = he_left.id;\n          he_left.prev = he_bottom.id;\n          he_bottom.prev = he_right.id;\n          he_right.prev = he_top.id;\n\n          // Add the half-edges to the main topology map.\n          topology.halfEdges.set(he_top.id, he_top);\n          topology.halfEdges.set(he_right.id, he_right);\n          topology.halfEdges.set(he_bottom.id, he_bottom);\n          topology.halfEdges.set(he_left.id, he_left);\n\n          // Create and add the piece to the topology.\n          const piece: Piece = {\n            id: pieceId,\n            site: [ (topLeft[0] + bottomRight[0]) / 2, (topLeft[1] + bottomRight[1]) / 2 ], // Site is the center\n            halfEdge: he_top.id, // Point to any half-edge on its boundary\n            bounds: [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]] as AABB,\n          };\n          topology.pieces.set(pieceId, piece);\n\n          // --- 4. Link Twins and Create Edges ---\n          // An edge is defined by its start and end points. We create a consistent key\n          // to look up potential twins created by neighboring pieces.\n          const key = (p1: Vec2, p2: Vec2) => `${p1[0]},${p1[1]}-${p2[0]},${p2[1]}`;\n\n          const edgesToProcess = [\n            { he: he_top,    p1: topLeft,     p2: topRight,    isBoundary: r === 0 },\n            { he: he_right,  p1: topRight,    p2: bottomRight, isBoundary: c === cols - 1 },\n            { he: he_bottom, p1: bottomRight, p2: bottomLeft,  isBoundary: r === rows - 1 },\n            { he: he_left,   p1: bottomLeft,  p2: topLeft,     isBoundary: c === 0 },\n          ];\n\n          for (const edgeInfo of edgesToProcess) {\n            const twinKey = key(edgeInfo.p2, edgeInfo.p1);\n            const twinId = halfEdgeTwinMap.get(twinKey);\n\n            const edgeId = getUniqueId();\n            let edge: Edge;\n\n            if (twinId !== undefined) {\n              // Found a twin! This is an internal edge.\n              const twinHe = topology.halfEdges.get(twinId)!;\n              edgeInfo.he.twin = twinHe.id;\n              twinHe.twin = edgeInfo.he.id;\n\n              // The half-edge from the neighbor is the \"left\" one, ours is the \"right\".\n              edge = {\n                id: edgeId,\n                heLeft: twinHe.id,\n                heRight: edgeInfo.he.id,\n                bounds: polygonBounds([edgeInfo.p1, edgeInfo.p2]),\n              };\n              halfEdgeTwinMap.delete(twinKey); // Clean up map\n            } else {\n              // No twin found. This could be a boundary edge or its twin hasn't been created yet.\n              // We add it to the map to be found by a future neighbor.\n              const selfKey = key(edgeInfo.p1, edgeInfo.p2);\n              halfEdgeTwinMap.set(selfKey, edgeInfo.he.id);\n\n              // If we know it's on the boundary, create the edge now.\n              if (edgeInfo.isBoundary) {\n                edge = {\n                  id: edgeId,\n                  heLeft: edgeInfo.he.id,\n                  heRight: -1,\n                  bounds: polygonBounds([edgeInfo.p1, edgeInfo.p2]),\n                };\n                topology.boundary.push(edgeId);\n              } else {\n                continue; // It's an internal edge, wait for its twin to create the Edge object.\n              }\n            }\n            topology.edges.set(edgeId, edge);\n          }\n        }\n      }\n\n      return topology;\n    },\n  };\n  return RectangularPieceGenerator;\n};\nexport default RectangularPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, RectangularPieceGeneratorFactory, RectangularPieceGeneratorUIMetadata);\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other TabGenerators\ntype NullTabGeneratorName = \"NullTabGenerator\";\nexport const Name: NullTabGeneratorName = \"NullTabGenerator\";\n\n/** This generator doesn't take any special config */\nexport interface NullTabGeneratorConfig extends GeneratorConfig {\n  name: NullTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const NullTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"None\",\n  description: \"Do not generate tabs. All pieces have straight edges.\",\n  sortHint: 3,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/** Tab generator that does nothing, piece edges remain straight lines */\nexport const NullTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number,_config: NullTabGeneratorConfig) => {\n  const NullTabGenerator: TabGenerator = {\n    createTabSegments(_start: Vec2, _end: Vec2, _tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      return []; // does nothing\n    },\n  };\n  return NullTabGenerator;\n};\nexport default NullTabGeneratorFactory;\n\n// register the generator\nTabGeneratorRegistry.register(Name, NullTabGeneratorFactory, NullTabUIMetadata);\n\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, TabPlacement, RandomFn, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TriangleTabGeneratorName = \"TriangleTabGenerator\";\nexport const Name: TriangleTabGeneratorName = \"TriangleTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TriangleTabGeneratorConfig extends GeneratorConfig {\n  name: TriangleTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const TriangleTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Triangle\",\n  description: \"Creates a simple triangle between each (internal) piece edge.\",\n  sortHint: 2,\n  // these have to match the config above\n  controls: [],\n};\n\n/**\n * A simple TabGenerator that adds a triangular \"nub\" to an edge.\n *\n * This generator serves as a straightforward example of how to implement the\n * TabGenerator interface. It generates a three line segment that forms a\n * triangular tab.\n */\nexport const TriangleTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number, _config: TriangleTabGeneratorConfig) => {\n\n  const TriangleTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      // 1. Calculate edge vectors from the provided start and end points.\n      const edgeVector: Vec2 = [end[0] - start[0], end[1] - start[1]];\n      const edgeLength = Math.hypot(edgeVector[0], edgeVector[1]);\n\n      // Return nothing for zero-length edges.\n      if (edgeLength < 1e-6) {\n        return [];\n      }\n\n      // Calculate a perpendicular vector (normal) to the edge.\n      const edgeDir: Vec2 = [edgeVector[0] / edgeLength, edgeVector[1] / edgeLength];\n      const normalDir: Vec2 = [-edgeDir[1], edgeDir[0]];\n\n      // 2. Calculate the position of the tab's peak.\n      // Find the midpoint of the edge segment this tab occupies.\n      const midPoint: Vec2 = [start[0] + edgeVector[0] / 2, start[1] + edgeVector[1] / 2];\n\n      // Determine the tab's direction from the `convex` property.\n      // `true` (outward) is a positive direction, `false` (inward) is negative.\n      const direction = tab.convex ? 1 : -1;\n\n      // The tab's height is defined by its `size` property (a fraction of the edge length).\n      const tabHeight = edgeLength * tab.size * direction;\n\n      // Calculate the nub point by moving from the midpoint along the normal.\n      const nubPoint: Vec2 = [\n        midPoint[0] + normalDir[0] * tabHeight,\n        midPoint[1] + normalDir[1] * tabHeight,\n      ];\n\n      // 3. Create the segments for the tab.\n      const result: EdgeSegment[] = [];\n      result.push({ type: 'line', p: start });\n      result.push({ type: 'line', p: nubPoint });\n      result.push({ type: 'line', p: end });\n\n      return result;\n    },\n  };\n  return TriangleTabGenerator;\n};\nexport default TriangleTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TriangleTabGeneratorFactory, TriangleTabUIMetadata);\n","// component that renders single page application for generating puzzles\nimport m from 'mithril';\n\n// UI parts\nimport GitHubCorner from './ui/GitHubCorner';\nimport Puzzle from './ui/Puzzle';\nimport DownloadPuzzleButton from './ui/DownloadPuzzleButton';\nimport GeometryCheckIndicator from './ui/GeometryCheckIndicator';\nimport UploadImageButton from './ui/UploadImageButton';\nimport GeneratorPicker from './ui/GeneratorPicker';\nimport NumberInputControl from './ui/inputs/NumberInputControl';\nimport BooleanInputControl from './ui/inputs/BooleanInputControl';\nimport AspectRatioPicker from './ui/AspectRatioPicker';\nimport ColorPicker from './ui/ColorPicker';\n\n// geometry parts\nimport type { PuzzleGeometry } from './geometry/types';\nimport type { GeneratorConfig, GeneratorName, GeneratorRegistry } from './geometry/generators/Generator';\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabPlacementStrategyRegistry, TabGeneratorRegistry } from './geometry/generators/Generator';\nimport { Name as PoissonGeneratorName } from './geometry/generators/point/PoissonPointGenerator';\nimport { Name as VoronoiGeneratorName } from './geometry/generators/piece/VoronoiPieceGenerator';\nimport { Name as SimpleTabPlacementStrategyName } from './geometry/generators/tab_placement/SimpleTabPlacementStrategy';\nimport { Name as TraditionalTabGeneratorName } from './geometry/generators/tab/TraditionalTabGenerator';\nimport { buildPuzzle } from './geometry/PuzzleMaker';\nimport { checkGeometryInWorker } from './geometry/GeometryChecker';\n\n// register generators\nimport \"./geometry/generators/point/GridJitterPointGenerator\";\nimport \"./geometry/generators/point/PoissonPointGenerator\";\nimport \"./geometry/generators/piece/VoronoiPieceGenerator\";\nimport \"./geometry/generators/piece/RectangularPieceGenerator\";\nimport \"./geometry/generators/tab_placement/SimpleTabPlacementStrategy\";\nimport \"./geometry/generators/tab/NullTabGenerator\";\nimport \"./geometry/generators/tab/TriangleTabGenerator\";\nimport \"./geometry/generators/tab/TraditionalTabGenerator\";\n\n// Webawesome components\nimport { registerIconLibrary } from '@awesome.me/webawesome/dist/webawesome.js';\nimport \"@awesome.me/webawesome/dist/styles/themes/default.css\";\n\n// CSS for this component\nimport './index.css';\n\n// detect light/dark mode\nlet isDarkMode = false;\nfunction configureDarkLightTheme() {\n  const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n  function manageDarkLightTheme() {\n    if (darkModeQuery.matches) {\n      document.documentElement.classList.add('wa-dark');\n      isDarkMode = true;\n    } else {\n      document.documentElement.classList.remove('wa-dark');\n      isDarkMode = false;\n    }\n  }\n  manageDarkLightTheme();\n  darkModeQuery.addEventListener('change', manageDarkLightTheme);\n}\nconfigureDarkLightTheme();\n\n// component that draws the page\nconst Page: m.ClosureComponent<unknown> = () => {\n\n  const defaultWidth = 800;\n  const defaultHeight = 600;\n\n  const defaultPointGenerator = PoissonGeneratorName;\n  const defaultPieceGenerator = VoronoiGeneratorName;\n  const defaultTabGenerator = TraditionalTabGeneratorName;\n\n  /** State tracked for each type of generator */\n  interface GeneratorState<C extends GeneratorConfig = GeneratorConfig> {\n    label: string;\n    registry: GeneratorRegistry<unknown>;\n    name : GeneratorName;\n    config: C;\n  }\n\n  interface PageState {\n    /** Random seed */\n    seed: number;\n    /** Width of canvas in pixels */\n    canvasWidth: number;\n    /** Height of canvas in pixels */\n    canvasHeight: number;\n    /** Aspect ratio of canvas, width/height */\n    aspectRatio: number;\n    /** Minimum distance between control points (pixels) */\n    distance: number;\n    /** Color of pieces */\n    color: string;\n    /** Should we draw the seed points? */\n    drawPoints: boolean;\n    /** Color of seed points */\n    pointColor: string;\n    /** Problems found by the geometry check algorithms */\n    geometryProblems: {\n      /** If true, the geometry will be re-checked whenever a new puzzle is generated */\n      autoCheck: boolean;\n      /** Count of problems found in the last check */\n      problems?: number;\n      /** Percent complete of in-progress geometry check */\n      progress?: number;\n    },\n    /** Dirty flag that keeps us from hitting the puzzle generation function too hard */\n    dirty: boolean;\n    /** Currently selected and configured generators for each part of puzzle generation */\n    generators: Record<string, GeneratorState>;\n    /** Generated puzzle geometry */\n    puzzle?: PuzzleGeometry;\n    /** User uploaded image */\n    backgroundImageUrl?: string;\n    /** Name of uploaded image */\n    backgroundImageName: string;\n  };\n\n  // component state\n  const state: PageState = {\n    seed: new Date().getTime() % 10240,\n    canvasWidth: defaultWidth,\n    canvasHeight: defaultHeight,\n    aspectRatio: defaultWidth / defaultHeight,\n    distance: 40,\n    color: isDarkMode ? \"#DDDDDD\" : \"#333333\",\n    drawPoints: false,\n    pointColor: isDarkMode ? \"#FF0000\" : \"#0000FF\",\n    geometryProblems: {\n      autoCheck: false,\n      problems: undefined,\n      progress: undefined,\n    },\n    dirty: true,\n    generators: {\n      /** Strategy for creating points (which influences piece generation) */\n      point: {\n        label: \"Seed Points\",\n        registry: PointGeneratorRegistry,\n        name: defaultPointGenerator,\n        config: PointGeneratorRegistry.getDefaultConfig(defaultPointGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for turning points into puzzle pieces */\n      piece: {\n        label: \"Piece Generation\",\n        registry: PieceGeneratorRegistry,\n        name: defaultPieceGenerator,\n        config: PieceGeneratorRegistry.getDefaultConfig(defaultPieceGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for placing tabs on piece edges */\n      placement: {\n        label: \"Tab Placement\",\n        registry: TabPlacementStrategyRegistry,\n        name: SimpleTabPlacementStrategyName,\n        config: TabPlacementStrategyRegistry.getDefaultConfig(SimpleTabPlacementStrategyName, defaultWidth, defaultHeight),\n      },\n      /** Style of tabs to generate */\n      tab: {\n        label: \"Tabs\",\n        registry: TabGeneratorRegistry,\n        name: defaultTabGenerator,\n        config: TabGeneratorRegistry.getDefaultConfig(defaultTabGenerator, defaultWidth, defaultHeight),\n      },\n    },\n    puzzle: undefined,\n    backgroundImageUrl: undefined,\n    backgroundImageName: '',\n  };\n\n  // utility to invoke the geometry checks\n  function handleCheckGeometry() {\n    if (!state.puzzle) return;\n\n    state.geometryProblems.progress = 0;\n    m.redraw();\n\n    // this uses a web worker to not block the main thread\n    checkGeometryInWorker(state.puzzle, (processed, total) => {\n      state.geometryProblems.progress = (processed / total) * 100;\n      m.redraw();\n    }).then((problems) => {\n      state.geometryProblems.problems = problems.length;\n      state.geometryProblems.progress = undefined;\n      if (state.puzzle) {\n        state.puzzle.problems = problems;\n      }\n      m.redraw();\n    }).catch((err) => {\n      state.geometryProblems.progress = undefined;\n      console.error(err);\n      m.redraw();\n    });\n  }\n\n  // Mithril component\n  return {\n\n    oncreate: () => {\n      buildPuzzle({\n        width: state.canvasWidth,\n        height: state.canvasHeight,\n        pieceSize: state.distance,\n        pointConfig: state.generators.point.config,\n        pieceConfig: state.generators.piece.config,\n        placementConfig: state.generators.placement.config,\n        tabConfig: state.generators.tab.config,\n        seed: state.seed,\n      }).then((puzzle) => {\n        state.puzzle = puzzle;\n        m.redraw();\n        if (state.geometryProblems.autoCheck) {\n          handleCheckGeometry();\n        }\n      }).catch((err) => {\n        console.error(err);\n      });\n    },\n\n    onupdate: () => {\n      if (state.dirty) {\n        state.dirty = false;\n        // rebuild the puzzle geometry\n        buildPuzzle({\n          width: state.canvasWidth,\n          height: state.canvasHeight,\n          pieceSize: state.distance,\n          pointConfig: state.generators.point.config,\n          pieceConfig: state.generators.piece.config,\n          placementConfig: state.generators.placement.config,\n          tabConfig: state.generators.tab.config,\n          seed: state.seed,\n        }).then((puzzle) => {\n          state.geometryProblems.problems = undefined;\n          state.geometryProblems.progress = undefined;\n          state.puzzle = puzzle;\n          m.redraw();\n          if (state.geometryProblems.autoCheck) {\n            handleCheckGeometry();\n          }\n        }).catch((err) => {\n          console.error(err);\n        });\n      }\n    },\n\n    onremove: () => {\n      if (state.backgroundImageUrl) {\n        // clean up memory\n        URL.revokeObjectURL(state.backgroundImageUrl);\n        state.backgroundImageUrl = undefined;\n      }\n    },\n\n    // component lifecycle: render our output\n    view: () => {\n\n      return m(\".page\", [\n        m(GitHubCorner, {\n          link: \"https://github.com/weevilgenius/puzzle-generator\",\n        }),\n        m(\"h1\", \"Puzzle Generator\"),\n        m(\".container\", [\n\n          state.puzzle && m('.puzzle-stack', [\n\n            // main puzzle display\n            m(Puzzle, {\n              width: state.canvasWidth,\n              height: state.canvasHeight,\n              color: state.color,\n              imageUrl: state.backgroundImageUrl,\n              puzzle: state.puzzle,\n              isDirty: state.dirty,\n              pointColor: state.drawPoints ? state.pointColor : undefined,\n              onPuzzleChanged: (puzzle) => {\n                // user dragged a vertex to tweak the puzzle\n                state.puzzle = puzzle;\n                m.redraw();\n              },\n            }),\n\n            m('.actions', [\n\n              // SVG download button\n              m(DownloadPuzzleButton, {\n                puzzle: state.puzzle,\n                width: state.canvasWidth,\n                height: state.canvasHeight,\n                color: state.color,\n              }),\n\n              // Geometry check display\n              m(GeometryCheckIndicator, {\n                autoCheck: state.geometryProblems.autoCheck,\n                problems: state.geometryProblems.problems,\n                progressPercent: state.geometryProblems.progress,\n                onCheckRequested: () => {\n                  if (!state.dirty) {\n                    handleCheckGeometry();\n                  }\n                  m.redraw();\n                },\n                onAutocheckChanged: (autocheck) => {\n                  if (autocheck !== state.geometryProblems.autoCheck) {\n                    state.geometryProblems.autoCheck = autocheck;\n                    m.redraw();\n                  }\n                },\n              }),\n\n            ]),\n          ]),\n\n          // puzzle generation controls\n          m(\".controls\", [\n\n            // background image\n            m('.background-image', [\n              m(UploadImageButton, {\n                label: \"Background Image\",\n                onUpload: (imageUrl, filename, width, height) => {\n                  // clear any previous image\n                  if (state.backgroundImageUrl) {\n                    URL.revokeObjectURL(state.backgroundImageUrl);\n                  }\n                  state.canvasWidth = width;\n                  state.canvasHeight = height;\n                  state.aspectRatio = width / height;\n                  state.backgroundImageUrl = imageUrl;\n                  state.backgroundImageName = filename;\n                  state.dirty = true;\n                  m.redraw();\n                },\n              }),\n              m('span.background-image-label', state.backgroundImageName),\n            ]),\n\n            // Puzzle aspect ratio\n            m(AspectRatioPicker, {\n              ratio: state.aspectRatio,\n              disabled: state.backgroundImageUrl !== undefined,\n              onChange: (ratio) => {\n                state.aspectRatio = ratio;\n                state.canvasWidth = state.canvasHeight * ratio;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Random number seed\n            m(NumberInputControl, {\n              config: {\n                name: 'seed',\n                label: 'Seed',\n                type: 'number',\n              },\n              value: state.seed,\n              onChange: (value) => {\n                state.seed = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece size\n            m(NumberInputControl, {\n              config: {\n                name: 'pieceSize',\n                label: 'Piece size',\n                type: 'number',\n              },\n              value: state.distance,\n              onChange: (value) => {\n                state.distance = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece color\n            m(ColorPicker, {\n              label: 'Piece color',\n              color: state.color,\n              size: \"small\",\n              onUpdate: (newColor) => {\n                state.color = newColor;\n                m.redraw();\n              },\n            }),\n\n            // draw seed points?\n            m('.draw-points', [\n              m(BooleanInputControl, {\n                config: {\n                  name: 'drawPoints',\n                  label: 'Draw seed points',\n                  type: 'boolean',\n                },\n                value: state.drawPoints,\n                onChange: (value) => {\n                  state.drawPoints = value;\n                  m.redraw();\n                },\n              }),\n              state.drawPoints && m(ColorPicker, {\n                label: 'Seed points color',\n                color: state.pointColor,\n                size: \"small\",\n                onUpdate: (newColor) => {\n                  state.pointColor = newColor;\n                  m.redraw();\n                },\n              }),\n            ]),\n\n            // render a generator picker for each type of generator\n            ...Object.entries(state.generators).map(([type, generator]) => {\n              return m(\"label\", [\n                generator.label + ':',\n                m(GeneratorPicker, {\n                  generator: generator.name,\n                  registry: generator.registry,\n                  config: generator.config,\n                  onGeneratorChange: (generatorName) => {\n                    if (generatorName != generator.name) {\n                      console.log(`${type} generator changed to ${generatorName}`);\n                      generator.name = generatorName;\n                      // generator changed, we need a new blank config\n                      state.generators[type].config = generator.registry.getDefaultConfig(generatorName, state.canvasWidth, state.canvasHeight);\n                      state.dirty = true;\n                      m.redraw();\n                    }\n                  },\n                  onConfigChange: (key, value) => {\n                    console.log(`${type} generator config \"${key}\" changed to ${String(value)}`);\n                    generator.config[key] = value;\n                    state.dirty = true;\n                    m.redraw();\n                  },\n                }),\n              ]);\n            }),\n\n          ]), // .controls\n\n        ]), // .container\n\n      ]);\n    }, // view()\n  };\n};\n\n// configure Webawesome icons to use Material Symbols\nregisterIconLibrary('material', {\n  resolver: (name) => {\n    const match = name.match(/^(.*?)(_(rounded|sharp))?$/);\n    if (match) {\n      return `https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${match[3] ?? 'outlined'}/${match[1]}.svg`;\n    }\n    return '';\n  },\n  mutator: (svg) => svg.setAttribute('fill', 'currentColor'),\n});\n\n// Ask Mithril to render the page, our componet gets placed into the root element.\n// Mithril will rerender automatically after DOM event handlers defined in component\n// views and also whenever m.redraw() is called.\nm.mount(document.body, Page);\n"],"names":["GitHubCorner","attrs","m","GeneratorRegistry","name","factory","uiMetadata","width","height","config","generator","a","b","g","newConfig","metadata","control","PointGeneratorRegistry","PieceGeneratorRegistry","TabPlacementStrategyRegistry","TabGeneratorRegistry","distanceSq","p1","p2","dx","dy","serializeTopology","topology","calculateSegmentsBounds","startPoint","segments","xmin","ymin","xmax","ymax","updateBounds","p","segment","getPieceBounds","piece","minX","minY","maxX","maxY","startingEdgeId","currentEdge","segmentBounds","MAX_CLICK_DISTANCE","MAX_CLICK_DISTANCE_SQ","findClosestVertex","puzzle","clickPos","closestVertexIndex","minDistanceSq","i","distSq","polygonBounds","polygon","arePointsEqual","generateSegmentsForEdge","edge","tabGenerator","random","heLeft","heRight","edgeStart","edgeEnd","heLeftSegments","currentPos","tab","tabStartPos","tabStartPoint","tabEndPoint","tabSegments","invertSegments","originalStart","inverted","segmentStart","prevSegment","mulberry32","seed","buildPuzzle","options","pieceSize","pointConfig","pieceConfig","placementConfig","tabConfig","pointGenerator","pieceGenerator","placementStrategy","points","drawPuzzle","canvas","pieceColor","pointColor","ctx","he","destination","problemPoint","x","y","moveVertex","vertexIndex","newPos","oldPos","departingEdges","affectedPieceIDs","delta","departingEdge","predecessorEdge","lastSegment","regenerateAffectedTabs","pieceId","vertex","affectedEdges","movedVertexPos","halfEdgeToEdgeMap","destinationVertex","parentEdge","affectedPieces","he1","he2","Puzzle","state","getEventCoords","rect","touch","handleDragStart","coords","handleDragMove","handleDragEnd","dom","e","createSVG","pathData","pathD","downloadSvg","svg","filename","blob","url","DownloadPuzzleButton","GeometryCheckIndicator","showProgress","showOKBadge","showProblemBadge","checkbox","calculateDisplayDimensions","originalWidth","originalHeight","maxWidth","aspectRatio","UploadImageButton","file","bitmap","uploadUrl","err","BooleanInputControl","newValue","NumberInputControl","input","RangeInputControl","StringInputControl","GeneratorPicker","generators","newSelected","panel","value","commonAspectRatios","AspectRatioPicker","isCustom","selectOptions","ratioStr","selectedValue","range","ColorPicker","tinyNDArrayOfInteger","gridShape","dimensions","totalLength","stride","dimension","tinyNDArrayOfArray","data","index","tinyNdarray","sphereRandom","sampleSphere","d","rng","v","d2","r2","rr","r","theta","h","moore","size","length","neighbors","neighbor","require$$0","getNeighbourhood","dimensionNumber","neighbourhood","origin","n","dist","n1","n2","squareDist1","squareDist2","neighbourhoodCache","getNeighbourhoodMemoized","tinyNDArray","require$$1","require$$2","squaredEuclideanDistance","point1","point2","result","FixedDensityPDS","maxShape","floatPrecisionMitigation","epsilonDistance","point","valid","internalArrayIndex","neighbourIndex","currentDimensionValue","existingPoint","tries","angle","distance","currentPoint","newPoint","inShape","gridData","fixedDensity","euclideanDistance","VariableDensityPDS","pointIndex","existingPointDistance","pointDistance","minDistance","maxDistance","currentDistance","sampleIndex","variableDensity","PoissonDiskSampling","poissonDiskSampling","Name","PoissonPointUIMetadata","PoissonPointGeneratorFactory","_width","_height","_config","runtimeOpts","epsilon","splitter","resulterrbound","sum","elen","flen","f","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","EPSILON","EDGE_STACK","Delaunator","getX","defaultGetX","getY","defaultGetY","maxTriangles","hullPrev","hullNext","hullTri","hullHash","i0","i1","i2","minDist","i0x","i0y","i1x","i1y","minRadius","circumradius","i2x","i2y","quicksort","hull","j","d0","id","center","circumcenter","hullSize","k","xp","yp","start","key","q","t","pseudoAngle","triangles","halfedges","ar","a0","b0","al","bl","p0","pr","pl","inCircle","hbl","br","px","py","ex","ey","fx","fy","ap","bp","cp","cl","ids","dists","left","right","temp","tempDist","median","swap","arr","tmp","Path","x0","y0","w","Polygon","Voronoi","delaunay","vectors","circumcenters","t2","t3","x1","y1","x2","y2","x3","y3","ab","context","buffer","inedges","ti","tj","xi","yi","xj","yj","h0","h1","cell","S","c0","c1","ci","cj","loop","ai","li","aj","lj","e0","V","P","e1","sx0","sy0","sx1","sy1","flip","vx0","vy0","vxn","vyn","vx","vy","tau","pow","pointX","pointY","collinear","jitter","Delaunay","that","flatArray","flatIterable","_","bounds","hullIndex","_hullIndex","l","dc","dt","array","getUniqueId","VoronoiPieceGeneratorUIMetadata","linkPieceHalfEdges","map","len","pointToKey","VoronoiPieceGeneratorFactory","_runtimeOpts","voronoi","halfEdgeEndpointMap","site","pieceHalfEdgeIds","he1_next","keyForTwin","twinId","edgeId","vertexSet","SimpleTabPlacementStrategyUIMetadata","placeTabOnEdge","edgeLength","tabSize","SimpleTabPlacementStrategyFactory","minEdgeLength","maxTabSize","edges","TraditionalTabUIMetadata","createTraditionalTab","jitterPct","heightToWidthRatio","inward","ux","uy","s","A","C","E","dir","nubHeight","shoulder_height","bez1","bez2","bez3","TraditionalTabGeneratorFactory","end","checkGeometryInWorker","onProgress","resolve","reject","worker","CheckGeometryWorker","event","error","message","GridJitterPointUIMetadata","GridJitterPointGeneratorFactory","RectangularPieceGeneratorUIMetadata","RectangularPieceGeneratorFactory","_points","cols","rows","cellWidth","cellHeight","gridVertices","rowVertices","halfEdgeTwinMap","topLeft","topRight","bottomLeft","bottomRight","he_top","he_right","he_bottom","he_left","edgesToProcess","edgeInfo","twinKey","twinHe","selfKey","NullTabUIMetadata","NullTabGeneratorFactory","_start","_end","_tab","_random","TriangleTabUIMetadata","TriangleTabGeneratorFactory","edgeVector","edgeDir","normalDir","midPoint","direction","tabHeight","nubPoint","isDarkMode","configureDarkLightTheme","darkModeQuery","manageDarkLightTheme","Page","defaultPointGenerator","PoissonGeneratorName","defaultPieceGenerator","VoronoiGeneratorName","defaultTabGenerator","TraditionalTabGeneratorName","SimpleTabPlacementStrategyName","handleCheckGeometry","processed","total","problems","autocheck","imageUrl","ratio","newColor","type","generatorName","registerIconLibrary","match"],"mappings":"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","x_google_ignoreList":[18,19,20,21,22,23,24,26,27,28,29,30,31,32]}