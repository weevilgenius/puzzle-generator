{"version":3,"file":"index-CH9Hs6Jz.js","sources":["../../src/ui/GitHubCorner.ts","../../src/geometry/generators/Generator.ts","../../src/utils/UniqueId.ts","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/utils.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/poly-bezier.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js","../../node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js","../../node_modules/.pnpm/splaytree@0.1.4/node_modules/splaytree/index.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/edge_type.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/operation.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/compute_fields.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/sweep_event.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/equals.js","../../node_modules/.pnpm/robust-predicates@2.0.4/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@2.0.4/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/signed_area.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/compare_events.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/divide_segment.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/segment_intersection.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/possible_intersection.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/compare_segments.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/subdivide_segments.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/contour.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/connect_edges.js","../../node_modules/.pnpm/tinyqueue@1.2.3/node_modules/tinyqueue/index.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/fill_queue.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/src/index.js","../../node_modules/.pnpm/martinez-polygon-clipping@0.7.4/node_modules/martinez-polygon-clipping/index.js","../../src/geometry/utils.ts","../../src/utils/mulberry.ts","../../src/geometry/PuzzleMaker.ts","../../src/geometry/borderShapes.ts","../../src/geometry/modifiers.ts","../../src/ui/Puzzle.ts","../../src/utils/svg.ts","../../src/ui/DownloadPuzzleButton.ts","../../src/ui/GeometryCheckIndicator.ts","../../src/ui/UploadImageButton.ts","../../src/ui/inputs/BooleanInputControl.ts","../../src/ui/inputs/NumberInputControl.ts","../../src/ui/inputs/RangeInputControl.ts","../../src/ui/inputs/StringInputControl.ts","../../src/ui/GeneratorPicker.ts","../../src/ui/AspectRatioPicker.ts","../../src/ui/ColorPicker.ts","../../src/ui/BorderShapePicker.ts","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/tiny-ndarray.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/sphere-random.js","../../node_modules/.pnpm/moore@1.0.0/node_modules/moore/index.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/neighbourhood.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/fixed-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/variable-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js","../../src/geometry/generators/point/PoissonPointGenerator.ts","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/delaunator@5.0.1/node_modules/delaunator/index.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/path.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/polygon.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/voronoi.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/delaunay.js","../../src/geometry/generators/piece/PieceGeneratorHelpers.ts","../../src/geometry/generators/piece/VoronoiPieceGenerator.ts","../../src/geometry/generators/tab_placement/SimpleTabPlacementStrategy.ts","../../src/geometry/generators/tab/TraditionalTabGenerator.ts","../../src/geometry/GeometryChecker.ts","../../src/geometry/generators/point/GridJitterPointGenerator.ts","../../src/geometry/generators/piece/RectangularPieceGenerator.ts","../../src/geometry/generators/tab/NullTabGenerator.ts","../../src/geometry/generators/tab/TriangleTabGenerator.ts","../../src/index.ts"],"sourcesContent":["// SVG rendering the GitHub Octocat in a corner with a link\n// adapted from https://github.com/tholman/github-corners/\nimport m from 'mithril';\n\n// include our CSS\nimport './GitHubCorner.css';\n\n// component attributes\nexport interface GitHubCornerAttrs extends m.Attributes {\n  /** Url to use when clicked */\n  link: string;\n}\n\n// Mithril component\nexport const GitHubCorner: m.Component<GitHubCornerAttrs, unknown> = {\n\n  view: ({ attrs }) => {\n\n    return m(\"a.github-corner\", {\n      href: attrs.link,\n      \"aria-label\": \"View source on GitHub\",\n      title: \"View source on GitHub\",\n      target: \"_blank\",\n    }, m(\"svg\", {\n      width: 80,\n      height: 80,\n      viewBox: \"0 0 250 250\",\n      \"aria-hidden\": \"true\",\n    }, [\n      m('path', {\n        d: \"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\",\n      }),\n      m('path.octo-arm', {\n        fill: \"currentColor\",\n        style: \"transform-origin: 130px 106px;\",\n        d: \"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\",\n      }),\n      m('path.octo-body', {\n        fill: \"currentColor\",\n        d: \"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\",\n      }),\n    ]));\n  },\n\n};\nexport default GitHubCorner;\n","import type { GeneratorUIMetadata } from '../ui_types';\nimport type { PathCommand } from '../types';\n\n/** The name of a particular generator implementation. Must be unique. */\nexport type GeneratorName = string;\n\n/** Base configuration for any generator */\nexport interface GeneratorConfig {\n  /** The name of the generator to which this config belongs */\n  name: GeneratorName;\n  // additional fields specific to this generator\n  [key: string]: unknown;\n}\n\n/**\n * A generic interface for a function that creates a configured generator instance.\n * @template T - The particular generator desired, e.g. RectangularPieceGenerator\n * @param border - The border of the puzzle\n * @param bounds - The maximum bounds of the puzzle\n * @param options - Options specific to this generator\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type GeneratorFactory<T> = (border: PathCommand[], bounds: { width: number; height: number }, options: any) => T;\n\n\ninterface RegisteredGenerator<T> {\n  factory: GeneratorFactory<T>;\n  uiMetadata: GeneratorUIMetadata;\n}\n\n/**\n * A generic registry for creating instances of generates from configurations.\n * This allows for a pluggable system where generators can be added dynamically.\n *\n * @template T The base interface for this type of generator, e.g. `TabGenerator`\n */\nexport class GeneratorRegistry<T> {\n  private generators = new Map<GeneratorName, RegisteredGenerator<T>>();\n\n  /**\n   * Registers a new generator factory associated with a specific generator type.\n   * Intended to be called from within each generator's implementation file.\n   * @param name The unique string identifier for the generator, e.g. \"TraditionalTabGenerator\"\n   * @param factory A function that takes an options object and returns a generator\n   * @param uiMetadata A description of the UI needed to configure the generator\n   */\n  public register(name: GeneratorName, factory: GeneratorFactory<T>, uiMetadata: GeneratorUIMetadata): void {\n    if (this.generators.has(name)) {\n      console.warn(`Generator \"${name}\" is already registered, overwriting`);\n    }\n    this.generators.set(name, { factory, uiMetadata });\n  }\n\n  /**\n   * Creates an instance of a generator based on the provided configuration object.\n   * It looks up the correct factory using the `name` property from the config.\n   * @param border The path of the border of the puzzle\n   * @param bounds The maximum bounds of the puzzle\n   * @param config A configuration object for the generator\n   * @returns A configured instance of the requested generator\n   */\n  public create(border: PathCommand[], bounds: { width: number; height: number }, config: GeneratorConfig): T {\n    const generator = this.generators.get(config.name);\n    if (!generator) {\n      throw new Error(`Unknown generator \"${config.name}\". Is it registered?`);\n    }\n    return generator.factory(border, bounds, config);\n  }\n\n  /**\n   * Returns a list of all available generators for populating a selector UI.\n   * @returns An array of objects with the name and human-readable display name.\n   */\n  public getAvailableGenerators(): { name: GeneratorName, displayName: string }[] {\n    return Array.from(this.generators.values())\n      .sort((a, b) => a.uiMetadata.sortHint - b.uiMetadata.sortHint)\n      .map((g) => ({\n        name: g.uiMetadata.name,\n        displayName: g.uiMetadata.displayName,\n      }));\n  }\n\n  /**\n   * Retrieves the full UI metadata for a single generator.\n   * @param name The name of the generator.\n   * @returns The UI metadata object, or undefined if not found.\n   */\n  public getUIMetadata(name: GeneratorName): GeneratorUIMetadata | undefined {\n    return this.generators.get(name)?.uiMetadata;\n  }\n\n  /**\n   * Builds a default (empty) config object for a given generator.\n   * @param name The name of the generator.\n   * @param width The width of the puzzle\n   * @param height The height of the puzzle\n   * @returns Default config object for the given generator\n   */\n  public getDefaultConfig(name: GeneratorName, width: number, height: number): GeneratorConfig {\n    const newConfig: GeneratorConfig = {\n      name: name,\n      width: width,\n      height: height,\n    };\n\n    const metadata = this.getUIMetadata(name);\n    if (metadata) {\n      for (const control of metadata.controls) {\n        newConfig[control.name] = control.defaultValue;\n      }\n    }\n\n    return newConfig;\n  }\n}\n\n/* ========================================================= *\\\n *  Public registeries                                       *\n\\* ========================================================= */\n\n// Public registry for PointGenerators\nimport type { PointGenerator } from \"./point/PointGenerator\";\nexport const PointGeneratorRegistry = new GeneratorRegistry<PointGenerator>();\n\n// Public registry for PieceGenerators\nimport type { PieceGenerator } from \"./piece/PieceGenerator\";\nexport const PieceGeneratorRegistry = new GeneratorRegistry<PieceGenerator>();\n\n// Public registry for TabPlacementStrategies\nimport type { TabPlacementStrategy } from \"./tab_placement/TabPlacementStrategy\";\nexport const TabPlacementStrategyRegistry = new GeneratorRegistry<TabPlacementStrategy>();\n\n// Public registry for TabGenerators\nimport type { TabGenerator } from \"./tab/TabGenerator\";\nexport const TabGeneratorRegistry = new GeneratorRegistry<TabGenerator>();\n","\nexport type UniqueId = number;\n\nlet id = 0;\nexport function getUniqueId(): UniqueId {\n  return id++;\n}\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexport default arcToBezier;","function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\nexport default class SplayTree {\n\n  constructor(compare = DEFAULT_COMPARE, noDuplicates = false) {\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  }\n\n\n  rotateLeft(x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) y.left.parent = x;\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)                this._root = y;\n    else if (x === x.parent.left) x.parent.left = y;\n    else                          x.parent.right = y;\n    if (y) y.left = x;\n    x.parent = y;\n  }\n\n\n  rotateRight(x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) y.right.parent = x;\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)               this._root = y;\n    else if(x === x.parent.left) x.parent.left = y;\n    else                         x.parent.right = y;\n    if (y) y.right = x;\n    x.parent = y;\n  }\n\n\n  _splay(x) {\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) this.rotateRight(p);\n        else              this.rotateLeft(p);\n      } else if (p.left === x && p.parent.left === p) {\n        this.rotateRight(p.parent);\n        this.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this.rotateLeft(p.parent);\n        this.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this.rotateRight(p);\n        this.rotateLeft(p);\n      } else {\n        this.rotateLeft(p);\n        this.rotateRight(p);\n      }\n    }\n  }\n\n\n  splay(x) {\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) ggp.left  = x;\n        else                 ggp.right = x;\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else gp.left = null;\n\n            p.right   = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else gp.right = null;\n\n            x.left    = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else p.left = null;\n\n        x.right  = p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else gp.right = null;\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else gp.left = null;\n\n            x.right   = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else p.right = null;\n\n        x.left   = p;\n        p.parent = x;\n      }\n    }\n  }\n\n\n  replace(u, v) {\n    if (!u.parent) this._root = v;\n    else if (u === u.parent.left) u.parent.left = v;\n    else u.parent.right = v;\n    if (v) v.parent = u.parent;\n  }\n\n\n  minNode(u = this._root) {\n    if (u) while (u.left) u = u.left;\n    return u;\n  }\n\n\n  maxNode(u = this._root) {\n    if (u) while (u.right) u = u.right;\n    return u;\n  }\n\n\n  insert(key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) return;\n        else if (comp(z.key, key) < 0) z = z.right;\n        else z = z.left;\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) z = z.right;\n        else z = z.left;\n      }\n    }\n\n    z = { key, data, left: null, right: null, parent: p };\n\n    if (!p)                          this._root = z;\n    else if (comp(p.key, z.key) < 0) p.right = z;\n    else                             p.left  = z;\n\n    this.splay(z);\n    this._size++;\n    return z;\n  }\n\n\n  find (key) {\n    var z    = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if      (cmp < 0) z = z.right;\n      else if (cmp > 0) z = z.left;\n      else              return z;\n    }\n    return null;\n  }\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param  {Key} key\n   * @return {boolean} true/false\n   */\n  contains (key) {\n    var node       = this._root;\n    var comparator = this._compare;\n    while (node)  {\n      var cmp = comparator(key, node.key);\n      if      (cmp === 0) return true;\n      else if (cmp < 0)   node = node.left;\n      else                node = node.right;\n    }\n\n    return false;\n  }\n\n\n  remove (key) {\n    var z = this.find(key);\n\n    if (!z) return false;\n\n    this.splay(z);\n\n    if (!z.left) this.replace(z, z.right);\n    else if (!z.right) this.replace(z, z.left);\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  }\n\n\n  removeNode(z) {\n    if (!z) return false;\n\n    this.splay(z);\n\n    if (!z.left) this.replace(z, z.right);\n    else if (!z.right) this.replace(z, z.left);\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  }\n\n\n  erase (key) {\n    var z = this.find(key);\n    if (!z) return;\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) sMax.right = t;\n      else   this._root = t;\n      t.parent = sMax;\n    }\n\n    this._size--;\n  }\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) node = node.left;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) successor = successor.left;\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  }\n\n\n  /**\n   * Predecessor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) predecessor = predecessor.right;\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  }\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param  {forEachCallback} callback\n   * @return {SplayTree}\n   */\n  forEach(callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range(low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._compare;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param  {Array<Key>}    keys\n   * @param  {Array<Value>}  [values]\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n   *                                         tree's comparator. Sorting is done\n   *                                         in-place\n   * @return {AVLTree}\n   */\n  load(keys = [], values = [], presort = false) {\n    if (this._size !== 0) throw new Error('bulk-load: tree is not empty');\n    const size = keys.length;\n    if (presort) sort(keys, values, 0, size - 1, this._compare);\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  }\n\n\n  min() {\n    var node = this.minNode(this._root);\n    if (node) return node.key;\n    else      return null;\n  }\n\n\n  max() {\n    var node = this.maxNode(this._root);\n    if (node) return node.key;\n    else      return null;\n  }\n\n  isEmpty() { return this._root === null; }\n  get size() { return this._size; }\n\n\n  /**\n   * Create a tree and load it with items\n   * @param  {Array<Key>}          keys\n   * @param  {Array<Value>?}        [values]\n\n   * @param  {Function?}            [comparator]\n   * @param  {Boolean?}             [presort=false] Pre-sort keys and values, using\n   *                                               tree's comparator. Sorting is done\n   *                                               in-place\n   * @param  {Boolean?}             [noDuplicates=false]   Allow duplicates\n   * @return {SplayTree}\n   */\n  static createTree(keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  }\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","export const NORMAL               = 0;\nexport const NON_CONTRIBUTING     = 1;\nexport const SAME_TRANSITION      = 2;\nexport const DIFFERENT_TRANSITION = 3;\n","export const INTERSECTION = 0;\nexport const UNION        = 1;\nexport const DIFFERENCE   = 2;\nexport const XOR          = 3;\n","import {\n  NORMAL,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION,\n  NON_CONTRIBUTING\n} from './edge_type';\nimport {\n  INTERSECTION,\n  UNION,\n  DIFFERENCE,\n  XOR\n} from './operation';\n\n/**\n * @param  {SweepEvent} event\n * @param  {SweepEvent} prev\n * @param  {Operation} operation\n */\nexport default function computeFields (event, prev, operation) {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else {\n    if (event.isSubject === prev.isSubject) {\n      event.inOut      = !prev.inOut;\n      event.otherInOut = prev.otherInOut;\n\n    // previous line segment in sweepline belongs to the clipping polygon\n    } else {\n      event.inOut      = !prev.otherInOut;\n      event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n    }\n\n    // compute prevInResult field\n    if (prev) {\n      event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n        ? prev.prevInResult : prev;\n    }\n  }\n\n  // check if the line segment belongs to the Boolean operation\n  let isInResult = inResult(event, operation);\n  if (isInResult) {\n    event.resultTransition = determineResultTransition(event, operation);\n  } else {\n    event.resultTransition = 0;\n  }\n}\n\n\n/* eslint-disable indent */\nfunction inResult(event, operation) {\n  switch (event.type) {\n    case NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          // return (event.isSubject && !event.otherInOut) ||\n          //         (!event.isSubject && event.otherInOut);\n          return (event.isSubject && event.otherInOut) ||\n                  (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n      break;\n    case SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}\n/* eslint-enable indent */\n\n\nfunction determineResultTransition(event, operation) {\n  let thisIn = !event.inOut;\n  let thatIn = !event.otherInOut;\n\n  let isIn;\n  switch (operation) {\n    case INTERSECTION:\n      isIn = thisIn && thatIn; break;\n    case UNION:\n      isIn = thisIn || thatIn; break;\n    case XOR:\n      isIn = thisIn ^ thatIn; break;\n    case DIFFERENCE:\n      if (event.isSubject) {\n        isIn = thisIn && !thatIn;\n      } else {\n        isIn = thatIn && !thisIn;\n      }\n      break;\n  }\n  return isIn ? +1 : -1;\n}\n","import { NORMAL } from './edge_type';\n\n\nexport default class SweepEvent {\n\n\n  /**\n   * Sweepline event\n   *\n   * @class {SweepEvent}\n   * @param {Array.<Number>}  point\n   * @param {Boolean}         left\n   * @param {SweepEvent=}     otherEvent\n   * @param {Boolean}         isSubject\n   * @param {Number}          edgeType\n   */\n  constructor (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Type of result transition (0 = not in result, +1 = out-in, -1, in-out)\n     * @type {Number}\n     */\n    this.resultTransition = 0;\n\n    // connection step\n\n    /**\n     * @type {Number}\n     */\n    this.otherPos = -1;\n\n    /**\n     * @type {Number}\n     */\n    this.outputContourId = -1;\n\n    this.isExteriorRing = true;   // TODO: Looks unused, remove?\n  }\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isBelow (p) {\n    const p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  }\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isAbove (p) {\n    return !this.isBelow(p);\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  }\n\n\n  /**\n   * Does event belong to result?\n   * @return {Boolean}\n   */\n  get inResult() {\n    return this.resultTransition !== 0;\n  }\n\n\n  clone () {\n    const copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.contourId        = this.contourId;\n    copy.resultTransition = this.resultTransition;\n    copy.prevInResult     = this.prevInResult;\n    copy.isExteriorRing   = this.isExteriorRing;\n    copy.inOut            = this.inOut;\n    copy.otherInOut       = this.otherInOut;\n\n    return copy;\n  }\n}\n","export default function equals(p1, p2) {\n  if (p1[0] === p2[0]) {\n    if (p1[1] === p2[1]) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n// const EPSILON = 1e-9;\n// const abs = Math.abs;\n// TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n// Precision problem.\n//\n// module.exports = function equals(p1, p2) {\n//   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n// };\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","import {orient2d} from 'robust-predicates';\n\n/**\n * Signed area of the triangle (p0, p1, p2)\n * @param  {Array.<Number>} p0\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Number}\n */\nexport default function signedArea(p0, p1, p2) {\n  const res = orient2d(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]);\n  if (res > 0) return -1;\n  if (res < 0) return 1;\n  return 0;\n}\n","import signedArea from './signed_area';\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nexport default function compareEvents(e1, e2) {\n  const p1 = e1.point;\n  const p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  return specialCases(e1, e2, p1, p2);\n}\n\n\n/* eslint-disable no-unused-vars */\nfunction specialCases(e1, e2, p1, p2) {\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n  // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n/* eslint-enable no-unused-vars */\n","import SweepEvent    from './sweep_event';\nimport equals        from './equals';\nimport compareEvents from './compare_events';\n\n/**\n * @param  {SweepEvent} se\n * @param  {Array.<Number>} p\n * @param  {Queue} queue\n * @return {Queue}\n */\nexport default function divideSegment(se, p, queue)  {\n  const r = new SweepEvent(p, false, se,            se.isSubject);\n  const l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  /* eslint-disable no-console */\n  if (equals(se.point, se.otherEvent.point)) {\n    console.warn('what is that, a collapsed segment?', se);\n  }\n  /* eslint-enable no-console */\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n}\n","//const EPS = 1e-9;\n\n/**\n * Finds the magnitude of the cross product of two vectors (if we pretend\n * they're in three dimensions)\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The magnitude of the cross product\n */\nfunction crossProduct(a, b) {\n  return (a[0] * b[1]) - (a[1] * b[0]);\n}\n\n/**\n * Finds the dot product of two vectors.\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The dot product\n */\nfunction dotProduct(a, b) {\n  return (a[0] * b[0]) + (a[1] * b[1]);\n}\n\n/**\n * Finds the intersection (if any) between two line segments a and b, given the\n * line segments' end points a1, a2 and b1, b2.\n *\n * This algorithm is based on Schneider and Eberly.\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n * Page 244.\n *\n * @param {Array.<Number>} a1 point of first line\n * @param {Array.<Number>} a2 point of first line\n * @param {Array.<Number>} b1 point of second line\n * @param {Array.<Number>} b2 point of second line\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n *                                         (meaning connected segments) as\n *                                         intersections\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n * intersection. If they overlap, the two end points of the overlapping segment.\n * Otherwise, null.\n */\nexport default function (a1, a2, b1, b2, noEndpointTouch) {\n  // The algorithm expects our lines in the form P + sd, where P is a point,\n  // s is on the interval [0, 1], and d is a vector.\n  // We are passed two points. P can be the first point of each pair. The\n  // vector, then, could be thought of as the distance (in x and y components)\n  // from the first point to the second point.\n  // So first, let's make our vectors:\n  const va = [a2[0] - a1[0], a2[1] - a1[1]];\n  const vb = [b2[0] - b1[0], b2[1] - b1[1]];\n  // We also define a function to convert back to regular point form:\n\n  /* eslint-disable arrow-body-style */\n\n  function toPoint(p, s, d) {\n    return [\n      p[0] + s * d[0],\n      p[1] + s * d[1]\n    ];\n  }\n\n  /* eslint-enable arrow-body-style */\n\n  // The rest is pretty much a straight port of the algorithm.\n  const e = [b1[0] - a1[0], b1[1] - a1[1]];\n  let kross    = crossProduct(va, vb);\n  let sqrKross = kross * kross;\n  const sqrLenA  = dotProduct(va, va);\n  //const sqrLenB  = dotProduct(vb, vb);\n\n  // Check for line intersection. This works because of the properties of the\n  // cross product -- specifically, two vectors are parallel if and only if the\n  // cross product is the 0 vector. The full calculation involves relative error\n  // to account for possible very small line segments. See Schneider & Eberly\n  // for details.\n  if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n    // If they're not parallel, then (because these are line segments) they\n    // still might not actually intersect. This code checks that the\n    // intersection point of the lines is actually on both line segments.\n    const s = crossProduct(e, vb) / kross;\n    if (s < 0 || s > 1) {\n      // not on line segment a\n      return null;\n    }\n    const t = crossProduct(e, va) / kross;\n    if (t < 0 || t > 1) {\n      // not on line segment b\n      return null;\n    }\n    if (s === 0 || s === 1) {\n      // on an endpoint of line segment a\n      return noEndpointTouch ? null : [toPoint(a1, s, va)];\n    }\n    if (t === 0 || t === 1) {\n      // on an endpoint of line segment b\n      return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n    }\n    return [toPoint(a1, s, va)];\n  }\n\n  // If we've reached this point, then the lines are either parallel or the\n  // same, but the segments could overlap partially or fully, or not at all.\n  // So we need to find the overlap, if any. To do that, we can use e, which is\n  // the (vector) difference between the two initial points. If this is parallel\n  // with the line itself, then the two lines are the same line, and there will\n  // be overlap.\n  //const sqrLenE = dotProduct(e, e);\n  kross = crossProduct(e, va);\n  sqrKross = kross * kross;\n\n  if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n  // Lines are just parallel, not the same. No overlap.\n    return null;\n  }\n\n  const sa = dotProduct(va, e) / sqrLenA;\n  const sb = sa + dotProduct(va, vb) / sqrLenA;\n  const smin = Math.min(sa, sb);\n  const smax = Math.max(sa, sb);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n\n    // overlap on an end point\n    if (smin === 1) {\n      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n    }\n\n    if (smax === 0) {\n      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    if (noEndpointTouch && smin === 0 && smax === 1) return null;\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    return [\n      toPoint(a1, smin > 0 ? smin : 0, va),\n      toPoint(a1, smax < 1 ? smax : 1, va)\n    ];\n  }\n\n  return null;\n}\n","import divideSegment from './divide_segment';\nimport intersection  from './segment_intersection';\nimport equals        from './equals';\nimport compareEvents from './compare_events';\nimport {\n  NON_CONTRIBUTING,\n  SAME_TRANSITION,\n  DIFFERENT_TRANSITION\n} from './edge_type';\n\n/**\n * @param  {SweepEvent} se1\n * @param  {SweepEvent} se2\n * @param  {Queue}      queue\n * @return {Number}\n */\nexport default function possibleIntersection (se1, se2, queue) {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n  const inter = intersection(\n    se1.point, se1.otherEvent.point,\n    se2.point, se2.otherEvent.point\n  );\n\n  const nintersections = inter ? inter.length : 0;\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n    // if(se1.contourId === se2.contourId){\n    // console.warn('Edges of the same polygon overlap',\n    //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    // }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n      divideSegment(se1, inter[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n      divideSegment(se2, inter[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  const events        = [];\n  let leftCoincide  = false;\n  let rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se2.type = NON_CONTRIBUTING;\n    se1.type = (se2.inOut === se1.inOut)\n      ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[1].otherEvent, events[0].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n}\n","import signedArea    from './signed_area';\nimport compareEvents from './compare_events';\nimport equals        from './equals';\n\n\n/**\n * @param  {SweepEvent} le1\n * @param  {SweepEvent} le2\n * @return {Number}\n */\nexport default function compareSegments(le1, le2) {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return le1.isBelow(le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    let p1 = le1.point, p2 = le2.point;\n    if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n      p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]) return 0;\n      else return le1.contourId > le2.contourId ? 1 : -1;\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n}\n","import Tree                 from 'splaytree';\nimport computeFields        from './compute_fields';\nimport possibleIntersection from './possible_intersection';\nimport compareSegments      from './compare_segments';\nimport {\n  INTERSECTION,\n  DIFFERENCE\n} from './operation';\n\n\nexport default function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n  const sweepLine = new Tree(compareSegments);\n  const sortedEvents = [];\n\n  const rightbound = Math.min(sbbox[2], cbbox[2]);\n\n  let prev, next, begin;\n\n  while (eventQueue.length !== 0) {\n    let event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      next  = prev = sweepLine.insert(event);\n      begin = sweepLine.minNode();\n\n      if (prev !== begin) prev = sweepLine.prev(prev);\n      else                prev = null;\n\n      next = sweepLine.next(next);\n\n      const prevEvent = prev ? prev.key : null;\n      let prevprevEvent;\n      computeFields(event, prevEvent, operation);\n      if (next) {\n        if (possibleIntersection(event, next.key, eventQueue) === 2) {\n          computeFields(event, prevEvent, operation);\n          computeFields(next.key, event, operation);\n        }\n      }\n\n      if (prev) {\n        if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n          let prevprev = prev;\n          if (prevprev !== begin) prevprev = sweepLine.prev(prevprev);\n          else                    prevprev = null;\n\n          prevprevEvent = prevprev ? prevprev.key : null;\n          computeFields(prevEvent, prevprevEvent, operation);\n          computeFields(event,     prevEvent,     operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = prev = sweepLine.find(event);\n\n      if (prev && next) {\n\n        if (prev !== begin) prev = sweepLine.prev(prev);\n        else                prev = null;\n\n        next = sweepLine.next(next);\n        sweepLine.remove(event);\n\n        if (next && prev) {\n          possibleIntersection(prev.key, next.key, eventQueue);\n        }\n      }\n    }\n  }\n  return sortedEvents;\n}\n","export default class Contour {\n\n  /**\n   * Contour\n   *\n   * @class {Contour}\n   */\n  constructor() {\n    this.points = [];\n    this.holeIds = [];\n    this.holeOf = null;\n    this.depth = null;\n  }\n\n  isExterior() {\n    return this.holeOf == null;\n  }\n\n}\n","import compareEvents from './compare_events';\nimport Contour from './contour';\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<SweepEvent>}\n */\nfunction orderEvents(sortedEvents) {\n  let event, i, len, tmp;\n  const resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  let sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        tmp = resultEvents[i];\n        resultEvents[i] = resultEvents[i + 1];\n        resultEvents[i + 1] = tmp;\n        sorted = false;\n      }\n    }\n  }\n\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    event.otherPos = i;\n  }\n\n  // imagine, the right event is found in the beginning of the queue,\n  // when his left counterpart is not marked yet\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    event = resultEvents[i];\n    if (!event.left) {\n      tmp = event.otherPos;\n      event.otherPos = event.otherEvent.otherPos;\n      event.otherEvent.otherPos = tmp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\n/**\n * @param  {Number} pos\n * @param  {Array.<SweepEvent>} resultEvents\n * @param  {Object>}    processed\n * @return {Number}\n */\nfunction nextPos(pos, resultEvents, processed, origPos) {\n  let newPos = pos + 1,\n    p = resultEvents[pos].point,\n    p1;\n  const length = resultEvents.length;\n\n  if (newPos < length)\n    p1 = resultEvents[newPos].point;\n\n  while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else {\n      newPos++;\n    }\n    if (newPos < length) {\n      p1 = resultEvents[newPos].point;\n    }\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos] && newPos > origPos) {\n    newPos--;\n  }\n\n  return newPos;\n}\n\n\nfunction initializeContourFromContext(event, contours, contourId) {\n  const contour = new Contour();\n  if (event.prevInResult != null) {\n    const prevInResult = event.prevInResult;\n    // Note that it is valid to query the \"previous in result\" for its output contour id,\n    // because we must have already processed it (i.e., assigned an output contour id)\n    // in an earlier iteration, otherwise it wouldn't be possible that it is \"previous in\n    // result\".\n    const lowerContourId = prevInResult.outputContourId;\n    const lowerResultTransition = prevInResult.resultTransition;\n    if (lowerResultTransition > 0) {\n      // We are inside. Now we have to check if the thing below us is another hole or\n      // an exterior contour.\n      const lowerContour = contours[lowerContourId];\n      if (lowerContour.holeOf != null) {\n        // The lower contour is a hole => Connect the new contour as a hole to its parent,\n        // and use same depth.\n        const parentContourId = lowerContour.holeOf;\n        contours[parentContourId].holeIds.push(contourId);\n        contour.holeOf = parentContourId;\n        contour.depth = contours[lowerContourId].depth;\n      } else {\n        // The lower contour is an exterior contour => Connect the new contour as a hole,\n        // and increment depth.\n        contours[lowerContourId].holeIds.push(contourId);\n        contour.holeOf = lowerContourId;\n        contour.depth = contours[lowerContourId].depth + 1;\n      }\n    } else {\n      // We are outside => this contour is an exterior contour of same depth.\n      contour.holeOf = null;\n      contour.depth = contours[lowerContourId].depth;\n    }\n  } else {\n    // There is no lower/previous contour => this contour is an exterior contour of depth 0.\n    contour.holeOf = null;\n    contour.depth = 0;\n  }\n  return contour;\n}\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<*>} polygons\n */\nexport default function connectEdges(sortedEvents) {\n  let i, len;\n  const resultEvents = orderEvents(sortedEvents);\n\n  // \"false\"-filled array\n  const processed = {};\n  const contours = [];\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n\n    if (processed[i]) {\n      continue;\n    }\n\n    const contourId = contours.length;\n    const contour = initializeContourFromContext(resultEvents[i], contours, contourId);\n\n    // Helper function that combines marking an event as processed with assigning its output contour ID\n    const markAsProcessed = (pos) => {\n      processed[pos] = true;\n      if (pos < resultEvents.length && resultEvents[pos]) {\n        resultEvents[pos].outputContourId = contourId;\n      }\n    };\n\n    let pos = i;\n    let origPos = i;\n\n    const initial = resultEvents[i].point;\n    contour.points.push(initial);\n\n    /* eslint no-constant-condition: \"off\" */\n    while (true) {\n      markAsProcessed(pos);\n\n      pos = resultEvents[pos].otherPos;\n\n      markAsProcessed(pos);\n      contour.points.push(resultEvents[pos].point);\n\n      pos = nextPos(pos, resultEvents, processed, origPos);\n\n      if (pos == origPos || pos >= resultEvents.length || !resultEvents[pos]) {\n        break;\n      }\n    }\n\n    contours.push(contour);\n  }\n\n  return contours;\n}\n","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","import Queue           from 'tinyqueue';\nimport SweepEvent      from './sweep_event';\nimport compareEvents   from './compare_events';\nimport { DIFFERENCE }  from './operation';\n\nconst max = Math.max;\nconst min = Math.min;\n\nlet contourId = 0;\n\n\nfunction processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n  let i, len, s1, s2, e1, e2;\n  for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n    s1 = contourOrHole[i];\n    s2 = contourOrHole[i + 1];\n    e1 = new SweepEvent(s1, false, undefined, isSubject);\n    e2 = new SweepEvent(s2, false, e1,        isSubject);\n    e1.otherEvent = e2;\n\n    if (s1[0] === s2[0] && s1[1] === s2[1]) {\n      continue; // skip collapsed edges, or it breaks\n    }\n\n    e1.contourId = e2.contourId = depth;\n    if (!isExteriorRing) {\n      e1.isExteriorRing = false;\n      e2.isExteriorRing = false;\n    }\n    if (compareEvents(e1, e2) > 0) {\n      e2.left = true;\n    } else {\n      e1.left = true;\n    }\n\n    const x = s1[0], y = s1[1];\n    bbox[0] = min(bbox[0], x);\n    bbox[1] = min(bbox[1], y);\n    bbox[2] = max(bbox[2], x);\n    bbox[3] = max(bbox[3], y);\n\n    // Pushing it so the queue is sorted from left to right,\n    // with object on the left having the highest priority.\n    Q.push(e1);\n    Q.push(e2);\n  }\n}\n\n\nexport default function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n  const eventQueue = new Queue(null, compareEvents);\n  let polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n  for (i = 0, ii = subject.length; i < ii; i++) {\n    polygonSet = subject[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n    }\n  }\n\n  for (i = 0, ii = clipping.length; i < ii; i++) {\n    polygonSet = clipping[i];\n    for (j = 0, jj = polygonSet.length; j < jj; j++) {\n      isExteriorRing = j === 0;\n      if (operation === DIFFERENCE) isExteriorRing = false;\n      if (isExteriorRing) contourId++;\n      processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n    }\n  }\n\n  return eventQueue;\n}\n","import subdivideSegments from './subdivide_segments';\nimport connectEdges      from './connect_edges';\nimport fillQueue         from './fill_queue';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  UNION,\n  XOR\n}        from './operation';\n\nconst EMPTY = [];\n\n\nfunction trivialOperation(subject, clipping, operation) {\n  let result = null;\n  if (subject.length * clipping.length === 0) {\n    if        (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n  let result = null;\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if        (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION ||\n               operation === XOR) {\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nexport default function boolean(subject, clipping, operation) {\n  if (typeof subject[0][0][0] === 'number') {\n    subject = [subject];\n  }\n  if (typeof clipping[0][0][0] === 'number') {\n    clipping = [clipping];\n  }\n  let trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  const sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n  const cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  // console.time('fill queue');\n  const eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('fill queue');\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  // console.time('subdivide edges');\n  const sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  //console.timeEnd('subdivide edges');\n\n  // console.time('connect vertices');\n  const contours = connectEdges(sortedEvents, operation);\n  //console.timeEnd('connect vertices');\n\n  // Convert contours to polygons\n  const polygons = [];\n  for (let i = 0; i < contours.length; i++) {\n    let contour = contours[i];\n    if (contour.isExterior()) {\n      // The exterior ring goes first\n      let rings = [contour.points];\n      // Followed by holes if any\n      for (let j = 0; j < contour.holeIds.length; j++) {\n        let holeId = contour.holeIds[j];\n        rings.push(contours[holeId].points);\n      }\n      polygons.push(rings);\n    }\n  }\n\n  return polygons;\n}\n","import boolean from './src/';\nimport {\n  INTERSECTION,\n  DIFFERENCE,\n  UNION,\n  XOR\n} from './src/operation';\n\nexport function union (subject, clipping) {\n  return boolean(subject, clipping, UNION);\n}\n\nexport function diff (subject, clipping) {\n  return boolean(subject, clipping, DIFFERENCE);\n}\n\nexport function xor (subject, clipping) {\n  return boolean(subject, clipping, XOR);\n}\n\nexport function intersection (subject, clipping) {\n  return boolean(subject, clipping, INTERSECTION);\n}\n\n/**\n * @enum {Number}\n */\nexport const operations = { UNION, DIFFERENCE, INTERSECTION, XOR };\n","// this file contains various geometry-related utilities\nimport type {\n  AABB,\n  ArcTo,\n  CurveTo,\n  Edge,\n  EdgeID,\n  EdgeSegment,\n  HalfEdge,\n  HalfEdgeID,\n  PathCommand,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  RandomFn,\n  Vec2,\n  Vertex,\n  VertexID,\n} from \"./types\";\nimport { getUniqueId } from \"../utils/UniqueId\";\nimport { Bezier } from \"bezier-js\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\nimport * as martinez from 'martinez-polygon-clipping';\nimport type { TabGenerator } from \"./generators/tab/TabGenerator\";\n\n/**\n * Calculates the squared Euclidean distance between two points.\n * Used for efficient distance comparisons without the need for Math.sqrt().\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns The squared distance between the points.\n */\nexport function distanceSq(p1: Vec2, p2: Vec2): number {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\n\n/** Serializable version of PuzzleTopology */\nexport interface PuzzleTopologySerializable {\n  vertices: Vertex[];\n  pieces: [PieceID, Piece][];\n  edges: [EdgeID, Edge][];\n  halfEdges: [HalfEdgeID, HalfEdge][];\n  boundary: EdgeID[];\n  borderPath: PathCommand[];\n}\n\n/**\n * Converts a PuzzleTopology with Maps to a plain object representation. Note that\n * modern browsers support Map with structuredClone(), but older browsers do not,\n * so it is safer to manually serialize.\n */\nexport function serializeTopology(topology: PuzzleTopology): PuzzleTopologySerializable {\n  return {\n    vertices: topology.vertices,\n    pieces: Array.from(topology.pieces.entries()),\n    edges: Array.from(topology.edges.entries()),\n    halfEdges: Array.from(topology.halfEdges.entries()),\n    boundary: topology.boundary,\n    borderPath: topology.borderPath,\n  };\n}\n\n/** Revives a serialized topology back into a PuzzleTopology with Maps. */\nexport function deserializeTopology(serialized: PuzzleTopologySerializable): PuzzleTopology {\n  return {\n    vertices: serialized.vertices,\n    pieces: new Map(serialized.pieces),\n    edges: new Map(serialized.edges),\n    halfEdges: new Map(serialized.halfEdges),\n    boundary: serialized.boundary,\n    borderPath: serialized.borderPath,\n  };\n}\n\n\n/**\n * Checks if two Axis-Aligned Bounding Boxes intersect.\n * @param a - The first AABB.\n * @param b - The second AABB.\n * @returns `true` if they overlap, `false` otherwise.\n */\nexport function doAABBsIntersect(a: AABB, b: AABB): boolean {\n  // x-axis check\n  if (a[2] < b[0] || a[0] > b[2]) {\n    return false;\n  }\n  // y-axis check\n  if (a[3] < b[1] || a[1] > b[3]) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a path.\n *\n * @param startPoint The starting point of the path.\n * @param segments The array of segments defining the rest of the path.\n * @returns Bounding box for the entire set of segments\n */\nexport function calculateSegmentsBounds(startPoint: Vec2, segments: EdgeSegment[]): AABB {\n  let [xmin, ymin] = startPoint;\n  let [xmax, ymax] = startPoint;\n\n  const updateBounds = (p: Vec2) => {\n    xmin = Math.min(xmin, p[0]);\n    ymin = Math.min(ymin, p[1]);\n    xmax = Math.max(xmax, p[0]);\n    ymax = Math.max(ymax, p[1]);\n  };\n\n  for (const segment of segments) {\n    if (segment.type === 'line') {\n      updateBounds(segment.p);\n    } else { // 'bezier'\n      // For a robust bounding box, we must check the control points,\n      // as the curve can extend beyond its endpoint.\n      updateBounds(segment.p1);\n      updateBounds(segment.p2);\n      updateBounds(segment.p3);\n    }\n  }\n\n  return [xmin, ymin, xmax, ymax];\n}\n\n/**\n * Calculates the precise bounding box for a single puzzle piece by traversing\n * its boundary and finding the extremities of all its geometric segments.\n *\n * @param piece The piece whose bounding box needs to be recalculated.\n * @param topology The full puzzle topology, used to access half-edge data.\n * @returns A new AABB for the piece.\n */\nexport function getPieceBounds(piece: Piece, topology: PuzzleTopology): AABB {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  const startingEdgeId = piece.halfEdge;\n  let currentEdge = topology.halfEdges.get(startingEdgeId);\n\n  if (!currentEdge) {\n    // Should not happen in a valid topology\n    return piece.bounds;\n  }\n\n  // helper function expands the bounding box to include a given point.\n  const updateBounds = (p: Vec2) => {\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  };\n\n  // Traverse the entire boundary of the piece, one half-edge at a time.\n  do {\n    // account for the starting point of the current edge\n    updateBounds(currentEdge.origin);\n\n    // account for all points within the edge's segments (if any)\n    if (currentEdge.segments) {\n      const segmentBounds = calculateSegmentsBounds(currentEdge.origin, currentEdge.segments);\n      updateBounds([segmentBounds[0], segmentBounds[1]]);\n      updateBounds([segmentBounds[2], segmentBounds[3]]);\n    }\n\n    // move to the next half-edge around the piece\n    currentEdge = topology.halfEdges.get(currentEdge.next);\n\n  } while (currentEdge && currentEdge.id !== startingEdgeId);\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n// The maximum distance (in pixels) from a click to a vertex to consider it a \"hit\".\nconst MAX_CLICK_DISTANCE = 100;\nconst MAX_CLICK_DISTANCE_SQ = MAX_CLICK_DISTANCE * MAX_CLICK_DISTANCE;\n\n/**\n * Finds the index of the vertex closest to a given point.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The index of the closest vertex in the `topology.vertices` array,\n * or `null` if no vertex is within the click threshold.\n */\nexport function findClosestVertex(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): VertexID | null {\n  let closestVertexIndex = -1;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (let i = 0; i < puzzle.vertices.length; i++) {\n    const distSq = distanceSq(puzzle.vertices[i], clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestVertexIndex = i;\n    }\n  }\n\n  return closestVertexIndex === -1 ? null : closestVertexIndex;\n}\n\n/**\n * Finds the piece ID of the seed point closest to a given position.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The PieceID whose seed point is closest, or null if none within threshold.\n */\nexport function findClosestSeedPoint(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): PieceID | null {\n  let closestPieceId: PieceID | null = null;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (const piece of puzzle.pieces.values()) {\n    const distSq = distanceSq(piece.site, clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestPieceId = piece.id;\n    }\n  }\n\n  return closestPieceId;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a given polygon.\n * @param polygon - An array of vertices representing the polygon.\n * @returns The AABB or a zero-area box at the origin if the polygon is empty.\n */\nexport function polygonBounds(polygon: Vec2[]): AABB {\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = polygon[0][0];\n  let minY = polygon[0][1];\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 1; i < polygon.length; i++) {\n    const p = polygon[i];\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n/**\n * Checks if two points are effectively at the same location.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns `true` if points are equal.\n */\nexport function arePointsEqual(p1: Vec2, p2: Vec2): boolean {\n  return Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6;\n}\n\n/**\n * Generates the full segment path for an edge based on its TabPlacements.\n * This function modifies the half-edges of the provided edge in place.\n */\nexport function generateSegmentsForEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  tabGenerator: TabGenerator,\n  random: RandomFn\n): void {\n  if (!edge.tabs) { return; }\n  const heLeft = topology.halfEdges.get(edge.heLeft)!;\n  const heRight = topology.halfEdges.get(edge.heRight)!;\n\n  const edgeStart = heLeft.origin;\n  const edgeEnd = heRight.origin;\n  //const edgeLength = Math.hypot(edgeEnd[0] - edgeStart[0], edgeEnd[1] - edgeStart[1]);\n\n  const heLeftSegments: EdgeSegment[] = [];\n  let currentPos = edgeStart;\n\n  // Sort tabs by their position to process them in order\n  edge.tabs.sort((a, b) => a.position - b.position);\n\n  for (const tab of edge.tabs) {\n    //const tabWidth = edgeLength * tab.size;\n    // Calculate the start point of this tab's region\n    const tabStartPos = tab.position - tab.size / 2;\n    const tabStartPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * tabStartPos,\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * tabStartPos,\n    ];\n\n    // Add a straight line from the last position to the start of this tab\n    if (Math.hypot(tabStartPoint[0] - currentPos[0], tabStartPoint[1] - currentPos[1]) > 1e-6) {\n      heLeftSegments.push({ type: 'line', p: tabStartPoint });\n    }\n\n    // Generate segments for the tab itself\n    const tabEndPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * (tabStartPos + tab.size),\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * (tabStartPos + tab.size),\n    ];\n    const tabSegments = tabGenerator.createTabSegments(tabStartPoint, tabEndPoint, tab, random);\n    heLeftSegments.push(...tabSegments);\n\n    currentPos = tabEndPoint;\n  }\n\n  // Add a final line segment to the end of the edge\n  if (Math.hypot(edgeEnd[0] - currentPos[0], edgeEnd[1] - currentPos[1]) > 1e-6) {\n    heLeftSegments.push({ type: 'line', p: edgeEnd });\n  }\n\n  // Assign the generated segments and create the inverse for the twin\n  heLeft.segments = heLeftSegments;\n  heRight.segments = invertSegments(heLeftSegments, edgeStart);\n\n  // update the edge bounding box\n  edge.bounds = calculateSegmentsBounds(edgeStart, heLeftSegments);\n}\n\n/**\n * Creates an inverted copy of an array of edge segments.\n */\nexport function invertSegments(segments: EdgeSegment[], originalStart: Vec2): EdgeSegment[] {\n  const inverted: EdgeSegment[] = [];\n\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const segment = segments[i];\n    let segmentStart = originalStart;\n    if (i > 0) {\n      const prevSegment = segments[i-1];\n      segmentStart = (prevSegment.type === 'line') ? prevSegment.p : prevSegment.p3;\n    }\n\n    if (segment.type === 'line') {\n      inverted.push({ type: 'line', p: segmentStart });\n    } else { // 'bezier'\n      inverted.push({\n        type: 'bezier',\n        p1: segment.p2,\n        p2: segment.p1,\n        p3: segmentStart,\n      });\n    }\n  }\n  return inverted;\n}\n\n\n/**\n * Helper function to reverse a single Bézier curve segment.\n * The new curve starts where the old one ended and vice-versa.\n */\nexport function invertCurve(segment: CurveTo, newEndPoint: Vec2): CurveTo {\n  return {\n    type: 'bezier',\n    p1: segment.p2, // Control points are swapped\n    p2: segment.p1,\n    p3: newEndPoint, // The new end point is the start point of the original\n  };\n}\n\n/**\n * Converts an arc segment into an array of cubic Bézier curves.\n * @param start - The starting point of the arc.\n * @param arc - The ArcTo segment.\n * @returns An array of Bézier curve definitions.\n */\nfunction arcToBeziers(start: Vec2, arc: ArcTo): CurveTo[] {\n  const { p, radii, rotation, largeArc, sweep } = arc;\n  const [startX, startY] = start;\n  const [endX, endY] = p;\n  const [rx, ry] = radii;\n\n  const cubicBeziers = arcToBezier({\n    px: startX,\n    py: startY,\n    cx: endX,\n    cy: endY,\n    rx,\n    ry,\n    xAxisRotation: rotation,\n    largeArcFlag: largeArc ? 1 : 0,\n    sweepFlag: sweep ? 1 : 0,\n  });\n\n\n  // convert output to CurveTo\n  const curves: CurveTo[] = cubicBeziers.map((curve) => {\n    return {\n      type: 'bezier',\n      p1: [ curve.x1, curve.y1 ],\n      p2: [ curve.x2, curve.y2 ],\n      p3: [ curve.x, curve.y ],\n    };\n  });\n  return curves;\n}\n\n/**\n * Flattens a complex boundary path into an array of simple polygons.\n * This is used to prepare the boundary for geometric clipping operations.\n * @param boundary The boundary path to flatten.\n * @returns An array of polygons, where each polygon is an array of vertices.\n * The first polygon is the outer boundary, and subsequent ones are holes.\n */\nexport function flattenBoundary(boundary: PathCommand[]): Vec2[][] {\n  const polygons: Vec2[][] = [];\n  let currentPolygon: Vec2[] = [];\n\n  if (boundary.length === 0 || boundary[0].type !== 'move') {\n    // Return an empty array if the boundary is malformed or empty\n    return [];\n  }\n\n  let currentPoint: Vec2 = [0, 0];\n  for (const command of boundary) {\n    switch (command.type) {\n    case 'move':\n      if (currentPolygon.length > 0) {\n        polygons.push(currentPolygon);\n      }\n      currentPoint = command.p;\n      currentPolygon = [currentPoint];\n      break;\n\n    case 'line':\n      currentPolygon.push(command.p);\n      currentPoint = command.p;\n      break;\n\n    case 'bezier': {\n      // use bezier-js to create a Look-Up Table (LUT) of points\n      const { p1, p2, p3 } = command;\n      const curve = new Bezier([...currentPoint, ...p1, ...p2, ...p3]);\n      const points = curve.getLUT(100);\n      currentPolygon.push(...points.slice(1).map((p) => [p.x, p.y] as Vec2));\n      currentPoint = p3;\n      break;\n    }\n\n    case 'arc': {\n      // Convert the arc into one or more Bézier curves.\n      const beziers = arcToBeziers(currentPoint, command);\n      let arcStartPoint = currentPoint;\n      for (const b of beziers) {\n        // convert each Bézier as above\n        const curve = new Bezier([...arcStartPoint, ...b.p1, ...b.p2, ...b.p3]);\n        const points = curve.getLUT(100); // 100 points is a good approximation\n        currentPolygon.push(...points.slice(1).map((p) => [p.x, p.y] as Vec2));\n        arcStartPoint = b.p3;\n      }\n      currentPoint = command.p;\n      break;\n    }}\n  }\n  if (currentPolygon.length > 0) {\n    polygons.push(currentPolygon);\n  }\n\n  return polygons;\n}\n\n/**\n * Determines if a point is inside a complex boundary path.\n *\n * This function uses the ray casting (even-odd) algorithm. It handles complex\n * paths by first flattening them into a series of simple polygons. It also correctly\n * handles \"holes\" created by sub-paths (via `MoveTo`), assuming standard winding\n * rules.\n *\n * @param point The point to check.\n * @param boundary The boundary path defining the shape.\n * @returns `true` if the point is inside the boundary, `false` otherwise.\n */\nexport function isPointInBoundary(point: Vec2, boundary: PathCommand[]): boolean {\n\n  if (boundary.length > 0 && boundary[0].type !== 'move') {\n    throw new Error(\"Boundary path must start with a 'move' command.\");\n  }\n\n  // flatten the entire path into simple polygons\n  const polygons = flattenBoundary(boundary);\n\n  // use the even-odd rule to determine inclusion\n  let insideCount = 0;\n  for (const poly of polygons) {\n    if (isPointInPolygon(point, poly)) {\n      insideCount++;\n    }\n  }\n  return insideCount % 2 === 1;\n}\n\n// type guard for Martinez library return values\nfunction isMartinezPolygon(geometry: martinez.Geometry): geometry is martinez.Polygon {\n  return Array.isArray(geometry[0]) && Array.isArray(geometry[0][0]) && typeof geometry[0][0][0] === 'number';\n}\n\n/**\n * Clips a polygon against the puzzle boundary.\n *\n * @param polygon The polygon to be clipped (e.g., a grid cell). This should be a simple array of vertices.\n * @param boundary The pre-flattened boundary to clip against.\n * @returns An array of resulting polygons, or null if there is no intersection.\n * Each resulting polygon is an array of vertices.\n */\nexport function clipPolygonAgainstBoundary(polygon: Vec2[], boundary: Vec2[]): Vec2[][] | null {\n\n  // use the martinez-polygon-clipping library to handle clipping\n  // It expects input in a specific GeoJSON-like format, so we must wrap our\n  // simple polygons in arrays to match.\n  const subject = [polygon.map((p) => ([p[0], p[1]]))];\n  const clipper = [boundary.map((p) => ([p[0], p[1]]))];\n\n  const clipped = martinez.intersection(subject, clipper);\n\n  if (!clipped || clipped.length === 0) {\n    return null; // No intersection found.\n  }\n\n  if (isMartinezPolygon(clipped)) {\n    return clipped as Vec2[][];\n  }\n\n  // unwrap the result back to our Vec2[][] format.\n  return clipped.map((poly) =>\n    poly[0].map((p) => ([p[0], p[1]] as Vec2))\n  );\n}\n\n/**\n * Checks if a point is inside a simple polygon using the ray casting algorithm.\n * @param point The point to check.\n * @param polygon An array of vertices defining the polygon.\n * @returns `true` if the point is inside.\n */\nexport function isPointInPolygon(point: Vec2, polygon: Vec2[]): boolean {\n  const [x, y] = point;\n  let isInside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const [xi, yi] = polygon[i];\n    const [xj, yj] = polygon[j];\n\n    // This condition checks if the horizontal ray from the point intersects the edge.\n    const intersect = ((yi > y) !== (yj > y)) &&\n      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n\n  return isInside;\n}\n\n/**\n * Creates a closed, doubly-linked loop of half-edges from an ordered list of vertices.\n * @param vertices - An array of vertices in counter-clockwise order.\n * @param pieceId - The ID of the piece this half-edge loop belongs to.\n * @param topology - The main puzzle topology object, which will be mutated.\n * @returns The array of newly created HalfEdge objects.\n */\nexport function createHalfEdgeLoop(\n  vertices: Vec2[],\n  pieceId: PieceID,\n  topology: PuzzleTopology,\n): HalfEdge[] {\n  const newHalfEdges: HalfEdge[] = [];\n\n  // 1. Add any new, unique vertices to the main list\n  for (const vertex of vertices) {\n    if (!topology.vertices.find((v) => arePointsEqual(v, vertex))) {\n      topology.vertices.push(vertex);\n    }\n  }\n\n  // 2. Create a half-edge for each vertex\n  for (const vertex of vertices) {\n    const he: HalfEdge = {\n      id: getUniqueId(),\n      origin: vertex,\n      twin: -1,\n      next: -1,\n      prev: -1,\n      piece: pieceId,\n    };\n    newHalfEdges.push(he);\n  }\n\n  // 3. Link the created half-edges into a circular doubly-linked list\n  const numEdges = newHalfEdges.length;\n  for (let i = 0; i < numEdges; i++) {\n    const nextIndex = (i + 1) % numEdges;\n    const prevIndex = (i + numEdges - 1) % numEdges;\n    newHalfEdges[i].next = newHalfEdges[nextIndex].id;\n    newHalfEdges[i].prev = newHalfEdges[prevIndex].id;\n  }\n\n  // 4. Add all new half-edges to the topology\n  newHalfEdges.forEach((he) => topology.halfEdges.set(he.id, he));\n\n  return newHalfEdges;\n}\n\n/**\n * Links a set of half-edges to their twins or creates new boundary edges.\n * @param halfEdges - The list of half-edges to process.\n * @param topology - The main puzzle topology object, which will be mutated.\n * @param halfEdgeTwinMap - The map used to look up twin half-edges.\n * @param isBoundaryEdgeFn - A callback function that returns true if a given edge should be treated as part of the puzzle's outer boundary.\n */\nexport function linkAndCreateEdges(\n  halfEdges: HalfEdge[],\n  topology: PuzzleTopology,\n  halfEdgeTwinMap: Map<string, HalfEdgeID>,\n  isBoundaryEdgeFn: (p1: Vec2, p2: Vec2) => boolean,\n): void {\n  const key = (p1: Vec2, p2: Vec2) => `${p1[0]},${p1[1]}-${p2[0]},${p2[1]}`;\n  const numEdges = halfEdges.length;\n\n  for (let i = 0; i < numEdges; i++) {\n    const he = halfEdges[i];\n    const p1 = he.origin;\n    const p2 = topology.halfEdges.get(he.next)!.origin;\n\n    const twinKey = key(p2, p1);\n    const twinId = halfEdgeTwinMap.get(twinKey);\n    const edgeId = getUniqueId();\n    let edge: Edge;\n\n    if (twinId !== undefined) {\n      // Found a twin! This is an internal edge.\n      const twinHe = topology.halfEdges.get(twinId)!;\n      he.twin = twinHe.id;\n      twinHe.twin = he.id;\n      edge = { id: edgeId, heLeft: twinHe.id, heRight: he.id, bounds: polygonBounds([p1, p2]) };\n      halfEdgeTwinMap.delete(twinKey);\n    } else {\n      // No twin found.\n      const selfKey = key(p1, p2);\n      halfEdgeTwinMap.set(selfKey, he.id);\n\n      if (isBoundaryEdgeFn(p1, p2)) {\n        // This is a new edge on the puzzle's custom boundary.\n        edge = { id: edgeId, heLeft: he.id, heRight: -1, bounds: polygonBounds([p1, p2]) };\n        topology.boundary.push(edgeId);\n      } else {\n        // It's an internal grid edge, wait for its neighbor to find it.\n        continue;\n      }\n    }\n    topology.edges.set(edgeId, edge);\n  }\n}\n","\n/**\n * Simple seeded PRNG. The state space is 32 bits, so the period (the point at\n * which random numbers repeat for the same seed) is 2^32.\n * See https://github.com/cprosche/mulberry32 for more details.\n * @param seed seed number\n * @returns function which returns a random number each time it is called\n */\nexport function mulberry32(seed: number) {\n  return function() {\n    let t = seed += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nexport default mulberry32;\n","import type { PathCommand, PieceID, PuzzleGeometry, Vec2 } from \"./types\";\nimport {\n  PointGeneratorRegistry,\n  PieceGeneratorRegistry,\n  TabPlacementStrategyRegistry,\n  TabGeneratorRegistry,\n  type GeneratorConfig,\n} from \"./generators/Generator\";\nimport { generateSegmentsForEdge } from \"./utils\";\nimport mulberry32 from \"../utils/mulberry\";\n\n/**\n * Configuration options for the entire puzzle generation process.\n */\nexport interface PuzzleGenerationOptions {\n  /** Maximum bounds of the puzzle (pre-computed from the boundary path) */\n  bounds: {\n    width: number;\n    height: number;\n  };\n  /** A rough guide for piece size */\n  pieceSize: number;\n  /** Random seed to produce repeatable puzzles */\n  seed?: number;\n  /** How should the points that control the pieces get generated? */\n  pointConfig: GeneratorConfig;\n  /** How should the pieces get built? */\n  pieceConfig: GeneratorConfig;\n  /** How should tabs get placed on piece edges? */\n  placementConfig: GeneratorConfig;\n  /** How should tabs get constructed? */\n  tabConfig: GeneratorConfig;\n  /** Boundary path of the puzzle border */\n  border: PathCommand[];\n  /** Optional pre-generated seed points. If provided, point generation is skipped. */\n  seedPoints?: Vec2[];\n  /** If true, skip tab placement and generation (for real-time preview) */\n  skipTabs?: boolean;\n}\n\n/**\n * Orchestrates the procedural generation of a jigsaw puzzle\n * by coordinating various pluggable generators.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function buildPuzzle(options: PuzzleGenerationOptions): Promise<PuzzleGeometry> {\n  const { bounds, pieceSize, border } = options;\n  const { pointConfig, pieceConfig, placementConfig, tabConfig } = options;\n\n  console.log(`rebuilding puzzle with dimensions ${bounds.width}x${bounds.height}, piece size ${pieceSize}`);\n\n  // get and configure the necessary generators\n  const pointGenerator = PointGeneratorRegistry.create(border, bounds, pointConfig);\n  const pieceGenerator = PieceGeneratorRegistry.create(border, bounds, pieceConfig);\n  const placementStrategy = TabPlacementStrategyRegistry.create(border, bounds, placementConfig);\n  const tabGenerator = TabGeneratorRegistry.create(border, bounds, tabConfig);\n\n  // seeded PRNG used to generate repeatable random numbers\n  const seed = options.seed ?? new Date().getTime();\n  const random = mulberry32(seed);\n\n  // 1. Generate or use provided seed points for the pieces\n  const points = options.seedPoints ??\n    pointGenerator.generatePoints({ width: bounds.width, height: bounds.height, pieceSize, random, border });\n  console.log(`${options.seedPoints ? 'Using' : 'Generated'} ${points.length} points`);\n\n  // 2. Convert points to a puzzle topology (pieces and edges)\n  const topology = pieceGenerator.generatePieces(points, { random, pieceSize, border, bounds });\n  console.log(`Generated ${topology.pieces.size} pieces`);\n\n  // 3. Place tabs on internal edges (skip if requested)\n  if (!options.skipTabs) {\n    placementStrategy.placeTabs({ topology, random });\n\n    // 4. Generate geometry for placed tabs\n    for (const edge of topology.edges.values()) {\n      // only internal edges can accept tabs\n      const isInternal = edge.heRight !== -1;\n      if (isInternal && edge.tabs && edge.tabs.length > 0) {\n        // use the tab generator to create the segment path for an edge based on its TabPlacements\n        generateSegmentsForEdge(edge, topology, tabGenerator, random);\n      }\n    }\n  }\n\n  // 5. Assemble the final puzzle data structure\n  const puzzle: PuzzleGeometry = {\n    created: new Date().toISOString(),\n    seed,\n    width: bounds.width,\n    height: bounds.height,\n    pieceSize,\n    pointConfig,\n    pieceConfig,\n    placementConfig,\n    tabConfig,\n    seedPoints: points,\n    vertices: topology.vertices,\n    boundary: topology.boundary,\n    borderPath: topology.borderPath,\n    pieces: topology.pieces,\n    edges: topology.edges,\n    halfEdges: topology.halfEdges,\n  };\n\n  return puzzle;\n}\n\n/**\n * Rebuilds a puzzle with modified seed points, preserving all other configuration.\n * This is used when the user drags a seed point to a new location.\n *\n * @param originalPuzzle The original puzzle geometry\n * @param pieceId The ID of the piece whose seed point was moved\n * @param newSeedPosition The new position for the seed point\n * @returns A new puzzle with the updated seed point\n */\nexport async function rebuildPuzzleWithUpdatedSeedPoint(\n  originalPuzzle: PuzzleGeometry,\n  pieceId: PieceID,\n  newSeedPosition: Vec2\n): Promise<PuzzleGeometry> {\n  // Create updated points array by finding the piece index\n  const updatedPoints = [...originalPuzzle.seedPoints];\n  let pointIndex = 0;\n  for (const piece of originalPuzzle.pieces.values()) {\n    if (piece.id === pieceId) {\n      updatedPoints[pointIndex] = newSeedPosition;\n      break;\n    }\n    pointIndex++;\n  }\n\n  // Rebuild with updated points but same configuration (INCLUDING tabs this time)\n  return buildPuzzle({\n    bounds: {\n      width: originalPuzzle.width,\n      height: originalPuzzle.height,\n    },\n    border: originalPuzzle.borderPath,\n    pieceSize: originalPuzzle.pieceSize,\n    pointConfig: originalPuzzle.pointConfig,\n    pieceConfig: originalPuzzle.pieceConfig,\n    placementConfig: originalPuzzle.placementConfig,\n    tabConfig: originalPuzzle.tabConfig,\n    seed: originalPuzzle.seed,\n    seedPoints: updatedPoints,\n    skipTabs: false, // Include tabs in final version\n  });\n}\n\n/** Draws puzzle geometry onto a canvas */\nexport function drawPuzzle(puzzle: PuzzleGeometry, canvas: HTMLCanvasElement, pieceColor: string, pointColor?: string) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error(\"Could not get 2D context from canvas\");\n    return;\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // In debug mode, we draw each piece's full boundary in a different color.\n  // This helps visualize the ownership of each edge.\n  const debugMode = false;\n\n  if (debugMode) {\n    const debugColors = [\n      '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',\n      '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff',\n      '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',\n    ];\n    ctx.lineWidth = 2; // Use a thicker line for better visibility\n\n    let pieceIndex = 0;\n    for (const piece of puzzle.pieces.values()) {\n      const pieceColor = debugColors[pieceIndex % debugColors.length];\n      ctx.strokeStyle = pieceColor;\n      ctx.beginPath();\n      ctx.setLineDash([5, 5]); // use dashed lines\n\n      // Get the starting half-edge for this piece's boundary\n      let currentHe = puzzle.halfEdges.get(piece.halfEdge);\n      if (!currentHe) continue;\n\n      const startHeId = currentHe.id;\n      ctx.moveTo(currentHe.origin[0], currentHe.origin[1]);\n\n      // Traverse the boundary of the piece by following the 'next' pointers\n      // until we get back to the starting half-edge.\n      do {\n        if (currentHe.segments) {\n          // If the edge has a custom tab, draw its segments\n          for (const segment of currentHe.segments) {\n            switch (segment.type) {\n            case 'bezier':\n              ctx.bezierCurveTo(segment.p1[0], segment.p1[1], segment.p2[0], segment.p2[1], segment.p3[0], segment.p3[1]);\n              break;\n            case 'line':\n              ctx.lineTo(segment.p[0], segment.p[1]);\n              break;\n            }\n          }\n        } else {\n          // Otherwise, draw a straight line to the start of the next half-edge\n          const nextHe = puzzle.halfEdges.get(currentHe.next)!;\n          ctx.lineTo(nextHe.origin[0], nextHe.origin[1]);\n        }\n        // Move to the next half-edge in the loop\n        currentHe = puzzle.halfEdges.get(currentHe.next)!;\n      } while (currentHe.id !== startHeId);\n\n      ctx.stroke();\n      pieceIndex++;\n    }\n\n    // Reset line dash for subsequent drawing operations.\n    ctx.setLineDash([]);\n\n  } else {\n    // normal mode drawing, optimized for efficiency\n\n    // Style for piece boundaries\n    ctx.strokeStyle = pieceColor;\n    ctx.lineWidth = 1;\n\n    // it's more efficient to batch all paths together\n    ctx.beginPath();\n\n    // By iterating through all unique edges and drawing the curve for one of\n    // its half-edges, we ensure every cut is defined exactly once.\n    for (const edge of puzzle.edges.values()) {\n      // We consistently choose heLeft. The tab generator puts the \"outie\"\n      // or \"innie\" on this half-edge, and the twin gets the inverse.\n      const he = puzzle.halfEdges.get(edge.heLeft);\n      if (!he) continue; // should not happen\n\n      // move to the start of this edge segment\n      ctx.moveTo(he.origin[0], he.origin[1]);\n\n      if (he.segments && he.segments.length > 0) {\n        // if a custom tab is defined, draw each segment in order\n        for (const segment of he.segments) {\n          switch (segment.type) {\n          case 'bezier':\n            ctx.bezierCurveTo(\n              segment.p1[0], segment.p1[1],\n              segment.p2[0], segment.p2[1],\n              segment.p3[0], segment.p3[1]\n            );\n            break;\n          case 'line':\n            ctx.lineTo(segment.p[0], segment.p[1]);\n            break;\n          }\n        }\n      } else {\n        // no tab, draw a straight line to the edge's endpoint.\n        // The end point of a half-edge is the origin of its twin.\n        // For boundary edges, the twin is -1, so we find the end point\n        // by looking at the start of the next half-edge around the piece.\n        let destination: Vec2;\n        // For an internal edge, the destination is the origin of the twin half-edge.\n        if (he.twin !== -1) {\n          const twinHe = puzzle.halfEdges.get(he.twin)!;\n          destination = twinHe.origin;\n        } else {\n          // For a boundary edge, the destination is the origin of the next half-edge in the loop.\n          const nextHe = puzzle.halfEdges.get(he.next)!;\n          destination = nextHe.origin;\n        }\n        ctx.lineTo(destination[0], destination[1]);\n      }\n    }\n\n    // stroke the entire path containing all the unique puzzle edges\n    ctx.stroke();\n  }\n\n  // if the puzzle has problems like intersecting/overlapping pieces, highlight them\n  if (puzzle.problems && puzzle.problems.length > 0) {\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = 'red';\n    for (const problemPoint of puzzle.problems) {\n      const [x, y] = problemPoint;\n      ctx.beginPath();\n      ctx.arc(x, y, 8, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }\n\n  // draw the piece sites (original Voronoi points) for reference\n  if (pointColor) {\n    ctx.fillStyle = pointColor;\n    for (const piece of puzzle.pieces.values()) {\n      const [x, y] = piece.site;\n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n}\n","/**\n * Utility functions for generating common puzzle border shapes.\n *\n * These functions create PathCommand arrays that define various boundary shapes\n * for puzzles. The paths are compatible with SVG path syntax and can be used\n * for both rendering and geometric clipping operations.\n */\n\nimport type { PathCommand } from './types';\n\n/**\n * Creates a rectangular border path.\n *\n * @param width - Width of the rectangle in pixels\n * @param height - Height of the rectangle in pixels\n * @returns A PathCommand array representing a closed rectangle\n *\n * @example\n * const border = createRectangleBorder(800, 600); // a rectangle from (0,0) to (800,600)\n */\nexport function createRectangleBorder(width: number, height: number): PathCommand[] {\n  return [\n    { type: 'move', p: [0, 0] },\n    { type: 'line', p: [width, 0] },\n    { type: 'line', p: [width, height] },\n    { type: 'line', p: [0, height] },\n    { type: 'line', p: [0, 0] },\n  ];\n}\n\n/**\n * Creates a circular border path using elliptical arcs.\n *\n * The circle is centered within the bounding box defined by diameter.\n * Uses two 180-degree arcs to form a complete circle.\n *\n * @param diameter - Diameter of the circle in pixels\n * @returns A PathCommand array representing a closed circle\n *\n * @example\n * const border = createCircleBorder(600); // a circle with radius 300, centered at (300, 300)\n */\nexport function createCircleBorder(diameter: number): PathCommand[] {\n  const radius = diameter / 2;\n  const center = radius;\n\n  return [\n    // Start at the leftmost point of the circle\n    { type: 'move', p: [0, center] },\n    // Draw top semicircle (left to right)\n    {\n      type: 'arc',\n      p: [diameter, center],\n      radii: [radius, radius],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n    // Draw bottom semicircle (right to left)\n    {\n      type: 'arc',\n      p: [0, center],\n      radii: [radius, radius],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n  ];\n}\n\n/**\n * Creates an elliptical border path.\n *\n * The ellipse is centered within the bounding box defined by width and height.\n * Uses two 180-degree arcs to form a complete ellipse.\n *\n * @param width - Width of the ellipse (horizontal diameter) in pixels\n * @param height - Height of the ellipse (vertical diameter) in pixels\n * @returns A PathCommand array representing a closed ellipse\n *\n * @example\n * const border = createEllipseBorder(800, 600); // an ellipse with horizontal radius 400, vertical radius 300\n */\nexport function createEllipseBorder(width: number, height: number): PathCommand[] {\n  const radiusX = width / 2;\n  const radiusY = height / 2;\n\n  return [\n    // Start at the leftmost point of the ellipse\n    { type: 'move', p: [0, radiusY] },\n    // Draw top half (left to right)\n    {\n      type: 'arc',\n      p: [width, radiusY],\n      radii: [radiusX, radiusY],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n    // Draw bottom half (right to left)\n    {\n      type: 'arc',\n      p: [0, radiusY],\n      radii: [radiusX, radiusY],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n  ];\n}\n\n/**\n * Creates a rectangle with rounded corners.\n *\n * The rectangle is created with four straight edges and four quarter-circle arcs\n * at the corners. The corner radius is clamped to prevent invalid geometry.\n *\n * @param width - Width of the rectangle in pixels\n * @param height - Height of the rectangle in pixels\n * @param cornerRadius - Radius of the corner arcs in pixels\n * @returns A PathCommand array representing a rounded rectangle\n *\n * @example\n * const border = createRoundedRectBorder(800, 600, 50);\n * // Creates an 800x600 rectangle with 50px rounded corners\n */\nexport function createRoundedRectBorder(\n  width: number,\n  height: number,\n  cornerRadius: number\n): PathCommand[] {\n  // Clamp corner radius to prevent invalid geometry\n  // (radius can't be more than half the shortest side)\n  const maxRadius = Math.min(width, height) / 2;\n  const r = Math.min(cornerRadius, maxRadius);\n\n  return [\n    // Start at top-left corner (after the arc)\n    { type: 'move', p: [r, 0] },\n\n    // Top edge\n    { type: 'line', p: [width - r, 0] },\n\n    // Top-right corner\n    {\n      type: 'arc',\n      p: [width, r],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n\n    // Right edge\n    { type: 'line', p: [width, height - r] },\n\n    // Bottom-right corner\n    {\n      type: 'arc',\n      p: [width - r, height],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n\n    // Bottom edge\n    { type: 'line', p: [r, height] },\n\n    // Bottom-left corner\n    {\n      type: 'arc',\n      p: [0, height - r],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n\n    // Left edge\n    { type: 'line', p: [0, r] },\n\n    // Top-left corner (back to start)\n    {\n      type: 'arc',\n      p: [r, 0],\n      radii: [r, r],\n      rotation: 0,\n      largeArc: false,\n      sweep: true,\n    },\n  ];\n}\n","import type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  Piece,\n  PieceID,\n  PuzzleGeometry,\n  Vec2,\n  VertexID,\n} from './types';\nimport { TabPlacementStrategyRegistry, TabGeneratorRegistry } from './generators/Generator';\nimport { generateSegmentsForEdge, getPieceBounds } from './utils';\nimport { createRectangleBorder } from './borderShapes';\nimport mulberry32 from \"../utils/mulberry\";\n\n\n/**\n * Finds the closest vertex to a click position and moves it to a new position,\n * updating all connected edges and pieces. This function directly modifies the\n * provided puzzle object.\n *\n * @param puzzle The puzzle data structure to modify.\n * @param vertexIndex The index of the vertex to move in the `puzzle.vertices` array\n * @param newPos The new [x, y] coordinates to move the vertex to.\n */\nexport function moveVertex(\n  puzzle: PuzzleGeometry,\n  vertexIndex: VertexID,\n  newPos: Vec2\n): void {\n  // --- 1. Get the vertex's original position ---\n  if (vertexIndex < 0 || vertexIndex >= puzzle.vertices.length) {\n    console.warn(\"moveVertex called with invalid vertex index:\", vertexIndex);\n    return;\n  }\n  const oldPos = puzzle.vertices[vertexIndex];\n\n  // --- 2. Update the master vertex in the vertices array ---\n  puzzle.vertices[vertexIndex] = newPos;\n\n  // --- 3. Identify all half-edges that are affected by this move ---\n  const departingEdges: HalfEdge[] = [];\n  for (const he of puzzle.halfEdges.values()) {\n    // A half-edge \"departs\" from the vertex if its origin is at the old position.\n    if (he.origin[0] === oldPos[0] && he.origin[1] === oldPos[1]) {\n      departingEdges.push(he);\n    }\n  }\n\n  const affectedPieceIDs = new Set<PieceID>();\n  const delta: Vec2 = [newPos[0] - oldPos[0], newPos[1] - oldPos[1]];\n\n  // --- 4. Update the geometry of all affected half-edges ---\n  for (const departingEdge of departingEdges) {\n    // The origin of the departing edge is now the new position.\n    departingEdge.origin = newPos;\n    affectedPieceIDs.add(departingEdge.piece);\n\n    // Now we must update the half-edge that *flows into* this vertex.\n    // This is the predecessor in the piece's boundary loop.\n    const predecessorEdge = puzzle.halfEdges.get(departingEdge.prev);\n\n    if (predecessorEdge?.segments) {\n      const lastSegment = predecessorEdge.segments[predecessorEdge.segments.length - 1];\n\n      // Update the endpoint of the predecessor's final segment.\n      if (lastSegment.type === 'line') {\n        lastSegment.p = newPos;\n      } else { // 'bezier'\n        lastSegment.p3 = newPos;\n        // For a smooth transition, we translate the control points by the same\n        // amount as the endpoint. More sophisticated logic could be used here\n        // for better curve preservation.\n        lastSegment.p1 = [lastSegment.p1[0] + delta[0], lastSegment.p1[1] + delta[1]];\n        lastSegment.p2 = [lastSegment.p2[0] + delta[0], lastSegment.p2[1] + delta[1]];\n      }\n      affectedPieceIDs.add(predecessorEdge.piece);\n    }\n  }\n\n  // --- 5. Rebuild any tabs affected by the vertex move ---\n  regenerateAffectedTabs(puzzle, vertexIndex);\n\n  // --- 6. Recalculate the bounding boxes for all affected pieces ---\n  for (const pieceId of affectedPieceIDs) {\n    const piece = puzzle.pieces.get(pieceId);\n    if (piece) {\n      piece.bounds = getPieceBounds(piece, puzzle);\n    }\n  }\n}\n\n\n/**\n * Finds all full (interior) edges connected to a given vertex and regenerates their tabs.\n *\n * @param puzzle The puzzle and its topology.\n * @param vertex The the vertex that was modified.\n */\nexport function regenerateAffectedTabs(\n  puzzle: PuzzleGeometry,\n  vertex: VertexID\n): void {\n\n  const { seed, width, height, placementConfig, tabConfig } = puzzle;\n  const random = mulberry32(seed);\n\n  // Create a simple rectangular border for the modifier operations\n  const border = createRectangleBorder(width, height);\n  const bounds = { width, height };\n\n  // recreate the placement strategy and tab generator that were used for this puzzle\n  const placementStrategy = TabPlacementStrategyRegistry.create(border, bounds, placementConfig);\n  const tabGenerator = TabGeneratorRegistry.create(border, bounds, tabConfig);\n\n  const affectedEdges = new Set<Edge>();\n  const movedVertexPos = puzzle.vertices[vertex];\n\n  // To efficiently find the parent Edge of a HalfEdge, we can build a lookup map.\n  // This is much faster than iterating through all edges every time.\n  const halfEdgeToEdgeMap = new Map<EdgeID, Edge>();\n  for (const edge of puzzle.edges.values()) {\n    halfEdgeToEdgeMap.set(edge.heLeft, edge);\n    // heRight can be -1 for boundary edges, so check first.\n    if (edge.heRight !== -1) {\n      halfEdgeToEdgeMap.set(edge.heRight, edge);\n    }\n  }\n\n  // Find all half-edges that either start or end at the moved vertex.\n  for (const he of puzzle.halfEdges.values()) {\n    const destinationVertex = puzzle.halfEdges.get(he.next)?.origin;\n\n    // Is this half-edge starting at the moved vertex?\n    const startsAtVertex = he.origin === movedVertexPos;\n    // Is this half-edge ending at the moved vertex?\n    const endsAtVertex = destinationVertex === movedVertexPos;\n\n    if (startsAtVertex || endsAtVertex) {\n      const parentEdge = halfEdgeToEdgeMap.get(he.id);\n      if (parentEdge) {\n        affectedEdges.add(parentEdge);\n      }\n    }\n  }\n\n  // re-run the placement strategy in case it needs to make a change\n  placementStrategy.updateTabPlacements(Array.from(affectedEdges), { topology: puzzle, random });\n\n  const affectedPieces = new Set<Piece>();\n\n  // Now, regenerate the tabs for the unique set of affected edges.\n  for (const edge of affectedEdges) {\n    // only add tabs to internal edges\n    const isInternal = edge.heRight !== -1;\n    if (isInternal) {\n      // remove any existing segments\n      const he1 = puzzle.halfEdges.get(edge.heLeft);\n      if (he1) {\n        he1.segments = undefined;\n        affectedPieces.add(puzzle.pieces.get(he1.piece)!);\n      }\n      const he2 = puzzle.halfEdges.get(edge.heRight);\n      if (he2) {\n        he2.segments = undefined;\n        affectedPieces.add(puzzle.pieces.get(he2.piece)!);\n      }\n\n      // regenerate segments\n      generateSegmentsForEdge(edge, puzzle, tabGenerator, random);\n    }\n  }\n\n  // recalculate boundaries for affected pieces\n  for (const piece of affectedPieces) {\n    piece.bounds = getPieceBounds(piece, puzzle);\n  }\n\n}","import m from 'mithril';\nimport { buildPuzzle, drawPuzzle } from \"../geometry/PuzzleMaker\";\nimport { moveVertex } from '../geometry/modifiers';\nimport { findClosestVertex, findClosestSeedPoint, distanceSq } from '../geometry/utils';\nimport type { PieceID, VertexID } from '../geometry/types';\nimport type { PuzzleGeometry, Vec2 } from '../geometry/types';\nimport type MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// include our CSS\nimport './Puzzle.css';\n\n// component attributes\nexport interface PuzzleAttrs extends m.Attributes {\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Generated puzzle geometry */\n  puzzle: PuzzleGeometry,\n  /** If true, geometry is being regenerated */\n  isDirty: boolean;\n  /** If set, draw the seed points in this color */\n  pointColor?: string;\n  /** User uploaded image */\n  imageUrl?: string;\n  /** Callback indicating user modified the puzzle geometry */\n  onPuzzleChanged: (puzzle: PuzzleGeometry) => void;\n  /** Callback when user drags a seed point */\n  onSeedPointMoved?: (pieceId: PieceID, newPosition: Vec2) => void;\n}\n\n// Throttling constant for real-time regeneration during drag\nconst REGENERATION_THROTTLE_MS = 50; // Limit to ~20 updates/second\n\n// Distance thresholds for hover feedback (smaller than click/drag threshold)\nconst HOVER_DISTANCE = 5; // pixels\nconst HOVER_DISTANCE_SQ = HOVER_DISTANCE * HOVER_DISTANCE;\n\n// Mithril component\nexport const Puzzle: m.ClosureComponent<PuzzleAttrs> = () => {\n\n  // component state\n  const state = {\n    /** Canvas HTML element */\n    canvas: null as HTMLCanvasElement | null,\n    /** Is the user currently dragging something? */\n    isDragging: false,\n    /** The index of the vertex being dragged. */\n    draggedVertexId: -1 as VertexID,\n    /** The ID of the seed point (piece) being dragged. */\n    draggedSeedPointId: -1 as PieceID,\n    /** Timestamp of last regeneration (for throttling). */\n    lastRegenerationTime: 0,\n    /** Pending setTimeout ID for throttled regeneration. */\n    pendingRegeneration: null as number | null,\n    /** Document-level mousemove handler for dragging outside canvas */\n    documentMouseMove: null as ((e: MouseEvent) => void) | null,\n    /** Document-level mouseup handler for ending drag outside canvas */\n    documentMouseUp: null as ((e: MouseEvent) => void) | null,\n  };\n\n  // helper function to check if mouse is hovering near a draggable item\n  const isNearDraggableItem = (mousePos: Vec2, attrs: PuzzleAttrs): boolean => {\n    // Check seed points if visible\n    if (attrs.pointColor) {\n      for (const piece of attrs.puzzle.pieces.values()) {\n        if (distanceSq(piece.site, mousePos) < HOVER_DISTANCE_SQ) {\n          return true;\n        }\n      }\n    }\n\n    // Check vertices\n    for (const vertex of attrs.puzzle.vertices) {\n      if (distanceSq(vertex, mousePos) < HOVER_DISTANCE_SQ) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  // helper function to normalize coordinates between mouse clicks and mobile touches\n  const getEventCoords = (e: MouseEvent | TouchEvent): Vec2 => {\n    if (!state.canvas) return [0, 0];\n    const rect = state.canvas.getBoundingClientRect();\n\n    if (e instanceof TouchEvent) {\n      // TouchEvent\n      if (e.changedTouches.length > 0) {\n        const touch = e.changedTouches[0];\n        return [touch.clientX - rect.left, touch.clientY - rect.top];\n      }\n    } else {\n      // MouseEvent\n      return [e.clientX - rect.left, e.clientY - rect.top];\n    }\n    return [0, 0];\n  };\n\n  // helper function to determine what is being dragged\n  const getDragTarget = (clickPos: Vec2, attrs: PuzzleAttrs):\n    { type: 'vertex'; id: VertexID } |\n    { type: 'seedPoint'; id: PieceID } |\n    { type: 'none' } =>\n  {\n    // Only allow seed point dragging if points are visible\n    if (attrs.pointColor) {\n      const seedPointId = findClosestSeedPoint(attrs.puzzle, clickPos);\n      if (seedPointId !== null) {\n        return { type: 'seedPoint', id: seedPointId };\n      }\n    }\n\n    // Check for vertex dragging\n    const vertexId = findClosestVertex(attrs.puzzle, clickPos);\n    if (vertexId !== null) {\n      return { type: 'vertex', id: vertexId };\n    }\n\n    return { type: 'none' };\n  };\n\n  // handles mouse movement for cursor changes (not dragging)\n  const handleMouseMove = (e: MouseEvent & MithrilViewEvent, attrs: PuzzleAttrs) => {\n    e.redraw = false;\n\n    // Don't change cursor while dragging\n    if (state.isDragging) return;\n\n    const coords = getEventCoords(e);\n    const isNearItem = isNearDraggableItem(coords, attrs);\n\n    if (state.canvas) {\n      state.canvas.style.cursor = isNearItem ? 'grab' : 'default';\n    }\n  };\n\n  // helper function to regenerate puzzle without tabs for real-time preview\n  const regeneratePuzzleWithoutTabs = (attrs: PuzzleAttrs, pieceId: PieceID, newPosition: Vec2) => {\n    // Update seed points array\n    const updatedPoints = [...attrs.puzzle.seedPoints];\n    let pointIndex = 0;\n    for (const piece of attrs.puzzle.pieces.values()) {\n      if (piece.id === pieceId) {\n        updatedPoints[pointIndex] = newPosition;\n        break;\n      }\n      pointIndex++;\n    }\n\n    // Regenerate WITHOUT tabs for real-time preview\n    buildPuzzle({\n      bounds: { width: attrs.puzzle.width, height: attrs.puzzle.height },\n      border: attrs.puzzle.borderPath,\n      pieceSize: attrs.puzzle.pieceSize,\n      pointConfig: attrs.puzzle.pointConfig,\n      pieceConfig: attrs.puzzle.pieceConfig,\n      placementConfig: attrs.puzzle.placementConfig,\n      tabConfig: attrs.puzzle.tabConfig,\n      seed: attrs.puzzle.seed,\n      seedPoints: updatedPoints,\n      skipTabs: true, // KEY: Skip expensive tab generation\n    }).then((previewPuzzle) => {\n      // Only update if still dragging the same point (avoid race conditions)\n      if (state.draggedSeedPointId === pieceId) {\n        drawPuzzle(previewPuzzle, state.canvas!, attrs.color, attrs.pointColor);\n      }\n    }).catch((err) => {\n      console.error('Failed to regenerate preview:', err);\n    });\n  };\n\n  // handles the start of a drag operation (mouse or mobile)\n  const handleDragStart = (e: (MouseEvent | TouchEvent) & MithrilViewEvent, attrs: PuzzleAttrs) => {\n    e.redraw = false;\n\n    // for touch events, ignore multiple touches (like pinch zoom)\n    if (e instanceof TouchEvent) {\n      if (e.touches.length > 1) {\n        state.isDragging = false;\n        state.draggedVertexId = -1;\n        state.draggedSeedPointId = -1;\n        return;\n      }\n    }\n\n    // for mouse events, only handle the primary button.\n    if (e instanceof MouseEvent && e.button !== 0) return;\n\n    const coords = getEventCoords(e);\n    const target = getDragTarget(coords, attrs);\n\n    if (target.type === 'vertex') {\n      state.draggedVertexId = target.id;\n    } else if (target.type === 'seedPoint') {\n      state.draggedSeedPointId = target.id;\n    }\n\n    // For mouse events, attach document-level listeners to track drag outside canvas\n    if (e instanceof MouseEvent && (state.draggedVertexId >= 0 || state.draggedSeedPointId >= 0)) {\n      state.documentMouseMove = (docEvent: MouseEvent) => {\n        const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n        mithrilEvent.redraw = false;\n        handleDragMove(mithrilEvent, attrs);\n      };\n      state.documentMouseUp = (docEvent: MouseEvent) => {\n        const mithrilEvent = docEvent as MouseEvent & MithrilViewEvent;\n        mithrilEvent.redraw = false;\n        handleDragEnd(mithrilEvent, attrs);\n      };\n      document.addEventListener('mousemove', state.documentMouseMove);\n      document.addEventListener('mouseup', state.documentMouseUp);\n    }\n  };\n\n  // handles drag movement (mouse or mobile)\n  const handleDragMove = (e: (MouseEvent | TouchEvent) & MithrilViewEvent, attrs: PuzzleAttrs) => {\n    e.redraw = false;\n\n    const coords = getEventCoords(e);\n\n    // Handle vertex dragging (existing logic)\n    if (state.draggedVertexId >= 0) {\n      state.isDragging = true;\n      e.preventDefault();\n\n      // Update cursor to grabbing\n      if (state.canvas) {\n        state.canvas.style.cursor = 'grabbing';\n      }\n\n      moveVertex(attrs.puzzle, state.draggedVertexId, coords);\n      drawPuzzle(attrs.puzzle, state.canvas!, attrs.color, attrs.pointColor);\n      return;\n    }\n\n    // Handle seed point dragging (NEW: real-time regeneration without tabs)\n    if (state.draggedSeedPointId >= 0) {\n      state.isDragging = true;\n      e.preventDefault();\n\n      // Update cursor to grabbing\n      if (state.canvas) {\n        state.canvas.style.cursor = 'grabbing';\n      }\n\n      // Throttle regeneration to avoid overwhelming the system\n      const now = performance.now();\n      if (now - state.lastRegenerationTime < REGENERATION_THROTTLE_MS) {\n        // Schedule a delayed regeneration\n        if (state.pendingRegeneration) {\n          clearTimeout(state.pendingRegeneration);\n        }\n        state.pendingRegeneration = window.setTimeout(() => {\n          regeneratePuzzleWithoutTabs(attrs, state.draggedSeedPointId, coords);\n        }, REGENERATION_THROTTLE_MS);\n        return;\n      }\n\n      // Perform immediate regeneration\n      state.lastRegenerationTime = now;\n      regeneratePuzzleWithoutTabs(attrs, state.draggedSeedPointId, coords);\n    }\n  };\n\n  // handles the end of a drag (mouse or mobile)\n  const handleDragEnd = (e: (MouseEvent | TouchEvent) & MithrilViewEvent, attrs: PuzzleAttrs) => {\n    e.redraw = false;\n\n    // Clear any pending regeneration\n    if (state.pendingRegeneration) {\n      clearTimeout(state.pendingRegeneration);\n      state.pendingRegeneration = null;\n    }\n\n    const wasDraggingVertex = state.draggedVertexId >= 0 && state.isDragging;\n    const wasDraggingSeedPoint = state.draggedSeedPointId >= 0 && state.isDragging;\n\n    if (wasDraggingVertex) {\n      e.preventDefault();\n      attrs.onPuzzleChanged(attrs.puzzle);\n    }\n\n    if (wasDraggingSeedPoint) {\n      e.preventDefault();\n      // Trigger final regeneration with FULL geometry including tabs\n      const pieceId = state.draggedSeedPointId;\n      const finalPosition = getEventCoords(e);\n\n      if (attrs.onSeedPointMoved) {\n        attrs.onSeedPointMoved(pieceId, finalPosition);\n      }\n    }\n\n    // Remove document-level listeners if they were attached\n    if (state.documentMouseMove) {\n      document.removeEventListener('mousemove', state.documentMouseMove);\n      state.documentMouseMove = null;\n    }\n    if (state.documentMouseUp) {\n      document.removeEventListener('mouseup', state.documentMouseUp);\n      state.documentMouseUp = null;\n    }\n\n    // Reset cursor\n    if (state.canvas) {\n      state.canvas.style.cursor = 'default';\n    }\n\n    // Reset state\n    state.isDragging = false;\n    state.draggedVertexId = -1;\n    state.draggedSeedPointId = -1;\n    state.lastRegenerationTime = 0;\n  };\n\n  return {\n    // component lifecycle: called after our DOM element is created and attached\n    oncreate: ({ dom, attrs }) => {\n      state.canvas = dom.querySelector<HTMLCanvasElement>(\"canvas.puzzle\");\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color, attrs.pointColor);\n      }\n    },\n\n    onupdate: ({ attrs }) => {\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color, attrs.pointColor);\n      }\n    },\n\n    // component lifecycle: cleanup when component is removed\n    onremove: () => {\n      // Clean up document-level listeners if component is destroyed during drag\n      if (state.documentMouseMove) {\n        document.removeEventListener('mousemove', state.documentMouseMove);\n        state.documentMouseMove = null;\n      }\n      if (state.documentMouseUp) {\n        document.removeEventListener('mouseup', state.documentMouseUp);\n        state.documentMouseUp = null;\n      }\n    },\n\n    // component lifecycle: render our output\n    view: ({ attrs }) => {\n\n      return m(\".puzzle-stack\", [\n\n        // user uploaded image\n        m(\"img.background\", {\n          width: attrs.width,\n          height: attrs.height,\n          src: attrs.imageUrl,\n        }),\n\n        // canvas for rendering the current puzzle\n        m('canvas.puzzle', {\n          width: attrs.width,\n          height: attrs.height,\n          style: {\n            width: `${attrs.width}px`,\n            height: `${attrs.height}px`,\n            touchAction: 'manipulation',\n          },\n\n          // mouse events\n          onmousedown: (e: MouseEvent & MithrilViewEvent) => handleDragStart(e, attrs),\n          onmousemove: (e: MouseEvent & MithrilViewEvent) => {\n            handleMouseMove(e, attrs);\n            handleDragMove(e, attrs);\n          },\n          onmouseup: (e: MouseEvent & MithrilViewEvent) => handleDragEnd(e, attrs),\n\n          // touch events\n          ontouchstart: (e: TouchEvent & MithrilViewEvent) => handleDragStart(e, attrs),\n          ontouchmove: (e: TouchEvent & MithrilViewEvent) => handleDragMove(e, attrs),\n          ontouchend: (e: TouchEvent & MithrilViewEvent) => handleDragEnd(e, attrs),\n          ontouchcancel: (e: TouchEvent & MithrilViewEvent) => handleDragEnd(e, attrs),\n        }),\n      ]);\n    },\n\n  };\n};\nexport default Puzzle;\n\n","import { PuzzleTopology, Vec2 } from \"../geometry/types\";\n\n/**\n * Generates an SVG string representation of the puzzle's cut lines.\n *\n * @param topology - The puzzle topology containing the geometric data.\n * @param width - The width of the SVG viewport.\n * @param height - The height of the SVG viewport.\n * @param pieceColor - Optional color to draw the pieces (default black)\n * @returns A string containing the complete SVG markup.\n */\nexport function createSVG(topology: PuzzleTopology, width: number, height: number, pieceColor = \"black\"): string {\n  // how many digits to preserve when converting decimal numbers to SVG string\n  const precisionDigits = 3;\n\n  // Array to hold the individual path commands (e.g., \"M 10 10\", \"L 100 100\").\n  const pathData: string[] = [];\n\n  // Iterate over each unique edge, ensuring each cut is only defined once.\n  for (const edge of topology.edges.values()) {\n    const he = topology.halfEdges.get(edge.heLeft);\n    if (!he) continue;\n\n    // SVG Path Command: \"M\" - move to the starting point of the half-edge.\n    pathData.push(`M ${he.origin[0].toFixed(precisionDigits)} ${he.origin[1].toFixed(precisionDigits)}`);\n\n    if (he.segments) {\n      // if a custom tab is defined, draw each segment in order\n      for (const segment of he.segments) {\n        switch (segment.type) {\n        case 'bezier':\n          // SVG Path Command: \"C\" - draw a cubic Bézier curve.\n          pathData.push(\n            `C ${segment.p1[0].toFixed(precisionDigits)} ${segment.p1[1].toFixed(precisionDigits)}, ` +\n            `${segment.p2[0].toFixed(precisionDigits)} ${segment.p2[1].toFixed(precisionDigits)}, ` +\n            `${segment.p3[0].toFixed(precisionDigits)} ${segment.p3[1].toFixed(precisionDigits)}`\n          );\n          break;\n        case 'line':\n          // SVG Path Command: \"L\" - draw a straight line to the destination.\n          pathData.push(`L ${segment.p[0].toFixed(precisionDigits)} ${segment.p[1].toFixed(precisionDigits)}`);\n          break;\n        }\n      }\n    } else {\n      // SVG Path Command: \"L\" - draw a straight line to the destination.\n      let destination: Vec2;\n      if (he.twin !== -1) {\n        // Internal edge: destination is the start of the twin half-edge.\n        const twinHe = topology.halfEdges.get(he.twin)!;\n        destination = twinHe.origin;\n      } else {\n        // Boundary edge: destination is the start of the next half-edge.\n        const nextHe = topology.halfEdges.get(he.next)!;\n        destination = nextHe.origin;\n      }\n      pathData.push(`L ${destination[0].toFixed(precisionDigits)} ${destination[1].toFixed(precisionDigits)}`);\n    }\n  }\n\n  // Join all path commands into a single string for the 'd' attribute.\n  const pathD = pathData.join(' ');\n\n  // Construct the final SVG markup.\n  // The <path> element uses vector-effect=\"non-scaling-stroke\" which is a best\n  // practice for laser cutting files, as it ensures the line width remains\n  // constant regardless of scaling.\n  const svgString = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg\n  width=\"${width}\"\n  height=\"${height}\"\n  viewBox=\"0 0 ${width} ${height}\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  version=\"1.1\"\n>\n  <path\n    d=\"${pathD}\"\n    fill=\"none\"\n    stroke=\"${pieceColor}\"\n    stroke-width=\"1\"\n    vector-effect=\"non-scaling-stroke\"\n  />\n</svg>`\n    .trim() // strip leading and trailing whitespace\n    .replace(/\\r\\n/g, '\\n'); // use unix line endings for max compatibility\n\n  return svgString;\n}\n\n\n/**\n * Offers a SVG file for download\n * @param svg SVG string as generated by drawSVG()\n * @param filename Optional name of file for download\n */\nexport function downloadSvg(svg: string, filename = \"puzzle.svg\") {\n  // create a blob from the SVG string\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n\n  // create a temporary object URL for the blob\n  const url = URL.createObjectURL(blob);\n\n  // create a hidden <a> element with the download attribute\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  a.hidden = true;\n\n  // click it\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n\n  // clean up\n  setTimeout(() => URL.revokeObjectURL(url), 100);\n}\n","// UI component that offers a SVG download when clicked\nimport m from 'mithril';\nimport { createSVG, downloadSvg } from '../utils/svg';\nimport type { PuzzleTopology } from '../geometry/types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\nexport interface DownloadPuzzleButtonAttrs extends m.Attributes {\n  /** Generated puzzle geometry */\n  puzzle: PuzzleTopology;\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Optional filename for the download */\n  filename?: string;\n}\n\nexport const DownloadPuzzleButton: m.Component<DownloadPuzzleButtonAttrs> = {\n  view: ({ attrs }) => {\n    return m('wa-button.download-svg', {\n      size: 'small',\n      onclick: () => {\n        // convert the puzzle geometry into a SVG string\n        const svg = createSVG(attrs.puzzle, attrs.width, attrs.height, attrs.color);\n        // offer it as a download\n        downloadSvg(svg, attrs.filename ?? 'puzzle.svg');\n      },\n    }, 'Download SVG');\n  },\n};\nexport default DownloadPuzzleButton;\n","// UI component to initiate and display geometry checks\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/badge/badge.js';\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\nimport '@awesome.me/webawesome/dist/components/progress-bar/progress-bar.js';\nimport '@awesome.me/webawesome/dist/components/tooltip/tooltip.js';\n\n// component CSS\nimport './GeometryCheckIndicator.css';\n\n// component attributes\nexport interface GeometryCheckIndicatorAttrs extends m.Attributes {\n  /** If true, the auto check box is checked */\n  autoCheck: boolean;\n  /** If present, represents the number of geometry problems found in the most recent check */\n  problems?: number;\n  /** If present represents the percent complete of the current geometry check */\n  progressPercent?: number;\n  /** Handler called when user clicks the check now button */\n  onCheckRequested?: () => void;\n  /** Called when the user toggles the auto check on or off */\n  onAutocheckChanged?: (autocheck: boolean) => void;\n};\n\n// component\nexport const GeometryCheckIndicator: m.Component<GeometryCheckIndicatorAttrs> = {\n  view: ({ attrs }) => {\n    const showProgress = attrs.progressPercent !== undefined && attrs.progressPercent < 100;\n    const showOKBadge = !showProgress && attrs.problems !== undefined && attrs.problems == 0;\n    const showProblemBadge = !showProgress && attrs.problems !== undefined && attrs.problems > 0;\n\n    return m('.geometry-check-indicator', [\n\n      // label\n      m('.label', \"Geometry Check:\"),\n\n      // run now button\n      m('wa-tooltip', { for: 'check-geometry-now'}, 'Check geometry now'),\n      m('wa-button#check-geometry-now', {\n        variant: 'neutral',\n        appearance: 'plain',\n        size: 'small',\n        disabled: showProgress,\n        onclick: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          attrs.onCheckRequested?.();\n        },\n      }, m('wa-icon', {\n        library: 'material',\n        name: 'editor_choice',\n        label: 'Check geometry now',\n      })),\n\n      // auto check checkbox\n      m('wa-tooltip', { for: 'auto-check-geometry' }, 'Check geometry after every change'),\n      m('wa-checkbox#auto-check-geometry', {\n        checked: attrs.autoCheck,\n        disabled: showProgress,\n        size: 'small',\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const checkbox = e.target as WaCheckbox;\n          attrs.onAutocheckChanged?.(checkbox.checked);\n        },\n      }, 'auto check'),\n\n      // progress indicator\n      showProgress && m('wa-progress-bar', {\n        label: 'Geometry check progress',\n        value: attrs.progressPercent ?? 0,\n      }),\n\n      // OK badge\n      showOKBadge && m('wa-badge', {\n        variant: 'success',\n        pill: true,\n      }, 'OK'),\n\n      // Problems badge\n      showProblemBadge && m('wa-badge', {\n        variant: 'danger',\n        pill: true,\n      }, `${attrs.problems} issue${attrs.problems === 1 ? '' : 's'}`),\n\n    ]);\n  },\n};\nexport default GeometryCheckIndicator;\n","// UI component that allows the user to select an image to upload when clicked\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\n// component attributes\nexport interface UploadImageAttrs extends m.Attributes {\n  /** Optional label for the button, default \"Upload Image\" */\n  label?: string;\n  /** If true, the button will be disabled */\n  disabled?: boolean;\n  /**\n   * Called when the user uploads an image. The caller is responsible for\n   * cleaning up the returned image URL.\n   */\n  onUpload: (imageUrl: string, filename: string, width: number, height: number) => void;\n};\n\n// utility to determine display dimensions that are the same aspect ratio\nfunction calculateDisplayDimensions(originalWidth: number, originalHeight: number, maxWidth = 800): {\n  width: number;\n  height: number;\n} {\n  if (originalWidth <= maxWidth) {\n    return {\n      width: originalWidth,\n      height: originalHeight,\n    };\n  }\n\n  const aspectRatio = originalHeight / originalWidth;\n  return {\n    width: maxWidth,\n    height: Math.round(maxWidth * aspectRatio),\n  };\n}\n\n// component\nexport const UploadImageButton: m.ClosureComponent<UploadImageAttrs> = () => {\n\n  // component state\n  const state = {\n    inputElement: undefined as HTMLInputElement | undefined,\n  };\n\n  return {\n\n    view: ({ attrs }) => {\n      return [\n\n        // button for display\n        m('wa-button.upload-button', {\n          size: 'small',\n          disabled: attrs.disabled === true,\n          onclick: () => {\n            if (state.inputElement) {\n              state.inputElement.click();\n            }\n          },\n        }, attrs.label ?? 'Upload Image'),\n\n        // hidden file input that does the work\n        m('input[type=file]', {\n          style: { display: 'none' },\n          accept: 'image/*',\n          oncreate: ({ dom }) => {\n            state.inputElement = dom as HTMLInputElement;\n          },\n          onchange: (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            if (state.inputElement) {\n              const file = state.inputElement.files?.[0];\n              if (file?.type.startsWith('image/')) {\n                createImageBitmap(file)\n                  .then((bitmap) => {\n                    // get the image dimensions, scaled to fit in the display area\n                    const { width, height } = calculateDisplayDimensions(bitmap.width, bitmap.height);\n                    const uploadUrl = URL.createObjectURL(file);\n                    bitmap.close();\n                    attrs.onUpload(uploadUrl, file.name, width, height);\n                  })\n                  .catch((err) => {\n                    console.error('could not create a bitmap image: ', err);\n                  });\n              }\n            }\n          },\n        }),\n      ];\n    },\n  };\n};\nexport default UploadImageButton;\n","// UI component to take boolean input\nimport m from 'mithril';\nimport type { BooleanUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\n\n// component attributes\nexport interface BooleanInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: BooleanUIControl;\n  /** Current value */\n  value: boolean;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: boolean) => void;\n}\n\n// component\nexport const BooleanInputControl: m.ClosureComponent<BooleanInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-checkbox.boolean-input', {\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        checked: attrs.value,\n        onchange: (e: Event) => {\n          const input = e.target as WaCheckbox;\n          const newValue = input.checked;\n          attrs.onChange(newValue);\n        },\n      }, attrs.config.label);\n    },\n  };\n};\nexport default BooleanInputControl;\n","// UI component to take a number input\nimport m from 'mithril';\nimport type { NumberUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface NumberInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: NumberUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const NumberInputControl: m.ClosureComponent<NumberInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.number-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"number\",\n        inputmode: \"numeric\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        onchange: (e: Event) => {\n          const input = e.target as WaInput;\n          const newValue = parseFloat(input.value ?? '');\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default NumberInputControl;\n","// UI component to take number input from a slider\nimport m from 'mithril';\nimport type { RangeUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// component attributes\nexport interface RangeInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: RangeUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const RangeInputControl: m.ClosureComponent<RangeInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-slider.range-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        step: attrs.config.step,\n        'with-tooltip': true,\n        onchange: (e: Event) => {\n          const input = e.target as WaSlider;\n          const newValue = input.value;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default RangeInputControl;\n","// UI component to take string input\nimport m from 'mithril';\nimport type { StringUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface StringInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: StringUIControl;\n  /** Current value */\n  value?: string;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: string | undefined) => void;\n}\n\n// component\nexport const StringInputControl: m.ClosureComponent<StringInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.string-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"text\",\n        inputmode: \"text\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        onchange: (e: Event) => {\n          const input = e.target as WaInput;\n          const newValue = input.value ?? '';\n          attrs.onChange(newValue.length > 0 ? newValue : undefined);\n        },\n      });\n    },\n  };\n};\nexport default StringInputControl;\n","// UI component that lets the user pick and configure a generator\nimport m from 'mithril';\nimport type { GeneratorRegistry, GeneratorConfig, GeneratorName } from '../geometry/generators/Generator';\nimport BooleanInputControl from './inputs/BooleanInputControl';\nimport NumberInputControl from './inputs/NumberInputControl';\nimport RangeInputControl from './inputs/RangeInputControl';\nimport StringInputControl from './inputs/StringInputControl';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/tab/tab.js';\nimport '@awesome.me/webawesome/dist/components/tab-group/tab-group.js';\nimport '@awesome.me/webawesome/dist/components/tab-panel/tab-panel.js';\nimport type { WaTabShowEvent } from '@awesome.me/webawesome';\n\n\n// include our CSS\nimport './GeneratorPicker.css';\n\n// component attributes\nexport interface GeneratorPickerAttrs<C extends GeneratorConfig = GeneratorConfig> extends m.Attributes {\n  /** Currently selected generator for this type */\n  generator: GeneratorName;\n  /** All the registered generators for this type */\n  registry: GeneratorRegistry<unknown>;\n  /** Current configuration for the selected generator */\n  config: C;\n  /** Called when the selected generator changes */\n  onGeneratorChange: (generatorName: string) => void;\n  /** Called when any config value changes */\n  onConfigChange: <K extends keyof C>(key: K, value: C[K]) => void;\n}\n\n// component\nexport const GeneratorPicker: m.ClosureComponent<GeneratorPickerAttrs> = () => {\n\n  // no component state\n\n  // component\n  return {\n\n    view: ({ attrs }) => {\n\n      const generators = attrs.registry.getAvailableGenerators();\n\n      return m(\".generator-picker\",\n        m('wa-tab-group', {\n          active: attrs.generator,\n          // custom Webawesome event triggered when a new tab panel is shown\n          'onwa-tab-show': (e: WaTabShowEvent) => {\n            const newSelected = e.detail.name;\n            if (attrs.generator !== newSelected) {\n              attrs.onGeneratorChange(newSelected);\n            }\n          },\n        }, [\n          ...generators.map((generator) => {\n            // get the UI metadata associated with this generator\n            const uiMetadata = attrs.registry.getUIMetadata(generator.name);\n\n            // tab contains name of generator\n            const tab = m('wa-tab', { panel: generator.name }, generator.displayName);\n\n            // matching panel contains controls specific to that generator\n            const panel = m('wa-tab-panel', { name: generator.name }, m('.controls',\n              [\n                // detailed description of the generator if available\n                uiMetadata?.description ? m('p', uiMetadata.description) : null,\n\n                // UI controls defined by the generator\n                ...uiMetadata?.controls.map((control) => {\n                  switch(control.type) {\n                  case \"range\":\n                    return m(RangeInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"boolean\":\n                    return m(BooleanInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) === true,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"number\":\n                    return m(NumberInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"string\":\n                    return m(StringInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as string | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  }\n                }) ?? [],\n\n                // no controls message when appropriate\n                (!uiMetadata?.description && uiMetadata?.controls.length == 0) ? m('p', 'No controls for this strategy.') : null,\n              ])\n            );\n            return [tab, panel];\n          }),\n        ])\n      );\n    },\n  };\n};\nexport default GeneratorPicker;\n","// UI component to let the user select an aspect ratio\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/option/option.js';\nimport '@awesome.me/webawesome/dist/components/select/select.js';\nimport WaSelect from '@awesome.me/webawesome/dist/components/select/select.js';\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// this component's CSS\nimport './AspectRatioPicker.css';\n\n// component attributes\nexport interface AspectRatioPickerAttr extends m.Attributes {\n  /** Current ratio */\n  ratio: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current ratio */\n  onChange: (ratio: number) => void;\n}\n\n// data\nconst commonAspectRatios: [string, string, number][] = [\n  [\"Square\",           \"1:1\",    1],\n\n  // --- Landscape ---\n  [\"Classic Photo\",    \"5:4\",    5/4],\n  [\"Standard Photo\",   \"4:3\",    4/3],\n  [\"35mm/DSLR\",        \"3:2\",    3/2],\n  [\"Widescreen\",       \"16:9\",   16/9],\n  [\"UltraWide\",        \"21:9\",   21/9],\n  [\"Panorama\",         \"2:1\",    2/1],\n\n  // --- Portrait ---\n  [\"Instagram Portrait\",       \"4:5\",    4/5],\n  [\"Classic Portrait\",         \"3:4\",    3/4],\n  [\"DSLR Portrait\",            \"2:3\",    2/3],\n  [\"Phone Portrait\",           \"9:16\",   9/16],\n  [\"Tall Poster\",              \"9:21\",   9/21],\n  [\"Tall Panorama\",            \"1:2\",    1/2],\n];\n\n// component\nexport const AspectRatioPicker: m.Component<AspectRatioPickerAttr> = {\n  view: ({ attrs }) => {\n\n    // Determine if the current ratio is a custom value (not in our predefined list)\n    const isCustom = !commonAspectRatios.some(([, , value]) => value === attrs.ratio);\n\n    // Generate the list of <wa-option> elements\n    const selectOptions = commonAspectRatios.map(([name, ratioStr, value]) =>\n      m('wa-option', {\n        value: String(value), // select values are strings\n      }, `${name} [${ratioStr}]`)\n    );\n\n    // If the ratio is custom, add a temporary \"Custom\" option to the start of the list\n    if (isCustom) {\n      selectOptions.unshift(m('wa-option', { value: 'custom' }, 'Custom'));\n    }\n\n    return m('.aspect-ratio-picker', [\n\n      // drop down with common ratios\n      m('wa-select', {\n        label: 'Aspect Ratio',\n        size: 'small',\n        disabled: attrs.disabled,\n        value: isCustom ? 'custom' : String(attrs.ratio),\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const select = e.target as WaSelect;\n          const selectedValue = select.value as string;\n\n          // 'custom' is a placeholder, so we only trigger onChange for actual numeric values.\n          if (selectedValue && selectedValue !== 'custom') {\n            attrs.onChange(Number(selectedValue));\n          }\n        },\n      }, selectOptions),\n\n      // slider for any ratio\n      m('wa-slider', {\n        // allow ratios from 1:4 (0.25) to 4:1 (4.0)\n        min: 0.25,\n        max: 4,\n        step: 0.01,\n        'with-tooltip': true,\n        size: 'small',\n        disabled: attrs.disabled,\n        value: attrs.ratio,\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const range = e.target as WaSlider;\n          attrs.onChange(range.value);\n        },\n      }),\n    ]);\n  },\n};\nexport default AspectRatioPicker;\n","// UI component to let the user select a color\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\nimport WaColorPicker from '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\n\n// this component's CSS\nimport './ColorPicker.css';\n\n// component attributes\nexport interface ColorPickerAttrs extends m.Attributes {\n  /** Label to display next to the color picker */\n  label: string;\n  /** Current color */\n  color: string;\n  /** Optional size of picker trigger area */\n  size?: \"small\" | \"medium\" | \"large\";\n  /** Called when the user changes the color */\n  onUpdate: (newColor: string) => void;\n};\n\n// component with no state\nexport const ColorPicker: m.Component<ColorPickerAttrs> = {\n  view: ({ attrs }) => {\n    return m('wa-color-picker', {\n      label: attrs.label,\n      value: attrs.color,\n      size: attrs.size ?? \"medium\",\n      format: 'rgb',\n      onchange: (e: Event & MithrilViewEvent) => {\n        e.redraw = false;\n        const input = e.target as WaColorPicker;\n        attrs.onUpdate(input.value ?? '');\n      },\n    });\n  },\n};\nexport default ColorPicker;\n","// UI component to let the user select a border shape\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/option/option.js';\nimport '@awesome.me/webawesome/dist/components/select/select.js';\nimport WaSelect from '@awesome.me/webawesome/dist/components/select/select.js';\n\n// component attributes\nexport interface BorderShapePickerAttr extends m.Attributes {\n  /** Current border shape */\n  shape: BorderShapeType;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the border shape */\n  onChange: (shape: BorderShapeType) => void;\n}\n\n// Available border shape types\nexport type BorderShapeType = 'rectangle' | 'circle' | 'ellipse' | 'rounded-rect';\n\n// data\nconst borderShapes: [BorderShapeType, string][] = [\n  ['rectangle', 'Rectangle'],\n  ['circle', 'Circle'],\n  ['ellipse', 'Ellipse'],\n  ['rounded-rect', 'Rounded Rectangle'],\n];\n\n// component\nexport const BorderShapePicker: m.Component<BorderShapePickerAttr> = {\n  view: ({ attrs }) => {\n\n    // Generate the list of <wa-option> elements\n    const selectOptions = borderShapes.map(([value, name]) =>\n      m('wa-option', {\n        value: value,\n      }, name)\n    );\n\n    return m('wa-select', {\n      label: 'Border Shape',\n      size: 'small',\n      disabled: attrs.disabled,\n      value: attrs.shape,\n      onchange: (e: Event & MithrilViewEvent) => {\n        e.redraw = false; // parent component triggers redraws as necessary\n        const select = e.target as WaSelect;\n        const selectedValue = select.value as BorderShapeType;\n\n        if (selectedValue) {\n          attrs.onChange(selectedValue);\n        }\n      },\n    }, selectOptions);\n  },\n};\nexport default BorderShapePicker;\n","\"use strict\";\n\nfunction tinyNDArrayOfInteger (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        dimension;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    return {\n        stride: stride,\n        data: new Uint32Array(totalLength)\n    };\n}\n\nfunction tinyNDArrayOfArray (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        data = [],\n        dimension, index;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    for (index = 0; index < totalLength; index++) {\n        data.push([]);\n    }\n\n    return {\n        stride: stride,\n        data: data\n    };\n}\n\nmodule.exports = {\n    integer: tinyNDArrayOfInteger,\n    array: tinyNDArrayOfArray\n};","\"use strict\";\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n","module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n","\"use strict\";\n\nvar moore = require('moore');\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    // filter out neighbours who are too far from the center cell\n    // the impact of this, performance wise, is surprisingly small, even in 3d and higher dimensions\n    neighbourhood = neighbourhood.filter(function (n) {\n        var dist = 0;\n\n        for (var d = 0; d < dimensionNumber; d++) {\n            dist += Math.pow(Math.max(0, Math.abs(n[d]) - 1), 2);\n        }\n\n        return dist < dimensionNumber; // cellSize = Math.sqrt(this.dimension)\n    });\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0,\n            dimension;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n}\n\nvar neighbourhoodCache = {};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhoodMemoized (dimensionNumber) {\n    if (!neighbourhoodCache[dimensionNumber]) {\n        neighbourhoodCache[dimensionNumber] = getNeighbourhood(dimensionNumber);\n    }\n\n    return neighbourhoodCache[dimensionNumber];\n}\n\nmodule.exports = getNeighbourhoodMemoized;","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').integer,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nfunction squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n}\n\n/**\n * FixedDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction FixedDensityPDS (options, rng) {\n    if (typeof options.distanceFunction === 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.squaredMinDistance = this.minDistance * this.minDistance;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.minDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints\n}\n\nFixedDensityPDS.prototype.shape = null;\nFixedDensityPDS.prototype.dimension = null;\nFixedDensityPDS.prototype.minDistance = null;\nFixedDensityPDS.prototype.maxDistance = null;\nFixedDensityPDS.prototype.minDistancePlusEpsilon = null;\nFixedDensityPDS.prototype.squaredMinDistance = null;\nFixedDensityPDS.prototype.deltaDistance = null;\nFixedDensityPDS.prototype.cellSize = null;\nFixedDensityPDS.prototype.maxTries = null;\nFixedDensityPDS.prototype.rng = null;\nFixedDensityPDS.prototype.neighbourhood = null;\n\nFixedDensityPDS.prototype.currentPoint = null;\nFixedDensityPDS.prototype.processList = null;\nFixedDensityPDS.prototype.samplePoints = null;\nFixedDensityPDS.prototype.gridShape = null;\nFixedDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nFixedDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nFixedDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nFixedDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nFixedDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nFixedDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will always throw an error.\n */\nFixedDensityPDS.prototype.getAllPointsWithDistance = function () {\n    throw new Error('PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation');\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nFixedDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = FixedDensityPDS;\n","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').array,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Euclidean distance\n */\nfunction euclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return Math.sqrt(result);\n}\n\n/**\n * VariableDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function} options.distanceFunction Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {float} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} rng RNG function, defaults to Math.random\n * @constructor\n */\nfunction VariableDensityPDS (options, rng) {\n    if (typeof options.distanceFunction !== 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n    this.distanceFunction = options.distanceFunction;\n    this.bias = Math.max(0, Math.min(1, options.bias || 0));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.maxDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.currentDistance = 0;\n    this.processList = [];\n    this.samplePoints = [];\n    this.sampleDistance = []; // used to store the distance for a given point\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints and sampleDistance\n}\n\nVariableDensityPDS.prototype.shape = null;\nVariableDensityPDS.prototype.dimension = null;\nVariableDensityPDS.prototype.minDistance = null;\nVariableDensityPDS.prototype.maxDistance = null;\nVariableDensityPDS.prototype.minDistancePlusEpsilon = null;\nVariableDensityPDS.prototype.deltaDistance = null;\nVariableDensityPDS.prototype.cellSize = null;\nVariableDensityPDS.prototype.maxTries = null;\nVariableDensityPDS.prototype.distanceFunction = null;\nVariableDensityPDS.prototype.bias = null;\nVariableDensityPDS.prototype.rng = null;\nVariableDensityPDS.prototype.neighbourhood = null;\n\nVariableDensityPDS.prototype.currentPoint = null;\nVariableDensityPDS.prototype.currentDistance = null;\nVariableDensityPDS.prototype.processList = null;\nVariableDensityPDS.prototype.samplePoints = null;\nVariableDensityPDS.prototype.sampleDistance = null;\nVariableDensityPDS.prototype.gridShape = null;\nVariableDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nVariableDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nVariableDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nVariableDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        pointIndex = this.samplePoints.length,\n        dimension;\n\n    this.processList.push(pointIndex);\n    this.samplePoints.push(point);\n    this.sampleDistance.push(this.distanceFunction(point));\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex].push(pointIndex); // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nVariableDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint,\n        existingPointDistance;\n\n    var pointDistance = this.distanceFunction(point);\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex].length > 0) {\n            for (var i = 0; i < this.grid.data[internalArrayIndex].length; i++) {\n                existingPoint = this.samplePoints[this.grid.data[internalArrayIndex][i]];\n                existingPointDistance = this.sampleDistance[this.grid.data[internalArrayIndex][i]];\n\n                var minDistance = Math.min(existingPointDistance, pointDistance);\n                var maxDistance = Math.max(existingPointDistance, pointDistance);\n                var dist = minDistance + (maxDistance - minDistance) * this.bias;\n\n                if (euclideanDistance(point, existingPoint) < this.minDistance + this.deltaDistance * dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nVariableDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        currentDistance,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            var sampleIndex = this.processList.shift();\n            this.currentPoint = this.samplePoints[sampleIndex];\n            this.currentDistance = this.sampleDistance[sampleIndex];\n        }\n\n        currentPoint = this.currentPoint;\n        currentDistance = this.currentDistance;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * (currentDistance + (1 - currentDistance) * this.bias);\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @returns {Array[]} Sample points with their distance function result\n */\nVariableDensityPDS.prototype.getAllPointsWithDistance = function () {\n    var result = new Array(this.samplePoints.length),\n        i = 0,\n        dimension = 0,\n        point;\n\n    for (i = 0; i < this.samplePoints.length; i++) {\n        point = new Array(this.dimension + 1);\n\n        for (dimension = 0; dimension < this.dimension; dimension++) {\n            point[dimension] = this.samplePoints[i][dimension];\n        }\n\n        point[this.dimension] = this.sampleDistance[i];\n\n        result[i] = point;\n    }\n\n    return result;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nVariableDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = [];\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = VariableDensityPDS;\n","\"use strict\";\n\nvar FixedDensityPDS = require('./implementations/fixed-density');\nvar VariableDensityPDS = require('./implementations/variable-density');\n\n/**\n * PoissonDiskSampling constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [options.distanceFunction] Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {function|null} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction PoissonDiskSampling (options, rng) {\n    this.shape = options.shape;\n\n    if (typeof options.distanceFunction === 'function') {\n        this.implementation = new VariableDensityPDS(options, rng);\n    } else {\n        this.implementation = new FixedDensityPDS(options, rng);\n    }\n}\n\nPoissonDiskSampling.prototype.implementation = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    return this.implementation.addRandomPoint();\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    return this.implementation.addPoint(point);\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    return this.implementation.next();\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    return this.implementation.fill();\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.implementation.getAllPoints();\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will throw an error if a distance function was not provided to the constructor.\n * @returns {Array[]} Sample points with their distance function result\n */\nPoissonDiskSampling.prototype.getAllPointsWithDistance = function () {\n    return this.implementation.getAllPointsWithDistance();\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    this.implementation.reset();\n};\n\nmodule.exports = PoissonDiskSampling;\n","import PoissonDiskSampling from 'poisson-disk-sampling';\nimport type { Vec2, PathCommand } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\nimport { isPointInBoundary } from '../../utils';\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype PoissonPointGeneratorName = \"PoissonPointGenerator\";\nexport const Name: PoissonPointGeneratorName = \"PoissonPointGenerator\";\n\n/** Required config for this generator */\nexport interface PoissonPointGeneratorConfig extends GeneratorConfig {\n  name: PoissonPointGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const PoissonPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Poisson\",\n  description: \"Generate seed points using Poisson disk sampling. \" +\n    \"The algorithm produces points that are tightly-packed, but no closer to \" +\n    \"each other than a specified minimum distance (the piece size), resulting \" +\n    \"in a natural, organic look.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A point generator that uses Poisson disk sampling to create a more organic\n * distribution of random points. `pieceSize` is interpreted as the minimum\n * distance between generated points.\n */\nexport const PoissonPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, _config: PoissonPointGeneratorConfig) => {\n  const PoissonPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random, border } = runtimeOpts;\n\n      // generate points randomly in a Poisson disk sampling within rectangular bounds\n      const poisson = new PoissonDiskSampling(\n        {\n          shape: [width, height], // clamps generated points within bounds\n          minDistance: pieceSize,\n          tries: 20,\n        },\n        random\n      );\n\n      // have to cast because @types/PoissonDiskSampling is not correct for fill()\n      const allPoints = poisson.fill() as unknown as Vec2[];\n\n      // Filter points to only include those inside the custom boundary\n      const filteredPoints = allPoints.filter((point) => isPointInBoundary(point, border));\n\n      return filteredPoints;\n    },\n  };\n  return PoissonPointGenerator;\n};\nexport default PoissonPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, PoissonPointGeneratorFactory, PoissonPointUIMetadata);\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const {delaunay: {points, hull, triangles}, vectors} = this;\n    let bx, by; // lazily computed barycenter of the hull\n\n    // Compute circumcenters.\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const ex = x3 - x1;\n      const ey = y3 - y1;\n      const ab = (dx * ey - dy * ex) * 2;\n\n      if (Math.abs(ab) < 1e-9) {\n        // For a degenerate triangle, the circumcenter is at the infinity, in a\n        // direction orthogonal to the halfedge and away from the “center” of\n        // the diagram <bx, by>, defined as the hull’s barycenter.\n        if (bx === undefined) {\n          bx = by = 0;\n          for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];\n          bx /= hull.length, by /= hull.length;\n        }\n        const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);\n        x = (x1 + x3) / 2 - a * ey;\n        y = (y1 + y3) / 2 + a * ex;\n      } else {\n        const d = 1 / ab;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x = x1 + (ey * bl - dy * cl) * d;\n        y = y1 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x;\n      circumcenters[j + 1] = y;\n    }\n\n    // Compute exterior cell rays.\n    let h = hull[hull.length - 1];\n    let p0, p1 = h * 4;\n    let x0, x1 = points[2 * h];\n    let y0, y1 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull.length; ++i) {\n      h = hull[i];\n      p0 = p1, x0 = x1, y0 = y1;\n      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;\n    if (hull.length <= 1) return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull[hull.length - 1];\n    for (let i = 0; i < hull.length; ++i) {\n      h0 = h1, h1 = hull[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = h0 * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null || !points.length) return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;\n    for (let i = 2; i < n; i += 2) {\n      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])\n        context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) cell.index = i, yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci) for (const j of this.delaunay.neighbors(i)) {\n      const cj = this._clip(j);\n      // find the common edge\n      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n          if (ci[ai] === cj[aj]\n              && ci[ai + 1] === cj[aj + 1]\n              && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]\n              && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {\n            yield j;\n            break loop;\n          }\n        }\n      }\n    }\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    // degenerate case (1 valid point: return the box)\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return this._simplify(V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points));\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    // for more robustness, always consider the segment in the same order\n    const flip = c0 < c1;\n    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];\n    while (true) {\n      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n      // undefined, the conditional statement will be executed.\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n  _simplify(P) {\n    if (P && P.length > 4) {\n      for (let i = 0; i < P.length; i+= 2) {\n        const j = (i + 2) % P.length, k = (i + 4) % P.length;\n        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n          P.splice(j, 2), i -= 2;\n        }\n      }\n      if (!P.length) P = null;\n    }\n    return P;\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n","/**\n * Reusable helper functions for piece generators that work with custom boundaries.\n *\n * These utilities extract common patterns from piece generators to avoid code\n * duplication and ensure consistent behavior across different generation strategies.\n */\n\nimport type { PathCommand, Vec2, Piece, PieceID, PuzzleTopology } from '../../types';\nimport {\n  flattenBoundary,\n  isPointInBoundary,\n  clipPolygonAgainstBoundary,\n  createHalfEdgeLoop,\n  polygonBounds,\n} from '../../utils';\n\n/**\n * Pre-computed boundary data that can be reused across multiple operations.\n * Computing the flattened polygon is expensive, so we cache it at factory creation time.\n */\nexport interface BoundaryContext {\n  /** The original boundary path */\n  originalBorder: PathCommand[];\n  /** The boundary converted to a simple polygon for clipping operations */\n  flattenedPolygon: Vec2[];\n}\n\n/**\n * Creates a boundary context from a path command array.\n * This should be called once when the generator factory is created.\n *\n * @param border - The boundary path to process\n * @returns A boundary context containing both original and flattened representations\n */\nexport function createBoundaryContext(border: PathCommand[]): BoundaryContext {\n  return {\n    originalBorder: border,\n    flattenedPolygon: flattenBoundary(border)[0],\n  };\n}\n\n/**\n * Calculates the centroid (geometric center) of a polygon.\n *\n * @param vertices - The vertices of the polygon\n * @returns The centroid as a 2D point\n */\nexport function calculateCentroid(vertices: Vec2[]): Vec2 {\n  if (vertices.length === 0) {\n    return [0, 0];\n  }\n\n  const sum = vertices.reduce(\n    (acc, v) => [acc[0] + v[0], acc[1] + v[1]],\n    [0, 0]\n  );\n  return [sum[0] / vertices.length, sum[1] / vertices.length];\n}\n\n/**\n * Creates a puzzle piece from a polygon by constructing the piece object,\n * creating its half-edge loop, and adding it to the topology.\n *\n * @param pieceId - The unique identifier for this piece\n * @param vertices - The vertices of the polygon defining the piece boundary\n * @param topology - The puzzle topology to add the piece to (mutated in place)\n * @returns The created piece object\n */\nexport function createPieceFromPolygon(\n  pieceId: PieceID,\n  vertices: Vec2[],\n  topology: PuzzleTopology\n): Piece {\n  const piece: Piece = {\n    id: pieceId,\n    site: calculateCentroid(vertices),\n    halfEdge: -1, // Will be set by createHalfEdgeLoop\n    bounds: polygonBounds(vertices),\n  };\n\n  // Create the half-edge loop for the piece's vertices\n  const newHalfEdges = createHalfEdgeLoop(vertices, pieceId, topology);\n  if (newHalfEdges.length > 0) {\n    piece.halfEdge = newHalfEdges[0].id;\n  }\n\n  return piece;\n}\n\n/**\n * Clips a cell polygon against the puzzle boundary.\n *\n * This function determines whether a cell is fully inside, fully outside, or\n * partially overlapping the boundary, and returns the appropriate clipped polygon.\n *\n * @param cellPolygon - The polygon to clip (e.g., a grid cell or Voronoi cell)\n * @param boundaryContext - Pre-computed boundary data\n * @returns The clipped polygon vertices, or null if the cell is completely outside\n */\nexport function clipCellToBoundary(\n  cellPolygon: Vec2[],\n  boundaryContext: BoundaryContext\n): Vec2[] | null {\n  // Test how many corners of the cell are inside the boundary\n  const cornerInside = cellPolygon.map((corner) =>\n    isPointInBoundary(corner, boundaryContext.originalBorder)\n  );\n  const insideCount = cornerInside.filter(Boolean).length;\n\n  if (insideCount === 0) {\n    // Cell is completely outside the boundary\n    return null;\n  }\n\n  if (insideCount === cellPolygon.length) {\n    // Cell is fully inside the boundary, no clipping needed\n    return cellPolygon;\n  }\n\n  // Partial overlap - clip the cell against the boundary\n  const clipped = clipPolygonAgainstBoundary(\n    cellPolygon,\n    boundaryContext.flattenedPolygon\n  );\n\n  return clipped?.[0] ?? null;\n}\n","import { Delaunay } from 'd3-delaunay';\nimport { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  PathCommand,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { linkAndCreateEdges } from '../../utils';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\nimport {\n  createBoundaryContext,\n  createPieceFromPolygon,\n  clipCellToBoundary,\n  type BoundaryContext,\n} from \"./PieceGeneratorHelpers\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\nexport const Name: VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\n\n/** Required config for this generator */\nexport interface VoronoiPieceGeneratorConfig extends GeneratorConfig {\n  name: VoronoiPieceGeneratorName;\n  // no special config\n}\n\n/** UI metadata needed for this generator */\nexport const VoronoiPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Voronoi\",\n  description: \"Construct pieces by building a Voronoi diagram from the seed points. \" +\n    \"Each piece consists of all area of the plane closer to its seed point than \" +\n    \"any other seed point. In practice, this creates irregular polygons with 3-8 \" +\n    \"sides.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * Creates a consistent string key for a point, handling floating point inaccuracies.\n * @param p The point.\n * @returns A string key.\n */\nfunction pointToKey(p: Vec2): string {\n  return `${p[0].toPrecision(7)},${p[1].toPrecision(7)}`;\n}\n\n/**\n * Checks if a point is near the boundary polygon (within a small tolerance).\n * Used to determine if an edge lies on the puzzle's outer boundary.\n * @param point The point to check.\n * @param boundaryContext The boundary context with flattened polygon.\n * @returns True if the point is close to any edge of the boundary polygon.\n */\nfunction isPointNearBoundary(point: Vec2, boundaryContext: BoundaryContext): boolean {\n  const tolerance = 1e-3; // Small tolerance for floating point comparisons\n  const polygon = boundaryContext.flattenedPolygon;\n\n  // Check if point is close to any edge of the boundary polygon\n  for (let i = 0; i < polygon.length; i++) {\n    const p1 = polygon[i];\n    const p2 = polygon[(i + 1) % polygon.length];\n\n    // Calculate distance from point to line segment\n    const dist = distanceToSegment(point, p1, p2);\n    if (dist < tolerance) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Calculates the minimum distance from a point to a line segment.\n * @param point The point.\n * @param segStart Start of the line segment.\n * @param segEnd End of the line segment.\n * @returns The minimum distance.\n */\nfunction distanceToSegment(point: Vec2, segStart: Vec2, segEnd: Vec2): number {\n  const [px, py] = point;\n  const [x1, y1] = segStart;\n  const [x2, y2] = segEnd;\n\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lengthSq = dx * dx + dy * dy;\n\n  if (lengthSq === 0) {\n    // Degenerate segment (point)\n    return Math.hypot(px - x1, py - y1);\n  }\n\n  // Project point onto line, clamped to segment\n  let t = ((px - x1) * dx + (py - y1) * dy) / lengthSq;\n  t = Math.max(0, Math.min(1, t));\n\n  const projX = x1 + t * dx;\n  const projY = y1 + t * dy;\n\n  return Math.hypot(px - projX, py - projY);\n}\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const VoronoiPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (border: PathCommand[], bounds: { width: number; height: number }, _config: VoronoiPieceGeneratorConfig) => {\n  const { width, height } = bounds;\n\n  // Pre-compute boundary data once for reuse across all cells\n  const boundaryContext: BoundaryContext = createBoundaryContext(border);\n\n  const VoronoiPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param points The seed points for the centers of the puzzle pieces.\n     * @param _runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(points: Vec2[], runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n      const { border } = runtimeOpts;\n\n      // Note: Lloyd's relaxation could be performed here to create more uniform\n      // piece shapes. This would involve creating the Voronoi diagram, calculating\n      // the centroid of each cell, moving the input point to that centroid, and\n      // repeating for a number of iterations before proceeding.\n\n      console.log(`VoronoiPieceGenerator using dimensions ${width}x${height}`);\n      // 1. Generate Voronoi diagram from points, clipped to the rectangular bounds.\n      const delaunay = Delaunay.from(points);\n      const voronoi = delaunay.voronoi([0, 0, width, height]);\n\n      // 2. Initialize data structures for the topology.\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n        borderPath: border,\n      };\n\n      // Map to find twin half-edges\n      const halfEdgeTwinMap = new Map<string, HalfEdgeID>();\n\n      // 3. For each Voronoi cell, clip it against the puzzle boundary and create a piece\n      let pieceIdCounter = 0;\n      for (let i = 0; i < points.length; i++) {\n        const site = points[i];\n        const cellPolygon = voronoi.cellPolygon(i);\n\n        if (!cellPolygon) continue;\n\n        // Clip the Voronoi cell against the custom puzzle boundary\n        const clippedVertices = clipCellToBoundary(cellPolygon, boundaryContext);\n\n        if (!clippedVertices) {\n          // Cell is completely outside the boundary, skip it\n          continue;\n        }\n\n        // Create the piece from the (possibly clipped) polygon\n        const pieceId = pieceIdCounter++;\n        const piece = createPieceFromPolygon(pieceId, clippedVertices, topology);\n\n        // Override the site to use the original seed point instead of centroid\n        piece.site = site;\n\n        topology.pieces.set(pieceId, piece);\n\n        // Collect the half-edges for this piece to link them with neighbors\n        const pieceHalfEdges: HalfEdge[] = [];\n        let currentHeId = piece.halfEdge;\n        if (currentHeId !== -1) {\n          const startHeId = currentHeId;\n          do {\n            const he = topology.halfEdges.get(currentHeId)!;\n            pieceHalfEdges.push(he);\n            currentHeId = he.next;\n          } while (currentHeId !== startHeId);\n        }\n\n        // Link edges to neighbors or mark them as part of the boundary\n        // For Voronoi, we determine boundary edges by checking if both vertices\n        // lie on the puzzle's outer boundary\n        linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n          // An edge is on the puzzle boundary if it was created by clipping\n          // We can detect this by checking if the edge lies on the rectangular bounds\n          // (for rectangular puzzles) or by checking against the boundary polygon\n\n          // For now, use a simple heuristic: if the edge has no twin after all pieces\n          // are processed, it's a boundary edge. This is handled by linkAndCreateEdges.\n\n          // Since we need to know if it's on the *custom* boundary (not just the rect),\n          // we check if both points are on the flattened boundary polygon.\n          // This is a simplified check - a full implementation would verify the edge\n          // lies on the boundary path itself.\n          const onBoundary = isPointNearBoundary(p1, boundaryContext) &&\n            isPointNearBoundary(p2, boundaryContext);\n          return onBoundary;\n        });\n      }\n\n      // 4. Final step: Collect all unique vertices.\n      const vertexSet = new Map<string, Vec2>();\n      for (const he of topology.halfEdges.values()) {\n        const key = pointToKey(he.origin);\n        if (!vertexSet.has(key)) {\n          vertexSet.set(key, he.origin);\n        }\n      }\n      topology.vertices = Array.from(vertexSet.values());\n\n      return topology;\n    },\n  };\n  return VoronoiPieceGenerator;\n};\nexport default VoronoiPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, VoronoiPieceGeneratorFactory, VoronoiPieceGeneratorUIMetadata);\n","import type { PuzzleTopology, Edge, PathCommand, RandomFn, TabPlacement } from \"../../types\";\nimport type { TabPlacementStrategy, TabPlacementStrategyRuntimeOptions } from \"./TabPlacementStrategy\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabPlacementStrategyRegistry } from \"../Generator\";\n\n// Name of this strategy, uniquely identifies from all other TabPlacementStrategies\ntype SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\nexport const Name: SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\n\n/** Custom config for this strategy */\nexport interface SimpleTabPlacementStrategyConfig extends GeneratorConfig {\n  name: SimpleTabPlacementStrategyName;\n  /** The default size of the tab as a fraction (0-1) of the edge length. */\n  tabSize?: number;\n  /** Edges shorter than this value will not have a tab. */\n  minEdgeLength?: number;\n  /** The maximum absolute width that a tab can have. Wide tabs will get clamped to this value. */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this strategy */\nexport const SimpleTabPlacementStrategyUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Simple\",\n  description: \"Creates a single tab in the center of each edge with a random orientation.\",\n  sortHint: 1,\n  // these have to match the config above\n  controls: [\n    {\n      type: 'range',\n      name: 'tabSize',\n      label: 'Tab Size',\n      optional: true,\n      min: 0.01,\n      max: 1.0,\n      step: 0.01,\n      defaultValue: 0.5,\n      helpText: 'The width of the tab as a fraction of the edge length',\n    },\n    {\n      type: 'number',\n      name: 'minEdgeLength',\n      label: 'Minimum Edge Length',\n      optional: true,\n      defaultValue: 15,\n      helpText: 'Edges shorter than this value will not have a tab',\n    },\n    {\n      type: 'number',\n      name: 'maxTabSize',\n      label: 'Maximum Tab Size',\n      helpText: 'Maximum width of a generated tab',\n    },\n  ],\n};\n\n// helper function to do the actual placement work\nfunction placeTabOnEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  config: { tabSize: number, minEdgeLength: number, maxTabSize?: number },\n  random: RandomFn\n): void {\n  // clear any existing tabs in case we're re-evaluating\n  edge.tabs = undefined;\n\n  // we only place on internal edges\n  const isInternal = edge.heRight !== -1;\n  if (!isInternal) { return; }\n\n  const he1 = topology.halfEdges.get(edge.heLeft);\n  const he2 = topology.halfEdges.get(edge.heRight);\n  if (!he1 || !he2) return;\n\n  const p1 = he1.origin;\n  const p2 = he2.origin;\n  const edgeLength = Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);\n\n  // add a tab, if the edge is long enough\n  if (edgeLength >= config.minEdgeLength) {\n    let tabSize = config.tabSize;\n\n    // clamp tab width if requested\n    if (config.maxTabSize && (edgeLength * tabSize) > config.maxTabSize) {\n      tabSize = config.maxTabSize / edgeLength;\n    }\n\n    const tab: TabPlacement = {\n      position: 0.5, // center of the edge\n      size: tabSize,\n      convex: random() > 0.5, // tab is \"innie\" or \"outie\"\n    };\n    edge.tabs = [tab];\n  }\n}\n\n/**\n * A straightforward tab placement strategy that adds a single tab to the\n * center of each internal edge of the puzzle.\n */\nexport const SimpleTabPlacementStrategyFactory: GeneratorFactory<TabPlacementStrategy> = (\n  _border: PathCommand[],\n  _bounds: { width: number; height: number },\n  config: SimpleTabPlacementStrategyConfig,\n): TabPlacementStrategy => {\n  const { tabSize = 0.5, minEdgeLength = 0, maxTabSize } = config;\n  const placementConfig = { tabSize, minEdgeLength, maxTabSize };\n\n  return {\n    placeTabs(runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of topology.edges.values()) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n    updateTabPlacements(edges: Edge[], runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of edges) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n  };\n};\nexport default SimpleTabPlacementStrategyFactory;\n\n// register the strategy\nTabPlacementStrategyRegistry.register(Name, SimpleTabPlacementStrategyFactory, SimpleTabPlacementStrategyUIMetadata);","import type { TabGenerator } from \"./TabGenerator\";\nimport type { CurveTo, EdgeSegment, PathCommand, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\nexport const Name: TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TraditionalTabGeneratorConfig extends GeneratorConfig {\n  name: TraditionalTabGeneratorName;\n  /** Amount of randomness to apply to each tab (0-100) */\n  jitter?: number;\n  /** The height of the tab's nub as a fraction of its width. Default: 50% */\n  heightToWidthRatio?: number;\n  /** If provided, the width of a tab's features will be clamped to this value */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TraditionalTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Traditional\",\n  description: \"Creates a traditional rounded tab for each (internal) piece edge.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      defaultValue: 8,\n      min: 0,\n      max: 100,\n      step: 1,\n      helpText: 'Adds randomness to the tab shape. 0 means completely uniform tabs',\n    },\n    {\n      type: 'range',\n      name: 'heightToWidthRatio',\n      label: 'Tab Height',\n      defaultValue: 50,\n      min: 5,\n      max: 100,\n      step: 5,\n      helpText: 'The height of the tab as a percent of its width',\n    },\n  ],\n};\n\n\n/**\n * Build a puzzle nub using three cubic Bézier segments that replace a straight\n * edge AB. Curve 1 is a gentle S-curve up to the nub edge, Curve 2 is the arch\n * across the top of the nub, Curve 3 is the mirror of curve 1 back to the baseline.\n *   - the edge is parameterised from 0.0 → 1.0 along its length;\n *   - the nub is centred roughly at s = 0.5 and spans ≈ 4 · t of the edge;\n *   - the peak of the nub reaches ± 3 · t away from the baseline.\n *\n * @param a         Edge start point.\n * @param b         Edge end point.\n * @param jitterPct “Jitter” slider value (0–100 %).\n * @param heightToWidthRatio Ratio of tab height to segment length\n * @param random    Seeded RNG so callers can reproduce shapes.\n * @param inward    If true the nub is an **indent**; otherwise a **bump**.\n * @param maxTabSize Optional maximum absolute width for the tab.\n *\n * @returns Three cubic Bézier segments, ordered from a→b.\n */\nfunction createTraditionalTab(\n  a: Vec2,\n  b: Vec2,\n  jitterPct: number,\n  heightToWidthRatio: number,\n  random: RandomFn,\n  inward = false\n): EdgeSegment[] {\n  /* --- 1.  Work in a local (u,v) coordinate frame ---------------------- */\n\n  const ux = b[0] - a[0];\n  const uy = b[1] - a[1];\n  const len = Math.hypot(ux, uy);\n  if (len === 0) {\n    console.warn(\"Edge has zero length\");\n    return [];\n  }\n\n  // Basis vectors:  u along the edge, v = +90° (right-hand rule).\n  const u: Vec2 = [ux / len, uy / len];\n  const v: Vec2 = [-u[1], u[0]]; // perpendicular\n\n  /** Convert (s,w) → world coordinates.  Both s and w are normalised by len. */\n  const P = (s: number, w: number): Vec2 => [\n    a[0] + (u[0] * s + v[0] * w) * len,\n    a[1] + (u[1] * s + v[1] * w) * len,\n  ];\n\n  /* --- 2.  Derive the five random perturbations a…e -------------------- */\n\n  const j = jitterPct / 100;\n  const rng = () => (random() * 2 - 1) * j; // uniform(-j, +j)\n\n  const A = rng(); // entry handle offset\n  const B = rng(); // l-shift of whole nub\n  const C = rng(); // vertical wobble of apex\n  const D = rng(); // anti-sym tweak\n  const E = rng(); // exit handle offset\n\n  /* --- 3.  Fixed shape constants -------------------------------------- */\n\n  // 't' is a fixed constant that defines the tab's internal proportions.\n  // A value of 0.2 means the central arch of the tab will span 80% (4 * 0.2)\n  const t = 0.1625; // 65%\n\n  // if (maxTabSize) {\n  //   const absoluteTabWidth = 4 * t * len;\n  //   if (absoluteTabWidth > maxTabSize) {\n  //     // recalculate t so that the tab width equals the max size, clamping it\n  //     t = maxTabSize / (4 * len);\n  //   }\n  // }\n\n  const dir = inward ? -1 : 1; // bump (+) or hole (-)\n  const nubHeight = heightToWidthRatio;\n  const shoulder_height = nubHeight / 3;\n\n  /* --- 4.  Anchor & control points in (s,w) ---------------------------- */\n\n  const pointsSW: Vec2[] = [\n    [0.0               ,           0],\n    [0.2               ,           A * shoulder_height],\n    [0.5 + B + D       , dir * (-shoulder_height + C * nubHeight)],\n    [0.5 - t + B       , dir * ( shoulder_height + C * nubHeight)],\n    [0.5 - 2*t + B - D , dir * (nubHeight + C * nubHeight)],\n    [0.5 + 2*t + B - D , dir * (nubHeight + C * nubHeight)],\n    [0.5 + t + B       , dir * ( shoulder_height + C * nubHeight)],\n    [0.5 + B + D       , dir * (-shoulder_height + C * nubHeight)],\n    [0.8               ,           E * shoulder_height],\n    [1.0               ,           0],\n  ];\n\n  /* --- 5.  Map to world coords and split into 3 Béziers ---------------- */\n\n  const points: Vec2[] = pointsSW.map(([s, w]) => P(s, w));\n\n  const bez1: CurveTo = { type: 'bezier', p1: points[1], p2: points[2], p3: points[3] };\n  const bez2: CurveTo = { type: 'bezier', p1: points[4], p2: points[5], p3: points[6] };\n  const bez3: CurveTo = { type: 'bezier', p1: points[7], p2: points[8], p3: points[9] };\n\n  return [bez1, bez2, bez3];\n}\n\n/**\n * A factory that creates a TabGenerator for creating traditional, smoothly curved\n * puzzle piece tabs using a provided geometry function. The nub is built using\n * three cubic Bézier segments that replace a straight edge AB. Curve 1 is a\n * gentle S-curve up to the nub edge, Curve 2 is the arch across the top of the\n * nub, Curve 3 is the mirror of curve 1 back to the baseline.\n */\nexport const TraditionalTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, config: TraditionalTabGeneratorConfig): TabGenerator => {\n  const { jitter = 8, heightToWidthRatio = 50 } = config;\n\n  const TraditionalTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, random: RandomFn): EdgeSegment[] {\n      const inward = !tab.convex;\n      return createTraditionalTab(start, end, jitter, heightToWidthRatio/100, random, inward);\n    },\n  };\n  return TraditionalTabGenerator;\n};\nexport default TraditionalTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TraditionalTabGeneratorFactory, TraditionalTabUIMetadata);\n","import type {\n  AABB,\n  EdgeSegment,\n  LineTo,\n  Piece,\n  PuzzleTopology,\n  Vec2,\n} from \"./types\";\nimport {\n  distanceSq,\n  calculateSegmentsBounds,\n  serializeTopology,\n  doAABBsIntersect,\n} from \"./utils\";\nimport type { CheckGeometryWorkerInput, CheckGeometryWorkerOutput } from '../workers/CheckGeometryWorker';\nimport { Bezier } from 'bezier-js';\n\n// import the worker script\nimport CheckGeometryWorker from '../workers/CheckGeometryWorker?worker';\n\n/** An internal structure to hold a segment and its pre-calculated properties. */\ninterface BoundarySegment {\n  /** The geometric definition of the segment. */\n  segment: EdgeSegment;\n  /** The starting point of this segment. */\n  startPoint: Vec2;\n  /** The pre-calculated bounding box for this segment. */\n  bbox: AABB;\n}\n\n// helper to gets the end point of a segment.\nfunction getEndPoint(s: EdgeSegment): Vec2 {\n  return s.type === 'line' ? s.p : s.p3;\n}\n\n// helper to get a Bezier object for use with bezier-js\nfunction boundaryToBezier(boundary: BoundarySegment): Bezier {\n  if (boundary.segment.type !== 'bezier') {\n    throw new Error('Boundary segment is not a Bezier curve');\n  }\n  const { startPoint } = boundary;\n  const { p1, p2, p3 } = boundary.segment;\n  return new Bezier(\n    { x: startPoint[0], y: startPoint[1] },\n    { x: p1[0], y: p1[1] },\n    { x: p2[0], y: p2[1] },\n    { x: p3[0], y: p3[1] }\n  );\n}\n\n/**\n * Traverses a piece's boundary and collects all its geometric segments.\n * @param piece - The piece to process.\n * @param puzzle - The full puzzle geometry, for half-edge lookups.\n * @returns An ordered array of BoundarySegment objects.\n */\nfunction getPieceBoundary(piece: Piece, puzzle: PuzzleTopology): BoundarySegment[] {\n  const boundary: BoundarySegment[] = [];\n  const startHeId = piece.halfEdge;\n  let currentHeId = startHeId;\n\n  do {\n    const he = puzzle.halfEdges.get(currentHeId);\n    if (!he) {\n      console.error(`Could not find half-edge with ID: ${currentHeId}`);\n      break;\n    }\n\n    let startPoint = he.origin;\n\n    if (he.segments && he.segments.length > 0) {\n      // Add segments from the half-edge definition\n      for (const segment of he.segments) {\n        boundary.push({\n          segment,\n          startPoint,\n          bbox: calculateSegmentsBounds(startPoint, [segment]),\n        });\n        // The next segment starts where the current one ends\n        startPoint = segment.type === 'line' ? segment.p : segment.p3;\n      }\n    } else {\n      // If no segments, it's a straight line to the next half-edge's origin\n      const nextHe = puzzle.halfEdges.get(he.next);\n      if (!nextHe) {\n        console.error(`Could not find next half-edge for ID: ${he.next}`);\n        continue;\n      }\n      const lineSegment: LineTo = { type: 'line', p: nextHe.origin };\n      boundary.push({\n        segment: lineSegment,\n        startPoint: startPoint,\n        bbox: calculateSegmentsBounds(startPoint, [lineSegment]),\n      });\n    }\n\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId);\n\n  return boundary;\n}\n\n/**\n * Performs precise intersection detection between two geometric segments.\n * This function handles Line/Line, Line/Curve, and Curve/Curve cases.\n *\n * @param s1 - The first boundary segment.\n * @param s2 - The second boundary segment.\n * @param adjacent - True of the segments are next to each other on the boundary.\n * @returns An array of Vec2 points representing all found intersections.\n */\nfunction narrowPhaseDetection(s1: BoundarySegment, s2: BoundarySegment, adjacent: boolean): Promise<Vec2[]> {\n  return new Promise<Vec2[]>((resolve) => {\n\n    const intersections: Vec2[] = [];\n    const type1 = s1.segment.type;\n    const type2 = s2.segment.type;\n    const tolerance = 0.01; // values this close to the beginning or end of a curve are effectively at the ends\n\n\n    // Bezier vs. Bezier\n    if (type1 === 'bezier' && type2 === 'bezier') {\n      const bezier1 = boundaryToBezier(s1);\n      const bezier2 = boundaryToBezier(s2);\n\n      // intersects() returns an array of strings that look like \"float/float\"\n      const pairs = bezier1.intersects(bezier2) as string[];\n\n      pairs.forEach((pair) => {\n        const tValues = pair.split('/');\n        const t1 = parseFloat(tValues[0]);\n        const t2 = parseFloat(tValues[1]);\n\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t1 > (1.0 - tolerance) && t2 < tolerance || t1 < tolerance && t2 > (1.0 - tolerance);\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n\n        // extract the intersection point\n        const p = bezier1.get(t1);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Bezier vs. Line\n    else if (type1 === 'bezier' || type2 === 'bezier') {\n      const curveBoundary = type1 === 'bezier' ? s1 : s2;\n      const lineBoundary = type1 === 'line' ? s1 : s2;\n\n      const curve = boundaryToBezier(curveBoundary);\n      const line = {\n        p1: { x: lineBoundary.startPoint[0], y: lineBoundary.startPoint[1] },\n        p2: { x: (lineBoundary.segment as LineTo).p[0], y: (lineBoundary.segment as LineTo).p[1] },\n      };\n\n      // intersects() returns an array of t-values on the curve\n      const tValues = curve.intersects(line) as number[]; // always numbers when comparing to line\n      tValues.forEach((t) => {\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t > (1.0 - tolerance) || t < tolerance;\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n        const p = curve.get(t);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Line vs. Line\n    else {\n      // only non-adjacent line segments need to be compared\n      if (!adjacent) {\n        return resolve(intersections);\n      }\n\n      const p1 = s1.startPoint;\n      const p2 = s1.segment.p;\n      const p3 = s2.startPoint;\n      const p4 = s2.segment.p;\n\n      const [x1, y1] = p1;\n      const [x2, y2] = p2;\n      const [x3, y3] = p3;\n      const [x4, y4] = p4;\n\n      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n      if (den !== 0) { // Ensure lines are not parallel or collinear\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n\n        // If an intersection exists on both line segments\n        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n          const intersectX = x1 + t * (x2 - x1);\n          const intersectY = y1 + t * (y2 - y1);\n          intersections.push([intersectX, intersectY]);\n        }\n      }\n    }\n\n    resolve(intersections);\n  });\n}\n\n/**\n * Detects self-intersections within each piece of a puzzle geometry.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @param onProgress - Optional callback invoked to report progress.\n * @returns An array of Vec2 points, where each point is an overlap.\n */\nasync function detectIntersections(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  const intersections: Vec2[] = [];\n  const EPSILON_SQUARED = 1e-8; // Tolerance for floating point comparisons\n\n  const pieces = Array.from(puzzle.pieces.values());\n  const totalPieces = pieces.length;\n  let processedCount = 0;\n\n  // 1. Iterate through each piece\n  for (const piece of puzzle.pieces.values()) {\n\n    // report progress\n    onProgress?.(processedCount, totalPieces);\n\n    const boundary = getPieceBoundary(piece, puzzle);\n    const numSegments = boundary.length;\n    if (numSegments < 2) {\n      processedCount++;\n      continue;\n    }\n\n    // 2. Compare every segment with every other segment that comes after it\n    for (let i = 0; i < numSegments; i++) {\n      for (let j = i + 1; j < numSegments; j++) {\n        const seg1 = boundary[i];\n        const seg2 = boundary[j];\n\n        // 3. Broad-phase detection using bounding boxes\n        if (!doAABBsIntersect(seg1.bbox, seg2.bbox)) {\n          // no intersections\n          continue;\n        }\n\n        // 4. Distinguish between adjacent and non-adjacent intersections\n        const areAdjacent = (j === i + 1) || (i === 0 && j === numSegments - 1);\n\n        // 5. Narrow-phase detection (using a bezier library)\n        const potentialPoints = await narrowPhaseDetection(seg1, seg2, areAdjacent);\n\n        if (potentialPoints.length === 0) {\n          // no intersections\n          continue;\n        }\n\n        if (areAdjacent) {\n          const connectionPoint = (i === 0 && j === numSegments - 1)\n            ? seg1.startPoint // we're comparing the final segment with the first segment\n            : getEndPoint(seg1.segment); // we're comparing adjacent segments\n\n          for (const point of potentialPoints) {\n            // An intersection is only an error if it's NOT at the connection point.\n            if (distanceSq(point, connectionPoint) > EPSILON_SQUARED) {\n              intersections.push(point);\n            }\n          }\n        } else {\n          // For non-adjacent segments, ANY intersection is an error.\n          intersections.push(...potentialPoints);\n        }\n      }\n    }\n    processedCount++;\n  }\n\n  // final call to signify completion\n  onProgress?.(totalPieces, totalPieces);\n\n  console.log(`detected ${intersections.length} intersections in ${puzzle.pieces.size} pieces`);\n  return intersections;\n}\n\n\n/**\n * Checks a puzzle for geometry issues such as intersecting pieces or too narrow geometry.\n * @param puzzle - Geometry to check\n * @param onProgress - Optional callpack for managing a progress bar\n * @returns A Promise for coordinates that have problem geometry\n */\nexport async function checkGeometry(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  // find points where pieces intersect/overlap\n  const intersections = await detectIntersections(puzzle, onProgress);\n\n  if (intersections.length < 2) {\n    return intersections;\n  }\n\n  // Note: the intersection algorithm can return multiple points clustered very\n  // closely, which is confusing for the user, so here we filter them out\n  const MIN_DISTANCE = 1;\n  const filtered: Vec2[] = [intersections[0]];\n\n  for (let i = 1; i < intersections.length; i++) {\n    const current = intersections[i];\n    const last = filtered[filtered.length - 1];\n    if (distanceSq(current, last) > MIN_DISTANCE * MIN_DISTANCE) {\n      filtered.push(current);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Wraps the `checkGeometry` function in a web worker to run it off the main thread,\n * preventing the UI from freezing during intensive calculations.\n *\n * @param puzzle - The puzzle topology to check.\n * @param onProgress - An optional callback to receive progress updates.\n * @returns A promise that resolves with an array of intersection points or rejects on error.\n */\nexport function checkGeometryInWorker(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n  return new Promise((resolve, reject) => {\n    const worker = new CheckGeometryWorker();\n\n    // Handle messages received from the worker\n    worker.onmessage = (event: MessageEvent<CheckGeometryWorkerOutput>) => {\n      const data = event.data;\n\n      switch (data.type) {\n      case 'progress':\n        onProgress?.(data.processed, data.total);\n        break;\n      case 'done':\n        resolve(data.results);\n        worker.terminate();\n        break;\n      case 'error':\n        reject(new Error(data.message));\n        worker.terminate();\n        break;\n      }\n    };\n\n    // Handle any critical errors with the worker itself\n    worker.onerror = (error: ErrorEvent) => {\n      reject(new Error(error.message));\n      worker.terminate();\n    };\n\n    // serialize the puzzle topology and send it to the worker to kick off the process\n    const message: CheckGeometryWorkerInput = {\n      topology: serializeTopology(puzzle),\n    };\n    worker.postMessage(message);\n  });\n}","import type { Vec2, PathCommand } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\nimport { isPointInBoundary } from '../../utils';\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\nexport const Name: GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\n\n/** Required config for this generator */\nexport interface GridJitterPointGeneratorConfig extends GeneratorConfig {\n  name: GridJitterPointGeneratorName;\n  /** Amount of random jitter (0 to 100) */\n  jitter: number;\n}\n\n/** UI metadata needed for this generator */\nexport const GridJitterPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Grid\",\n  description: \"Generate seed points using a grid with optional random jitter. \" +\n    \"Has a uniform, regular look, especially with low randomness values.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n      helpText: 'Amount of jitter to apply to each grid point (0 to 100%)',\n    },\n  ],\n};\n\n/**\n * A point generator that uses grid + random jitter. `jitter` represents the\n * strength of jitter applied to each point, from 0 (straight grid) to 1\n * (completely random).\n */\nexport const GridJitterPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, config: GridJitterPointGeneratorConfig) => {\n  const { jitter = 50 } = config;\n\n  const GridJitterPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random, border } = runtimeOpts;\n\n      const points: Vec2[] = [];\n      // assemble a grid\n      for (let x = 0; x < width; x += pieceSize) {\n        for (let y = 0; y < height; y += pieceSize) {\n          // initial position is the center of each grid cell\n          const point: Vec2 = [x + pieceSize / 2, y + pieceSize / 2];\n          // add random jitter\n          if (jitter > 0) {\n            point[0] += (random() - 0.5) * (jitter / 100) * pieceSize;\n            point[1] += (random() - 0.5) * (jitter / 100)  * pieceSize;\n          }\n\n          // Only include points that are inside the custom boundary\n          if (isPointInBoundary(point, border)) {\n            points.push(point);\n          }\n        }\n      }\n      return points;\n    },\n  };\n  return GridJitterPointGenerator;\n};\nexport default GridJitterPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, GridJitterPointGeneratorFactory, GridJitterPointUIMetadata);\n","import { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  PathCommand,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport {\n  linkAndCreateEdges,\n} from \"../../utils\";\nimport {\n  createBoundaryContext,\n  createPieceFromPolygon,\n  clipCellToBoundary,\n  type BoundaryContext,\n} from \"./PieceGeneratorHelpers\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\nexport const Name: RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\n\n/** Required config for this generator */\nexport interface RectangularPieceGeneratorConfig extends GeneratorConfig {\n  name: RectangularPieceGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const RectangularPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Rectangular\",\n  description: \"Construct pieces from a regular grid. All pieces have 4 sides \" +\n    \"and are the same size (except when the border is irregular). This generator \" +\n    \"ignores seed points.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A `PieceGenerator` that uses a grid to create the puzzle's topology. It\n * builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const RectangularPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (border: PathCommand[], bounds: { width: number; height: number }, _config: RectangularPieceGeneratorConfig) => {\n\n  const { width, height } = bounds;\n\n  // Pre-compute boundary data once for reuse across all cells\n  const boundaryContext: BoundaryContext = createBoundaryContext(border);\n\n  const RectangularPieceGenerator: PieceGenerator = {\n    /**\n     * Builds a puzzle topology based on a grid, ignores seed points.\n     * @param _points The seed points. Ignored by this generator.\n     * @param runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(_points: Vec2[], runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n      const { pieceSize, border } = runtimeOpts;\n\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n        borderPath: border,\n      };\n\n      // --- 1. Calculate Grid Dimensions ---\n      // Determine the number of rows and columns based on the desired piece size.\n      const cols = Math.ceil(width / pieceSize);\n      const rows = Math.ceil(height / pieceSize);\n\n      // Calculate the actual width and height of each cell\n      const cellWidth = Math.round(width / cols);\n      const cellHeight = Math.round(height / rows);\n\n      // --- 2. Create Vertices ---\n      // A 2D array to hold all vertex points for easy lookup by grid index.\n      const gridVertices: Vec2[][] = [];\n      for (let r = 0; r <= rows; r++) {\n        const rowVertices: Vec2[] = [];\n        for (let c = 0; c <= cols; c++) {\n          const x = c * cellWidth;\n          const y = r * cellHeight;\n          rowVertices.push([x, y]);\n        }\n        gridVertices.push(rowVertices);\n      }\n      // Flatten the 2D array into the final list for the topology.\n      topology.vertices = gridVertices.flat();\n\n      // --- 3. Create Pieces and Half-Edges ---\n      // This map will help us find the twin of a half-edge. The key is a string\n      // representing the start and end vertices of an edge, e.g., \"x1,y1-x2,y2\".\n      const halfEdgeTwinMap = new Map<string, HalfEdgeID>();\n\n      // NOTE: Using a string key based on floating point coordinates can be very\n      // fragile. Tiny precision errors can cause lookups to fail. This approach\n      // is safe here because the grid coordinates are normalized to integers.\n\n      // build each piece\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n\n          const pieceId = r * cols + c;\n\n          // Get the four corner vertices for the current grid cell.\n          const topLeft = gridVertices[r][c];\n          const topRight = gridVertices[r][c + 1];\n          const bottomLeft = gridVertices[r + 1][c];\n          const bottomRight = gridVertices[r + 1][c + 1];\n\n          // Clip the grid cell against the puzzle boundary\n          const cellPolygon = [topLeft, topRight, bottomRight, bottomLeft];\n          const pieceVertices = clipCellToBoundary(cellPolygon, boundaryContext);\n\n          if (!pieceVertices) {\n            // Cell is completely outside the boundary, skip it\n            continue;\n          }\n\n          // Create the piece from the (possibly clipped) polygon\n          const piece = createPieceFromPolygon(pieceId, pieceVertices, topology);\n          topology.pieces.set(pieceId, piece);\n\n          // Collect the half-edges for this piece to link them with neighbors\n          const pieceHalfEdges: HalfEdge[] = [];\n          let currentHeId = piece.halfEdge;\n          if (currentHeId !== -1) {\n            const startHeId = currentHeId;\n            do {\n              const he = topology.halfEdges.get(currentHeId)!;\n              pieceHalfEdges.push(he);\n              currentHeId = he.next;\n            } while (currentHeId !== startHeId);\n          }\n\n          // link edges to neighbors or mark them as part of the boundary\n          linkAndCreateEdges(pieceHalfEdges, topology, halfEdgeTwinMap, (p1, p2) => {\n            // This function determines if an edge is on the puzzle's outer boundary.\n            // An edge is a grid edge if both points lie on one of the cell's original sides.\n            const isClose = (val: number, target: number) => Math.abs(val - target) < 1e-6;\n            const onTop = isClose(p1[1], topLeft[1]) && isClose(p2[1], topLeft[1]);\n            const onRight = isClose(p1[0], topRight[0]) && isClose(p2[0], topRight[0]);\n            const onBottom = isClose(p1[1], bottomLeft[1]) && isClose(p2[1], bottomLeft[1]);\n            const onLeft = isClose(p1[0], topLeft[0]) && isClose(p2[0], topLeft[0]);\n\n            // If it's NOT a grid edge, it must be a new puzzle boundary edge.\n            return !(onTop || onRight || onBottom || onLeft);\n          });\n\n        }\n      }\n\n      return topology;\n    },\n  };\n  return RectangularPieceGenerator;\n};\nexport default RectangularPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, RectangularPieceGeneratorFactory, RectangularPieceGeneratorUIMetadata);\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, PathCommand, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other TabGenerators\ntype NullTabGeneratorName = \"NullTabGenerator\";\nexport const Name: NullTabGeneratorName = \"NullTabGenerator\";\n\n/** This generator doesn't take any special config */\nexport interface NullTabGeneratorConfig extends GeneratorConfig {\n  name: NullTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const NullTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"None\",\n  description: \"Do not generate tabs. All pieces have straight edges.\",\n  sortHint: 3,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/** Tab generator that does nothing, piece edges remain straight lines */\nexport const NullTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, _config: NullTabGeneratorConfig) => {\n  const NullTabGenerator: TabGenerator = {\n    createTabSegments(_start: Vec2, _end: Vec2, _tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      return []; // does nothing\n    },\n  };\n  return NullTabGenerator;\n};\nexport default NullTabGeneratorFactory;\n\n// register the generator\nTabGeneratorRegistry.register(Name, NullTabGeneratorFactory, NullTabUIMetadata);\n\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, PathCommand, TabPlacement, RandomFn, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TriangleTabGeneratorName = \"TriangleTabGenerator\";\nexport const Name: TriangleTabGeneratorName = \"TriangleTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TriangleTabGeneratorConfig extends GeneratorConfig {\n  name: TriangleTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const TriangleTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Triangle\",\n  description: \"Creates a simple triangle between each (internal) piece edge.\",\n  sortHint: 2,\n  // these have to match the config above\n  controls: [],\n};\n\n/**\n * A simple TabGenerator that adds a triangular \"nub\" to an edge.\n *\n * This generator serves as a straightforward example of how to implement the\n * TabGenerator interface. It generates a three line segment that forms a\n * triangular tab.\n */\nexport const TriangleTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_border: PathCommand[], _bounds: { width: number; height: number }, _config: TriangleTabGeneratorConfig) => {\n\n  const TriangleTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      // 1. Calculate edge vectors from the provided start and end points.\n      const edgeVector: Vec2 = [end[0] - start[0], end[1] - start[1]];\n      const edgeLength = Math.hypot(edgeVector[0], edgeVector[1]);\n\n      // Return nothing for zero-length edges.\n      if (edgeLength < 1e-6) {\n        return [];\n      }\n\n      // Calculate a perpendicular vector (normal) to the edge.\n      const edgeDir: Vec2 = [edgeVector[0] / edgeLength, edgeVector[1] / edgeLength];\n      const normalDir: Vec2 = [-edgeDir[1], edgeDir[0]];\n\n      // 2. Calculate the position of the tab's peak.\n      // Find the midpoint of the edge segment this tab occupies.\n      const midPoint: Vec2 = [start[0] + edgeVector[0] / 2, start[1] + edgeVector[1] / 2];\n\n      // Determine the tab's direction from the `convex` property.\n      // `true` (outward) is a positive direction, `false` (inward) is negative.\n      const direction = tab.convex ? 1 : -1;\n\n      // The tab's height is defined by its `size` property (a fraction of the edge length).\n      const tabHeight = edgeLength * tab.size * direction;\n\n      // Calculate the nub point by moving from the midpoint along the normal.\n      const nubPoint: Vec2 = [\n        midPoint[0] + normalDir[0] * tabHeight,\n        midPoint[1] + normalDir[1] * tabHeight,\n      ];\n\n      // 3. Create the segments for the tab.\n      const result: EdgeSegment[] = [];\n      result.push({ type: 'line', p: start });\n      result.push({ type: 'line', p: nubPoint });\n      result.push({ type: 'line', p: end });\n\n      return result;\n    },\n  };\n  return TriangleTabGenerator;\n};\nexport default TriangleTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TriangleTabGeneratorFactory, TriangleTabUIMetadata);\n","// component that renders single page application for generating puzzles\nimport m from 'mithril';\n\n// UI parts\nimport GitHubCorner from './ui/GitHubCorner';\nimport Puzzle from './ui/Puzzle';\nimport DownloadPuzzleButton from './ui/DownloadPuzzleButton';\nimport GeometryCheckIndicator from './ui/GeometryCheckIndicator';\nimport UploadImageButton from './ui/UploadImageButton';\nimport GeneratorPicker from './ui/GeneratorPicker';\nimport NumberInputControl from './ui/inputs/NumberInputControl';\nimport BooleanInputControl from './ui/inputs/BooleanInputControl';\nimport AspectRatioPicker from './ui/AspectRatioPicker';\nimport ColorPicker from './ui/ColorPicker';\nimport BorderShapePicker, { type BorderShapeType } from './ui/BorderShapePicker';\n\n// geometry parts\nimport type { PuzzleGeometry } from './geometry/types';\nimport type { GeneratorConfig, GeneratorName, GeneratorRegistry } from './geometry/generators/Generator';\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabPlacementStrategyRegistry, TabGeneratorRegistry } from './geometry/generators/Generator';\nimport { Name as PoissonGeneratorName } from './geometry/generators/point/PoissonPointGenerator';\nimport { Name as VoronoiGeneratorName } from './geometry/generators/piece/VoronoiPieceGenerator';\nimport { Name as SimpleTabPlacementStrategyName } from './geometry/generators/tab_placement/SimpleTabPlacementStrategy';\nimport { Name as TraditionalTabGeneratorName } from './geometry/generators/tab/TraditionalTabGenerator';\nimport { buildPuzzle, rebuildPuzzleWithUpdatedSeedPoint } from './geometry/PuzzleMaker';\nimport { checkGeometryInWorker } from './geometry/GeometryChecker';\nimport { createRectangleBorder, createCircleBorder, createEllipseBorder, createRoundedRectBorder } from './geometry/borderShapes';\n\n// register generators\nimport \"./geometry/generators/point/GridJitterPointGenerator\";\nimport \"./geometry/generators/point/PoissonPointGenerator\";\nimport \"./geometry/generators/piece/VoronoiPieceGenerator\";\nimport \"./geometry/generators/piece/RectangularPieceGenerator\";\nimport \"./geometry/generators/tab_placement/SimpleTabPlacementStrategy\";\nimport \"./geometry/generators/tab/NullTabGenerator\";\nimport \"./geometry/generators/tab/TriangleTabGenerator\";\nimport \"./geometry/generators/tab/TraditionalTabGenerator\";\n\n// Webawesome components\nimport { registerIconLibrary } from '@awesome.me/webawesome/dist/webawesome.js';\nimport \"@awesome.me/webawesome/dist/styles/themes/default.css\";\n\n// CSS for this component\nimport './index.css';\n\n// detect light/dark mode\nlet isDarkMode = false;\nfunction configureDarkLightTheme() {\n  const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n  function manageDarkLightTheme() {\n    if (darkModeQuery.matches) {\n      document.documentElement.classList.add('wa-dark');\n      isDarkMode = true;\n    } else {\n      document.documentElement.classList.remove('wa-dark');\n      isDarkMode = false;\n    }\n  }\n  manageDarkLightTheme();\n  darkModeQuery.addEventListener('change', manageDarkLightTheme);\n}\nconfigureDarkLightTheme();\n\n// component that draws the page\nconst Page: m.ClosureComponent<unknown> = () => {\n\n  const defaultWidth = 800;\n  const defaultHeight = 600;\n\n  const defaultPointGenerator = PoissonGeneratorName;\n  const defaultPieceGenerator = VoronoiGeneratorName;\n  const defaultTabGenerator = TraditionalTabGeneratorName;\n\n  /** State tracked for each type of generator */\n  interface GeneratorState<C extends GeneratorConfig = GeneratorConfig> {\n    label: string;\n    registry: GeneratorRegistry<unknown>;\n    name : GeneratorName;\n    config: C;\n  }\n\n  interface PageState {\n    /** Random seed */\n    seed: number;\n    /** Width of canvas in pixels */\n    canvasWidth: number;\n    /** Height of canvas in pixels */\n    canvasHeight: number;\n    /** Aspect ratio of canvas, width/height */\n    aspectRatio: number;\n    /** Minimum distance between control points (pixels) */\n    distance: number;\n    /** Color of pieces */\n    color: string;\n    /** Should we draw the seed points? */\n    drawPoints: boolean;\n    /** Color of seed points */\n    pointColor: string;\n    /** Selected border shape */\n    borderShape: BorderShapeType;\n    /** Corner radius for rounded rectangle (pixels) */\n    borderCornerRadius: number;\n    /** Problems found by the geometry check algorithms */\n    geometryProblems: {\n      /** If true, the geometry will be re-checked whenever a new puzzle is generated */\n      autoCheck: boolean;\n      /** Count of problems found in the last check */\n      problems?: number;\n      /** Percent complete of in-progress geometry check */\n      progress?: number;\n    },\n    /** Dirty flag that keeps us from hitting the puzzle generation function too hard */\n    dirty: boolean;\n    /** Currently selected and configured generators for each part of puzzle generation */\n    generators: Record<string, GeneratorState>;\n    /** Generated puzzle geometry */\n    puzzle?: PuzzleGeometry;\n    /** User uploaded image */\n    backgroundImageUrl?: string;\n    /** Name of uploaded image */\n    backgroundImageName: string;\n  };\n\n  // component state\n  const state: PageState = {\n    seed: new Date().getTime() % 10240,\n    canvasWidth: defaultWidth,\n    canvasHeight: defaultHeight,\n    aspectRatio: defaultWidth / defaultHeight,\n    distance: 40,\n    color: isDarkMode ? \"#DDDDDD\" : \"#333333\",\n    drawPoints: false,\n    pointColor: isDarkMode ? \"#FF0000\" : \"#0000FF\",\n    borderShape: 'rectangle',\n    borderCornerRadius: 50,\n    geometryProblems: {\n      autoCheck: false,\n      problems: undefined,\n      progress: undefined,\n    },\n    dirty: true,\n    generators: {\n      /** Strategy for creating points (which influences piece generation) */\n      point: {\n        label: \"Seed Points\",\n        registry: PointGeneratorRegistry,\n        name: defaultPointGenerator,\n        config: PointGeneratorRegistry.getDefaultConfig(defaultPointGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for turning points into puzzle pieces */\n      piece: {\n        label: \"Piece Generation\",\n        registry: PieceGeneratorRegistry,\n        name: defaultPieceGenerator,\n        config: PieceGeneratorRegistry.getDefaultConfig(defaultPieceGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for placing tabs on piece edges */\n      placement: {\n        label: \"Tab Placement\",\n        registry: TabPlacementStrategyRegistry,\n        name: SimpleTabPlacementStrategyName,\n        config: TabPlacementStrategyRegistry.getDefaultConfig(SimpleTabPlacementStrategyName, defaultWidth, defaultHeight),\n      },\n      /** Style of tabs to generate */\n      tab: {\n        label: \"Tabs\",\n        registry: TabGeneratorRegistry,\n        name: defaultTabGenerator,\n        config: TabGeneratorRegistry.getDefaultConfig(defaultTabGenerator, defaultWidth, defaultHeight),\n      },\n    },\n    puzzle: undefined,\n    backgroundImageUrl: undefined,\n    backgroundImageName: '',\n  };\n\n  // utility to create border based on selected shape\n  function createBorder(): import('./geometry/types').PathCommand[] {\n    const { canvasWidth, canvasHeight, borderShape, borderCornerRadius } = state;\n\n    switch (borderShape) {\n    case 'rectangle':\n      return createRectangleBorder(canvasWidth, canvasHeight);\n    case 'circle':\n      // Use the smaller dimension to ensure the circle fits\n      return createCircleBorder(Math.min(canvasWidth, canvasHeight));\n    case 'ellipse':\n      return createEllipseBorder(canvasWidth, canvasHeight);\n    case 'rounded-rect':\n      return createRoundedRectBorder(canvasWidth, canvasHeight, borderCornerRadius);\n    default:\n      return createRectangleBorder(canvasWidth, canvasHeight);\n    }\n  }\n\n  // utility to invoke the geometry checks\n  function handleCheckGeometry() {\n    if (!state.puzzle) return;\n\n    state.geometryProblems.progress = 0;\n    m.redraw();\n\n    // this uses a web worker to not block the main thread\n    checkGeometryInWorker(state.puzzle, (processed, total) => {\n      state.geometryProblems.progress = (processed / total) * 100;\n      m.redraw();\n    }).then((problems) => {\n      state.geometryProblems.problems = problems.length;\n      state.geometryProblems.progress = undefined;\n      if (state.puzzle) {\n        state.puzzle.problems = problems;\n      }\n      m.redraw();\n    }).catch((err) => {\n      state.geometryProblems.progress = undefined;\n      console.error(err);\n      m.redraw();\n    });\n  }\n\n  // Mithril component\n  return {\n\n    oncreate: () => {\n      buildPuzzle({\n        bounds: {\n          width: state.canvasWidth,\n          height: state.canvasHeight,\n        },\n        border: createBorder(),\n        pieceSize: state.distance,\n        pointConfig: state.generators.point.config,\n        pieceConfig: state.generators.piece.config,\n        placementConfig: state.generators.placement.config,\n        tabConfig: state.generators.tab.config,\n        seed: state.seed,\n      }).then((puzzle) => {\n        state.puzzle = puzzle;\n        m.redraw();\n        if (state.geometryProblems.autoCheck) {\n          handleCheckGeometry();\n        }\n      }).catch((err) => {\n        console.error(err);\n      });\n    },\n\n    onupdate: () => {\n      if (state.dirty) {\n        state.dirty = false;\n        // rebuild the puzzle geometry\n        buildPuzzle({\n          bounds: {\n            width: state.canvasWidth,\n            height: state.canvasHeight,\n          },\n          border: createBorder(),\n          pieceSize: state.distance,\n          pointConfig: state.generators.point.config,\n          pieceConfig: state.generators.piece.config,\n          placementConfig: state.generators.placement.config,\n          tabConfig: state.generators.tab.config,\n          seed: state.seed,\n        }).then((puzzle) => {\n          state.geometryProblems.problems = undefined;\n          state.geometryProblems.progress = undefined;\n          state.puzzle = puzzle;\n          m.redraw();\n          if (state.geometryProblems.autoCheck) {\n            handleCheckGeometry();\n          }\n        }).catch((err) => {\n          console.error(err);\n        });\n      }\n    },\n\n    onremove: () => {\n      if (state.backgroundImageUrl) {\n        // clean up memory\n        URL.revokeObjectURL(state.backgroundImageUrl);\n        state.backgroundImageUrl = undefined;\n      }\n    },\n\n    // component lifecycle: render our output\n    view: () => {\n\n      return m(\".page\", [\n        m(GitHubCorner, {\n          link: \"https://github.com/weevilgenius/puzzle-generator\",\n        }),\n        m(\"h1\", \"Puzzle Generator\"),\n        m(\".container\", [\n\n          state.puzzle && m('.puzzle-stack', [\n\n            // main puzzle display\n            m(Puzzle, {\n              width: state.canvasWidth,\n              height: state.canvasHeight,\n              color: state.color,\n              imageUrl: state.backgroundImageUrl,\n              puzzle: state.puzzle,\n              isDirty: state.dirty,\n              pointColor: state.drawPoints ? state.pointColor : undefined,\n              onPuzzleChanged: (puzzle) => {\n                // user dragged a vertex to tweak the puzzle\n                state.puzzle = puzzle;\n                m.redraw();\n              },\n              onSeedPointMoved: (pieceId, newPosition) => {\n                // user dragged a seed point to a new position\n                state.dirty = false; // Prevent double-regeneration\n\n                if (!state.puzzle) return;\n\n                rebuildPuzzleWithUpdatedSeedPoint(state.puzzle, pieceId, newPosition)\n                  .then((puzzle) => {\n                    state.geometryProblems.problems = undefined;\n                    state.geometryProblems.progress = undefined;\n                    state.puzzle = puzzle;\n                    m.redraw();\n\n                    if (state.geometryProblems.autoCheck) {\n                      handleCheckGeometry();\n                    }\n                  })\n                  .catch((err) => {\n                    console.error('Failed to rebuild puzzle with updated seed point:', err);\n                  });\n              },\n            }),\n\n            m('.actions', [\n\n              // SVG download button\n              m(DownloadPuzzleButton, {\n                puzzle: state.puzzle,\n                width: state.canvasWidth,\n                height: state.canvasHeight,\n                color: state.color,\n              }),\n\n              // Geometry check display\n              m(GeometryCheckIndicator, {\n                autoCheck: state.geometryProblems.autoCheck,\n                problems: state.geometryProblems.problems,\n                progressPercent: state.geometryProblems.progress,\n                onCheckRequested: () => {\n                  if (!state.dirty) {\n                    handleCheckGeometry();\n                  }\n                  m.redraw();\n                },\n                onAutocheckChanged: (autocheck) => {\n                  if (autocheck !== state.geometryProblems.autoCheck) {\n                    state.geometryProblems.autoCheck = autocheck;\n                    m.redraw();\n                  }\n                },\n              }),\n\n            ]),\n          ]),\n\n          // puzzle generation controls\n          m(\".controls\", [\n\n            // background image\n            m('.background-image', [\n              m(UploadImageButton, {\n                label: \"Background Image\",\n                onUpload: (imageUrl, filename, width, height) => {\n                  // clear any previous image\n                  if (state.backgroundImageUrl) {\n                    URL.revokeObjectURL(state.backgroundImageUrl);\n                  }\n                  state.canvasWidth = width;\n                  state.canvasHeight = height;\n                  state.aspectRatio = width / height;\n                  state.backgroundImageUrl = imageUrl;\n                  state.backgroundImageName = filename;\n                  state.dirty = true;\n                  m.redraw();\n                },\n              }),\n              m('span.background-image-label', state.backgroundImageName),\n            ]),\n\n            // Puzzle aspect ratio\n            m(AspectRatioPicker, {\n              ratio: state.aspectRatio,\n              disabled: state.backgroundImageUrl !== undefined,\n              onChange: (ratio) => {\n                state.aspectRatio = ratio;\n                state.canvasWidth = state.canvasHeight * ratio;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Border shape\n            m(BorderShapePicker, {\n              shape: state.borderShape,\n              disabled: state.backgroundImageUrl !== undefined,\n              onChange: (shape) => {\n                state.borderShape = shape;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Corner radius for rounded rectangle\n            state.borderShape === 'rounded-rect' && m(NumberInputControl, {\n              config: {\n                name: 'cornerRadius',\n                label: 'Corner Radius',\n                type: 'number',\n              },\n              value: state.borderCornerRadius,\n              onChange: (value) => {\n                state.borderCornerRadius = value ?? 50;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Random number seed\n            m(NumberInputControl, {\n              config: {\n                name: 'seed',\n                label: 'Seed',\n                type: 'number',\n              },\n              value: state.seed,\n              onChange: (value) => {\n                state.seed = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece size\n            m(NumberInputControl, {\n              config: {\n                name: 'pieceSize',\n                label: 'Piece size',\n                type: 'number',\n              },\n              value: state.distance,\n              onChange: (value) => {\n                state.distance = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece color\n            m(ColorPicker, {\n              label: 'Piece color',\n              color: state.color,\n              size: \"small\",\n              onUpdate: (newColor) => {\n                state.color = newColor;\n                m.redraw();\n              },\n            }),\n\n            // draw seed points?\n            m('.draw-points', [\n              m(BooleanInputControl, {\n                config: {\n                  name: 'drawPoints',\n                  label: 'Draw seed points',\n                  type: 'boolean',\n                },\n                value: state.drawPoints,\n                onChange: (value) => {\n                  state.drawPoints = value;\n                  m.redraw();\n                },\n              }),\n              state.drawPoints && m(ColorPicker, {\n                label: 'Seed points color',\n                color: state.pointColor,\n                size: \"small\",\n                onUpdate: (newColor) => {\n                  state.pointColor = newColor;\n                  m.redraw();\n                },\n              }),\n            ]),\n\n            // render a generator picker for each type of generator\n            ...Object.entries(state.generators).map(([type, generator]) => {\n              return m(\"label\", [\n                generator.label + ':',\n                m(GeneratorPicker, {\n                  generator: generator.name,\n                  registry: generator.registry,\n                  config: generator.config,\n                  onGeneratorChange: (generatorName) => {\n                    if (generatorName != generator.name) {\n                      console.log(`${type} generator changed to ${generatorName}`);\n                      generator.name = generatorName;\n                      // generator changed, we need a new blank config\n                      state.generators[type].config = generator.registry.getDefaultConfig(generatorName, state.canvasWidth, state.canvasHeight);\n                      state.dirty = true;\n                      m.redraw();\n                    }\n                  },\n                  onConfigChange: (key, value) => {\n                    console.log(`${type} generator config \"${key}\" changed to ${String(value)}`);\n                    generator.config[key] = value;\n                    state.dirty = true;\n                    m.redraw();\n                  },\n                }),\n              ]);\n            }),\n\n          ]), // .controls\n\n        ]), // .container\n\n      ]);\n    }, // view()\n  };\n};\n\n// configure Webawesome icons to use Material Symbols\nregisterIconLibrary('material', {\n  resolver: (name) => {\n    const match = name.match(/^(.*?)(_(rounded|sharp))?$/);\n    if (match) {\n      return `https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${match[3] ?? 'outlined'}/${match[1]}.svg`;\n    }\n    return '';\n  },\n  mutator: (svg) => svg.setAttribute('fill', 'currentColor'),\n});\n\n// Ask Mithril to render the page, our componet gets placed into the root element.\n// Mithril will rerender automatically after DOM event handlers defined in component\n// views and also whenever m.redraw() is called.\nm.mount(document.body, Page);\n"],"names":["GitHubCorner","attrs","m","GeneratorRegistry","name","factory","uiMetadata","border","bounds","config","generator","a","b","g","width","height","newConfig","metadata","control","PointGeneratorRegistry","PieceGeneratorRegistry","TabPlacementStrategyRegistry","TabGeneratorRegistry","id","getUniqueId","abs","cos","sin","acos","atan2","sqrt","pow","crt","v","pi","tau","quart","epsilon","nMax","nMin","ZERO","utils","t","derivativeFn","d","l","points","_3d","order","mt","p","ret","mt2","t2","c","dCpts","i","ratios","f1","f2","f3","f4","dpoints","list","j","dpt","M","precision","len","sum","ds","de","ts","te","d1","d2","v2","r","v1","s","obj","o","dx1","dy1","dx2","dy2","cross","dot","pos","p1","p2","dx","dy","LUT","point","mdist","mpos","idx","n","bottom","top","x1","y1","x2","y2","x3","y3","x4","y4","nx","ny","p3","p4","Bezier","sections","mx","my","MX","MY","bbox","s1","bbox1","s2","bbox2","curveIntersectionThreshold","intersections","a1","a2","l1","l2","iss","forward","back","bpl","fpl","start","end","shape","curve","min","max","line","tx","ty","aligned","reduce","m1","m2","pa","pb","pc","pd","q","q2","discriminant","u1","mp3","mp33","cosphi","phi","crtr","t1","sd","kOnly","num","dnm","adk","dk","k","dd","qdsum","pk","nk","v3","trm","sq","b1","b2","dims","dim","_bbox","c1","c2","c1b","c2b","threshold","cc1","cc2","pairs","pair","results","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","e","_","PolyBezier","curves","offset","coords","args","coordlen","newargs","higher","step","baselength","abc","S","B","E","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","A","nc1","nc2","x","y","last","print","angle","u","um","C","steps","error","lut","hits","closest","ft","np","pim","r1","r2","q1","R","_p","pt","result","roots","mfn","extrema","lbbox","tbbox","nv","n1","n2","segment","pass1","pass2","distanceFn","clockwise","ov","rc","d3","d4","mid","fline","bline","ls","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","fs","fe","bs","be","outline","shapes","left","right","errorThreshold","np1","ref","circles","t_s","t_e","safety","np2","np3","prev_arc","curr_good","prev_good","done","t_m","prev_e","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_i","_s","err","TAU","mapToEllipse","_ref","rx","ry","sinphi","centerx","centery","xp","yp","approxUnitArc","ang1","ang2","vectorAngle","ux","uy","vx","vy","sign","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","_ref2","_ref2$xAxisRotation","xAxisRotation","_ref2$largeArcFlag","_ref2$sweepFlag","lambda","_getArcCenter","_getArcCenter2","ratio","_mapToEllipse","_mapToEllipse2","_mapToEllipse3","DEFAULT_COMPARE","SplayTree","compare","noDuplicates","gp","ggp","key","data","z","comp","cmp","node","comparator","sMax","returnValue","successor","predecessor","callback","current","low","high","fn","ctx","Q","index","keys","values","presort","size","sort","loadRecursive","parent","middle","pivot","tmp","NORMAL","NON_CONTRIBUTING","SAME_TRANSITION","DIFFERENT_TRANSITION","INTERSECTION","UNION","DIFFERENCE","XOR","computeFields","event","prev","operation","inResult","determineResultTransition","thisIn","thatIn","isIn","SweepEvent","otherEvent","isSubject","edgeType","p0","copy","equals","splitter","resulterrbound","elen","flen","f","h","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","C1","C2","D","orient2dadapt","ax","ay","bx","by","detsum","acxtail","acytail","bcxtail","bcytail","ahi","alo","bhi","blo","_j","_0","s0","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","signedArea","res","compareEvents","specialCases","divideSegment","se","queue","crossProduct","dotProduct","intersection$1","noEndpointTouch","va","vb","toPoint","kross","sqrKross","sqrLenA","sa","sb","smin","smax","possibleIntersection","se1","se2","inter","intersection","nintersections","events","leftCoincide","rightCoincide","compareSegments","le1","le2","subdivide","eventQueue","subject","clipping","sbbox","cbbox","sweepLine","Tree","sortedEvents","rightbound","next","begin","prevEvent","prevprevEvent","prevprev","Contour","orderEvents","resultEvents","sorted","nextPos","processed","origPos","newPos","length","initializeContourFromContext","contours","contourId","contour","prevInResult","lowerContourId","lowerContour","parentContourId","connectEdges","markAsProcessed","initial","tinyqueueModule","TinyQueue","defaultCompare","item","halfLength","best","processPolygon","contourOrHole","depth","isExteriorRing","fillQueue","Queue","polygonSet","ii","jj","EMPTY","trivialOperation","compareBBoxes","boolean","trivial","subdivideSegments","polygons","rings","holeId","distanceSq","serializeTopology","topology","calculateSegmentsBounds","startPoint","xmin","ymin","xmax","ymax","updateBounds","getPieceBounds","piece","minX","minY","maxX","maxY","startingEdgeId","currentEdge","segmentBounds","MAX_CLICK_DISTANCE","MAX_CLICK_DISTANCE_SQ","findClosestVertex","puzzle","clickPos","closestVertexIndex","minDistanceSq","distSq","findClosestSeedPoint","closestPieceId","polygonBounds","polygon","arePointsEqual","generateSegmentsForEdge","edge","tabGenerator","random","heLeft","heRight","edgeStart","edgeEnd","heLeftSegments","currentPos","tab","tabStartPos","tabStartPoint","tabEndPoint","tabSegments","invertSegments","originalStart","inverted","segmentStart","prevSegment","arcToBeziers","radii","rotation","largeArc","sweep","startX","startY","endX","endY","flattenBoundary","boundary","currentPolygon","currentPoint","command","beziers","arcStartPoint","isPointInBoundary","insideCount","poly","isPointInPolygon","isMartinezPolygon","geometry","clipPolygonAgainstBoundary","clipper","clipped","martinez.intersection","isInside","xi","yi","xj","yj","createHalfEdgeLoop","vertices","pieceId","newHalfEdges","vertex","he","numEdges","nextIndex","prevIndex","linkAndCreateEdges","halfEdges","halfEdgeTwinMap","isBoundaryEdgeFn","twinKey","twinId","edgeId","twinHe","selfKey","mulberry32","seed","buildPuzzle","options","pieceSize","pointConfig","pieceConfig","placementConfig","tabConfig","pointGenerator","pieceGenerator","placementStrategy","rebuildPuzzleWithUpdatedSeedPoint","originalPuzzle","newSeedPosition","updatedPoints","pointIndex","drawPuzzle","canvas","pieceColor","pointColor","destination","problemPoint","createRectangleBorder","createCircleBorder","diameter","radius","center","createEllipseBorder","radiusX","radiusY","createRoundedRectBorder","cornerRadius","maxRadius","moveVertex","vertexIndex","oldPos","departingEdges","affectedPieceIDs","delta","departingEdge","predecessorEdge","lastSegment","regenerateAffectedTabs","affectedEdges","movedVertexPos","halfEdgeToEdgeMap","destinationVertex","parentEdge","affectedPieces","he1","he2","REGENERATION_THROTTLE_MS","HOVER_DISTANCE","HOVER_DISTANCE_SQ","Puzzle","state","isNearDraggableItem","mousePos","getEventCoords","rect","touch","getDragTarget","seedPointId","vertexId","handleMouseMove","isNearItem","regeneratePuzzleWithoutTabs","newPosition","previewPuzzle","handleDragStart","target","docEvent","mithrilEvent","handleDragMove","handleDragEnd","now","wasDraggingVertex","wasDraggingSeedPoint","finalPosition","dom","createSVG","pathData","pathD","downloadSvg","svg","filename","blob","url","DownloadPuzzleButton","GeometryCheckIndicator","showProgress","showOKBadge","showProblemBadge","checkbox","calculateDisplayDimensions","originalWidth","originalHeight","maxWidth","aspectRatio","UploadImageButton","file","bitmap","uploadUrl","BooleanInputControl","newValue","NumberInputControl","input","RangeInputControl","StringInputControl","GeneratorPicker","generators","newSelected","panel","value","commonAspectRatios","AspectRatioPicker","isCustom","selectOptions","ratioStr","selectedValue","range","ColorPicker","borderShapes","BorderShapePicker","tinyNDArrayOfInteger","gridShape","dimensions","totalLength","stride","dimension","tinyNDArrayOfArray","tinyNdarray","sphereRandom","sampleSphere","rng","rr","theta","moore","neighbors","neighbor","require$$0","getNeighbourhood","dimensionNumber","neighbourhood","origin","dist","squareDist1","squareDist2","neighbourhoodCache","getNeighbourhoodMemoized","tinyNDArray","require$$1","require$$2","squaredEuclideanDistance","point1","point2","FixedDensityPDS","maxShape","floatPrecisionMitigation","epsilonDistance","valid","internalArrayIndex","neighbourIndex","currentDimensionValue","existingPoint","tries","distance","newPoint","inShape","gridData","fixedDensity","euclideanDistance","VariableDensityPDS","existingPointDistance","pointDistance","minDistance","maxDistance","currentDistance","sampleIndex","variableDensity","PoissonDiskSampling","poissonDiskSampling","Name","PoissonPointUIMetadata","PoissonPointGeneratorFactory","_border","_bounds","_config","runtimeOpts","EPSILON","EDGE_STACK","Delaunator","getX","defaultGetX","getY","defaultGetY","maxTriangles","hullPrev","hullNext","hullTri","hullHash","i0","i1","i2","minDist","i0x","i0y","i1x","i1y","minRadius","circumradius","i2x","i2y","quicksort","hull","d0","circumcenter","hullSize","pseudoAngle","triangles","halfedges","ar","a0","b0","al","bl","pr","pl","inCircle","hbl","br","ex","ey","fx","fy","ap","bp","cp","cl","ids","dists","temp","tempDist","median","swap","Path","x0","y0","w","Polygon","Voronoi","delaunay","vectors","circumcenters","t3","ab","context","buffer","inedges","ti","tj","h0","h1","cell","c0","ci","cj","loop","ai","li","aj","lj","e0","V","P","sx0","sy0","sx1","sy1","flip","vx0","vy0","vxn","vyn","pointX","pointY","collinear","jitter","Delaunay","that","flatArray","flatIterable","hullIndex","_hullIndex","dc","dt","array","createBoundaryContext","calculateCentroid","acc","createPieceFromPolygon","clipCellToBoundary","cellPolygon","boundaryContext","corner","VoronoiPieceGeneratorUIMetadata","pointToKey","isPointNearBoundary","distanceToSegment","segStart","segEnd","lengthSq","projX","projY","VoronoiPieceGeneratorFactory","voronoi","pieceIdCounter","site","clippedVertices","pieceHalfEdges","currentHeId","startHeId","vertexSet","SimpleTabPlacementStrategyUIMetadata","placeTabOnEdge","edgeLength","tabSize","SimpleTabPlacementStrategyFactory","minEdgeLength","maxTabSize","edges","TraditionalTabUIMetadata","createTraditionalTab","jitterPct","heightToWidthRatio","inward","dir","nubHeight","shoulder_height","bez1","bez2","bez3","TraditionalTabGeneratorFactory","checkGeometryInWorker","onProgress","resolve","reject","worker","CheckGeometryWorker","message","GridJitterPointUIMetadata","GridJitterPointGeneratorFactory","RectangularPieceGeneratorUIMetadata","RectangularPieceGeneratorFactory","_points","cols","rows","cellWidth","cellHeight","gridVertices","rowVertices","topLeft","topRight","bottomLeft","bottomRight","pieceVertices","isClose","val","onTop","onRight","onBottom","onLeft","NullTabUIMetadata","NullTabGeneratorFactory","_start","_end","_tab","_random","TriangleTabUIMetadata","TriangleTabGeneratorFactory","edgeVector","edgeDir","normalDir","midPoint","direction","tabHeight","nubPoint","isDarkMode","configureDarkLightTheme","darkModeQuery","manageDarkLightTheme","Page","defaultPointGenerator","PoissonGeneratorName","defaultPieceGenerator","VoronoiGeneratorName","defaultTabGenerator","TraditionalTabGeneratorName","SimpleTabPlacementStrategyName","createBorder","canvasWidth","canvasHeight","borderShape","borderCornerRadius","handleCheckGeometry","total","problems","autocheck","imageUrl","newColor","type","generatorName","registerIconLibrary","match"],"mappings":"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","x_google_ignoreList":[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,46,47,48,49,50,51,52,54,55,56,57,58,59,60]}