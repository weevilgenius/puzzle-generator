import{m as y,g as He}from"./mithril-DD6GaBKN.js";import{r as Ve}from"./shoelace-BEtx4ju6.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))r(n);new MutationObserver(n=>{for(const t of n)if(t.type==="childList")for(const s of t.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&r(s)}).observe(document,{childList:!0,subtree:!0});function i(n){const t={};return n.integrity&&(t.integrity=n.integrity),n.referrerPolicy&&(t.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?t.credentials="include":n.crossOrigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function r(n){if(n.ep)return;n.ep=!0;const t=i(n);fetch(n.href,t)}})();const qe={view:({attrs:a})=>y("a.github-corner",{href:a.link,"aria-label":"View source on GitHub",title:"View source on GitHub",target:"_blank"},y("svg",{width:80,height:80,viewBox:"0 0 250 250","aria-hidden":"true"},[y("path",{d:"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"}),y("path.octo-arm",{fill:"currentColor",style:"transform-origin: 130px 106px;",d:"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"}),y("path.octo-body",{fill:"currentColor",d:"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"})]))};class ge{generators=new Map;register(e,i,r){this.generators.has(e)&&console.warn(`Generator "${e}" is already registered, overwriting`),this.generators.set(e,{factory:i,uiMetadata:r})}create(e,i,r){const n=this.generators.get(r.name);if(!n)throw new Error(`Unknown generator "${r.name}". Is it registered?`);return n.factory(e,i,r)}getAvailableGenerators(){return Array.from(this.generators.values()).sort((e,i)=>e.uiMetadata.sortHint-i.uiMetadata.sortHint).map(e=>({name:e.uiMetadata.name,displayName:e.uiMetadata.displayName}))}getUIMetadata(e){return this.generators.get(e)?.uiMetadata}getDefaultConfig(e,i,r){const n={name:e,width:i,height:r},t=this.getUIMetadata(e);if(t)for(const s of t.controls)n[s.name]=s.defaultValue;return n}}const Y=new ge,J=new ge,O=new ge;function je(a){return function(){let e=a+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}async function ye(a){const{width:e,height:i,pieceSize:r}=a,{pointConfig:n,pieceConfig:t,tabConfig:s}=a;console.log(`rebuilding puzzle with dimensions ${e}x${i}, piece size ${r}`);const o=Y.create(e,i,n),l=J.create(e,i,t),h=O.create(e,i,s),u=a.seed??new Date().getTime(),c=je(u),d=o.generatePoints({width:e,height:i,pieceSize:r,random:c});console.log(`Generated ${d.length} points`);const g=l.generatePieces(d,{random:c,pieceSize:r});console.log(`Generated ${g.pieces.size} pieces`);for(const p of g.edges.values())p.heRight!==-1&&h.addTab(p,{topology:g,random:c});return{created:new Date().toISOString(),seed:u,width:e,height:i,vertices:g.vertices,boundary:g.boundary,pieces:g.pieces,edges:g.edges,halfEdges:g.halfEdges}}function we(a,e,i,r=!1){const n=e.getContext("2d");if(!n){console.error("Could not get 2D context from canvas");return}n.clearRect(0,0,e.width,e.height);{n.strokeStyle=i,n.lineWidth=1,n.beginPath();for(const t of a.edges.values()){const s=a.halfEdges.get(t.heLeft);if(s)if(n.moveTo(s.origin[0],s.origin[1]),s.segments)for(const o of s.segments)switch(o.type){case"bezier":n.bezierCurveTo(o.p1[0],o.p1[1],o.p2[0],o.p2[1],o.p3[0],o.p3[1]);break;case"line":n.lineTo(o.p[0],o.p[1]);break}else{let o;s.twin!==-1?o=a.halfEdges.get(s.twin).origin:o=a.halfEdges.get(s.next).origin,n.lineTo(o[0],o[1])}}n.stroke()}if(a.problems&&a.problems.length>0){n.lineWidth=2,n.strokeStyle="red";for(const t of a.problems){const[s,o]=t;n.beginPath(),n.arc(s,o,8,0,2*Math.PI),n.stroke()}}if(r){n.fillStyle="blue";for(const t of a.pieces.values()){const[s,o]=t.site;n.beginPath(),n.arc(s,o,3,0,2*Math.PI),n.fill()}}}const We=()=>{const a={canvas:null};return{oncreate:({dom:e,attrs:i})=>{if(a.canvas=e.querySelector("canvas.puzzle"),!a.canvas){console.log("couldn't get canvas element");return}i.isDirty||we(i.puzzle,a.canvas,i.color)},onupdate:({attrs:e})=>{if(!a.canvas){console.log("couldn't get canvas element");return}e.isDirty||we(e.puzzle,a.canvas,e.color)},view:({attrs:e})=>y(".puzzle-stack",[y("img.background",{width:e.width,height:e.height,src:e.imageUrl}),y("canvas.puzzle",{width:e.width,height:e.height,style:{width:`${e.width}px`,height:`${e.height}px`}})])}};function Oe(a,e,i,r="black"){const t=[];for(const l of a.edges.values()){const h=a.halfEdges.get(l.heLeft);if(h)if(t.push(`M ${h.origin[0].toFixed(3)} ${h.origin[1].toFixed(3)}`),h.segments)for(const u of h.segments)switch(u.type){case"bezier":t.push(`C ${u.p1[0].toFixed(3)} ${u.p1[1].toFixed(3)}, ${u.p2[0].toFixed(3)} ${u.p2[1].toFixed(3)}, ${u.p3[0].toFixed(3)} ${u.p3[1].toFixed(3)}`);break;case"line":t.push(`L ${u.p[0].toFixed(3)} ${u.p[1].toFixed(3)}`);break}else{let u;h.twin!==-1?u=a.halfEdges.get(h.twin).origin:u=a.halfEdges.get(h.next).origin,t.push(`L ${u[0].toFixed(3)} ${u[1].toFixed(3)}`)}}const s=t.join(" ");return`
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg
  width="${e}"
  height="${i}"
  viewBox="0 0 ${e} ${i}"
  xmlns="http://www.w3.org/2000/svg"
  version="1.1"
>
  <path
    d="${s}"
    fill="none"
    stroke="${r}"
    stroke-width="1"
    vector-effect="non-scaling-stroke"
  />
</svg>`.trim().replace(/\r\n/g,`
`)}function Be(a,e="puzzle.svg"){const i=new Blob([a],{type:"image/svg+xml"}),r=URL.createObjectURL(i),n=document.createElement("a");n.href=r,n.download=e,n.hidden=!0,document.body.appendChild(n),n.click(),document.body.removeChild(n),setTimeout(()=>URL.revokeObjectURL(r),100)}const Ke={view:({attrs:a})=>y("sl-button.download-svg",{onclick:()=>{const e=Oe(a.puzzle,a.width,a.height,a.color);Be(e,a.filename??"puzzle.svg")}},"Download SVG")},Ye={view:({attrs:a})=>{const e=a.progressPercent!==void 0&&a.progressPercent<100,i=!e&&a.problems!==void 0&&a.problems==0,r=!e&&a.problems!==void 0&&a.problems>0;return y(".geometry-check-indicator",[y(".label","Geometry Check:"),y("sl-tooltip",{content:"Check geometry now"},y("sl-icon-button.check-now",{library:"material",name:"editor_choice",label:"Check geometry now",disabled:e,onclick:n=>{n.redraw=!1,a.onCheckRequested?.()}})),y("sl-tooltip",{content:"Check geometry after every change"},y("sl-checkbox",{checked:a.autoCheck,disabled:e,size:"small","onsl-change":n=>{n.redraw=!1;const t=n.target;a.onAutocheckChanged?.(t.checked)}},"auto check")),e&&y("sl-progress-bar",{label:"Geometry check progress",value:a.progressPercent??0}),i&&y("sl-badge",{variant:"success",pill:!0},"OK"),r&&y("sl-badge",{variant:"danger",pill:!0},`${a.problems} issues`)])}};function Je(a,e,i=800){if(a<=i)return{width:a,height:e};const r=e/a;return{width:i,height:Math.round(i*r)}}const Xe=()=>{const a={inputElement:void 0};return{view:({attrs:e})=>[y("sl-button.upload-button",{disabled:e.disabled===!0,onclick:()=>{a.inputElement&&a.inputElement.click()}},e.label??"Upload Image"),y("input[type=file]",{style:{display:"none"},accept:"image/*",oncreate:({dom:i})=>{a.inputElement=i},onchange:i=>{if(i.redraw=!1,a.inputElement){const r=a.inputElement.files?.[0];r?.type.startsWith("image/")&&createImageBitmap(r).then(n=>{const{width:t,height:s}=Je(n.width,n.height),o=URL.createObjectURL(r);n.close(),e.onUpload(o,r.name,t,s)}).catch(n=>{console.error("could not create a bitmap image: ",n)})}}})]}},Qe=()=>({view:({attrs:a})=>y("sl-checkbox.boolean-input",{"help-text":a.config.helpText,disabled:a.disabled,checked:a.value,"onsl-change":e=>{const r=e.target.checked;a.onChange(r)}},a.config.label)}),ce=()=>({view:({attrs:a})=>y("sl-input.number-input",{label:a.config.label,"help-text":a.config.helpText,type:"number",inputmode:"numeric",size:"small",disabled:a.disabled,value:a.value,min:a.config.min,max:a.config.max,"onsl-change":e=>{const r=e.target.valueAsNumber;a.onChange(isNaN(r)?void 0:r)}})}),Ze=()=>({view:({attrs:a})=>y("sl-range.range-input",{label:a.config.label,"help-text":a.config.helpText,disabled:a.disabled,value:a.value,min:a.config.min,max:a.config.max,step:a.config.step,"onsl-change":e=>{const r=e.target.value;a.onChange(isNaN(r)?void 0:r)}})}),et=()=>({view:({attrs:a})=>y("sl-input.string-input",{label:a.config.label,"help-text":a.config.helpText,type:"text",inputmode:"text",size:"small",disabled:a.disabled,value:a.value,"onsl-change":e=>{const r=e.target.value;a.onChange(r.length>0?r:void 0)}})}),tt=()=>({oncreate:({dom:a,attrs:e})=>{a.querySelector("sl-tab-group").show(e.generator)},onupdate:({dom:a,attrs:e})=>{a.querySelector("sl-tab-group").show(e.generator)},view:({attrs:a})=>{const e=a.registry.getAvailableGenerators();return y(".generator-picker",y("sl-tab-group",{"onsl-tab-show":i=>{const r=i.detail.name;a.generator!==r&&a.onGeneratorChange(r)}},[...e.map(i=>{const r=a.registry.getUIMetadata(i.name),n=y("sl-tab",{slot:"nav",panel:i.name},i.displayName),t=y("sl-tab-panel",{name:i.name},y(".controls",[r?.description?y("p",r.description):null,...r?.controls.map(s=>{switch(s.type){case"range":return y(Ze,{config:s,value:a.config?.[s.name]??s.defaultValue,onChange:o=>{a.onConfigChange(s.name,o)}});case"boolean":return y(Qe,{config:s,value:(a.config?.[s.name]??s.defaultValue)===!0,onChange:o=>{a.onConfigChange(s.name,o)}});case"number":return y(ce,{config:s,value:a.config?.[s.name]??s.defaultValue,onChange:o=>{a.onConfigChange(s.name,o)}});case"string":return y(et,{config:s,value:a.config?.[s.name]??s.defaultValue,onChange:o=>{a.onConfigChange(s.name,o)}})}})??[],!r?.description&&r?.controls.length==0?y("p","No controls for this strategy."):null]));return[n,t]})]))}}),ve=[["Square","1:1",1],["Classic Photo","5:4",5/4],["Standard Photo","4:3",4/3],["35mm/DSLR","3:2",3/2],["Widescreen","16:9",16/9],["UltraWide","21:9",21/9],["Panorama","2:1",2/1],["Instagram Portrait","4:5",4/5],["Classic Portrait","3:4",3/4],["DSLR Portrait","2:3",2/3],["Phone Portrait","9:16",9/16],["Tall Poster","9:21",9/21],["Tall Panorama","1:2",1/2]],nt={view:({attrs:a})=>{const e=!ve.some(([,,r])=>r===a.ratio),i=ve.map(([r,n,t])=>y("sl-option",{value:String(t)},`${r} [${n}]`));return e&&i.unshift(y("sl-option",{value:"custom"},"Custom")),y(".aspect-ratio-picker",[y("sl-select",{label:"Aspect Ratio",size:"small",disabled:a.disabled,value:e?"custom":String(a.ratio),"onsl-change":r=>{r.redraw=!1;const t=r.target.value;t&&t!=="custom"&&a.onChange(Number(t))}},i),y("sl-range",{min:.25,max:4,step:.01,disabled:a.disabled,value:a.ratio,"onsl-change":r=>{r.redraw=!1;const n=r.target;a.onChange(n.value)}})])}},it={view:({attrs:a})=>y(".color-picker",[y(".label",a.label),y("sl-color-picker",{label:"Select a color",value:a.color,size:a.size??"medium",format:"rgb","onsl-change":e=>{e.redraw=!1;const i=e.target;a.onUpdate(i.value)}})])};var te,Pe;function Ge(){if(Pe)return te;Pe=1;function a(i){var r=i.length,n=1,t=new Array(r),s;for(s=r;s>0;s--)t[s-1]=n,n=n*i[s-1];return{stride:t,data:new Uint32Array(n)}}function e(i){var r=i.length,n=1,t=new Array(r),s=[],o,l;for(o=r;o>0;o--)t[o-1]=n,n=n*i[o-1];for(l=0;l<n;l++)s.push([]);return{stride:t,data:s}}return te={integer:a,array:e},te}var ne,_e;function Ee(){if(_e)return ne;_e=1,ne=a;function a(e,i){var r=new Array(e),n=Math.floor(e/2)<<1,t=0,s,o,l,h,u;for(u=0;u<n;u+=2)s=-2*Math.log(i()),o=Math.sqrt(s),l=2*Math.PI*i(),t+=s,r[u]=o*Math.cos(l),r[u+1]=o*Math.sin(l);if(e%2){var c=Math.sqrt(-2*Math.log(i()))*Math.cos(2*Math.PI*i());r[e-1]=c,t+=Math.pow(c,2)}for(h=1/Math.sqrt(t),u=0;u<e;++u)r[u]*=h;return r}return ne}var ie,xe;function st(){return xe||(xe=1,ie=function(e,i){e=e||1,i=i||2;for(var r=e*2+1,n=Math.pow(r,i)-1,t=new Array(n),s=0;s<n;s++)for(var o=t[s]=new Array(i),l=s<n/2?s:s+1,h=1;h<=i;h++){var u=l%Math.pow(r,h);o[h-1]=u/Math.pow(r,h-1)-e,l-=u}return t}),ie}var se,De;function $e(){if(De)return se;De=1;var a=st();function e(n){var t=a(2,n),s=[],o;for(t=t.filter(function(l){for(var h=0,u=0;u<n;u++)h+=Math.pow(Math.max(0,Math.abs(l[u])-1),2);return h<n}),o=0;o<n;o++)s.push(0);return t.push(s),t.sort(function(l,h){var u=0,c=0,d;for(d=0;d<n;d++)u+=Math.pow(l[d],2),c+=Math.pow(h[d],2);return u<c?-1:u>c?1:0}),t}var i={};function r(n){return i[n]||(i[n]=e(n)),i[n]}return se=r,se}var oe,Me;function ot(){if(Me)return oe;Me=1;var a=Ge().integer,e=Ee(),i=$e();function r(t,s){for(var o=0,l=0;l<t.length;l++)o+=Math.pow(t[l]-s[l],2);return o}function n(t,s){if(typeof t.distanceFunction=="function")throw new Error("PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction");this.shape=t.shape,this.minDistance=t.minDistance,this.maxDistance=t.maxDistance||t.minDistance*2,this.maxTries=Math.ceil(Math.max(1,t.tries||30)),this.rng=s||Math.random;for(var o=0,l=0;l<this.shape.length;l++)o=Math.max(o,this.shape[l]);var h=Math.max(1,o/128|0),u=1e-14*h;this.dimension=this.shape.length,this.squaredMinDistance=this.minDistance*this.minDistance,this.minDistancePlusEpsilon=this.minDistance+u,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.minDistance/Math.sqrt(this.dimension),this.neighbourhood=i(this.dimension),this.currentPoint=null,this.processList=[],this.samplePoints=[],this.gridShape=[];for(var l=0;l<this.dimension;l++)this.gridShape.push(Math.ceil(this.shape[l]/this.cellSize));this.grid=a(this.gridShape)}return n.prototype.shape=null,n.prototype.dimension=null,n.prototype.minDistance=null,n.prototype.maxDistance=null,n.prototype.minDistancePlusEpsilon=null,n.prototype.squaredMinDistance=null,n.prototype.deltaDistance=null,n.prototype.cellSize=null,n.prototype.maxTries=null,n.prototype.rng=null,n.prototype.neighbourhood=null,n.prototype.currentPoint=null,n.prototype.processList=null,n.prototype.samplePoints=null,n.prototype.gridShape=null,n.prototype.grid=null,n.prototype.addRandomPoint=function(){for(var t=new Array(this.dimension),s=0;s<this.dimension;s++)t[s]=this.rng()*this.shape[s];return this.directAddPoint(t)},n.prototype.addPoint=function(t){var s,o=!0;if(t.length===this.dimension)for(s=0;s<this.dimension&&o;s++)o=t[s]>=0&&t[s]<this.shape[s];else o=!1;return o?this.directAddPoint(t):null},n.prototype.directAddPoint=function(t){var s=0,o=this.grid.stride,l;for(this.processList.push(t),this.samplePoints.push(t),l=0;l<this.dimension;l++)s+=(t[l]/this.cellSize|0)*o[l];return this.grid.data[s]=this.samplePoints.length,t},n.prototype.inNeighbourhood=function(t){var s=this.dimension,o=this.grid.stride,l,h,u,c,d;for(l=0;l<this.neighbourhood.length;l++){for(h=0,u=0;u<s;u++){if(c=(t[u]/this.cellSize|0)+this.neighbourhood[l][u],c<0||c>=this.gridShape[u]){h=-1;break}h+=c*o[u]}if(h!==-1&&this.grid.data[h]!==0&&(d=this.samplePoints[this.grid.data[h]-1],r(t,d)<this.squaredMinDistance))return!0}return!1},n.prototype.next=function(){for(var t,s,o,l,h,u,c;this.processList.length>0;){for(this.currentPoint===null&&(this.currentPoint=this.processList.shift()),l=this.currentPoint,t=0;t<this.maxTries;t++){for(u=!0,o=this.minDistancePlusEpsilon+this.deltaDistance*this.rng(),this.dimension===2?(s=this.rng()*Math.PI*2,h=[Math.cos(s),Math.sin(s)]):h=e(this.dimension,this.rng),c=0;u&&c<this.dimension;c++)h[c]=l[c]+h[c]*o,u=h[c]>=0&&h[c]<this.shape[c];if(u&&!this.inNeighbourhood(h))return this.directAddPoint(h)}t===this.maxTries&&(this.currentPoint=null)}return null},n.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},n.prototype.getAllPoints=function(){return this.samplePoints},n.prototype.getAllPointsWithDistance=function(){throw new Error("PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation")},n.prototype.reset=function(){var t=this.grid.data,s=0;for(s=0;s<t.length;s++)t[s]=0;this.samplePoints=[],this.currentPoint=null,this.processList.length=0},oe=n,oe}var re,ke;function rt(){if(ke)return re;ke=1;var a=Ge().array,e=Ee(),i=$e();function r(t,s){for(var o=0,l=0;l<t.length;l++)o+=Math.pow(t[l]-s[l],2);return Math.sqrt(o)}function n(t,s){if(typeof t.distanceFunction!="function")throw new Error("PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction");this.shape=t.shape,this.minDistance=t.minDistance,this.maxDistance=t.maxDistance||t.minDistance*2,this.maxTries=Math.ceil(Math.max(1,t.tries||30)),this.distanceFunction=t.distanceFunction,this.bias=Math.max(0,Math.min(1,t.bias||0)),this.rng=s||Math.random;for(var o=0,l=0;l<this.shape.length;l++)o=Math.max(o,this.shape[l]);var h=Math.max(1,o/128|0),u=1e-14*h;this.dimension=this.shape.length,this.minDistancePlusEpsilon=this.minDistance+u,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.maxDistance/Math.sqrt(this.dimension),this.neighbourhood=i(this.dimension),this.currentPoint=null,this.currentDistance=0,this.processList=[],this.samplePoints=[],this.sampleDistance=[],this.gridShape=[];for(var l=0;l<this.dimension;l++)this.gridShape.push(Math.ceil(this.shape[l]/this.cellSize));this.grid=a(this.gridShape)}return n.prototype.shape=null,n.prototype.dimension=null,n.prototype.minDistance=null,n.prototype.maxDistance=null,n.prototype.minDistancePlusEpsilon=null,n.prototype.deltaDistance=null,n.prototype.cellSize=null,n.prototype.maxTries=null,n.prototype.distanceFunction=null,n.prototype.bias=null,n.prototype.rng=null,n.prototype.neighbourhood=null,n.prototype.currentPoint=null,n.prototype.currentDistance=null,n.prototype.processList=null,n.prototype.samplePoints=null,n.prototype.sampleDistance=null,n.prototype.gridShape=null,n.prototype.grid=null,n.prototype.addRandomPoint=function(){for(var t=new Array(this.dimension),s=0;s<this.dimension;s++)t[s]=this.rng()*this.shape[s];return this.directAddPoint(t)},n.prototype.addPoint=function(t){var s,o=!0;if(t.length===this.dimension)for(s=0;s<this.dimension&&o;s++)o=t[s]>=0&&t[s]<this.shape[s];else o=!1;return o?this.directAddPoint(t):null},n.prototype.directAddPoint=function(t){var s=0,o=this.grid.stride,l=this.samplePoints.length,h;for(this.processList.push(l),this.samplePoints.push(t),this.sampleDistance.push(this.distanceFunction(t)),h=0;h<this.dimension;h++)s+=(t[h]/this.cellSize|0)*o[h];return this.grid.data[s].push(l),t},n.prototype.inNeighbourhood=function(t){var s=this.dimension,o=this.grid.stride,l,h,u,c,d,g,f=this.distanceFunction(t);for(l=0;l<this.neighbourhood.length;l++){for(h=0,u=0;u<s;u++){if(c=(t[u]/this.cellSize|0)+this.neighbourhood[l][u],c<0||c>=this.gridShape[u]){h=-1;break}h+=c*o[u]}if(h!==-1&&this.grid.data[h].length>0)for(var p=0;p<this.grid.data[h].length;p++){d=this.samplePoints[this.grid.data[h][p]],g=this.sampleDistance[this.grid.data[h][p]];var b=Math.min(g,f),m=Math.max(g,f),w=b+(m-b)*this.bias;if(r(t,d)<this.minDistance+this.deltaDistance*w)return!0}}return!1},n.prototype.next=function(){for(var t,s,o,l,h,u,c,d;this.processList.length>0;){if(this.currentPoint===null){var g=this.processList.shift();this.currentPoint=this.samplePoints[g],this.currentDistance=this.sampleDistance[g]}for(l=this.currentPoint,h=this.currentDistance,t=0;t<this.maxTries;t++){for(c=!0,o=this.minDistancePlusEpsilon+this.deltaDistance*(h+(1-h)*this.bias),this.dimension===2?(s=this.rng()*Math.PI*2,u=[Math.cos(s),Math.sin(s)]):u=e(this.dimension,this.rng),d=0;c&&d<this.dimension;d++)u[d]=l[d]+u[d]*o,c=u[d]>=0&&u[d]<this.shape[d];if(c&&!this.inNeighbourhood(u))return this.directAddPoint(u)}t===this.maxTries&&(this.currentPoint=null)}return null},n.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},n.prototype.getAllPoints=function(){return this.samplePoints},n.prototype.getAllPointsWithDistance=function(){var t=new Array(this.samplePoints.length),s=0,o=0,l;for(s=0;s<this.samplePoints.length;s++){for(l=new Array(this.dimension+1),o=0;o<this.dimension;o++)l[o]=this.samplePoints[s][o];l[this.dimension]=this.sampleDistance[s],t[s]=l}return t},n.prototype.reset=function(){var t=this.grid.data,s=0;for(s=0;s<t.length;s++)t[s]=[];this.samplePoints=[],this.currentPoint=null,this.processList.length=0},re=n,re}var ae,Te;function at(){if(Te)return ae;Te=1;var a=ot(),e=rt();function i(r,n){this.shape=r.shape,typeof r.distanceFunction=="function"?this.implementation=new e(r,n):this.implementation=new a(r,n)}return i.prototype.implementation=null,i.prototype.addRandomPoint=function(){return this.implementation.addRandomPoint()},i.prototype.addPoint=function(r){return this.implementation.addPoint(r)},i.prototype.next=function(){return this.implementation.next()},i.prototype.fill=function(){return this.implementation.fill()},i.prototype.getAllPoints=function(){return this.implementation.getAllPoints()},i.prototype.getAllPointsWithDistance=function(){return this.implementation.getAllPointsWithDistance()},i.prototype.reset=function(){this.implementation.reset()},ae=i,ae}var lt=at();const ht=He(lt),pe="PoissonPointGenerator",ct={name:pe,displayName:"Poisson",description:"Generate seed points using Poisson disk sampling. The algorithm produces points that are tightly-packed, but no closer to each other than a specified minimum distance (the piece size), resulting in a natural, organic look.",sortHint:1,controls:[]},ut=(a,e,i)=>({generatePoints(n){const{width:t,height:s,pieceSize:o,random:l}=n;return new ht({shape:[t,s],minDistance:o,tries:20},l).fill()}});Y.register(pe,ut,ct);const N=11102230246251565e-32,L=134217729,dt=(3+8*N)*N;function le(a,e,i,r,n){let t,s,o,l,h=e[0],u=r[0],c=0,d=0;u>h==u>-h?(t=h,h=e[++c]):(t=u,u=r[++d]);let g=0;if(c<a&&d<i)for(u>h==u>-h?(s=h+t,o=t-(s-h),h=e[++c]):(s=u+t,o=t-(s-u),u=r[++d]),t=s,o!==0&&(n[g++]=o);c<a&&d<i;)u>h==u>-h?(s=t+h,l=s-t,o=t-(s-l)+(h-l),h=e[++c]):(s=t+u,l=s-t,o=t-(s-l)+(u-l),u=r[++d]),t=s,o!==0&&(n[g++]=o);for(;c<a;)s=t+h,l=s-t,o=t-(s-l)+(h-l),h=e[++c],t=s,o!==0&&(n[g++]=o);for(;d<i;)s=t+u,l=s-t,o=t-(s-l)+(u-l),u=r[++d],t=s,o!==0&&(n[g++]=o);return(t!==0||g===0)&&(n[g++]=t),g}function gt(a,e){let i=e[0];for(let r=1;r<a;r++)i+=e[r];return i}function X(a){return new Float64Array(a)}const pt=(3+16*N)*N,ft=(2+12*N)*N,mt=(9+64*N)*N*N,q=X(4),Ce=X(8),ze=X(12),Se=X(16),R=X(4);function bt(a,e,i,r,n,t,s){let o,l,h,u,c,d,g,f,p,b,m,w,P,_,M,S,T,z;const v=a-n,k=i-n,D=e-t,x=r-t;_=v*x,d=L*v,g=d-(d-v),f=v-g,d=L*x,p=d-(d-x),b=x-p,M=f*b-(_-g*p-f*p-g*b),S=D*k,d=L*D,g=d-(d-D),f=D-g,d=L*k,p=d-(d-k),b=k-p,T=f*b-(S-g*p-f*p-g*b),m=M-T,c=M-m,q[0]=M-(m+c)+(c-T),w=_+m,c=w-_,P=_-(w-c)+(m-c),m=P-S,c=P-m,q[1]=P-(m+c)+(c-S),z=w+m,c=z-w,q[2]=w-(z-c)+(m-c),q[3]=z;let I=gt(4,q),G=ft*s;if(I>=G||-I>=G||(c=a-v,o=a-(v+c)+(c-n),c=i-k,h=i-(k+c)+(c-n),c=e-D,l=e-(D+c)+(c-t),c=r-x,u=r-(x+c)+(c-t),o===0&&l===0&&h===0&&u===0)||(G=mt*s+dt*Math.abs(I),I+=v*u+x*o-(D*h+k*l),I>=G||-I>=G))return I;_=o*x,d=L*o,g=d-(d-o),f=o-g,d=L*x,p=d-(d-x),b=x-p,M=f*b-(_-g*p-f*p-g*b),S=l*k,d=L*l,g=d-(d-l),f=l-g,d=L*k,p=d-(d-k),b=k-p,T=f*b-(S-g*p-f*p-g*b),m=M-T,c=M-m,R[0]=M-(m+c)+(c-T),w=_+m,c=w-_,P=_-(w-c)+(m-c),m=P-S,c=P-m,R[1]=P-(m+c)+(c-S),z=w+m,c=z-w,R[2]=w-(z-c)+(m-c),R[3]=z;const E=le(4,q,4,R,Ce);_=v*u,d=L*v,g=d-(d-v),f=v-g,d=L*u,p=d-(d-u),b=u-p,M=f*b-(_-g*p-f*p-g*b),S=D*h,d=L*D,g=d-(d-D),f=D-g,d=L*h,p=d-(d-h),b=h-p,T=f*b-(S-g*p-f*p-g*b),m=M-T,c=M-m,R[0]=M-(m+c)+(c-T),w=_+m,c=w-_,P=_-(w-c)+(m-c),m=P-S,c=P-m,R[1]=P-(m+c)+(c-S),z=w+m,c=z-w,R[2]=w-(z-c)+(m-c),R[3]=z;const C=le(E,Ce,4,R,ze);_=o*u,d=L*o,g=d-(d-o),f=o-g,d=L*u,p=d-(d-u),b=u-p,M=f*b-(_-g*p-f*p-g*b),S=l*h,d=L*l,g=d-(d-l),f=l-g,d=L*h,p=d-(d-h),b=h-p,T=f*b-(S-g*p-f*p-g*b),m=M-T,c=M-m,R[0]=M-(m+c)+(c-T),w=_+m,c=w-_,P=_-(w-c)+(m-c),m=P-S,c=P-m,R[1]=P-(m+c)+(c-S),z=w+m,c=z-w,R[2]=w-(z-c)+(m-c),R[3]=z;const A=le(C,ze,4,R,Se);return Se[A-1]}function Q(a,e,i,r,n,t){const s=(e-t)*(i-n),o=(a-n)*(r-t),l=s-o,h=Math.abs(s+o);return Math.abs(l)>=pt*h?l:-bt(a,e,i,r,n,t,h)}const Ie=Math.pow(2,-52),Z=new Uint32Array(512);class ee{static from(e,i=_t,r=xt){const n=e.length,t=new Float64Array(n*2);for(let s=0;s<n;s++){const o=e[s];t[2*s]=i(o),t[2*s+1]=r(o)}return new ee(t)}constructor(e){const i=e.length>>1;if(i>0&&typeof e[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=e;const r=Math.max(2*i-5,0);this._triangles=new Uint32Array(r*3),this._halfedges=new Int32Array(r*3),this._hashSize=Math.ceil(Math.sqrt(i)),this._hullPrev=new Uint32Array(i),this._hullNext=new Uint32Array(i),this._hullTri=new Uint32Array(i),this._hullHash=new Int32Array(this._hashSize),this._ids=new Uint32Array(i),this._dists=new Float64Array(i),this.update()}update(){const{coords:e,_hullPrev:i,_hullNext:r,_hullTri:n,_hullHash:t}=this,s=e.length>>1;let o=1/0,l=1/0,h=-1/0,u=-1/0;for(let v=0;v<s;v++){const k=e[2*v],D=e[2*v+1];k<o&&(o=k),D<l&&(l=D),k>h&&(h=k),D>u&&(u=D),this._ids[v]=v}const c=(o+h)/2,d=(l+u)/2;let g,f,p;for(let v=0,k=1/0;v<s;v++){const D=he(c,d,e[2*v],e[2*v+1]);D<k&&(g=v,k=D)}const b=e[2*g],m=e[2*g+1];for(let v=0,k=1/0;v<s;v++){if(v===g)continue;const D=he(b,m,e[2*v],e[2*v+1]);D<k&&D>0&&(f=v,k=D)}let w=e[2*f],P=e[2*f+1],_=1/0;for(let v=0;v<s;v++){if(v===g||v===f)continue;const k=vt(b,m,w,P,e[2*v],e[2*v+1]);k<_&&(p=v,_=k)}let M=e[2*p],S=e[2*p+1];if(_===1/0){for(let D=0;D<s;D++)this._dists[D]=e[2*D]-e[0]||e[2*D+1]-e[1];W(this._ids,this._dists,0,s-1);const v=new Uint32Array(s);let k=0;for(let D=0,x=-1/0;D<s;D++){const I=this._ids[D],G=this._dists[I];G>x&&(v[k++]=I,x=G)}this.hull=v.subarray(0,k),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(Q(b,m,w,P,M,S)<0){const v=f,k=w,D=P;f=p,w=M,P=S,p=v,M=k,S=D}const T=Pt(b,m,w,P,M,S);this._cx=T.x,this._cy=T.y;for(let v=0;v<s;v++)this._dists[v]=he(e[2*v],e[2*v+1],T.x,T.y);W(this._ids,this._dists,0,s-1),this._hullStart=g;let z=3;r[g]=i[p]=f,r[f]=i[g]=p,r[p]=i[f]=g,n[g]=0,n[f]=1,n[p]=2,t.fill(-1),t[this._hashKey(b,m)]=g,t[this._hashKey(w,P)]=f,t[this._hashKey(M,S)]=p,this.trianglesLen=0,this._addTriangle(g,f,p,-1,-1,-1);for(let v=0,k,D;v<this._ids.length;v++){const x=this._ids[v],I=e[2*x],G=e[2*x+1];if(v>0&&Math.abs(I-k)<=Ie&&Math.abs(G-D)<=Ie||(k=I,D=G,x===g||x===f||x===p))continue;let E=0;for(let V=0,Fe=this._hashKey(I,G);V<this._hashSize&&(E=t[(Fe+V)%this._hashSize],!(E!==-1&&E!==r[E]));V++);E=i[E];let C=E,A;for(;A=r[C],Q(I,G,e[2*C],e[2*C+1],e[2*A],e[2*A+1])>=0;)if(C=A,C===E){C=-1;break}if(C===-1)continue;let U=this._addTriangle(C,x,r[C],-1,-1,n[C]);n[x]=this._legalize(U+2),n[C]=U,z++;let $=r[C];for(;A=r[$],Q(I,G,e[2*$],e[2*$+1],e[2*A],e[2*A+1])<0;)U=this._addTriangle($,x,A,n[x],-1,n[$]),n[x]=this._legalize(U+2),r[$]=$,z--,$=A;if(C===E)for(;A=i[C],Q(I,G,e[2*A],e[2*A+1],e[2*C],e[2*C+1])<0;)U=this._addTriangle(A,x,C,-1,n[C],n[A]),this._legalize(U+2),n[A]=U,r[C]=C,z--,C=A;this._hullStart=i[x]=C,r[C]=i[$]=x,r[x]=$,t[this._hashKey(I,G)]=x,t[this._hashKey(e[2*C],e[2*C+1])]=C}this.hull=new Uint32Array(z);for(let v=0,k=this._hullStart;v<z;v++)this.hull[v]=k,k=r[k];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(e,i){return Math.floor(yt(e-this._cx,i-this._cy)*this._hashSize)%this._hashSize}_legalize(e){const{_triangles:i,_halfedges:r,coords:n}=this;let t=0,s=0;for(;;){const o=r[e],l=e-e%3;if(s=l+(e+2)%3,o===-1){if(t===0)break;e=Z[--t];continue}const h=o-o%3,u=l+(e+1)%3,c=h+(o+2)%3,d=i[s],g=i[e],f=i[u],p=i[c];if(wt(n[2*d],n[2*d+1],n[2*g],n[2*g+1],n[2*f],n[2*f+1],n[2*p],n[2*p+1])){i[e]=p,i[o]=d;const m=r[c];if(m===-1){let P=this._hullStart;do{if(this._hullTri[P]===c){this._hullTri[P]=e;break}P=this._hullPrev[P]}while(P!==this._hullStart)}this._link(e,m),this._link(o,r[s]),this._link(s,c);const w=h+(o+1)%3;t<Z.length&&(Z[t++]=w)}else{if(t===0)break;e=Z[--t]}}return s}_link(e,i){this._halfedges[e]=i,i!==-1&&(this._halfedges[i]=e)}_addTriangle(e,i,r,n,t,s){const o=this.trianglesLen;return this._triangles[o]=e,this._triangles[o+1]=i,this._triangles[o+2]=r,this._link(o,n),this._link(o+1,t),this._link(o+2,s),this.trianglesLen+=3,o}}function yt(a,e){const i=a/(Math.abs(a)+Math.abs(e));return(e>0?3-i:1+i)/4}function he(a,e,i,r){const n=a-i,t=e-r;return n*n+t*t}function wt(a,e,i,r,n,t,s,o){const l=a-s,h=e-o,u=i-s,c=r-o,d=n-s,g=t-o,f=l*l+h*h,p=u*u+c*c,b=d*d+g*g;return l*(c*b-p*g)-h*(u*b-p*d)+f*(u*g-c*d)<0}function vt(a,e,i,r,n,t){const s=i-a,o=r-e,l=n-a,h=t-e,u=s*s+o*o,c=l*l+h*h,d=.5/(s*h-o*l),g=(h*u-o*c)*d,f=(s*c-l*u)*d;return g*g+f*f}function Pt(a,e,i,r,n,t){const s=i-a,o=r-e,l=n-a,h=t-e,u=s*s+o*o,c=l*l+h*h,d=.5/(s*h-o*l),g=a+(h*u-o*c)*d,f=e+(s*c-l*u)*d;return{x:g,y:f}}function W(a,e,i,r){if(r-i<=20)for(let n=i+1;n<=r;n++){const t=a[n],s=e[t];let o=n-1;for(;o>=i&&e[a[o]]>s;)a[o+1]=a[o--];a[o+1]=t}else{const n=i+r>>1;let t=i+1,s=r;B(a,n,t),e[a[i]]>e[a[r]]&&B(a,i,r),e[a[t]]>e[a[r]]&&B(a,t,r),e[a[i]]>e[a[t]]&&B(a,i,t);const o=a[t],l=e[o];for(;;){do t++;while(e[a[t]]<l);do s--;while(e[a[s]]>l);if(s<t)break;B(a,t,s)}a[i+1]=a[s],a[s]=o,r-t+1>=s-i?(W(a,e,t,r),W(a,e,i,s-1)):(W(a,e,i,s-1),W(a,e,t,r))}}function B(a,e,i){const r=a[e];a[e]=a[i],a[i]=r}function _t(a){return a[0]}function xt(a){return a[1]}const Ae=1e-6;class H{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(e,i){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+i}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(e,i){this._+=`L${this._x1=+e},${this._y1=+i}`}arc(e,i,r){e=+e,i=+i,r=+r;const n=e+r,t=i;if(r<0)throw new Error("negative radius");this._x1===null?this._+=`M${n},${t}`:(Math.abs(this._x1-n)>Ae||Math.abs(this._y1-t)>Ae)&&(this._+="L"+n+","+t),r&&(this._+=`A${r},${r},0,1,1,${e-r},${i}A${r},${r},0,1,1,${this._x1=n},${this._y1=t}`)}rect(e,i,r,n){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+i}h${+r}v${+n}h${-r}Z`}value(){return this._||null}}class ue{constructor(){this._=[]}moveTo(e,i){this._.push([e,i])}closePath(){this._.push(this._[0].slice())}lineTo(e,i){this._.push([e,i])}value(){return this._.length?this._:null}}class Dt{constructor(e,[i,r,n,t]=[0,0,960,500]){if(!((n=+n)>=(i=+i))||!((t=+t)>=(r=+r)))throw new Error("invalid bounds");this.delaunay=e,this._circumcenters=new Float64Array(e.points.length*2),this.vectors=new Float64Array(e.points.length*2),this.xmax=n,this.xmin=i,this.ymax=t,this.ymin=r,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:e,hull:i,triangles:r},vectors:n}=this;let t,s;const o=this.circumcenters=this._circumcenters.subarray(0,r.length/3*2);for(let p=0,b=0,m=r.length,w,P;p<m;p+=3,b+=2){const _=r[p]*2,M=r[p+1]*2,S=r[p+2]*2,T=e[_],z=e[_+1],v=e[M],k=e[M+1],D=e[S],x=e[S+1],I=v-T,G=k-z,E=D-T,C=x-z,A=(I*C-G*E)*2;if(Math.abs(A)<1e-9){if(t===void 0){t=s=0;for(const $ of i)t+=e[$*2],s+=e[$*2+1];t/=i.length,s/=i.length}const U=1e9*Math.sign((t-T)*C-(s-z)*E);w=(T+D)/2-U*C,P=(z+x)/2+U*E}else{const U=1/A,$=I*I+G*G,V=E*E+C*C;w=T+(C*$-G*V)*U,P=z+(I*V-E*$)*U}o[b]=w,o[b+1]=P}let l=i[i.length-1],h,u=l*4,c,d=e[2*l],g,f=e[2*l+1];n.fill(0);for(let p=0;p<i.length;++p)l=i[p],h=u,c=d,g=f,u=l*4,d=e[2*l],f=e[2*l+1],n[h+2]=n[u]=g-f,n[h+3]=n[u+1]=d-c}render(e){const i=e==null?e=new H:void 0,{delaunay:{halfedges:r,inedges:n,hull:t},circumcenters:s,vectors:o}=this;if(t.length<=1)return null;for(let u=0,c=r.length;u<c;++u){const d=r[u];if(d<u)continue;const g=Math.floor(u/3)*2,f=Math.floor(d/3)*2,p=s[g],b=s[g+1],m=s[f],w=s[f+1];this._renderSegment(p,b,m,w,e)}let l,h=t[t.length-1];for(let u=0;u<t.length;++u){l=h,h=t[u];const c=Math.floor(n[h]/3)*2,d=s[c],g=s[c+1],f=l*4,p=this._project(d,g,o[f+2],o[f+3]);p&&this._renderSegment(d,g,p[0],p[1],e)}return i&&i.value()}renderBounds(e){const i=e==null?e=new H:void 0;return e.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),i&&i.value()}renderCell(e,i){const r=i==null?i=new H:void 0,n=this._clip(e);if(n===null||!n.length)return;i.moveTo(n[0],n[1]);let t=n.length;for(;n[0]===n[t-2]&&n[1]===n[t-1]&&t>1;)t-=2;for(let s=2;s<t;s+=2)(n[s]!==n[s-2]||n[s+1]!==n[s-1])&&i.lineTo(n[s],n[s+1]);return i.closePath(),r&&r.value()}*cellPolygons(){const{delaunay:{points:e}}=this;for(let i=0,r=e.length/2;i<r;++i){const n=this.cellPolygon(i);n&&(n.index=i,yield n)}}cellPolygon(e){const i=new ue;return this.renderCell(e,i),i.value()}_renderSegment(e,i,r,n,t){let s;const o=this._regioncode(e,i),l=this._regioncode(r,n);o===0&&l===0?(t.moveTo(e,i),t.lineTo(r,n)):(s=this._clipSegment(e,i,r,n,o,l))&&(t.moveTo(s[0],s[1]),t.lineTo(s[2],s[3]))}contains(e,i,r){return i=+i,i!==i||(r=+r,r!==r)?!1:this.delaunay._step(e,i,r)===e}*neighbors(e){const i=this._clip(e);if(i)for(const r of this.delaunay.neighbors(e)){const n=this._clip(r);if(n){e:for(let t=0,s=i.length;t<s;t+=2)for(let o=0,l=n.length;o<l;o+=2)if(i[t]===n[o]&&i[t+1]===n[o+1]&&i[(t+2)%s]===n[(o+l-2)%l]&&i[(t+3)%s]===n[(o+l-1)%l]){yield r;break e}}}}_cell(e){const{circumcenters:i,delaunay:{inedges:r,halfedges:n,triangles:t}}=this,s=r[e];if(s===-1)return null;const o=[];let l=s;do{const h=Math.floor(l/3);if(o.push(i[h*2],i[h*2+1]),l=l%3===2?l-2:l+1,t[l]!==e)break;l=n[l]}while(l!==s&&l!==-1);return o}_clip(e){if(e===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const i=this._cell(e);if(i===null)return null;const{vectors:r}=this,n=e*4;return this._simplify(r[n]||r[n+1]?this._clipInfinite(e,i,r[n],r[n+1],r[n+2],r[n+3]):this._clipFinite(e,i))}_clipFinite(e,i){const r=i.length;let n=null,t,s,o=i[r-2],l=i[r-1],h,u=this._regioncode(o,l),c,d=0;for(let g=0;g<r;g+=2)if(t=o,s=l,o=i[g],l=i[g+1],h=u,u=this._regioncode(o,l),h===0&&u===0)c=d,d=0,n?n.push(o,l):n=[o,l];else{let f,p,b,m,w;if(h===0){if((f=this._clipSegment(t,s,o,l,h,u))===null)continue;[p,b,m,w]=f}else{if((f=this._clipSegment(o,l,t,s,u,h))===null)continue;[m,w,p,b]=f,c=d,d=this._edgecode(p,b),c&&d&&this._edge(e,c,d,n,n.length),n?n.push(p,b):n=[p,b]}c=d,d=this._edgecode(m,w),c&&d&&this._edge(e,c,d,n,n.length),n?n.push(m,w):n=[m,w]}if(n)c=d,d=this._edgecode(n[0],n[1]),c&&d&&this._edge(e,c,d,n,n.length);else if(this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return n}_clipSegment(e,i,r,n,t,s){const o=t<s;for(o&&([e,i,r,n,t,s]=[r,n,e,i,s,t]);;){if(t===0&&s===0)return o?[r,n,e,i]:[e,i,r,n];if(t&s)return null;let l,h,u=t||s;u&8?(l=e+(r-e)*(this.ymax-i)/(n-i),h=this.ymax):u&4?(l=e+(r-e)*(this.ymin-i)/(n-i),h=this.ymin):u&2?(h=i+(n-i)*(this.xmax-e)/(r-e),l=this.xmax):(h=i+(n-i)*(this.xmin-e)/(r-e),l=this.xmin),t?(e=l,i=h,t=this._regioncode(e,i)):(r=l,n=h,s=this._regioncode(r,n))}}_clipInfinite(e,i,r,n,t,s){let o=Array.from(i),l;if((l=this._project(o[0],o[1],r,n))&&o.unshift(l[0],l[1]),(l=this._project(o[o.length-2],o[o.length-1],t,s))&&o.push(l[0],l[1]),o=this._clipFinite(e,o))for(let h=0,u=o.length,c,d=this._edgecode(o[u-2],o[u-1]);h<u;h+=2)c=d,d=this._edgecode(o[h],o[h+1]),c&&d&&(h=this._edge(e,c,d,o,h),u=o.length);else this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(o=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return o}_edge(e,i,r,n,t){for(;i!==r;){let s,o;switch(i){case 5:i=4;continue;case 4:i=6,s=this.xmax,o=this.ymin;break;case 6:i=2;continue;case 2:i=10,s=this.xmax,o=this.ymax;break;case 10:i=8;continue;case 8:i=9,s=this.xmin,o=this.ymax;break;case 9:i=1;continue;case 1:i=5,s=this.xmin,o=this.ymin;break}(n[t]!==s||n[t+1]!==o)&&this.contains(e,s,o)&&(n.splice(t,0,s,o),t+=2)}return t}_project(e,i,r,n){let t=1/0,s,o,l;if(n<0){if(i<=this.ymin)return null;(s=(this.ymin-i)/n)<t&&(l=this.ymin,o=e+(t=s)*r)}else if(n>0){if(i>=this.ymax)return null;(s=(this.ymax-i)/n)<t&&(l=this.ymax,o=e+(t=s)*r)}if(r>0){if(e>=this.xmax)return null;(s=(this.xmax-e)/r)<t&&(o=this.xmax,l=i+(t=s)*n)}else if(r<0){if(e<=this.xmin)return null;(s=(this.xmin-e)/r)<t&&(o=this.xmin,l=i+(t=s)*n)}return[o,l]}_edgecode(e,i){return(e===this.xmin?1:e===this.xmax?2:0)|(i===this.ymin?4:i===this.ymax?8:0)}_regioncode(e,i){return(e<this.xmin?1:e>this.xmax?2:0)|(i<this.ymin?4:i>this.ymax?8:0)}_simplify(e){if(e&&e.length>4){for(let i=0;i<e.length;i+=2){const r=(i+2)%e.length,n=(i+4)%e.length;(e[i]===e[r]&&e[r]===e[n]||e[i+1]===e[r+1]&&e[r+1]===e[n+1])&&(e.splice(r,2),i-=2)}e.length||(e=null)}return e}}const Mt=2*Math.PI,j=Math.pow;function kt(a){return a[0]}function Tt(a){return a[1]}function Ct(a){const{triangles:e,coords:i}=a;for(let r=0;r<e.length;r+=3){const n=2*e[r],t=2*e[r+1],s=2*e[r+2];if((i[s]-i[n])*(i[t+1]-i[n+1])-(i[t]-i[n])*(i[s+1]-i[n+1])>1e-10)return!1}return!0}function zt(a,e,i){return[a+Math.sin(a+e)*i,e+Math.cos(a-e)*i]}class fe{static from(e,i=kt,r=Tt,n){return new fe("length"in e?St(e,i,r,n):Float64Array.from(It(e,i,r,n)))}constructor(e){this._delaunator=new ee(e),this.inedges=new Int32Array(e.length/2),this._hullIndex=new Int32Array(e.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const e=this._delaunator,i=this.points;if(e.hull&&e.hull.length>2&&Ct(e)){this.collinear=Int32Array.from({length:i.length/2},(d,g)=>g).sort((d,g)=>i[2*d]-i[2*g]||i[2*d+1]-i[2*g+1]);const l=this.collinear[0],h=this.collinear[this.collinear.length-1],u=[i[2*l],i[2*l+1],i[2*h],i[2*h+1]],c=1e-8*Math.hypot(u[3]-u[1],u[2]-u[0]);for(let d=0,g=i.length/2;d<g;++d){const f=zt(i[2*d],i[2*d+1],c);i[2*d]=f[0],i[2*d+1]=f[1]}this._delaunator=new ee(i)}else delete this.collinear;const r=this.halfedges=this._delaunator.halfedges,n=this.hull=this._delaunator.hull,t=this.triangles=this._delaunator.triangles,s=this.inedges.fill(-1),o=this._hullIndex.fill(-1);for(let l=0,h=r.length;l<h;++l){const u=t[l%3===2?l-2:l+1];(r[l]===-1||s[u]===-1)&&(s[u]=l)}for(let l=0,h=n.length;l<h;++l)o[n[l]]=l;n.length<=2&&n.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=n[0],s[n[0]]=1,n.length===2&&(s[n[1]]=0,this.triangles[1]=n[1],this.triangles[2]=n[1]))}voronoi(e){return new Dt(this,e)}*neighbors(e){const{inedges:i,hull:r,_hullIndex:n,halfedges:t,triangles:s,collinear:o}=this;if(o){const c=o.indexOf(e);c>0&&(yield o[c-1]),c<o.length-1&&(yield o[c+1]);return}const l=i[e];if(l===-1)return;let h=l,u=-1;do{if(yield u=s[h],h=h%3===2?h-2:h+1,s[h]!==e)return;if(h=t[h],h===-1){const c=r[(n[e]+1)%r.length];c!==u&&(yield c);return}}while(h!==l)}find(e,i,r=0){if(e=+e,e!==e||(i=+i,i!==i))return-1;const n=r;let t;for(;(t=this._step(r,e,i))>=0&&t!==r&&t!==n;)r=t;return t}_step(e,i,r){const{inedges:n,hull:t,_hullIndex:s,halfedges:o,triangles:l,points:h}=this;if(n[e]===-1||!h.length)return(e+1)%(h.length>>1);let u=e,c=j(i-h[e*2],2)+j(r-h[e*2+1],2);const d=n[e];let g=d;do{let f=l[g];const p=j(i-h[f*2],2)+j(r-h[f*2+1],2);if(p<c&&(c=p,u=f),g=g%3===2?g-2:g+1,l[g]!==e)break;if(g=o[g],g===-1){if(g=t[(s[e]+1)%t.length],g!==f&&j(i-h[g*2],2)+j(r-h[g*2+1],2)<c)return g;break}}while(g!==d);return u}render(e){const i=e==null?e=new H:void 0,{points:r,halfedges:n,triangles:t}=this;for(let s=0,o=n.length;s<o;++s){const l=n[s];if(l<s)continue;const h=t[s]*2,u=t[l]*2;e.moveTo(r[h],r[h+1]),e.lineTo(r[u],r[u+1])}return this.renderHull(e),i&&i.value()}renderPoints(e,i){i===void 0&&(!e||typeof e.moveTo!="function")&&(i=e,e=null),i=i==null?2:+i;const r=e==null?e=new H:void 0,{points:n}=this;for(let t=0,s=n.length;t<s;t+=2){const o=n[t],l=n[t+1];e.moveTo(o+i,l),e.arc(o,l,i,0,Mt)}return r&&r.value()}renderHull(e){const i=e==null?e=new H:void 0,{hull:r,points:n}=this,t=r[0]*2,s=r.length;e.moveTo(n[t],n[t+1]);for(let o=1;o<s;++o){const l=2*r[o];e.lineTo(n[l],n[l+1])}return e.closePath(),i&&i.value()}hullPolygon(){const e=new ue;return this.renderHull(e),e.value()}renderTriangle(e,i){const r=i==null?i=new H:void 0,{points:n,triangles:t}=this,s=t[e*=3]*2,o=t[e+1]*2,l=t[e+2]*2;return i.moveTo(n[s],n[s+1]),i.lineTo(n[o],n[o+1]),i.lineTo(n[l],n[l+1]),i.closePath(),r&&r.value()}*trianglePolygons(){const{triangles:e}=this;for(let i=0,r=e.length/3;i<r;++i)yield this.trianglePolygon(i)}trianglePolygon(e){const i=new ue;return this.renderTriangle(e,i),i.value()}}function St(a,e,i,r){const n=a.length,t=new Float64Array(n*2);for(let s=0;s<n;++s){const o=a[s];t[s*2]=e.call(r,o,s,a),t[s*2+1]=i.call(r,o,s,a)}return t}function*It(a,e,i,r){let n=0;for(const t of a)yield e.call(r,t,n,a),yield i.call(r,t,n,a),++n}let At=0;function F(){return At++}const me="VoronoiPieceGenerator",Gt={name:me,displayName:"Voronoi",description:"Construct pieces by building a Voronoi diagram from the seed points. Each piece consists of all area of the plane closer to its seed point than any other seed point. In practice, this creates irregular polygons with 3-8 sides.",sortHint:1,controls:[]};function Et(a){if(a.length===0)return[0,0,0,0];let e=a[0][0],i=a[0][1],r=e,n=i;for(let t=1;t<a.length;t++){const s=a[t];e=Math.min(e,s[0]),i=Math.min(i,s[1]),r=Math.max(r,s[0]),n=Math.max(n,s[1])}return[e,i,r,n]}function $t(a,e){const i=a.length;for(let r=0;r<i;r++){const n=e.get(a[r]);n.next=a[(r+1)%i],n.prev=a[(r-1+i)%i]}}function K(a){return`${a[0].toPrecision(7)},${a[1].toPrecision(7)}`}function Lt(a,e){return Math.abs(a[0]-e[0])<1e-6&&Math.abs(a[1]-e[1])<1e-6}const Rt=(a,e,i)=>({generatePieces(n,t){console.log(`VoronoiPieceGenerator using dimensions ${a}x${e}`);const o=fe.from(n).voronoi([0,0,a,e]),l={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},h=new Map;for(let c=0;c<n.length;c++){const d=n[c],g=o.cellPolygon(c);if(!g)continue;const f={id:c,site:d,halfEdge:-1,bbox:Et(g)},p=[];for(let b=0;b<g.length-1;b++){const m=g[b],w=g[b+1];if(Lt(m,w))continue;const P={id:F(),origin:m,twin:-1,next:-1,prev:-1,piece:c};l.halfEdges.set(P.id,P),p.push(P.id);const _=`${K(m)}-${K(w)}`;h.set(_,P.id)}p.length!==0&&($t(p,l.halfEdges),f.halfEdge=p[0],l.pieces.set(c,f))}for(const c of l.halfEdges.values()){if(c.twin!==-1)continue;const d=l.halfEdges.get(c.next),g=c.origin,f=d.origin,p=`${K(f)}-${K(g)}`,b=h.get(p),m=F();let w;if(b!==void 0){const P=l.halfEdges.get(b);c.twin=P.id,P.twin=c.id,w={id:m,heLeft:c.id,heRight:P.id}}else w={id:m,heLeft:c.id,heRight:-1},l.boundary.push(m);l.edges.set(m,w)}const u=new Map;for(const c of l.halfEdges.values()){const d=K(c.origin);u.has(d)||u.set(d,c.origin)}return l.vertices=Array.from(u.values()),l}});J.register(me,Rt,Gt);const be="TraditionalTabGenerator",Ut={name:be,displayName:"Traditional",description:"Creates a traditional rounded tab for each (internal) piece edge.",sortHint:1,controls:[{type:"range",name:"size",label:"Tab Size",defaultValue:20,min:1,max:100,step:1,helpText:"Size of each tab as a percent relative to its edge length"},{type:"range",name:"jitter",label:"Randomness",defaultValue:8,min:0,max:100,step:1,helpText:"Adds randomness to the tab shape. 0 means completely uniform tabs"},{type:"number",name:"minTabSize",label:"Minimum Tab Size",defaultValue:20,optional:!0,helpText:"If provided, tabs will not generate on edges shorter than this value"},{type:"number",name:"maxTabSize",label:"Maximum Tab Width",optional:!0,helpText:"If provided, the width of a tab's features will be clamped to this value"}]};function Nt(a,e,i,r,n,t=!1,s){const o=e[0]-a[0],l=e[1]-a[1],h=Math.hypot(o,l);if(h===0)throw new Error("Edge has zero length");const u=[o/h,l/h],c=[-u[1],u[0]],d=(D,x)=>[a[0]+(u[0]*D+c[0]*x)*h,a[1]+(u[1]*D+c[1]*x)*h],g=r/100,f=()=>(n()*2-1)*g,p=f(),b=f(),m=f(),w=f(),P=f();let _=i/200;s&&4*_*h>s&&(_=s/(4*h));const M=t?-1:1,T=[[0,0],[.2,p],[.5+b+w,M*(-_+m)],[.5-_+b,M*(_+m)],[.5-2*_+b-w,M*(3*_+m)],[.5+2*_+b-w,M*(3*_+m)],[.5+_+b,M*(_+m)],[.5+b+w,M*(-_+m)],[.8,P],[1,0]].map(([D,x])=>d(D,x)),z={type:"bezier",p1:T[1],p2:T[2],p3:T[3]},v={type:"bezier",p1:T[4],p2:T[5],p3:T[6]},k={type:"bezier",p1:T[7],p2:T[8],p3:T[9]};return[z,v,k]}function Ft(a,e){return{type:"bezier",p1:a.p2,p2:a.p1,p3:e}}const Ht=(a,e,i)=>{const{size:r=20,jitter:n=8,minTabSize:t,maxTabSize:s}=i;return{addTab(l,h){const{topology:u,random:c}=h,d=u.halfEdges.get(l.heLeft),g=u.halfEdges.get(l.heRight);if(!d||!g)return;const f=d.origin,p=g.origin;if(t&&Math.hypot(p[0]-f[0],p[1]-f[1])<t)return;const b=c()>.5,m=Nt(f,p,r,n,c,b,s);if(m.length===0)return;const w=[];for(let P=m.length-1;P>=0;P--){const _=m[P],M=P>0?m[P-1].p3:f;w.push(Ft(_,M))}d.segments=m,g.segments=w}}};O.register(be,Ht,Ut);function Vt(a){return{vertices:a.vertices,pieces:Array.from(a.pieces.entries()),edges:Array.from(a.edges.entries()),halfEdges:Array.from(a.halfEdges.entries()),boundary:a.boundary}}function qt(a){return new Worker("/puzzle-generator/assets/CheckGeometryWorker-BOJd4zFt.js",{name:a?.name})}function jt(a,e){return new Promise((i,r)=>{const n=new qt;n.onmessage=s=>{const o=s.data;switch(o.type){case"progress":e?.(o.processed,o.total);break;case"done":i(o.results),n.terminate();break;case"error":r(new Error(o.message)),n.terminate();break}},n.onerror=s=>{r(new Error(s.message)),n.terminate()};const t={topology:Vt(a)};n.postMessage(t)})}const Le="GridJitterPointGenerator",Wt={name:Le,displayName:"Grid",description:"Generate seed points using a grid with optional random jitter. Has a uniform, regular look, especially with low randomness values.",sortHint:2,controls:[{type:"range",name:"jitter",label:"Randomness",min:0,max:100,step:5,defaultValue:50,helpText:"Amount of jitter to apply to each grid point (0 to 100%)"}]},Ot=(a,e,i)=>{const{jitter:r=50}=i;return{generatePoints(t){const{width:s,height:o,pieceSize:l,random:h}=t,u=[];for(let c=0;c<s;c+=l)for(let d=0;d<o;d+=l){const g=[c+l/2,d+l/2];r>0&&(g[0]+=(h()-.5)*(r/100)*l,g[1]+=(h()-.5)*(r/100)*l),u.push(g)}return u}}};Y.register(Le,Ot,Wt);const Re="RectangularPieceGenerator",Bt={name:Re,displayName:"Rectangular",description:"Construct pieces from a regular grid. All pieces have 4 sides and are the same size. This generator ignores seed points.",sortHint:2,controls:[]},Kt=(a,e,i)=>({generatePieces(n,t){const{pieceSize:s}=t,o={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},l=Math.ceil(a/s),h=Math.ceil(e/s),u=Math.round(a/l),c=Math.round(e/h),d=[];for(let f=0;f<=h;f++){const p=[];for(let b=0;b<=l;b++){const m=b*u,w=f*c;p.push([m,w])}d.push(p)}o.vertices=d.flat();const g=new Map;for(let f=0;f<h;f++)for(let p=0;p<l;p++){const b=f*l+p,m=d[f][p],w=d[f][p+1],P=d[f+1][p],_=d[f+1][p+1],M={id:F(),origin:m,twin:-1,next:-1,prev:-1,piece:b},S={id:F(),origin:w,twin:-1,next:-1,prev:-1,piece:b},T={id:F(),origin:_,twin:-1,next:-1,prev:-1,piece:b},z={id:F(),origin:P,twin:-1,next:-1,prev:-1,piece:b};M.next=S.id,S.next=T.id,T.next=z.id,z.next=M.id,M.prev=z.id,z.prev=T.id,T.prev=S.id,S.prev=M.id,o.halfEdges.set(M.id,M),o.halfEdges.set(S.id,S),o.halfEdges.set(T.id,T),o.halfEdges.set(z.id,z);const v={id:b,site:[(m[0]+_[0])/2,(m[1]+_[1])/2],halfEdge:M.id,bbox:[m[0],m[1],_[0],_[1]]};o.pieces.set(b,v);const k=(x,I)=>`${x[0]},${x[1]}-${I[0]},${I[1]}`,D=[{he:M,p1:m,p2:w,isBoundary:f===0},{he:S,p1:w,p2:_,isBoundary:p===l-1},{he:T,p1:_,p2:P,isBoundary:f===h-1},{he:z,p1:P,p2:m,isBoundary:p===0}];for(const x of D){const I=k(x.p2,x.p1),G=g.get(I),E=F();let C;if(G!==void 0){const A=o.halfEdges.get(G);x.he.twin=A.id,A.twin=x.he.id,C={id:E,heLeft:A.id,heRight:x.he.id},g.delete(I)}else{const A=k(x.p1,x.p2);if(g.set(A,x.he.id),x.isBoundary)C={id:E,heLeft:x.he.id,heRight:-1},o.boundary.push(E);else continue}o.edges.set(E,C)}}return o}});J.register(Re,Kt,Bt);const Ue="NullTabGenerator",Yt={name:Ue,displayName:"None",description:"Do not generate tabs. All pieces have straight edges.",sortHint:3,controls:[]},Jt=(a,e,i)=>({addTab(n,t){}});O.register(Ue,Jt,Yt);const Ne="TriangleTabGenerator",Xt={name:Ne,displayName:"Triangle",description:"Creates a simple triangle between each (internal) piece edge.",sortHint:2,controls:[{type:"range",name:"tabHeightRatio",label:"Tab Height",optional:!0,min:0,max:100,step:1,defaultValue:20,helpText:'Determines how "tall" the tab is relative to the length of the edge as a percent'}]},Qt=(a,e,i)=>{const{tabHeightRatio:r=20}=i;return{addTab(t,s){const{topology:o,random:l}=s,h=o.halfEdges.get(t.heLeft),u=o.halfEdges.get(t.heRight);if(!h||!u){console.warn("Could not find half-edges for a given internal edge:",t.id);return}const c=h.origin,d=u.origin,g=[d[0]-c[0],d[1]-c[1]],f=Math.sqrt(g[0]**2+g[1]**2);if(f<1e-6)return;const p=[g[0]/f,g[1]/f],b=[-p[1],p[0]],m=[c[0]+g[0]/2,c[1]+g[1]/2],w=l()>.5?1:-1,P=f*(r/100)*w,_=[m[0]+b[0]*P,m[1]+b[1]*P],M={type:"bezier",p1:_,p2:_,p3:d},S=[m[0]-b[0]*P,m[1]-b[1]*P],T={type:"bezier",p1:S,p2:S,p3:c};h.segments=[M],u.segments=[T]}}};O.register(Ne,Qt,Xt);let de=!1;function Zt(){const a=window.matchMedia("(prefers-color-scheme: dark)");function e(){a.matches?(document.documentElement.classList.add("sl-theme-dark"),de=!0):(document.documentElement.classList.remove("sl-theme-dark"),de=!1)}e(),a.addEventListener("change",e)}Zt();const en=()=>{const i=pe,r=me,n=be,t={seed:new Date().getTime()%10240,canvasWidth:800,canvasHeight:600,aspectRatio:800/600,distance:40,color:de?"#DDDDDD":"#333333",geometryProblems:{autoCheck:!1,problems:void 0,progress:void 0},dirty:!0,generators:{point:{label:"Seed Points",registry:Y,name:i,config:Y.getDefaultConfig(i,800,600)},piece:{label:"Piece Generation",registry:J,name:r,config:J.getDefaultConfig(r,800,600)},tab:{label:"Tabs",registry:O,name:n,config:O.getDefaultConfig(n,800,600)}},puzzle:void 0,backgroundImageUrl:void 0,backgroundImageName:""};function s(){t.puzzle&&(t.geometryProblems.progress=0,y.redraw(),jt(t.puzzle,(o,l)=>{t.geometryProblems.progress=o/l*100,y.redraw()}).then(o=>{t.geometryProblems.problems=o.length,t.geometryProblems.progress=void 0,t.puzzle&&(t.puzzle.problems=o),y.redraw()}).catch(o=>{t.geometryProblems.progress=void 0,console.error(o),y.redraw()}))}return{oncreate:()=>{ye({width:t.canvasWidth,height:t.canvasHeight,pieceSize:t.distance,pointConfig:t.generators.point.config,pieceConfig:t.generators.piece.config,tabConfig:t.generators.tab.config,seed:t.seed}).then(o=>{t.puzzle=o,y.redraw(),t.geometryProblems.autoCheck&&s()}).catch(o=>{console.error(o)})},onupdate:()=>{t.dirty&&(t.dirty=!1,ye({width:t.canvasWidth,height:t.canvasHeight,pieceSize:t.distance,pointConfig:t.generators.point.config,pieceConfig:t.generators.piece.config,tabConfig:t.generators.tab.config,seed:t.seed}).then(o=>{t.geometryProblems.problems=void 0,t.geometryProblems.progress=void 0,t.puzzle=o,y.redraw(),t.geometryProblems.autoCheck&&s()}).catch(o=>{console.error(o)}))},onremove:()=>{t.backgroundImageUrl&&(URL.revokeObjectURL(t.backgroundImageUrl),t.backgroundImageUrl=void 0)},view:()=>y(".page",[y(qe,{link:"https://github.com/weevilgenius/puzzle-generator"}),y("h1","Puzzle Generator"),y(".container",[t.puzzle&&y(".puzzle-stack",[y(We,{width:t.canvasWidth,height:t.canvasHeight,color:t.color,imageUrl:t.backgroundImageUrl,puzzle:t.puzzle,isDirty:t.dirty}),y(".actions",[y(Ke,{puzzle:t.puzzle,width:t.canvasWidth,height:t.canvasHeight,color:t.color}),y(Ye,{autoCheck:t.geometryProblems.autoCheck,problems:t.geometryProblems.problems,progressPercent:t.geometryProblems.progress,onCheckRequested:()=>{t.dirty||s(),y.redraw()},onAutocheckChanged:o=>{o!==t.geometryProblems.autoCheck&&(t.geometryProblems.autoCheck=o,y.redraw())}})])]),y(".controls",[y(".background-image",[y(Xe,{label:"Background Image",onUpload:(o,l,h,u)=>{t.backgroundImageUrl&&URL.revokeObjectURL(t.backgroundImageUrl),t.canvasWidth=h,t.canvasHeight=u,t.aspectRatio=h/u,t.backgroundImageUrl=o,t.backgroundImageName=l,t.dirty=!0,y.redraw()}}),y("span.background-image-label",t.backgroundImageName)]),y(nt,{ratio:t.aspectRatio,disabled:t.backgroundImageUrl!==void 0,onChange:o=>{t.aspectRatio=o,t.canvasWidth=t.canvasHeight*o,t.dirty=!0,y.redraw()}}),y(ce,{config:{name:"seed",label:"Seed",type:"number"},value:t.seed,onChange:o=>{t.seed=o??0,t.dirty=!0,y.redraw()}}),y(ce,{config:{name:"pieceSize",label:"Piece size",type:"number"},value:t.distance,onChange:o=>{t.distance=o??0,t.dirty=!0,y.redraw()}}),y(it,{label:"Piece color",color:t.color,size:"small",onUpdate:o=>{t.color=o,y.redraw()}}),...Object.entries(t.generators).map(([o,l])=>y("label",[l.label+":",y(tt,{generator:l.name,registry:l.registry,config:l.config,onGeneratorChange:h=>{h!=l.name&&(console.log(`${o} generator changed to ${h}`),l.name=h,t.generators[o].config=l.registry.getDefaultConfig(h,t.canvasWidth,t.canvasHeight),t.dirty=!0,y.redraw())},onConfigChange:(h,u)=>{console.log(`${o} generator config "${h}" changed to ${String(u)}`),l.config[h]=u,t.dirty=!0,y.redraw()}})]))])])])}};Ve("material",{resolver:a=>{const e=a.match(/^(.*?)(_(rounded|sharp))?$/);return e?`https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${e[3]??"outlined"}/${e[1]}.svg`:""},mutator:a=>a.setAttribute("fill","currentColor")});y.mount(document.body,en);
//# sourceMappingURL=index-CViKk4r8.js.map
