(function(){"use strict";function tt(o){return{vertices:o.vertices,pieces:new Map(o.pieces),edges:new Map(o.edges),halfEdges:new Map(o.halfEdges),boundary:o.boundary}}const{abs:F,cos:I,sin:D,acos:nt,atan2:R,sqrt:T,pow:S}=Math;function U(o){return o<0?-S(-o,1/3):S(o,1/3)}const W=Math.PI,V=2*W,N=W/2,et=1e-6,X=Number.MAX_SAFE_INTEGER||9007199254740991,H=Number.MIN_SAFE_INTEGER||-9007199254740991,it={x:0,y:0,z:0},y={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(o,n){const e=n(o);let i=e.x*e.x+e.y*e.y;return typeof e.z<"u"&&(i+=e.z*e.z),T(i)},compute:function(o,n,e){if(o===0)return n[0].t=0,n[0];const i=n.length-1;if(o===1)return n[i].t=1,n[i];const s=1-o;let c=n;if(i===0)return n[0].t=o,n[0];if(i===1){const u={x:s*c[0].x+o*c[1].x,y:s*c[0].y+o*c[1].y,t:o};return e&&(u.z=s*c[0].z+o*c[1].z),u}if(i<4){let u=s*s,f=o*o,a,h,l,x=0;i===2?(c=[c[0],c[1],c[2],it],a=u,h=s*o*2,l=f):i===3&&(a=u*s,h=u*o*3,l=s*f*3,x=o*f);const p={x:a*c[0].x+h*c[1].x+l*c[2].x+x*c[3].x,y:a*c[0].y+h*c[1].y+l*c[2].y+x*c[3].y,t:o};return e&&(p.z=a*c[0].z+h*c[1].z+l*c[2].z+x*c[3].z),p}const r=JSON.parse(JSON.stringify(n));for(;r.length>1;){for(let u=0;u<r.length-1;u++)r[u]={x:r[u].x+(r[u+1].x-r[u].x)*o,y:r[u].y+(r[u+1].y-r[u].y)*o},typeof r[u].z<"u"&&(r[u].z=r[u].z+(r[u+1].z-r[u].z)*o);r.splice(r.length-1,1)}return r[0].t=o,r[0]},computeWithRatios:function(o,n,e,i){const s=1-o,c=e,r=n;let u=c[0],f=c[1],a=c[2],h=c[3],l;if(u*=s,f*=o,r.length===2)return l=u+f,{x:(u*r[0].x+f*r[1].x)/l,y:(u*r[0].y+f*r[1].y)/l,z:i?(u*r[0].z+f*r[1].z)/l:!1,t:o};if(u*=s,f*=2*s,a*=o*o,r.length===3)return l=u+f+a,{x:(u*r[0].x+f*r[1].x+a*r[2].x)/l,y:(u*r[0].y+f*r[1].y+a*r[2].y)/l,z:i?(u*r[0].z+f*r[1].z+a*r[2].z)/l:!1,t:o};if(u*=s,f*=1.5*s,a*=3*s,h*=o*o*o,r.length===4)return l=u+f+a+h,{x:(u*r[0].x+f*r[1].x+a*r[2].x+h*r[3].x)/l,y:(u*r[0].y+f*r[1].y+a*r[2].y+h*r[3].y)/l,z:i?(u*r[0].z+f*r[1].z+a*r[2].z+h*r[3].z)/l:!1,t:o}},derive:function(o,n){const e=[];for(let i=o,s=i.length,c=s-1;s>1;s--,c--){const r=[];for(let u=0,f;u<c;u++)f={x:c*(i[u+1].x-i[u].x),y:c*(i[u+1].y-i[u].y)},n&&(f.z=c*(i[u+1].z-i[u].z)),r.push(f);e.push(r),i=r}return e},between:function(o,n,e){return n<=o&&o<=e||y.approximately(o,n)||y.approximately(o,e)},approximately:function(o,n,e){return F(o-n)<=(e||et)},length:function(o){const e=y.Tvalues.length;let i=0;for(let s=0,c;s<e;s++)c=.5*y.Tvalues[s]+.5,i+=y.Cvalues[s]*y.arcfn(c,o);return .5*i},map:function(o,n,e,i,s){const c=e-n,r=s-i,u=o-n,f=u/c;return i+r*f},lerp:function(o,n,e){const i={x:n.x+o*(e.x-n.x),y:n.y+o*(e.y-n.y)};return n.z!==void 0&&e.z!==void 0&&(i.z=n.z+o*(e.z-n.z)),i},pointToString:function(o){let n=o.x+"/"+o.y;return typeof o.z<"u"&&(n+="/"+o.z),n},pointsToString:function(o){return"["+o.map(y.pointToString).join(", ")+"]"},copy:function(o){return JSON.parse(JSON.stringify(o))},angle:function(o,n,e){const i=n.x-o.x,s=n.y-o.y,c=e.x-o.x,r=e.y-o.y,u=i*r-s*c,f=i*c+s*r;return R(u,f)},round:function(o,n){const e=""+o,i=e.indexOf(".");return parseFloat(e.substring(0,i+1+n))},dist:function(o,n){const e=o.x-n.x,i=o.y-n.y;return T(e*e+i*i)},closest:function(o,n){let e=S(2,63),i,s;return o.forEach(function(c,r){s=y.dist(n,c),s<e&&(e=s,i=r)}),{mdist:e,mpos:i}},abcratio:function(o,n){if(n!==2&&n!==3)return!1;if(typeof o>"u")o=.5;else if(o===0||o===1)return o;const e=S(o,n)+S(1-o,n),i=e-1;return F(i/e)},projectionratio:function(o,n){if(n!==2&&n!==3)return!1;if(typeof o>"u")o=.5;else if(o===0||o===1)return o;const e=S(1-o,n),i=S(o,n)+e;return e/i},lli8:function(o,n,e,i,s,c,r,u){const f=(o*i-n*e)*(s-r)-(o-e)*(s*u-c*r),a=(o*i-n*e)*(c-u)-(n-i)*(s*u-c*r),h=(o-e)*(c-u)-(n-i)*(s-r);return h==0?!1:{x:f/h,y:a/h}},lli4:function(o,n,e,i){const s=o.x,c=o.y,r=n.x,u=n.y,f=e.x,a=e.y,h=i.x,l=i.y;return y.lli8(s,c,r,u,f,a,h,l)},lli:function(o,n){return y.lli4(o,o.c,n,n.c)},makeline:function(o,n){return new w(o.x,o.y,(o.x+n.x)/2,(o.y+n.y)/2,n.x,n.y)},findbbox:function(o){let n=X,e=X,i=H,s=H;return o.forEach(function(c){const r=c.bbox();n>r.x.min&&(n=r.x.min),e>r.y.min&&(e=r.y.min),i<r.x.max&&(i=r.x.max),s<r.y.max&&(s=r.y.max)}),{x:{min:n,mid:(n+i)/2,max:i,size:i-n},y:{min:e,mid:(e+s)/2,max:s,size:s-e}}},shapeintersections:function(o,n,e,i,s){if(!y.bboxoverlap(n,i))return[];const c=[],r=[o.startcap,o.forward,o.back,o.endcap],u=[e.startcap,e.forward,e.back,e.endcap];return r.forEach(function(f){f.virtual||u.forEach(function(a){if(a.virtual)return;const h=f.intersects(a,s);h.length>0&&(h.c1=f,h.c2=a,h.s1=o,h.s2=e,c.push(h))})}),c},makeshape:function(o,n,e){const i=n.points.length,s=o.points.length,c=y.makeline(n.points[i-1],o.points[0]),r=y.makeline(o.points[s-1],n.points[0]),u={startcap:c,forward:o,back:n,endcap:r,bbox:y.findbbox([c,o,n,r])};return u.intersections=function(f){return y.shapeintersections(u,u.bbox,f,f.bbox,e)},u},getminmax:function(o,n,e){if(!e)return{min:0,max:0};let i=X,s=H,c,r;e.indexOf(0)===-1&&(e=[0].concat(e)),e.indexOf(1)===-1&&e.push(1);for(let u=0,f=e.length;u<f;u++)c=e[u],r=o.get(c),r[n]<i&&(i=r[n]),r[n]>s&&(s=r[n]);return{min:i,mid:(i+s)/2,max:s,size:s-i}},align:function(o,n){const e=n.p1.x,i=n.p1.y,s=-R(n.p2.y-i,n.p2.x-e),c=function(r){return{x:(r.x-e)*I(s)-(r.y-i)*D(s),y:(r.x-e)*D(s)+(r.y-i)*I(s)}};return o.map(c)},roots:function(o,n){n=n||{p1:{x:0,y:0},p2:{x:1,y:0}};const e=o.length-1,i=y.align(o,n),s=function(g){return 0<=g&&g<=1};if(e===2){const g=i[0].y,v=i[1].y,C=i[2].y,b=g-2*v+C;if(b!==0){const O=-T(v*v-g*C),q=-g+v,j=-(O+q)/b,$=-(-O+q)/b;return[j,$].filter(s)}else if(v!==C&&b===0)return[(2*v-C)/(2*v-2*C)].filter(s);return[]}const c=i[0].y,r=i[1].y,u=i[2].y,f=i[3].y;let a=-c+3*r-3*u+f,h=3*c-6*r+3*u,l=-3*c+3*r,x=c;if(y.approximately(a,0)){if(y.approximately(h,0))return y.approximately(l,0)?[]:[-x/l].filter(s);const g=T(l*l-4*h*x),v=2*h;return[(g-l)/v,(-l-g)/v].filter(s)}h/=a,l/=a,x/=a;const p=(3*l-h*h)/3,d=p/3,z=(2*h*h*h-9*h*l+27*x)/27,E=z/2,_=E*E+d*d*d;let A,k,P,m,M;if(_<0){const g=-p/3,v=g*g*g,C=T(v),b=-z/(2*C),O=b<-1?-1:b>1?1:b,q=nt(O),j=U(C),$=2*j;return P=$*I(q/3)-h/3,m=$*I((q+V)/3)-h/3,M=$*I((q+2*V)/3)-h/3,[P,m,M].filter(s)}else{if(_===0)return A=E<0?U(-E):-U(E),P=2*A-h/3,m=-A-h/3,[P,m].filter(s);{const g=T(_);return A=U(-E+g),k=U(E+g),[A-k-h/3].filter(s)}}},droots:function(o){if(o.length===3){const n=o[0],e=o[1],i=o[2],s=n-2*e+i;if(s!==0){const c=-T(e*e-n*i),r=-n+e,u=-(c+r)/s,f=-(-c+r)/s;return[u,f]}else if(e!==i&&s===0)return[(2*e-i)/(2*(e-i))];return[]}if(o.length===2){const n=o[0],e=o[1];return n!==e?[n/(n-e)]:[]}return[]},curvature:function(o,n,e,i,s){let c,r,u,f,a=0,h=0;const l=y.compute(o,n),x=y.compute(o,e),p=l.x*l.x+l.y*l.y;if(i?(c=T(S(l.y*x.z-x.y*l.z,2)+S(l.z*x.x-x.z*l.x,2)+S(l.x*x.y-x.x*l.y,2)),r=S(p+l.z*l.z,3/2)):(c=l.x*x.y-l.y*x.x,r=S(p,3/2)),c===0||r===0)return{k:0,r:0};if(a=c/r,h=r/c,!s){const d=y.curvature(o-.001,n,e,i,!0).k,z=y.curvature(o+.001,n,e,i,!0).k;f=(z-a+(a-d))/2,u=(F(z-a)+F(a-d))/2}return{k:a,r:h,dk:f,adk:u}},inflections:function(o){if(o.length<4)return[];const n=y.align(o,{p1:o[0],p2:o.slice(-1)[0]}),e=n[2].x*n[1].y,i=n[3].x*n[1].y,s=n[1].x*n[2].y,c=n[3].x*n[2].y,r=18*(-3*e+2*i+3*s-c),u=18*(3*e-i-3*s),f=18*(s-e);if(y.approximately(r,0)){if(!y.approximately(u,0)){let x=-f/u;if(0<=x&&x<=1)return[x]}return[]}const a=2*r;if(y.approximately(a,0))return[];const h=u*u-4*r*f;if(h<0)return[];const l=Math.sqrt(h);return[(l-u)/a,-(u+l)/a].filter(function(x){return 0<=x&&x<=1})},bboxoverlap:function(o,n){const e=["x","y"],i=e.length;for(let s=0,c,r,u,f;s<i;s++)if(c=e[s],r=o[c].mid,u=n[c].mid,f=(o[c].size+n[c].size)/2,F(r-u)>=f)return!1;return!0},expandbox:function(o,n){n.x.min<o.x.min&&(o.x.min=n.x.min),n.y.min<o.y.min&&(o.y.min=n.y.min),n.z&&n.z.min<o.z.min&&(o.z.min=n.z.min),n.x.max>o.x.max&&(o.x.max=n.x.max),n.y.max>o.y.max&&(o.y.max=n.y.max),n.z&&n.z.max>o.z.max&&(o.z.max=n.z.max),o.x.mid=(o.x.min+o.x.max)/2,o.y.mid=(o.y.min+o.y.max)/2,o.z&&(o.z.mid=(o.z.min+o.z.max)/2),o.x.size=o.x.max-o.x.min,o.y.size=o.y.max-o.y.min,o.z&&(o.z.size=o.z.max-o.z.min)},pairiteration:function(o,n,e){const i=o.bbox(),s=n.bbox(),c=1e5,r=e||.5;if(i.x.size+i.y.size<r&&s.x.size+s.y.size<r)return[(c*(o._t1+o._t2)/2|0)/c+"/"+(c*(n._t1+n._t2)/2|0)/c];let u=o.split(.5),f=n.split(.5),a=[{left:u.left,right:f.left},{left:u.left,right:f.right},{left:u.right,right:f.right},{left:u.right,right:f.left}];a=a.filter(function(l){return y.bboxoverlap(l.left.bbox(),l.right.bbox())});let h=[];return a.length===0||(a.forEach(function(l){h=h.concat(y.pairiteration(l.left,l.right,r))}),h=h.filter(function(l,x){return h.indexOf(l)===x})),h},getccenter:function(o,n,e){const i=n.x-o.x,s=n.y-o.y,c=e.x-n.x,r=e.y-n.y,u=i*I(N)-s*D(N),f=i*D(N)+s*I(N),a=c*I(N)-r*D(N),h=c*D(N)+r*I(N),l=(o.x+n.x)/2,x=(o.y+n.y)/2,p=(n.x+e.x)/2,d=(n.y+e.y)/2,z=l+u,E=x+f,_=p+a,A=d+h,k=y.lli8(l,x,z,E,p,d,_,A),P=y.dist(k,o);let m=R(o.y-k.y,o.x-k.x),M=R(n.y-k.y,n.x-k.x),g=R(e.y-k.y,e.x-k.x),v;return m<g?((m>M||M>g)&&(m+=V),m>g&&(v=g,g=m,m=v)):g<M&&M<m?(v=g,g=m,m=v):g+=V,k.s=m,k.e=g,k.r=P,k},numberSort:function(o,n){return o-n}};class L{constructor(n){this.curves=[],this._3d=!1,n&&(this.curves=n,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(n){return y.pointsToString(n.points)}).join(", ")+"]"}addCurve(n){this.curves.push(n),this._3d=this._3d||n._3d}length(){return this.curves.map(function(n){return n.length()}).reduce(function(n,e){return n+e})}curve(n){return this.curves[n]}bbox(){const n=this.curves;for(var e=n[0].bbox(),i=1;i<n.length;i++)y.expandbox(e,n[i].bbox());return e}offset(n){const e=[];return this.curves.forEach(function(i){e.push(...i.offset(n))}),new L(e)}}const{abs:G,min:Y,max:Z,cos:st,sin:rt,acos:ot,sqrt:J}=Math,ct=Math.PI;class w{constructor(n){let e=n&&n.forEach?n:Array.from(arguments).slice(),i=!1;if(typeof e[0]=="object"){i=e.length;const p=[];e.forEach(function(d){["x","y","z"].forEach(function(z){typeof d[z]<"u"&&p.push(d[z])})}),e=p}let s=!1;const c=e.length;if(i){if(i>4){if(arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");s=!0}}else if(c!==6&&c!==8&&c!==9&&c!==12&&arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const r=this._3d=!s&&(c===9||c===12)||n&&n[0]&&typeof n[0].z<"u",u=this.points=[];for(let p=0,d=r?3:2;p<c;p+=d){var f={x:e[p],y:e[p+1]};r&&(f.z=e[p+2]),u.push(f)}const a=this.order=u.length-1,h=this.dims=["x","y"];r&&h.push("z"),this.dimlen=h.length;const l=y.align(u,{p1:u[0],p2:u[a]}),x=y.dist(u[0],u[a]);this._linear=l.reduce((p,d)=>p+G(d.y),0)<x/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(n,e,i,s){if(typeof s>"u"&&(s=.5),s===0)return new w(e,e,i);if(s===1)return new w(n,e,e);const c=w.getABC(2,n,e,i,s);return new w(n,c.A,i)}static cubicFromPoints(n,e,i,s,c){typeof s>"u"&&(s=.5);const r=w.getABC(3,n,e,i,s);typeof c>"u"&&(c=y.dist(e,r.C));const u=c*(1-s)/s,f=y.dist(n,i),a=(i.x-n.x)/f,h=(i.y-n.y)/f,l=c*a,x=c*h,p=u*a,d=u*h,z={x:e.x-l,y:e.y-x},E={x:e.x+p,y:e.y+d},_=r.A,A={x:_.x+(z.x-_.x)/(1-s),y:_.y+(z.y-_.y)/(1-s)},k={x:_.x+(E.x-_.x)/s,y:_.y+(E.y-_.y)/s},P={x:n.x+(A.x-n.x)/s,y:n.y+(A.y-n.y)/s},m={x:i.x+(k.x-i.x)/(1-s),y:i.y+(k.y-i.y)/(1-s)};return new w(n,P,m,i)}static getUtils(){return y}getUtils(){return w.getUtils()}static get PolyBezier(){return L}valueOf(){return this.toString()}toString(){return y.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const n=this.points,e=n[0].x,i=n[0].y,s=["M",e,i,this.order===2?"Q":"C"];for(let c=1,r=n.length;c<r;c++)s.push(n[c].x),s.push(n[c].y);return s.join(" ")}setRatios(n){if(n.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=n,this._lut=[]}verify(){const n=this.coordDigest();n!==this._print&&(this._print=n,this.update())}coordDigest(){return this.points.map(function(n,e){return""+e+n.x+n.y+(n.z?n.z:0)}).join("")}update(){this._lut=[],this.dpoints=y.derive(this.points,this._3d),this.computedirection()}computedirection(){const n=this.points,e=y.angle(n[0],n[this.order],n[1]);this.clockwise=e>0}length(){return y.length(this.derivative.bind(this))}static getABC(n=2,e,i,s,c=.5){const r=y.projectionratio(c,n),u=1-r,f={x:r*e.x+u*s.x,y:r*e.y+u*s.y},a=y.abcratio(c,n);return{A:{x:i.x+(i.x-f.x)/a,y:i.y+(i.y-f.y)/a},B:i,C:f,S:e,E:s}}getABC(n,e){e=e||this.get(n);let i=this.points[0],s=this.points[this.order];return w.getABC(this.order,i,e,s,n)}getLUT(n){if(this.verify(),n=n||100,this._lut.length===n+1)return this._lut;this._lut=[],n++,this._lut=[];for(let e=0,i,s;e<n;e++)s=e/(n-1),i=this.compute(s),i.t=s,this._lut.push(i);return this._lut}on(n,e){e=e||5;const i=this.getLUT(),s=[];for(let c=0,r,u=0;c<i.length;c++)r=i[c],y.dist(r,n)<e&&(s.push(r),u+=c/i.length);return s.length?t/=s.length:!1}project(n){const e=this.getLUT(),i=e.length-1,s=y.closest(e,n),c=s.mpos,r=(c-1)/i,u=(c+1)/i,f=.1/i;let a=s.mdist,h=r,l=h,x;a+=1;for(let p;h<u+f;h+=f)x=this.compute(h),p=y.dist(n,x),p<a&&(a=p,l=h);return l=l<0?0:l>1?1:l,x=this.compute(l),x.t=l,x.d=a,x}get(n){return this.compute(n)}point(n){return this.points[n]}compute(n){return this.ratios?y.computeWithRatios(n,this.points,this.ratios,this._3d):y.compute(n,this.points,this._3d,this.ratios)}raise(){const n=this.points,e=[n[0]],i=n.length;for(let s=1,c,r;s<i;s++)c=n[s],r=n[s-1],e[s]={x:(i-s)/i*c.x+s/i*r.x,y:(i-s)/i*c.y+s/i*r.y};return e[i]=n[i-1],new w(e)}derivative(n){return y.compute(n,this.dpoints[0],this._3d)}dderivative(n){return y.compute(n,this.dpoints[1],this._3d)}align(){let n=this.points;return new w(y.align(n,{p1:n[0],p2:n[n.length-1]}))}curvature(n){return y.curvature(n,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return y.inflections(this.points)}normal(n){return this._3d?this.__normal3(n):this.__normal2(n)}__normal2(n){const e=this.derivative(n),i=J(e.x*e.x+e.y*e.y);return{t:n,x:-e.y/i,y:e.x/i}}__normal3(n){const e=this.derivative(n),i=this.derivative(n+.01),s=J(e.x*e.x+e.y*e.y+e.z*e.z),c=J(i.x*i.x+i.y*i.y+i.z*i.z);e.x/=s,e.y/=s,e.z/=s,i.x/=c,i.y/=c,i.z/=c;const r={x:i.y*e.z-i.z*e.y,y:i.z*e.x-i.x*e.z,z:i.x*e.y-i.y*e.x},u=J(r.x*r.x+r.y*r.y+r.z*r.z);r.x/=u,r.y/=u,r.z/=u;const f=[r.x*r.x,r.x*r.y-r.z,r.x*r.z+r.y,r.x*r.y+r.z,r.y*r.y,r.y*r.z-r.x,r.x*r.z-r.y,r.y*r.z+r.x,r.z*r.z];return{t:n,x:f[0]*e.x+f[1]*e.y+f[2]*e.z,y:f[3]*e.x+f[4]*e.y+f[5]*e.z,z:f[6]*e.x+f[7]*e.y+f[8]*e.z}}hull(n){let e=this.points,i=[],s=[],c=0;for(s[c++]=e[0],s[c++]=e[1],s[c++]=e[2],this.order===3&&(s[c++]=e[3]);e.length>1;){i=[];for(let r=0,u,f=e.length-1;r<f;r++)u=y.lerp(n,e[r],e[r+1]),s[c++]=u,i.push(u);e=i}return s}split(n,e){if(n===0&&e)return this.split(e).left;if(e===1)return this.split(n).right;const i=this.hull(n),s={left:this.order===2?new w([i[0],i[3],i[5]]):new w([i[0],i[4],i[7],i[9]]),right:this.order===2?new w([i[5],i[4],i[2]]):new w([i[9],i[8],i[6],i[3]]),span:i};return s.left._t1=y.map(0,0,1,this._t1,this._t2),s.left._t2=y.map(n,0,1,this._t1,this._t2),s.right._t1=y.map(n,0,1,this._t1,this._t2),s.right._t2=y.map(1,0,1,this._t1,this._t2),e?(e=y.map(e,n,1,0,1),s.right.split(e).left):s}extrema(){const n={};let e=[];return this.dims.forEach((function(i){let s=function(r){return r[i]},c=this.dpoints[0].map(s);n[i]=y.droots(c),this.order===3&&(c=this.dpoints[1].map(s),n[i]=n[i].concat(y.droots(c))),n[i]=n[i].filter(function(r){return r>=0&&r<=1}),e=e.concat(n[i].sort(y.numberSort))}).bind(this)),n.values=e.sort(y.numberSort).filter(function(i,s){return e.indexOf(i)===s}),n}bbox(){const n=this.extrema(),e={};return this.dims.forEach((function(i){e[i]=y.getminmax(this,i,n[i])}).bind(this)),e}overlaps(n){const e=this.bbox(),i=n.bbox();return y.bboxoverlap(e,i)}offset(n,e){if(typeof e<"u"){const i=this.get(n),s=this.normal(n),c={c:i,n:s,x:i.x+s.x*e,y:i.y+s.y*e};return this._3d&&(c.z=i.z+s.z*e),c}if(this._linear){const i=this.normal(0),s=this.points.map(function(c){const r={x:c.x+n*i.x,y:c.y+n*i.y};return c.z&&i.z&&(r.z=c.z+n*i.z),r});return[new w(s)]}return this.reduce().map(function(i){return i._linear?i.offset(n)[0]:i.scale(n)})}simple(){if(this.order===3){const s=y.angle(this.points[0],this.points[3],this.points[1]),c=y.angle(this.points[0],this.points[3],this.points[2]);if(s>0&&c<0||s<0&&c>0)return!1}const n=this.normal(0),e=this.normal(1);let i=n.x*e.x+n.y*e.y;return this._3d&&(i+=n.z*e.z),G(ot(i))<ct/3}reduce(){let n,e=0,i=0,s=.01,c,r=[],u=[],f=this.extrema().values;for(f.indexOf(0)===-1&&(f=[0].concat(f)),f.indexOf(1)===-1&&f.push(1),e=f[0],n=1;n<f.length;n++)i=f[n],c=this.split(e,i),c._t1=e,c._t2=i,r.push(c),e=i;return r.forEach(function(a){for(e=0,i=0;i<=1;)for(i=e+s;i<=1+s;i+=s)if(c=a.split(e,i),!c.simple()){if(i-=s,G(e-i)<s)return[];c=a.split(e,i),c._t1=y.map(e,0,1,a._t1,a._t2),c._t2=y.map(i,0,1,a._t1,a._t2),u.push(c),e=i;break}e<1&&(c=a.split(e,1),c._t1=y.map(e,0,1,a._t1,a._t2),c._t2=a._t2,u.push(c))}),u}translate(n,e,i){i=typeof i=="number"?i:e;const s=this.order;let c=this.points.map((r,u)=>(1-u/s)*e+u/s*i);return new w(this.points.map((r,u)=>({x:r.x+n.x*c[u],y:r.y+n.y*c[u]})))}scale(n){const e=this.order;let i=!1;if(typeof n=="function"&&(i=n),i&&e===2)return this.raise().scale(i);const s=this.clockwise,c=this.points;if(this._linear)return this.translate(this.normal(0),i?i(0):n,i?i(1):n);const r=i?i(0):n,u=i?i(1):n,f=[this.offset(0,10),this.offset(1,10)],a=[],h=y.lli4(f[0],f[0].c,f[1],f[1].c);if(!h)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach(function(l){const x=a[l*e]=y.copy(c[l*e]);x.x+=(l?u:r)*f[l].n.x,x.y+=(l?u:r)*f[l].n.y}),i?([0,1].forEach(function(l){if(!(e===2&&l)){var x=c[l+1],p={x:x.x-h.x,y:x.y-h.y},d=i?i((l+1)/e):n;i&&!s&&(d=-d);var z=J(p.x*p.x+p.y*p.y);p.x/=z,p.y/=z,a[l+1]={x:x.x+d*p.x,y:x.y+d*p.y}}}),new w(a)):([0,1].forEach(l=>{if(e===2&&l)return;const x=a[l*e],p=this.derivative(l),d={x:x.x+p.x,y:x.y+p.y};a[l+1]=y.lli4(x,d,h,c[l+1])}),new w(a))}outline(n,e,i,s){if(e=e===void 0?n:e,this._linear){const m=this.normal(0),M=this.points[0],g=this.points[this.points.length-1];let v,C,b;i===void 0&&(i=n,s=e),v={x:M.x+m.x*n,y:M.y+m.y*n},b={x:g.x+m.x*i,y:g.y+m.y*i},C={x:(v.x+b.x)/2,y:(v.y+b.y)/2};const O=[v,C,b];v={x:M.x-m.x*e,y:M.y-m.y*e},b={x:g.x-m.x*s,y:g.y-m.y*s},C={x:(v.x+b.x)/2,y:(v.y+b.y)/2};const q=[b,C,v],j=y.makeline(q[2],O[0]),$=y.makeline(O[2],q[0]),xt=[j,new w(O),$,new w(q)];return new L(xt)}const c=this.reduce(),r=c.length,u=[];let f=[],a,h=0,l=this.length();const x=typeof i<"u"&&typeof s<"u";function p(m,M,g,v,C){return function(b){const O=v/g,q=(v+C)/g,j=M-m;return y.map(b,0,1,m+O*j,m+q*j)}}c.forEach(function(m){const M=m.length();x?(u.push(m.scale(p(n,i,l,h,M))),f.push(m.scale(p(-e,-s,l,h,M)))):(u.push(m.scale(n)),f.push(m.scale(-e))),h+=M}),f=f.map(function(m){return a=m.points,a[3]?m.points=[a[3],a[2],a[1],a[0]]:m.points=[a[2],a[1],a[0]],m}).reverse();const d=u[0].points[0],z=u[r-1].points[u[r-1].points.length-1],E=f[r-1].points[f[r-1].points.length-1],_=f[0].points[0],A=y.makeline(E,d),k=y.makeline(z,_),P=[A].concat(u).concat([k]).concat(f);return new L(P)}outlineshapes(n,e,i){e=e||n;const s=this.outline(n,e).curves,c=[];for(let r=1,u=s.length;r<u/2;r++){const f=y.makeshape(s[r],s[u-r],i);f.startcap.virtual=r>1,f.endcap.virtual=r<u/2-1,c.push(f)}return c}intersects(n,e){return n?n.p1&&n.p2?this.lineIntersects(n):(n instanceof w&&(n=n.reduce()),this.curveintersects(this.reduce(),n,e)):this.selfintersects(e)}lineIntersects(n){const e=Y(n.p1.x,n.p2.x),i=Y(n.p1.y,n.p2.y),s=Z(n.p1.x,n.p2.x),c=Z(n.p1.y,n.p2.y);return y.roots(this.points,n).filter(r=>{var u=this.get(r);return y.between(u.x,e,s)&&y.between(u.y,i,c)})}selfintersects(n){const e=this.reduce(),i=e.length-2,s=[];for(let c=0,r,u,f;c<i;c++)u=e.slice(c,c+1),f=e.slice(c+2),r=this.curveintersects(u,f,n),s.push(...r);return s}curveintersects(n,e,i){const s=[];n.forEach(function(r){e.forEach(function(u){r.overlaps(u)&&s.push({left:r,right:u})})});let c=[];return s.forEach(function(r){const u=y.pairiteration(r.left,r.right,i);u.length>0&&(c=c.concat(u))}),c}arcs(n){return n=n||.5,this._iterate(n,[])}_error(n,e,i,s){const c=(s-i)/4,r=this.get(i+c),u=this.get(s-c),f=y.dist(n,e),a=y.dist(n,r),h=y.dist(n,u);return G(a-f)+G(h-f)}_iterate(n,e){let i=0,s=1,c;do{c=0,s=1;let r=this.get(i),u,f,a,h,l=!1,x=!1,p,d=s,z=1;do if(x=l,h=a,d=(i+s)/2,u=this.get(d),f=this.get(s),a=y.getccenter(r,u,f),a.interval={start:i,end:s},l=this._error(a,r,i,s)<=n,p=x&&!l,p||(z=s),l){if(s>=1){if(a.interval.end=z=1,h=a,s>1){let _={x:a.x+a.r*st(a.e),y:a.y+a.r*rt(a.e)};a.e+=y.angle({x:a.x,y:a.y},_,this.get(1))}break}s=s+(s-i)/2}else s=d;while(!p&&c++<100);if(c>=100)break;h=h||a,e.push(h),i=z}while(s<1);return e}}function K(o,n){const e=[n];o.type==="line"?e.push(o.p):e.push(o.p1,o.p2,o.p3);const i=e.map(c=>c[0]),s=e.map(c=>c[1]);return[Math.min(...i),Math.min(...s),Math.max(...i),Math.max(...s)]}function B(o,n){const e=o[0]-n[0],i=o[1]-n[1];return e*e+i*i}function ut(o){return o.segment.type==="line"?o.segment.p:o.segment.p3}function Q(o){if(o.segment.type!=="bezier")throw new Error("Boundary segment is not a Bezier curve");const{startPoint:n}=o,{p1:e,p2:i,p3:s}=o.segment;return new w({x:n[0],y:n[1]},{x:e[0],y:e[1]},{x:i[0],y:i[1]},{x:s[0],y:s[1]})}function ft(o,n){const e=[],i=o.halfEdge;let s=i;do{const c=n.halfEdges.get(s);if(!c){console.error(`Could not find half-edge with ID: ${s}`);break}let r=c.origin;if(c.segments&&c.segments.length>0)for(const u of c.segments)e.push({segment:u,startPoint:r,bbox:K(u,r)}),r=u.type==="line"?u.p:u.p3;else{const u=n.halfEdges.get(c.next);if(!u){console.error(`Could not find next half-edge for ID: ${c.next}`);continue}const f={type:"line",p:u.origin};e.push({segment:f,startPoint:r,bbox:K(f,r)})}s=c.next}while(s!==i);return e}function at(o,n){return!(o[2]<n[0]||o[0]>n[2]||o[3]<n[1]||o[1]>n[3])}function lt(o,n,e){return new Promise(i=>{const s=[],c=o.segment.type,r=n.segment.type;if(c==="bezier"&&r==="bezier"){const u=Q(o),f=Q(n);u.intersects(f).forEach(h=>{const l=h.split("/"),x=parseFloat(l[0]),p=parseFloat(l[1]);if(e&&(x>.99&&p<.01||x<.01&&p>.99))return;const d=u.get(x);s.push([d.x,d.y])})}else if(c==="bezier"||r==="bezier"){const u=c==="bezier"?o:n,f=c==="line"?o:n,a=Q(u),h={p1:{x:f.startPoint[0],y:f.startPoint[1]},p2:{x:f.segment.p[0],y:f.segment.p[1]}};a.intersects(h).forEach(x=>{const p=a.get(x);s.push([p.x,p.y])})}else{const u=o.startPoint,f=o.segment.p,a=n.startPoint,h=n.segment.p,[l,x]=u,[p,d]=f,[z,E]=a,[_,A]=h,k=(l-p)*(E-A)-(x-d)*(z-_);if(k!==0){const P=((l-z)*(E-A)-(x-E)*(z-_))/k,m=-((l-p)*(x-E)-(x-d)*(l-z))/k;if(P>=0&&P<=1&&m>=0&&m<=1){const M=l+P*(p-l),g=x+P*(d-x);s.push([M,g])}}}i(s)})}async function ht(o,n){const e=[],c=Array.from(o.pieces.values()).length;let r=0;for(const u of o.pieces.values()){n?.(r,c);const f=ft(u,o),a=f.length;if(a<2){r++;continue}for(let h=0;h<a;h++)for(let l=h+1;l<a;l++){const x=f[h],p=f[l];if(!at(x.bbox,p.bbox))continue;const d=l===h+1||h===0&&l===a-1,z=await lt(x,p,d);if(z.length!==0)if(d){const E=h===0&&l===a-1?x.startPoint:ut(x);for(const _ of z)B(_,E)>1e-8&&e.push(_)}else e.push(...z)}r++}return n?.(c,c),console.log(`detected ${e.length} intersections in ${o.pieces.size} pieces`),e}async function yt(o,n){const e=await ht(o,n);if(e.length<2)return e;const i=1,s=[e[0]];for(let c=1;c<e.length;c++){const r=e[c],u=s[s.length-1];B(r,u)>i*i&&s.push(r)}return s}self.onmessage=async o=>{try{const{topology:n}=o.data,e=tt(n),c={type:"done",results:await yt(e,(r,u)=>{const f={type:"progress",processed:r,total:u};self.postMessage(f)})};self.postMessage(c)}catch(n){const e={type:"error",message:n instanceof Error?n.message:`An error occurred in the CheckGeometryWorker: ${String(n)}.`};self.postMessage(e)}finally{self.close()}}})();
//# sourceMappingURL=CheckGeometryWorker-BOJd4zFt.js.map
