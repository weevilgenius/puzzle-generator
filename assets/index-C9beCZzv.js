import{m as y,g as Ke}from"./mithril-DD6GaBKN.js";import{r as Xe}from"./webawesome-BjM85SLR.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const t of i)if(t.type==="childList")for(const s of t.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&r(s)}).observe(document,{childList:!0,subtree:!0});function n(i){const t={};return i.integrity&&(t.integrity=i.integrity),i.referrerPolicy&&(t.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?t.credentials="include":i.crossOrigin==="anonymous"?t.credentials="omit":t.credentials="same-origin",t}function r(i){if(i.ep)return;i.ep=!0;const t=n(i);fetch(i.href,t)}})();const Ye={view:({attrs:a})=>y("a.github-corner",{href:a.link,"aria-label":"View source on GitHub",title:"View source on GitHub",target:"_blank"},y("svg",{width:80,height:80,viewBox:"0 0 250 250","aria-hidden":"true"},[y("path",{d:"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"}),y("path.octo-arm",{fill:"currentColor",style:"transform-origin: 130px 106px;",d:"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"}),y("path.octo-body",{fill:"currentColor",d:"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"})]))};class se{generators=new Map;register(e,n,r){this.generators.has(e)&&console.warn(`Generator "${e}" is already registered, overwriting`),this.generators.set(e,{factory:n,uiMetadata:r})}create(e,n,r){const i=this.generators.get(r.name);if(!i)throw new Error(`Unknown generator "${r.name}". Is it registered?`);return i.factory(e,n,r)}getAvailableGenerators(){return Array.from(this.generators.values()).sort((e,n)=>e.uiMetadata.sortHint-n.uiMetadata.sortHint).map(e=>({name:e.uiMetadata.name,displayName:e.uiMetadata.displayName}))}getUIMetadata(e){return this.generators.get(e)?.uiMetadata}getDefaultConfig(e,n,r){const i={name:e,width:n,height:r},t=this.getUIMetadata(e);if(t)for(const s of t.controls)i[s.name]=s.defaultValue;return i}}const Y=new se,J=new se,Q=new se,H=new se;function Je(a,e){const n=a[0]-e[0],r=a[1]-e[1];return n*n+r*r}function Qe(a){return{vertices:a.vertices,pieces:Array.from(a.pieces.entries()),edges:Array.from(a.edges.entries()),halfEdges:Array.from(a.halfEdges.entries()),boundary:a.boundary}}function Ze(a,e){let n=1/0,r=1/0,i=-1/0,t=-1/0;const s=a.halfEdge;let o=e.halfEdges.get(s);if(!o)return a.bounds;const l=c=>{n=Math.min(n,c[0]),r=Math.min(r,c[1]),i=Math.max(i,c[0]),t=Math.max(t,c[1])};do{if(l(o.origin),o.segments)for(const c of o.segments)c.type==="line"?l(c.p):(l(c.p1),l(c.p2),l(c.p3));o=e.halfEdges.get(o.next)}while(o&&o.id!==s);return[n,r,i,t]}const _e=100,et=_e*_e;function tt(a,e){let n=-1,r=et;for(let i=0;i<a.vertices.length;i++){const t=Je(a.vertices[i],e);t<r&&(r=t,n=i)}return n===-1?null:n}function X(a){if(a.length===0)return[0,0,0,0];let e=a[0][0],n=a[0][1],r=e,i=n;for(let t=1;t<a.length;t++){const s=a[t];e=Math.min(e,s[0]),n=Math.min(n,s[1]),r=Math.max(r,s[0]),i=Math.max(i,s[1])}return[e,n,r,i]}function nt(a,e){return Math.abs(a[0]-e[0])<1e-6&&Math.abs(a[1]-e[1])<1e-6}function Ue(a,e,n,r){if(!a.tabs)return;const i=e.halfEdges.get(a.heLeft),t=e.halfEdges.get(a.heRight),s=i.origin,o=t.origin,l=[];let c=s;a.tabs.sort((h,u)=>h.position-u.position);for(const h of a.tabs){const u=h.position-h.size/2,d=[s[0]+(o[0]-s[0])*u,s[1]+(o[1]-s[1])*u];Math.hypot(d[0]-c[0],d[1]-c[1])>1e-6&&l.push({type:"line",p:d});const g=[s[0]+(o[0]-s[0])*(u+h.size),s[1]+(o[1]-s[1])*(u+h.size)],p=n.createTabSegments(d,g,h,r);l.push(...p),c=g}Math.hypot(o[0]-c[0],o[1]-c[1])>1e-6&&l.push({type:"line",p:o}),i.segments=l,t.segments=it(l,s)}function it(a,e){const n=[];for(let r=a.length-1;r>=0;r--){const i=a[r];let t=e;if(r>0){const s=a[r-1];t=s.type==="line"?s.p:s.p3}i.type==="line"?n.push({type:"line",p:t}):n.push({type:"bezier",p1:i.p2,p2:i.p1,p3:t})}return n}function Ve(a){return function(){let e=a+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}async function xe(a){const{width:e,height:n,pieceSize:r}=a,{pointConfig:i,pieceConfig:t,placementConfig:s,tabConfig:o}=a;console.log(`rebuilding puzzle with dimensions ${e}x${n}, piece size ${r}`);const l=Y.create(e,n,i),c=J.create(e,n,t),h=Q.create(e,n,s),u=H.create(e,n,o),d=a.seed??new Date().getTime(),g=Ve(d),p=l.generatePoints({width:e,height:n,pieceSize:r,random:g});console.log(`Generated ${p.length} points`);const f=c.generatePieces(p,{random:g,pieceSize:r});console.log(`Generated ${f.pieces.size} pieces`),h.placeTabs({topology:f,random:g});for(const m of f.edges.values())m.heRight!==-1&&m.tabs&&m.tabs.length>0&&Ue(m,f,u,g);return{created:new Date().toISOString(),seed:d,width:e,height:n,pieceSize:r,pointConfig:i,pieceConfig:t,placementConfig:s,tabConfig:o,vertices:f.vertices,boundary:f.boundary,pieces:f.pieces,edges:f.edges,halfEdges:f.halfEdges}}function oe(a,e,n,r=!1){const i=e.getContext("2d");if(!i){console.error("Could not get 2D context from canvas");return}i.clearRect(0,0,e.width,e.height);{i.strokeStyle=n,i.lineWidth=1,i.beginPath();for(const t of a.edges.values()){const s=a.halfEdges.get(t.heLeft);if(s)if(i.moveTo(s.origin[0],s.origin[1]),s.segments&&s.segments.length>0)for(const o of s.segments)switch(o.type){case"bezier":i.bezierCurveTo(o.p1[0],o.p1[1],o.p2[0],o.p2[1],o.p3[0],o.p3[1]);break;case"line":i.lineTo(o.p[0],o.p[1]);break}else{let o;s.twin!==-1?o=a.halfEdges.get(s.twin).origin:o=a.halfEdges.get(s.next).origin,i.lineTo(o[0],o[1])}}i.stroke()}if(a.problems&&a.problems.length>0){i.lineWidth=2,i.strokeStyle="red";for(const t of a.problems){const[s,o]=t;i.beginPath(),i.arc(s,o,8,0,2*Math.PI),i.stroke()}}if(r){i.fillStyle="blue";for(const t of a.pieces.values()){const[s,o]=t.site;i.beginPath(),i.arc(s,o,3,0,2*Math.PI),i.fill()}}}function st(a,e,n){if(e<0||e>=a.vertices.length){console.warn("moveVertex called with invalid vertex index:",e);return}const r=a.vertices[e];a.vertices[e]=n;const i=[];for(const o of a.halfEdges.values())o.origin[0]===r[0]&&o.origin[1]===r[1]&&i.push(o);const t=new Set,s=[n[0]-r[0],n[1]-r[1]];for(const o of i){o.origin=n,t.add(o.piece);const l=a.halfEdges.get(o.prev);if(l?.segments){const c=l.segments[l.segments.length-1];c.type==="line"?c.p=n:(c.p3=n,c.p1=[c.p1[0]+s[0],c.p1[1]+s[1]],c.p2=[c.p2[0]+s[0],c.p2[1]+s[1]]),t.add(l.piece)}}ot(a,e);for(const o of t){const l=a.pieces.get(o);l&&(l.bounds=Ze(l,a))}}function ot(a,e){const{seed:n,width:r,height:i,placementConfig:t,tabConfig:s}=a,o=Ve(n),l=Q.create(r,i,t),c=H.create(r,i,s),h=new Set,u=a.vertices[e],d=new Map;for(const g of a.edges.values())d.set(g.heLeft,g),g.heRight!==-1&&d.set(g.heRight,g);for(const g of a.halfEdges.values()){const p=a.halfEdges.get(g.next)?.origin;if(g.origin===u||p===u){const m=d.get(g.id);m&&h.add(m)}}l.updateTabPlacements(Array.from(h),{topology:a,random:o});for(const g of h)if(g.heRight!==-1){const f=a.halfEdges.get(g.heLeft);f&&(f.segments=void 0);const b=a.halfEdges.get(g.heRight);b&&(b.segments=void 0),Ue(g,a,c,o)}}const rt=()=>{const a={canvas:null,isDragging:!1,draggedVertexId:-1};return{oncreate:({dom:e,attrs:n})=>{if(a.canvas=e.querySelector("canvas.puzzle"),!a.canvas){console.log("couldn't get canvas element");return}n.isDirty||oe(n.puzzle,a.canvas,n.color)},onupdate:({attrs:e})=>{if(!a.canvas){console.log("couldn't get canvas element");return}e.isDirty||oe(e.puzzle,a.canvas,e.color)},view:({attrs:e})=>y(".puzzle-stack",[y("img.background",{width:e.width,height:e.height,src:e.imageUrl}),y("canvas.puzzle",{width:e.width,height:e.height,style:{width:`${e.width}px`,height:`${e.height}px`},onmousedown:n=>{if(n.redraw=!1,n.button!==0)return;n.preventDefault();const r=[n.offsetX,n.offsetY],i=tt(e.puzzle,r);i!==null&&(a.draggedVertexId=i)},onmousemove:n=>{if(n.redraw=!1,a.draggedVertexId<0)return;a.isDragging=!0,n.preventDefault();const r=[n.offsetX,n.offsetY];st(e.puzzle,a.draggedVertexId,r),oe(e.puzzle,a.canvas,e.color)},onmouseup:n=>{n.redraw=!1,n.preventDefault(),a.isDragging&&e.onPuzzleChanged(e.puzzle),a.isDragging=!1,a.draggedVertexId=-1},onmouseleave:n=>{n.redraw=!1,a.isDragging&&(n.preventDefault(),e.onPuzzleChanged(e.puzzle),a.isDragging=!1,a.draggedVertexId=-1)}})])}};function at(a,e,n,r="black"){const t=[];for(const l of a.edges.values()){const c=a.halfEdges.get(l.heLeft);if(c)if(t.push(`M ${c.origin[0].toFixed(3)} ${c.origin[1].toFixed(3)}`),c.segments)for(const h of c.segments)switch(h.type){case"bezier":t.push(`C ${h.p1[0].toFixed(3)} ${h.p1[1].toFixed(3)}, ${h.p2[0].toFixed(3)} ${h.p2[1].toFixed(3)}, ${h.p3[0].toFixed(3)} ${h.p3[1].toFixed(3)}`);break;case"line":t.push(`L ${h.p[0].toFixed(3)} ${h.p[1].toFixed(3)}`);break}else{let h;c.twin!==-1?h=a.halfEdges.get(c.twin).origin:h=a.halfEdges.get(c.next).origin,t.push(`L ${h[0].toFixed(3)} ${h[1].toFixed(3)}`)}}const s=t.join(" ");return`
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg
  width="${e}"
  height="${n}"
  viewBox="0 0 ${e} ${n}"
  xmlns="http://www.w3.org/2000/svg"
  version="1.1"
>
  <path
    d="${s}"
    fill="none"
    stroke="${r}"
    stroke-width="1"
    vector-effect="non-scaling-stroke"
  />
</svg>`.trim().replace(/\r\n/g,`
`)}function lt(a,e="puzzle.svg"){const n=new Blob([a],{type:"image/svg+xml"}),r=URL.createObjectURL(n),i=document.createElement("a");i.href=r,i.download=e,i.hidden=!0,document.body.appendChild(i),i.click(),document.body.removeChild(i),setTimeout(()=>URL.revokeObjectURL(r),100)}const ct={view:({attrs:a})=>y("wa-button.download-svg",{size:"small",onclick:()=>{const e=at(a.puzzle,a.width,a.height,a.color);lt(e,a.filename??"puzzle.svg")}},"Download SVG")},ht={view:({attrs:a})=>{const e=a.progressPercent!==void 0&&a.progressPercent<100,n=!e&&a.problems!==void 0&&a.problems==0,r=!e&&a.problems!==void 0&&a.problems>0;return y(".geometry-check-indicator",[y(".label","Geometry Check:"),y("wa-tooltip",{for:"check-geometry-now"},"Check geometry now"),y("wa-button#check-geometry-now",{variant:"neutral",appearance:"plain",size:"small",disabled:e,onclick:i=>{i.redraw=!1,a.onCheckRequested?.()}},y("wa-icon",{library:"material",name:"editor_choice",label:"Check geometry now"})),y("wa-tooltip",{for:"auto-check-geometry"},"Check geometry after every change"),y("wa-checkbox#auto-check-geometry",{checked:a.autoCheck,disabled:e,size:"small",onchange:i=>{i.redraw=!1;const t=i.target;a.onAutocheckChanged?.(t.checked)}},"auto check"),e&&y("wa-progress-bar",{label:"Geometry check progress",value:a.progressPercent??0}),n&&y("wa-badge",{variant:"success",pill:!0},"OK"),r&&y("wa-badge",{variant:"danger",pill:!0},`${a.problems} issue${a.problems===1?"":"s"}`)])}};function ut(a,e,n=800){if(a<=n)return{width:a,height:e};const r=e/a;return{width:n,height:Math.round(n*r)}}const dt=()=>{const a={inputElement:void 0};return{view:({attrs:e})=>[y("wa-button.upload-button",{size:"small",disabled:e.disabled===!0,onclick:()=>{a.inputElement&&a.inputElement.click()}},e.label??"Upload Image"),y("input[type=file]",{style:{display:"none"},accept:"image/*",oncreate:({dom:n})=>{a.inputElement=n},onchange:n=>{if(n.redraw=!1,a.inputElement){const r=a.inputElement.files?.[0];r?.type.startsWith("image/")&&createImageBitmap(r).then(i=>{const{width:t,height:s}=ut(i.width,i.height),o=URL.createObjectURL(r);i.close(),e.onUpload(o,r.name,t,s)}).catch(i=>{console.error("could not create a bitmap image: ",i)})}}})]}},gt=()=>({view:({attrs:a})=>y("wa-checkbox.boolean-input",{hint:a.config.helpText,disabled:a.disabled,checked:a.value,onchange:e=>{const r=e.target.checked;a.onChange(r)}},a.config.label)}),pe=()=>({view:({attrs:a})=>y("wa-input.number-input",{label:a.config.label,hint:a.config.helpText,type:"number",inputmode:"numeric",size:"small",disabled:a.disabled,value:a.value,min:a.config.min,max:a.config.max,onchange:e=>{const n=e.target,r=parseFloat(n.value??"");a.onChange(isNaN(r)?void 0:r)}})}),ft=()=>({view:({attrs:a})=>y("wa-slider.range-input",{label:a.config.label,hint:a.config.helpText,disabled:a.disabled,value:a.value,min:a.config.min,max:a.config.max,step:a.config.step,onchange:e=>{const r=e.target.value;a.onChange(isNaN(r)?void 0:r)}})}),pt=()=>({view:({attrs:a})=>y("wa-input.string-input",{label:a.config.label,hint:a.config.helpText,type:"text",inputmode:"text",size:"small",disabled:a.disabled,value:a.value,onchange:e=>{const r=e.target.value??"";a.onChange(r.length>0?r:void 0)}})}),mt=()=>({view:({attrs:a})=>{const e=a.registry.getAvailableGenerators();return y(".generator-picker",y("wa-tab-group",{active:a.generator,"onwa-tab-show":n=>{const r=n.detail.name;a.generator!==r&&a.onGeneratorChange(r)}},[...e.map(n=>{const r=a.registry.getUIMetadata(n.name),i=y("wa-tab",{panel:n.name},n.displayName),t=y("wa-tab-panel",{name:n.name},y(".controls",[r?.description?y("p",r.description):null,...r?.controls.map(s=>{switch(s.type){case"range":return y(ft,{config:s,value:a.config?.[s.name]??s.defaultValue,onChange:o=>{a.onConfigChange(s.name,o)}});case"boolean":return y(gt,{config:s,value:(a.config?.[s.name]??s.defaultValue)===!0,onChange:o=>{a.onConfigChange(s.name,o)}});case"number":return y(pe,{config:s,value:a.config?.[s.name]??s.defaultValue,onChange:o=>{a.onConfigChange(s.name,o)}});case"string":return y(pt,{config:s,value:a.config?.[s.name]??s.defaultValue,onChange:o=>{a.onConfigChange(s.name,o)}})}})??[],!r?.description&&r?.controls.length==0?y("p","No controls for this strategy."):null]));return[i,t]})]))}}),De=[["Square","1:1",1],["Classic Photo","5:4",5/4],["Standard Photo","4:3",4/3],["35mm/DSLR","3:2",3/2],["Widescreen","16:9",16/9],["UltraWide","21:9",21/9],["Panorama","2:1",2/1],["Instagram Portrait","4:5",4/5],["Classic Portrait","3:4",3/4],["DSLR Portrait","2:3",2/3],["Phone Portrait","9:16",9/16],["Tall Poster","9:21",9/21],["Tall Panorama","1:2",1/2]],bt={view:({attrs:a})=>{const e=!De.some(([,,r])=>r===a.ratio),n=De.map(([r,i,t])=>y("wa-option",{value:String(t)},`${r} [${i}]`));return e&&n.unshift(y("wa-option",{value:"custom"},"Custom")),y(".aspect-ratio-picker",[y("wa-select",{label:"Aspect Ratio",size:"small",disabled:a.disabled,value:e?"custom":String(a.ratio),onchange:r=>{r.redraw=!1;const t=r.target.value;t&&t!=="custom"&&a.onChange(Number(t))}},n),y("wa-slider",{min:.25,max:4,step:.01,"with-tooltip":!0,size:"small",disabled:a.disabled,value:a.ratio,onchange:r=>{r.redraw=!1;const i=r.target;a.onChange(i.value)}})])}},yt={view:({attrs:a})=>y(".color-picker",[y(".label",a.label),y("wa-color-picker",{label:"Select a color",value:a.color,size:a.size??"medium",format:"rgb",onchange:e=>{e.redraw=!1;const n=e.target;a.onUpdate(n.value??"")}})])};var re,Me;function Ne(){if(Me)return re;Me=1;function a(n){var r=n.length,i=1,t=new Array(r),s;for(s=r;s>0;s--)t[s-1]=i,i=i*n[s-1];return{stride:t,data:new Uint32Array(i)}}function e(n){var r=n.length,i=1,t=new Array(r),s=[],o,l;for(o=r;o>0;o--)t[o-1]=i,i=i*n[o-1];for(l=0;l<i;l++)s.push([]);return{stride:t,data:s}}return re={integer:a,array:e},re}var ae,ke;function Fe(){if(ke)return ae;ke=1,ae=a;function a(e,n){var r=new Array(e),i=Math.floor(e/2)<<1,t=0,s,o,l,c,h;for(h=0;h<i;h+=2)s=-2*Math.log(n()),o=Math.sqrt(s),l=2*Math.PI*n(),t+=s,r[h]=o*Math.cos(l),r[h+1]=o*Math.sin(l);if(e%2){var u=Math.sqrt(-2*Math.log(n()))*Math.cos(2*Math.PI*n());r[e-1]=u,t+=Math.pow(u,2)}for(c=1/Math.sqrt(t),h=0;h<e;++h)r[h]*=c;return r}return ae}var le,Ce;function wt(){return Ce||(Ce=1,le=function(e,n){e=e||1,n=n||2;for(var r=e*2+1,i=Math.pow(r,n)-1,t=new Array(i),s=0;s<i;s++)for(var o=t[s]=new Array(n),l=s<i/2?s:s+1,c=1;c<=n;c++){var h=l%Math.pow(r,c);o[c-1]=h/Math.pow(r,c-1)-e,l-=h}return t}),le}var ce,Se;function He(){if(Se)return ce;Se=1;var a=wt();function e(i){var t=a(2,i),s=[],o;for(t=t.filter(function(l){for(var c=0,h=0;h<i;h++)c+=Math.pow(Math.max(0,Math.abs(l[h])-1),2);return c<i}),o=0;o<i;o++)s.push(0);return t.push(s),t.sort(function(l,c){var h=0,u=0,d;for(d=0;d<i;d++)h+=Math.pow(l[d],2),u+=Math.pow(c[d],2);return h<u?-1:h>u?1:0}),t}var n={};function r(i){return n[i]||(n[i]=e(i)),n[i]}return ce=r,ce}var he,Te;function vt(){if(Te)return he;Te=1;var a=Ne().integer,e=Fe(),n=He();function r(t,s){for(var o=0,l=0;l<t.length;l++)o+=Math.pow(t[l]-s[l],2);return o}function i(t,s){if(typeof t.distanceFunction=="function")throw new Error("PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction");this.shape=t.shape,this.minDistance=t.minDistance,this.maxDistance=t.maxDistance||t.minDistance*2,this.maxTries=Math.ceil(Math.max(1,t.tries||30)),this.rng=s||Math.random;for(var o=0,l=0;l<this.shape.length;l++)o=Math.max(o,this.shape[l]);var c=Math.max(1,o/128|0),h=1e-14*c;this.dimension=this.shape.length,this.squaredMinDistance=this.minDistance*this.minDistance,this.minDistancePlusEpsilon=this.minDistance+h,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.minDistance/Math.sqrt(this.dimension),this.neighbourhood=n(this.dimension),this.currentPoint=null,this.processList=[],this.samplePoints=[],this.gridShape=[];for(var l=0;l<this.dimension;l++)this.gridShape.push(Math.ceil(this.shape[l]/this.cellSize));this.grid=a(this.gridShape)}return i.prototype.shape=null,i.prototype.dimension=null,i.prototype.minDistance=null,i.prototype.maxDistance=null,i.prototype.minDistancePlusEpsilon=null,i.prototype.squaredMinDistance=null,i.prototype.deltaDistance=null,i.prototype.cellSize=null,i.prototype.maxTries=null,i.prototype.rng=null,i.prototype.neighbourhood=null,i.prototype.currentPoint=null,i.prototype.processList=null,i.prototype.samplePoints=null,i.prototype.gridShape=null,i.prototype.grid=null,i.prototype.addRandomPoint=function(){for(var t=new Array(this.dimension),s=0;s<this.dimension;s++)t[s]=this.rng()*this.shape[s];return this.directAddPoint(t)},i.prototype.addPoint=function(t){var s,o=!0;if(t.length===this.dimension)for(s=0;s<this.dimension&&o;s++)o=t[s]>=0&&t[s]<this.shape[s];else o=!1;return o?this.directAddPoint(t):null},i.prototype.directAddPoint=function(t){var s=0,o=this.grid.stride,l;for(this.processList.push(t),this.samplePoints.push(t),l=0;l<this.dimension;l++)s+=(t[l]/this.cellSize|0)*o[l];return this.grid.data[s]=this.samplePoints.length,t},i.prototype.inNeighbourhood=function(t){var s=this.dimension,o=this.grid.stride,l,c,h,u,d;for(l=0;l<this.neighbourhood.length;l++){for(c=0,h=0;h<s;h++){if(u=(t[h]/this.cellSize|0)+this.neighbourhood[l][h],u<0||u>=this.gridShape[h]){c=-1;break}c+=u*o[h]}if(c!==-1&&this.grid.data[c]!==0&&(d=this.samplePoints[this.grid.data[c]-1],r(t,d)<this.squaredMinDistance))return!0}return!1},i.prototype.next=function(){for(var t,s,o,l,c,h,u;this.processList.length>0;){for(this.currentPoint===null&&(this.currentPoint=this.processList.shift()),l=this.currentPoint,t=0;t<this.maxTries;t++){for(h=!0,o=this.minDistancePlusEpsilon+this.deltaDistance*this.rng(),this.dimension===2?(s=this.rng()*Math.PI*2,c=[Math.cos(s),Math.sin(s)]):c=e(this.dimension,this.rng),u=0;h&&u<this.dimension;u++)c[u]=l[u]+c[u]*o,h=c[u]>=0&&c[u]<this.shape[u];if(h&&!this.inNeighbourhood(c))return this.directAddPoint(c)}t===this.maxTries&&(this.currentPoint=null)}return null},i.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},i.prototype.getAllPoints=function(){return this.samplePoints},i.prototype.getAllPointsWithDistance=function(){throw new Error("PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation")},i.prototype.reset=function(){var t=this.grid.data,s=0;for(s=0;s<t.length;s++)t[s]=0;this.samplePoints=[],this.currentPoint=null,this.processList.length=0},he=i,he}var ue,Ie;function Pt(){if(Ie)return ue;Ie=1;var a=Ne().array,e=Fe(),n=He();function r(t,s){for(var o=0,l=0;l<t.length;l++)o+=Math.pow(t[l]-s[l],2);return Math.sqrt(o)}function i(t,s){if(typeof t.distanceFunction!="function")throw new Error("PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction");this.shape=t.shape,this.minDistance=t.minDistance,this.maxDistance=t.maxDistance||t.minDistance*2,this.maxTries=Math.ceil(Math.max(1,t.tries||30)),this.distanceFunction=t.distanceFunction,this.bias=Math.max(0,Math.min(1,t.bias||0)),this.rng=s||Math.random;for(var o=0,l=0;l<this.shape.length;l++)o=Math.max(o,this.shape[l]);var c=Math.max(1,o/128|0),h=1e-14*c;this.dimension=this.shape.length,this.minDistancePlusEpsilon=this.minDistance+h,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.maxDistance/Math.sqrt(this.dimension),this.neighbourhood=n(this.dimension),this.currentPoint=null,this.currentDistance=0,this.processList=[],this.samplePoints=[],this.sampleDistance=[],this.gridShape=[];for(var l=0;l<this.dimension;l++)this.gridShape.push(Math.ceil(this.shape[l]/this.cellSize));this.grid=a(this.gridShape)}return i.prototype.shape=null,i.prototype.dimension=null,i.prototype.minDistance=null,i.prototype.maxDistance=null,i.prototype.minDistancePlusEpsilon=null,i.prototype.deltaDistance=null,i.prototype.cellSize=null,i.prototype.maxTries=null,i.prototype.distanceFunction=null,i.prototype.bias=null,i.prototype.rng=null,i.prototype.neighbourhood=null,i.prototype.currentPoint=null,i.prototype.currentDistance=null,i.prototype.processList=null,i.prototype.samplePoints=null,i.prototype.sampleDistance=null,i.prototype.gridShape=null,i.prototype.grid=null,i.prototype.addRandomPoint=function(){for(var t=new Array(this.dimension),s=0;s<this.dimension;s++)t[s]=this.rng()*this.shape[s];return this.directAddPoint(t)},i.prototype.addPoint=function(t){var s,o=!0;if(t.length===this.dimension)for(s=0;s<this.dimension&&o;s++)o=t[s]>=0&&t[s]<this.shape[s];else o=!1;return o?this.directAddPoint(t):null},i.prototype.directAddPoint=function(t){var s=0,o=this.grid.stride,l=this.samplePoints.length,c;for(this.processList.push(l),this.samplePoints.push(t),this.sampleDistance.push(this.distanceFunction(t)),c=0;c<this.dimension;c++)s+=(t[c]/this.cellSize|0)*o[c];return this.grid.data[s].push(l),t},i.prototype.inNeighbourhood=function(t){var s=this.dimension,o=this.grid.stride,l,c,h,u,d,g,p=this.distanceFunction(t);for(l=0;l<this.neighbourhood.length;l++){for(c=0,h=0;h<s;h++){if(u=(t[h]/this.cellSize|0)+this.neighbourhood[l][h],u<0||u>=this.gridShape[h]){c=-1;break}c+=u*o[h]}if(c!==-1&&this.grid.data[c].length>0)for(var f=0;f<this.grid.data[c].length;f++){d=this.samplePoints[this.grid.data[c][f]],g=this.sampleDistance[this.grid.data[c][f]];var b=Math.min(g,p),m=Math.max(g,p),w=b+(m-b)*this.bias;if(r(t,d)<this.minDistance+this.deltaDistance*w)return!0}}return!1},i.prototype.next=function(){for(var t,s,o,l,c,h,u,d;this.processList.length>0;){if(this.currentPoint===null){var g=this.processList.shift();this.currentPoint=this.samplePoints[g],this.currentDistance=this.sampleDistance[g]}for(l=this.currentPoint,c=this.currentDistance,t=0;t<this.maxTries;t++){for(u=!0,o=this.minDistancePlusEpsilon+this.deltaDistance*(c+(1-c)*this.bias),this.dimension===2?(s=this.rng()*Math.PI*2,h=[Math.cos(s),Math.sin(s)]):h=e(this.dimension,this.rng),d=0;u&&d<this.dimension;d++)h[d]=l[d]+h[d]*o,u=h[d]>=0&&h[d]<this.shape[d];if(u&&!this.inNeighbourhood(h))return this.directAddPoint(h)}t===this.maxTries&&(this.currentPoint=null)}return null},i.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},i.prototype.getAllPoints=function(){return this.samplePoints},i.prototype.getAllPointsWithDistance=function(){var t=new Array(this.samplePoints.length),s=0,o=0,l;for(s=0;s<this.samplePoints.length;s++){for(l=new Array(this.dimension+1),o=0;o<this.dimension;o++)l[o]=this.samplePoints[s][o];l[this.dimension]=this.sampleDistance[s],t[s]=l}return t},i.prototype.reset=function(){var t=this.grid.data,s=0;for(s=0;s<t.length;s++)t[s]=[];this.samplePoints=[],this.currentPoint=null,this.processList.length=0},ue=i,ue}var de,Ee;function _t(){if(Ee)return de;Ee=1;var a=vt(),e=Pt();function n(r,i){this.shape=r.shape,typeof r.distanceFunction=="function"?this.implementation=new e(r,i):this.implementation=new a(r,i)}return n.prototype.implementation=null,n.prototype.addRandomPoint=function(){return this.implementation.addRandomPoint()},n.prototype.addPoint=function(r){return this.implementation.addPoint(r)},n.prototype.next=function(){return this.implementation.next()},n.prototype.fill=function(){return this.implementation.fill()},n.prototype.getAllPoints=function(){return this.implementation.getAllPoints()},n.prototype.getAllPointsWithDistance=function(){return this.implementation.getAllPointsWithDistance()},n.prototype.reset=function(){this.implementation.reset()},de=n,de}var xt=_t();const Dt=Ke(xt),ye="PoissonPointGenerator",Mt={name:ye,displayName:"Poisson",description:"Generate seed points using Poisson disk sampling. The algorithm produces points that are tightly-packed, but no closer to each other than a specified minimum distance (the piece size), resulting in a natural, organic look.",sortHint:1,controls:[]},kt=(a,e,n)=>({generatePoints(i){const{width:t,height:s,pieceSize:o,random:l}=i;return new Dt({shape:[t,s],minDistance:o,tries:20},l).fill()}});Y.register(ye,kt,Mt);const V=11102230246251565e-32,G=134217729,Ct=(3+8*V)*V;function ge(a,e,n,r,i){let t,s,o,l,c=e[0],h=r[0],u=0,d=0;h>c==h>-c?(t=c,c=e[++u]):(t=h,h=r[++d]);let g=0;if(u<a&&d<n)for(h>c==h>-c?(s=c+t,o=t-(s-c),c=e[++u]):(s=h+t,o=t-(s-h),h=r[++d]),t=s,o!==0&&(i[g++]=o);u<a&&d<n;)h>c==h>-c?(s=t+c,l=s-t,o=t-(s-l)+(c-l),c=e[++u]):(s=t+h,l=s-t,o=t-(s-l)+(h-l),h=r[++d]),t=s,o!==0&&(i[g++]=o);for(;u<a;)s=t+c,l=s-t,o=t-(s-l)+(c-l),c=e[++u],t=s,o!==0&&(i[g++]=o);for(;d<n;)s=t+h,l=s-t,o=t-(s-l)+(h-l),h=r[++d],t=s,o!==0&&(i[g++]=o);return(t!==0||g===0)&&(i[g++]=t),g}function St(a,e){let n=e[0];for(let r=1;r<a;r++)n+=e[r];return n}function Z(a){return new Float64Array(a)}const Tt=(3+16*V)*V,It=(2+12*V)*V,Et=(9+64*V)*V*V,j=Z(4),ze=Z(8),Ae=Z(12),Le=Z(16),R=Z(4);function zt(a,e,n,r,i,t,s){let o,l,c,h,u,d,g,p,f,b,m,w,D,_,k,I,C,T;const v=a-i,M=n-i,x=e-t,P=r-t;_=v*P,d=G*v,g=d-(d-v),p=v-g,d=G*P,f=d-(d-P),b=P-f,k=p*b-(_-g*f-p*f-g*b),I=x*M,d=G*x,g=d-(d-x),p=x-g,d=G*M,f=d-(d-M),b=M-f,C=p*b-(I-g*f-p*f-g*b),m=k-C,u=k-m,j[0]=k-(m+u)+(u-C),w=_+m,u=w-_,D=_-(w-u)+(m-u),m=D-I,u=D-m,j[1]=D-(m+u)+(u-I),T=w+m,u=T-w,j[2]=w-(T-u)+(m-u),j[3]=T;let E=St(4,j),A=It*s;if(E>=A||-E>=A||(u=a-v,o=a-(v+u)+(u-i),u=n-M,c=n-(M+u)+(u-i),u=e-x,l=e-(x+u)+(u-t),u=r-P,h=r-(P+u)+(u-t),o===0&&l===0&&c===0&&h===0)||(A=Et*s+Ct*Math.abs(E),E+=v*h+P*o-(x*c+M*l),E>=A||-E>=A))return E;_=o*P,d=G*o,g=d-(d-o),p=o-g,d=G*P,f=d-(d-P),b=P-f,k=p*b-(_-g*f-p*f-g*b),I=l*M,d=G*l,g=d-(d-l),p=l-g,d=G*M,f=d-(d-M),b=M-f,C=p*b-(I-g*f-p*f-g*b),m=k-C,u=k-m,R[0]=k-(m+u)+(u-C),w=_+m,u=w-_,D=_-(w-u)+(m-u),m=D-I,u=D-m,R[1]=D-(m+u)+(u-I),T=w+m,u=T-w,R[2]=w-(T-u)+(m-u),R[3]=T;const L=ge(4,j,4,R,ze);_=v*h,d=G*v,g=d-(d-v),p=v-g,d=G*h,f=d-(d-h),b=h-f,k=p*b-(_-g*f-p*f-g*b),I=x*c,d=G*x,g=d-(d-x),p=x-g,d=G*c,f=d-(d-c),b=c-f,C=p*b-(I-g*f-p*f-g*b),m=k-C,u=k-m,R[0]=k-(m+u)+(u-C),w=_+m,u=w-_,D=_-(w-u)+(m-u),m=D-I,u=D-m,R[1]=D-(m+u)+(u-I),T=w+m,u=T-w,R[2]=w-(T-u)+(m-u),R[3]=T;const S=ge(L,ze,4,R,Ae);_=o*h,d=G*o,g=d-(d-o),p=o-g,d=G*h,f=d-(d-h),b=h-f,k=p*b-(_-g*f-p*f-g*b),I=l*c,d=G*l,g=d-(d-l),p=l-g,d=G*c,f=d-(d-c),b=c-f,C=p*b-(I-g*f-p*f-g*b),m=k-C,u=k-m,R[0]=k-(m+u)+(u-C),w=_+m,u=w-_,D=_-(w-u)+(m-u),m=D-I,u=D-m,R[1]=D-(m+u)+(u-I),T=w+m,u=T-w,R[2]=w-(T-u)+(m-u),R[3]=T;const z=ge(S,Ae,4,R,Le);return Le[z-1]}function ee(a,e,n,r,i,t){const s=(e-t)*(n-i),o=(a-i)*(r-t),l=s-o,c=Math.abs(s+o);return Math.abs(l)>=Tt*c?l:-zt(a,e,n,r,i,t,c)}const $e=Math.pow(2,-52),te=new Uint32Array(512);class ne{static from(e,n=Rt,r=Ut){const i=e.length,t=new Float64Array(i*2);for(let s=0;s<i;s++){const o=e[s];t[2*s]=n(o),t[2*s+1]=r(o)}return new ne(t)}constructor(e){const n=e.length>>1;if(n>0&&typeof e[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=e;const r=Math.max(2*n-5,0);this._triangles=new Uint32Array(r*3),this._halfedges=new Int32Array(r*3),this._hashSize=Math.ceil(Math.sqrt(n)),this._hullPrev=new Uint32Array(n),this._hullNext=new Uint32Array(n),this._hullTri=new Uint32Array(n),this._hullHash=new Int32Array(this._hashSize),this._ids=new Uint32Array(n),this._dists=new Float64Array(n),this.update()}update(){const{coords:e,_hullPrev:n,_hullNext:r,_hullTri:i,_hullHash:t}=this,s=e.length>>1;let o=1/0,l=1/0,c=-1/0,h=-1/0;for(let v=0;v<s;v++){const M=e[2*v],x=e[2*v+1];M<o&&(o=M),x<l&&(l=x),M>c&&(c=M),x>h&&(h=x),this._ids[v]=v}const u=(o+c)/2,d=(l+h)/2;let g,p,f;for(let v=0,M=1/0;v<s;v++){const x=fe(u,d,e[2*v],e[2*v+1]);x<M&&(g=v,M=x)}const b=e[2*g],m=e[2*g+1];for(let v=0,M=1/0;v<s;v++){if(v===g)continue;const x=fe(b,m,e[2*v],e[2*v+1]);x<M&&x>0&&(p=v,M=x)}let w=e[2*p],D=e[2*p+1],_=1/0;for(let v=0;v<s;v++){if(v===g||v===p)continue;const M=$t(b,m,w,D,e[2*v],e[2*v+1]);M<_&&(f=v,_=M)}let k=e[2*f],I=e[2*f+1];if(_===1/0){for(let x=0;x<s;x++)this._dists[x]=e[2*x]-e[0]||e[2*x+1]-e[1];B(this._ids,this._dists,0,s-1);const v=new Uint32Array(s);let M=0;for(let x=0,P=-1/0;x<s;x++){const E=this._ids[x],A=this._dists[E];A>P&&(v[M++]=E,P=A)}this.hull=v.subarray(0,M),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(ee(b,m,w,D,k,I)<0){const v=p,M=w,x=D;p=f,w=k,D=I,f=v,k=M,I=x}const C=Gt(b,m,w,D,k,I);this._cx=C.x,this._cy=C.y;for(let v=0;v<s;v++)this._dists[v]=fe(e[2*v],e[2*v+1],C.x,C.y);B(this._ids,this._dists,0,s-1),this._hullStart=g;let T=3;r[g]=n[f]=p,r[p]=n[g]=f,r[f]=n[p]=g,i[g]=0,i[p]=1,i[f]=2,t.fill(-1),t[this._hashKey(b,m)]=g,t[this._hashKey(w,D)]=p,t[this._hashKey(k,I)]=f,this.trianglesLen=0,this._addTriangle(g,p,f,-1,-1,-1);for(let v=0,M,x;v<this._ids.length;v++){const P=this._ids[v],E=e[2*P],A=e[2*P+1];if(v>0&&Math.abs(E-M)<=$e&&Math.abs(A-x)<=$e||(M=E,x=A,P===g||P===p||P===f))continue;let L=0;for(let q=0,Oe=this._hashKey(E,A);q<this._hashSize&&(L=t[(Oe+q)%this._hashSize],!(L!==-1&&L!==r[L]));q++);L=n[L];let S=L,z;for(;z=r[S],ee(E,A,e[2*S],e[2*S+1],e[2*z],e[2*z+1])>=0;)if(S=z,S===L){S=-1;break}if(S===-1)continue;let U=this._addTriangle(S,P,r[S],-1,-1,i[S]);i[P]=this._legalize(U+2),i[S]=U,T++;let $=r[S];for(;z=r[$],ee(E,A,e[2*$],e[2*$+1],e[2*z],e[2*z+1])<0;)U=this._addTriangle($,P,z,i[P],-1,i[$]),i[P]=this._legalize(U+2),r[$]=$,T--,$=z;if(S===L)for(;z=n[S],ee(E,A,e[2*z],e[2*z+1],e[2*S],e[2*S+1])<0;)U=this._addTriangle(z,P,S,-1,i[S],i[z]),this._legalize(U+2),i[z]=U,r[S]=S,T--,S=z;this._hullStart=n[P]=S,r[S]=n[$]=P,r[P]=$,t[this._hashKey(E,A)]=P,t[this._hashKey(e[2*S],e[2*S+1])]=S}this.hull=new Uint32Array(T);for(let v=0,M=this._hullStart;v<T;v++)this.hull[v]=M,M=r[M];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(e,n){return Math.floor(At(e-this._cx,n-this._cy)*this._hashSize)%this._hashSize}_legalize(e){const{_triangles:n,_halfedges:r,coords:i}=this;let t=0,s=0;for(;;){const o=r[e],l=e-e%3;if(s=l+(e+2)%3,o===-1){if(t===0)break;e=te[--t];continue}const c=o-o%3,h=l+(e+1)%3,u=c+(o+2)%3,d=n[s],g=n[e],p=n[h],f=n[u];if(Lt(i[2*d],i[2*d+1],i[2*g],i[2*g+1],i[2*p],i[2*p+1],i[2*f],i[2*f+1])){n[e]=f,n[o]=d;const m=r[u];if(m===-1){let D=this._hullStart;do{if(this._hullTri[D]===u){this._hullTri[D]=e;break}D=this._hullPrev[D]}while(D!==this._hullStart)}this._link(e,m),this._link(o,r[s]),this._link(s,u);const w=c+(o+1)%3;t<te.length&&(te[t++]=w)}else{if(t===0)break;e=te[--t]}}return s}_link(e,n){this._halfedges[e]=n,n!==-1&&(this._halfedges[n]=e)}_addTriangle(e,n,r,i,t,s){const o=this.trianglesLen;return this._triangles[o]=e,this._triangles[o+1]=n,this._triangles[o+2]=r,this._link(o,i),this._link(o+1,t),this._link(o+2,s),this.trianglesLen+=3,o}}function At(a,e){const n=a/(Math.abs(a)+Math.abs(e));return(e>0?3-n:1+n)/4}function fe(a,e,n,r){const i=a-n,t=e-r;return i*i+t*t}function Lt(a,e,n,r,i,t,s,o){const l=a-s,c=e-o,h=n-s,u=r-o,d=i-s,g=t-o,p=l*l+c*c,f=h*h+u*u,b=d*d+g*g;return l*(u*b-f*g)-c*(h*b-f*d)+p*(h*g-u*d)<0}function $t(a,e,n,r,i,t){const s=n-a,o=r-e,l=i-a,c=t-e,h=s*s+o*o,u=l*l+c*c,d=.5/(s*c-o*l),g=(c*h-o*u)*d,p=(s*u-l*h)*d;return g*g+p*p}function Gt(a,e,n,r,i,t){const s=n-a,o=r-e,l=i-a,c=t-e,h=s*s+o*o,u=l*l+c*c,d=.5/(s*c-o*l),g=a+(c*h-o*u)*d,p=e+(s*u-l*h)*d;return{x:g,y:p}}function B(a,e,n,r){if(r-n<=20)for(let i=n+1;i<=r;i++){const t=a[i],s=e[t];let o=i-1;for(;o>=n&&e[a[o]]>s;)a[o+1]=a[o--];a[o+1]=t}else{const i=n+r>>1;let t=n+1,s=r;O(a,i,t),e[a[n]]>e[a[r]]&&O(a,n,r),e[a[t]]>e[a[r]]&&O(a,t,r),e[a[n]]>e[a[t]]&&O(a,n,t);const o=a[t],l=e[o];for(;;){do t++;while(e[a[t]]<l);do s--;while(e[a[s]]>l);if(s<t)break;O(a,t,s)}a[n+1]=a[s],a[s]=o,r-t+1>=s-n?(B(a,e,t,r),B(a,e,n,s-1)):(B(a,e,n,s-1),B(a,e,t,r))}}function O(a,e,n){const r=a[e];a[e]=a[n],a[n]=r}function Rt(a){return a[0]}function Ut(a){return a[1]}const Ge=1e-6;class F{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(e,n){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+n}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(e,n){this._+=`L${this._x1=+e},${this._y1=+n}`}arc(e,n,r){e=+e,n=+n,r=+r;const i=e+r,t=n;if(r<0)throw new Error("negative radius");this._x1===null?this._+=`M${i},${t}`:(Math.abs(this._x1-i)>Ge||Math.abs(this._y1-t)>Ge)&&(this._+="L"+i+","+t),r&&(this._+=`A${r},${r},0,1,1,${e-r},${n}A${r},${r},0,1,1,${this._x1=i},${this._y1=t}`)}rect(e,n,r,i){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+n}h${+r}v${+i}h${-r}Z`}value(){return this._||null}}class me{constructor(){this._=[]}moveTo(e,n){this._.push([e,n])}closePath(){this._.push(this._[0].slice())}lineTo(e,n){this._.push([e,n])}value(){return this._.length?this._:null}}class Vt{constructor(e,[n,r,i,t]=[0,0,960,500]){if(!((i=+i)>=(n=+n))||!((t=+t)>=(r=+r)))throw new Error("invalid bounds");this.delaunay=e,this._circumcenters=new Float64Array(e.points.length*2),this.vectors=new Float64Array(e.points.length*2),this.xmax=i,this.xmin=n,this.ymax=t,this.ymin=r,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:e,hull:n,triangles:r},vectors:i}=this;let t,s;const o=this.circumcenters=this._circumcenters.subarray(0,r.length/3*2);for(let f=0,b=0,m=r.length,w,D;f<m;f+=3,b+=2){const _=r[f]*2,k=r[f+1]*2,I=r[f+2]*2,C=e[_],T=e[_+1],v=e[k],M=e[k+1],x=e[I],P=e[I+1],E=v-C,A=M-T,L=x-C,S=P-T,z=(E*S-A*L)*2;if(Math.abs(z)<1e-9){if(t===void 0){t=s=0;for(const $ of n)t+=e[$*2],s+=e[$*2+1];t/=n.length,s/=n.length}const U=1e9*Math.sign((t-C)*S-(s-T)*L);w=(C+x)/2-U*S,D=(T+P)/2+U*L}else{const U=1/z,$=E*E+A*A,q=L*L+S*S;w=C+(S*$-A*q)*U,D=T+(E*q-L*$)*U}o[b]=w,o[b+1]=D}let l=n[n.length-1],c,h=l*4,u,d=e[2*l],g,p=e[2*l+1];i.fill(0);for(let f=0;f<n.length;++f)l=n[f],c=h,u=d,g=p,h=l*4,d=e[2*l],p=e[2*l+1],i[c+2]=i[h]=g-p,i[c+3]=i[h+1]=d-u}render(e){const n=e==null?e=new F:void 0,{delaunay:{halfedges:r,inedges:i,hull:t},circumcenters:s,vectors:o}=this;if(t.length<=1)return null;for(let h=0,u=r.length;h<u;++h){const d=r[h];if(d<h)continue;const g=Math.floor(h/3)*2,p=Math.floor(d/3)*2,f=s[g],b=s[g+1],m=s[p],w=s[p+1];this._renderSegment(f,b,m,w,e)}let l,c=t[t.length-1];for(let h=0;h<t.length;++h){l=c,c=t[h];const u=Math.floor(i[c]/3)*2,d=s[u],g=s[u+1],p=l*4,f=this._project(d,g,o[p+2],o[p+3]);f&&this._renderSegment(d,g,f[0],f[1],e)}return n&&n.value()}renderBounds(e){const n=e==null?e=new F:void 0;return e.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),n&&n.value()}renderCell(e,n){const r=n==null?n=new F:void 0,i=this._clip(e);if(i===null||!i.length)return;n.moveTo(i[0],i[1]);let t=i.length;for(;i[0]===i[t-2]&&i[1]===i[t-1]&&t>1;)t-=2;for(let s=2;s<t;s+=2)(i[s]!==i[s-2]||i[s+1]!==i[s-1])&&n.lineTo(i[s],i[s+1]);return n.closePath(),r&&r.value()}*cellPolygons(){const{delaunay:{points:e}}=this;for(let n=0,r=e.length/2;n<r;++n){const i=this.cellPolygon(n);i&&(i.index=n,yield i)}}cellPolygon(e){const n=new me;return this.renderCell(e,n),n.value()}_renderSegment(e,n,r,i,t){let s;const o=this._regioncode(e,n),l=this._regioncode(r,i);o===0&&l===0?(t.moveTo(e,n),t.lineTo(r,i)):(s=this._clipSegment(e,n,r,i,o,l))&&(t.moveTo(s[0],s[1]),t.lineTo(s[2],s[3]))}contains(e,n,r){return n=+n,n!==n||(r=+r,r!==r)?!1:this.delaunay._step(e,n,r)===e}*neighbors(e){const n=this._clip(e);if(n)for(const r of this.delaunay.neighbors(e)){const i=this._clip(r);if(i){e:for(let t=0,s=n.length;t<s;t+=2)for(let o=0,l=i.length;o<l;o+=2)if(n[t]===i[o]&&n[t+1]===i[o+1]&&n[(t+2)%s]===i[(o+l-2)%l]&&n[(t+3)%s]===i[(o+l-1)%l]){yield r;break e}}}}_cell(e){const{circumcenters:n,delaunay:{inedges:r,halfedges:i,triangles:t}}=this,s=r[e];if(s===-1)return null;const o=[];let l=s;do{const c=Math.floor(l/3);if(o.push(n[c*2],n[c*2+1]),l=l%3===2?l-2:l+1,t[l]!==e)break;l=i[l]}while(l!==s&&l!==-1);return o}_clip(e){if(e===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const n=this._cell(e);if(n===null)return null;const{vectors:r}=this,i=e*4;return this._simplify(r[i]||r[i+1]?this._clipInfinite(e,n,r[i],r[i+1],r[i+2],r[i+3]):this._clipFinite(e,n))}_clipFinite(e,n){const r=n.length;let i=null,t,s,o=n[r-2],l=n[r-1],c,h=this._regioncode(o,l),u,d=0;for(let g=0;g<r;g+=2)if(t=o,s=l,o=n[g],l=n[g+1],c=h,h=this._regioncode(o,l),c===0&&h===0)u=d,d=0,i?i.push(o,l):i=[o,l];else{let p,f,b,m,w;if(c===0){if((p=this._clipSegment(t,s,o,l,c,h))===null)continue;[f,b,m,w]=p}else{if((p=this._clipSegment(o,l,t,s,h,c))===null)continue;[m,w,f,b]=p,u=d,d=this._edgecode(f,b),u&&d&&this._edge(e,u,d,i,i.length),i?i.push(f,b):i=[f,b]}u=d,d=this._edgecode(m,w),u&&d&&this._edge(e,u,d,i,i.length),i?i.push(m,w):i=[m,w]}if(i)u=d,d=this._edgecode(i[0],i[1]),u&&d&&this._edge(e,u,d,i,i.length);else if(this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return i}_clipSegment(e,n,r,i,t,s){const o=t<s;for(o&&([e,n,r,i,t,s]=[r,i,e,n,s,t]);;){if(t===0&&s===0)return o?[r,i,e,n]:[e,n,r,i];if(t&s)return null;let l,c,h=t||s;h&8?(l=e+(r-e)*(this.ymax-n)/(i-n),c=this.ymax):h&4?(l=e+(r-e)*(this.ymin-n)/(i-n),c=this.ymin):h&2?(c=n+(i-n)*(this.xmax-e)/(r-e),l=this.xmax):(c=n+(i-n)*(this.xmin-e)/(r-e),l=this.xmin),t?(e=l,n=c,t=this._regioncode(e,n)):(r=l,i=c,s=this._regioncode(r,i))}}_clipInfinite(e,n,r,i,t,s){let o=Array.from(n),l;if((l=this._project(o[0],o[1],r,i))&&o.unshift(l[0],l[1]),(l=this._project(o[o.length-2],o[o.length-1],t,s))&&o.push(l[0],l[1]),o=this._clipFinite(e,o))for(let c=0,h=o.length,u,d=this._edgecode(o[h-2],o[h-1]);c<h;c+=2)u=d,d=this._edgecode(o[c],o[c+1]),u&&d&&(c=this._edge(e,u,d,o,c),h=o.length);else this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(o=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return o}_edge(e,n,r,i,t){for(;n!==r;){let s,o;switch(n){case 5:n=4;continue;case 4:n=6,s=this.xmax,o=this.ymin;break;case 6:n=2;continue;case 2:n=10,s=this.xmax,o=this.ymax;break;case 10:n=8;continue;case 8:n=9,s=this.xmin,o=this.ymax;break;case 9:n=1;continue;case 1:n=5,s=this.xmin,o=this.ymin;break}(i[t]!==s||i[t+1]!==o)&&this.contains(e,s,o)&&(i.splice(t,0,s,o),t+=2)}return t}_project(e,n,r,i){let t=1/0,s,o,l;if(i<0){if(n<=this.ymin)return null;(s=(this.ymin-n)/i)<t&&(l=this.ymin,o=e+(t=s)*r)}else if(i>0){if(n>=this.ymax)return null;(s=(this.ymax-n)/i)<t&&(l=this.ymax,o=e+(t=s)*r)}if(r>0){if(e>=this.xmax)return null;(s=(this.xmax-e)/r)<t&&(o=this.xmax,l=n+(t=s)*i)}else if(r<0){if(e<=this.xmin)return null;(s=(this.xmin-e)/r)<t&&(o=this.xmin,l=n+(t=s)*i)}return[o,l]}_edgecode(e,n){return(e===this.xmin?1:e===this.xmax?2:0)|(n===this.ymin?4:n===this.ymax?8:0)}_regioncode(e,n){return(e<this.xmin?1:e>this.xmax?2:0)|(n<this.ymin?4:n>this.ymax?8:0)}_simplify(e){if(e&&e.length>4){for(let n=0;n<e.length;n+=2){const r=(n+2)%e.length,i=(n+4)%e.length;(e[n]===e[r]&&e[r]===e[i]||e[n+1]===e[r+1]&&e[r+1]===e[i+1])&&(e.splice(r,2),n-=2)}e.length||(e=null)}return e}}const Nt=2*Math.PI,W=Math.pow;function Ft(a){return a[0]}function Ht(a){return a[1]}function qt(a){const{triangles:e,coords:n}=a;for(let r=0;r<e.length;r+=3){const i=2*e[r],t=2*e[r+1],s=2*e[r+2];if((n[s]-n[i])*(n[t+1]-n[i+1])-(n[t]-n[i])*(n[s+1]-n[i+1])>1e-10)return!1}return!0}function jt(a,e,n){return[a+Math.sin(a+e)*n,e+Math.cos(a-e)*n]}class we{static from(e,n=Ft,r=Ht,i){return new we("length"in e?Wt(e,n,r,i):Float64Array.from(Bt(e,n,r,i)))}constructor(e){this._delaunator=new ne(e),this.inedges=new Int32Array(e.length/2),this._hullIndex=new Int32Array(e.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const e=this._delaunator,n=this.points;if(e.hull&&e.hull.length>2&&qt(e)){this.collinear=Int32Array.from({length:n.length/2},(d,g)=>g).sort((d,g)=>n[2*d]-n[2*g]||n[2*d+1]-n[2*g+1]);const l=this.collinear[0],c=this.collinear[this.collinear.length-1],h=[n[2*l],n[2*l+1],n[2*c],n[2*c+1]],u=1e-8*Math.hypot(h[3]-h[1],h[2]-h[0]);for(let d=0,g=n.length/2;d<g;++d){const p=jt(n[2*d],n[2*d+1],u);n[2*d]=p[0],n[2*d+1]=p[1]}this._delaunator=new ne(n)}else delete this.collinear;const r=this.halfedges=this._delaunator.halfedges,i=this.hull=this._delaunator.hull,t=this.triangles=this._delaunator.triangles,s=this.inedges.fill(-1),o=this._hullIndex.fill(-1);for(let l=0,c=r.length;l<c;++l){const h=t[l%3===2?l-2:l+1];(r[l]===-1||s[h]===-1)&&(s[h]=l)}for(let l=0,c=i.length;l<c;++l)o[i[l]]=l;i.length<=2&&i.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=i[0],s[i[0]]=1,i.length===2&&(s[i[1]]=0,this.triangles[1]=i[1],this.triangles[2]=i[1]))}voronoi(e){return new Vt(this,e)}*neighbors(e){const{inedges:n,hull:r,_hullIndex:i,halfedges:t,triangles:s,collinear:o}=this;if(o){const u=o.indexOf(e);u>0&&(yield o[u-1]),u<o.length-1&&(yield o[u+1]);return}const l=n[e];if(l===-1)return;let c=l,h=-1;do{if(yield h=s[c],c=c%3===2?c-2:c+1,s[c]!==e)return;if(c=t[c],c===-1){const u=r[(i[e]+1)%r.length];u!==h&&(yield u);return}}while(c!==l)}find(e,n,r=0){if(e=+e,e!==e||(n=+n,n!==n))return-1;const i=r;let t;for(;(t=this._step(r,e,n))>=0&&t!==r&&t!==i;)r=t;return t}_step(e,n,r){const{inedges:i,hull:t,_hullIndex:s,halfedges:o,triangles:l,points:c}=this;if(i[e]===-1||!c.length)return(e+1)%(c.length>>1);let h=e,u=W(n-c[e*2],2)+W(r-c[e*2+1],2);const d=i[e];let g=d;do{let p=l[g];const f=W(n-c[p*2],2)+W(r-c[p*2+1],2);if(f<u&&(u=f,h=p),g=g%3===2?g-2:g+1,l[g]!==e)break;if(g=o[g],g===-1){if(g=t[(s[e]+1)%t.length],g!==p&&W(n-c[g*2],2)+W(r-c[g*2+1],2)<u)return g;break}}while(g!==d);return h}render(e){const n=e==null?e=new F:void 0,{points:r,halfedges:i,triangles:t}=this;for(let s=0,o=i.length;s<o;++s){const l=i[s];if(l<s)continue;const c=t[s]*2,h=t[l]*2;e.moveTo(r[c],r[c+1]),e.lineTo(r[h],r[h+1])}return this.renderHull(e),n&&n.value()}renderPoints(e,n){n===void 0&&(!e||typeof e.moveTo!="function")&&(n=e,e=null),n=n==null?2:+n;const r=e==null?e=new F:void 0,{points:i}=this;for(let t=0,s=i.length;t<s;t+=2){const o=i[t],l=i[t+1];e.moveTo(o+n,l),e.arc(o,l,n,0,Nt)}return r&&r.value()}renderHull(e){const n=e==null?e=new F:void 0,{hull:r,points:i}=this,t=r[0]*2,s=r.length;e.moveTo(i[t],i[t+1]);for(let o=1;o<s;++o){const l=2*r[o];e.lineTo(i[l],i[l+1])}return e.closePath(),n&&n.value()}hullPolygon(){const e=new me;return this.renderHull(e),e.value()}renderTriangle(e,n){const r=n==null?n=new F:void 0,{points:i,triangles:t}=this,s=t[e*=3]*2,o=t[e+1]*2,l=t[e+2]*2;return n.moveTo(i[s],i[s+1]),n.lineTo(i[o],i[o+1]),n.lineTo(i[l],i[l+1]),n.closePath(),r&&r.value()}*trianglePolygons(){const{triangles:e}=this;for(let n=0,r=e.length/3;n<r;++n)yield this.trianglePolygon(n)}trianglePolygon(e){const n=new me;return this.renderTriangle(e,n),n.value()}}function Wt(a,e,n,r){const i=a.length,t=new Float64Array(i*2);for(let s=0;s<i;++s){const o=a[s];t[s*2]=e.call(r,o,s,a),t[s*2+1]=n.call(r,o,s,a)}return t}function*Bt(a,e,n,r){let i=0;for(const t of a)yield e.call(r,t,i,a),yield n.call(r,t,i,a),++i}let Ot=0;function N(){return Ot++}const ve="VoronoiPieceGenerator",Kt={name:ve,displayName:"Voronoi",description:"Construct pieces by building a Voronoi diagram from the seed points. Each piece consists of all area of the plane closer to its seed point than any other seed point. In practice, this creates irregular polygons with 3-8 sides.",sortHint:1,controls:[]};function Xt(a,e){const n=a.length;for(let r=0;r<n;r++){const i=e.get(a[r]);i.next=a[(r+1)%n],i.prev=a[(r-1+n)%n]}}function K(a){return`${a[0].toPrecision(7)},${a[1].toPrecision(7)}`}const Yt=(a,e,n)=>({generatePieces(i,t){console.log(`VoronoiPieceGenerator using dimensions ${a}x${e}`);const o=we.from(i).voronoi([0,0,a,e]),l={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},c=new Map;for(let u=0;u<i.length;u++){const d=i[u],g=o.cellPolygon(u);if(!g)continue;const p={id:u,site:d,halfEdge:-1,bounds:X(g)},f=[];for(let b=0;b<g.length-1;b++){const m=g[b],w=g[b+1];if(nt(m,w))continue;const D={id:N(),origin:m,twin:-1,next:-1,prev:-1,piece:u};l.halfEdges.set(D.id,D),f.push(D.id);const _=`${K(m)}-${K(w)}`;c.set(_,D.id)}f.length!==0&&(Xt(f,l.halfEdges),p.halfEdge=f[0],l.pieces.set(u,p))}for(const u of l.halfEdges.values()){if(u.twin!==-1)continue;const d=l.halfEdges.get(u.next),g=u.origin,p=d.origin,f=`${K(p)}-${K(g)}`,b=c.get(f),m=N();let w;if(b!==void 0){const D=l.halfEdges.get(b);u.twin=D.id,D.twin=u.id,w={id:m,heLeft:u.id,heRight:D.id,bounds:X([g,p])}}else w={id:m,heLeft:u.id,heRight:-1,bounds:X([g,p])},l.boundary.push(m);l.edges.set(m,w)}const h=new Map;for(const u of l.halfEdges.values()){const d=K(u.origin);h.has(d)||h.set(d,u.origin)}return l.vertices=Array.from(h.values()),l}});J.register(ve,Yt,Kt);const ie="SimpleTabPlacementStrategy",Jt={name:ie,displayName:"Simple",description:"Creates a single tab in the center of each edge with a random orientation.",sortHint:1,controls:[{type:"range",name:"tabSize",label:"Tab Size",optional:!0,min:.01,max:1,step:.01,defaultValue:.5,helpText:"The width of the tab as a fraction of the edge length"},{type:"number",name:"minEdgeLength",label:"Minimum Edge Length",optional:!0,defaultValue:15,helpText:"Edges shorter than this value will not have a tab"}]};function Re(a,e,n,r){if(a.tabs=void 0,!(a.heRight!==-1))return;const t=e.halfEdges.get(a.heLeft),s=e.halfEdges.get(a.heRight);if(!t||!s)return;const o=t.origin,l=s.origin;if(Math.hypot(l[0]-o[0],l[1]-o[1])>=n.minEdgeLength){const h={position:.5,size:n.tabSize,convex:r()>.5};a.tabs=[h]}}const Qt=(a,e,n)=>{const{tabSize:r=.5,minEdgeLength:i=0}=n,t={tabSize:r,minEdgeLength:i};return{placeTabs(s){const{topology:o,random:l}=s;for(const c of o.edges.values())Re(c,o,t,l)},updateTabPlacements(s,o){const{topology:l,random:c}=o;for(const h of s)Re(h,l,t,c)}}};Q.register(ie,Qt,Jt);const Pe="TraditionalTabGenerator",Zt={name:Pe,displayName:"Traditional",description:"Creates a traditional rounded tab for each (internal) piece edge.",sortHint:1,controls:[{type:"range",name:"jitter",label:"Randomness",defaultValue:8,min:0,max:100,step:1,helpText:"Adds randomness to the tab shape. 0 means completely uniform tabs"},{type:"number",name:"maxTabSize",label:"Maximum Tab Width",optional:!0,helpText:"If provided, the width of a tab's features will be clamped to this value"}]};function en(a,e,n,r,i,t=!1,s){const o=e[0]-a[0],l=e[1]-a[1],c=Math.hypot(o,l);if(c===0)throw new Error("Edge has zero length");const h=[o/c,l/c],u=[-h[1],h[0]],d=(x,P)=>[a[0]+(h[0]*x+u[0]*P)*c,a[1]+(h[1]*x+u[1]*P)*c],g=r/100,p=()=>(i()*2-1)*g,f=p(),b=p(),m=p(),w=p(),D=p();let _=n/200;s&&4*_*c>s&&(_=s/(4*c));const k=t?-1:1,C=[[0,0],[.2,f],[.5+b+w,k*(-_+m)],[.5-_+b,k*(_+m)],[.5-2*_+b-w,k*(3*_+m)],[.5+2*_+b-w,k*(3*_+m)],[.5+_+b,k*(_+m)],[.5+b+w,k*(-_+m)],[.8,D],[1,0]].map(([x,P])=>d(x,P)),T={type:"bezier",p1:C[1],p2:C[2],p3:C[3]},v={type:"bezier",p1:C[4],p2:C[5],p3:C[6]},M={type:"bezier",p1:C[7],p2:C[8],p3:C[9]};return[T,v,M]}const tn=(a,e,n)=>{const{jitter:r=8,maxTabSize:i}=n;return{createTabSegments(s,o,l,c){const h=l.size*100,u=!l.convex;return en(s,o,h,r,c,u,i)}}};H.register(Pe,tn,Zt);function nn(a){return new Worker("/puzzle-generator/assets/CheckGeometryWorker-DOamIjPD.js",{name:a?.name})}function sn(a,e){return new Promise((n,r)=>{const i=new nn;i.onmessage=s=>{const o=s.data;switch(o.type){case"progress":e?.(o.processed,o.total);break;case"done":n(o.results),i.terminate();break;case"error":r(new Error(o.message)),i.terminate();break}},i.onerror=s=>{r(new Error(s.message)),i.terminate()};const t={topology:Qe(a)};i.postMessage(t)})}const qe="GridJitterPointGenerator",on={name:qe,displayName:"Grid",description:"Generate seed points using a grid with optional random jitter. Has a uniform, regular look, especially with low randomness values.",sortHint:2,controls:[{type:"range",name:"jitter",label:"Randomness",min:0,max:100,step:5,defaultValue:50,helpText:"Amount of jitter to apply to each grid point (0 to 100%)"}]},rn=(a,e,n)=>{const{jitter:r=50}=n;return{generatePoints(t){const{width:s,height:o,pieceSize:l,random:c}=t,h=[];for(let u=0;u<s;u+=l)for(let d=0;d<o;d+=l){const g=[u+l/2,d+l/2];r>0&&(g[0]+=(c()-.5)*(r/100)*l,g[1]+=(c()-.5)*(r/100)*l),h.push(g)}return h}}};Y.register(qe,rn,on);const je="RectangularPieceGenerator",an={name:je,displayName:"Rectangular",description:"Construct pieces from a regular grid. All pieces have 4 sides and are the same size. This generator ignores seed points.",sortHint:2,controls:[]},ln=(a,e,n)=>({generatePieces(i,t){const{pieceSize:s}=t,o={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},l=Math.ceil(a/s),c=Math.ceil(e/s),h=Math.round(a/l),u=Math.round(e/c),d=[];for(let p=0;p<=c;p++){const f=[];for(let b=0;b<=l;b++){const m=b*h,w=p*u;f.push([m,w])}d.push(f)}o.vertices=d.flat();const g=new Map;for(let p=0;p<c;p++)for(let f=0;f<l;f++){const b=p*l+f,m=d[p][f],w=d[p][f+1],D=d[p+1][f],_=d[p+1][f+1],k={id:N(),origin:m,twin:-1,next:-1,prev:-1,piece:b},I={id:N(),origin:w,twin:-1,next:-1,prev:-1,piece:b},C={id:N(),origin:_,twin:-1,next:-1,prev:-1,piece:b},T={id:N(),origin:D,twin:-1,next:-1,prev:-1,piece:b};k.next=I.id,I.next=C.id,C.next=T.id,T.next=k.id,k.prev=T.id,T.prev=C.id,C.prev=I.id,I.prev=k.id,o.halfEdges.set(k.id,k),o.halfEdges.set(I.id,I),o.halfEdges.set(C.id,C),o.halfEdges.set(T.id,T);const v={id:b,site:[(m[0]+_[0])/2,(m[1]+_[1])/2],halfEdge:k.id,bounds:[m[0],m[1],_[0],_[1]]};o.pieces.set(b,v);const M=(P,E)=>`${P[0]},${P[1]}-${E[0]},${E[1]}`,x=[{he:k,p1:m,p2:w,isBoundary:p===0},{he:I,p1:w,p2:_,isBoundary:f===l-1},{he:C,p1:_,p2:D,isBoundary:p===c-1},{he:T,p1:D,p2:m,isBoundary:f===0}];for(const P of x){const E=M(P.p2,P.p1),A=g.get(E),L=N();let S;if(A!==void 0){const z=o.halfEdges.get(A);P.he.twin=z.id,z.twin=P.he.id,S={id:L,heLeft:z.id,heRight:P.he.id,bounds:X([P.p1,P.p2])},g.delete(E)}else{const z=M(P.p1,P.p2);if(g.set(z,P.he.id),P.isBoundary)S={id:L,heLeft:P.he.id,heRight:-1,bounds:X([P.p1,P.p2])},o.boundary.push(L);else continue}o.edges.set(L,S)}}return o}});J.register(je,ln,an);const We="NullTabGenerator",cn={name:We,displayName:"None",description:"Do not generate tabs. All pieces have straight edges.",sortHint:3,controls:[]},hn=(a,e,n)=>({createTabSegments(i,t,s,o){return[]}});H.register(We,hn,cn);const Be="TriangleTabGenerator",un={name:Be,displayName:"Triangle",description:"Creates a simple triangle between each (internal) piece edge.",sortHint:2,controls:[]},dn=(a,e,n)=>({createTabSegments(i,t,s,o){const l=[t[0]-i[0],t[1]-i[1]],c=Math.hypot(l[0],l[1]);if(c<1e-6)return[];const h=[l[0]/c,l[1]/c],u=[-h[1],h[0]],d=[i[0]+l[0]/2,i[1]+l[1]/2],g=s.convex?1:-1,p=c*s.size*g,f=[d[0]+u[0]*p,d[1]+u[1]*p],b=[];return b.push({type:"line",p:i}),b.push({type:"line",p:f}),b.push({type:"line",p:t}),b}});H.register(Be,dn,un);let be=!1;function gn(){const a=window.matchMedia("(prefers-color-scheme: dark)");function e(){a.matches?(document.documentElement.classList.add("wa-dark"),be=!0):(document.documentElement.classList.remove("wa-dark"),be=!1)}e(),a.addEventListener("change",e)}gn();const fn=()=>{const n=ye,r=ve,i=Pe,t={seed:new Date().getTime()%10240,canvasWidth:800,canvasHeight:600,aspectRatio:800/600,distance:40,color:be?"#DDDDDD":"#333333",geometryProblems:{autoCheck:!1,problems:void 0,progress:void 0},dirty:!0,generators:{point:{label:"Seed Points",registry:Y,name:n,config:Y.getDefaultConfig(n,800,600)},piece:{label:"Piece Generation",registry:J,name:r,config:J.getDefaultConfig(r,800,600)},placement:{label:"Tab Placement",registry:Q,name:ie,config:Q.getDefaultConfig(ie,800,600)},tab:{label:"Tabs",registry:H,name:i,config:H.getDefaultConfig(i,800,600)}},puzzle:void 0,backgroundImageUrl:void 0,backgroundImageName:""};function s(){t.puzzle&&(t.geometryProblems.progress=0,y.redraw(),sn(t.puzzle,(o,l)=>{t.geometryProblems.progress=o/l*100,y.redraw()}).then(o=>{t.geometryProblems.problems=o.length,t.geometryProblems.progress=void 0,t.puzzle&&(t.puzzle.problems=o),y.redraw()}).catch(o=>{t.geometryProblems.progress=void 0,console.error(o),y.redraw()}))}return{oncreate:()=>{xe({width:t.canvasWidth,height:t.canvasHeight,pieceSize:t.distance,pointConfig:t.generators.point.config,pieceConfig:t.generators.piece.config,placementConfig:t.generators.placement.config,tabConfig:t.generators.tab.config,seed:t.seed}).then(o=>{t.puzzle=o,y.redraw(),t.geometryProblems.autoCheck&&s()}).catch(o=>{console.error(o)})},onupdate:()=>{t.dirty&&(t.dirty=!1,xe({width:t.canvasWidth,height:t.canvasHeight,pieceSize:t.distance,pointConfig:t.generators.point.config,pieceConfig:t.generators.piece.config,placementConfig:t.generators.placement.config,tabConfig:t.generators.tab.config,seed:t.seed}).then(o=>{t.geometryProblems.problems=void 0,t.geometryProblems.progress=void 0,t.puzzle=o,y.redraw(),t.geometryProblems.autoCheck&&s()}).catch(o=>{console.error(o)}))},onremove:()=>{t.backgroundImageUrl&&(URL.revokeObjectURL(t.backgroundImageUrl),t.backgroundImageUrl=void 0)},view:()=>y(".page",[y(Ye,{link:"https://github.com/weevilgenius/puzzle-generator"}),y("h1","Puzzle Generator"),y(".container",[t.puzzle&&y(".puzzle-stack",[y(rt,{width:t.canvasWidth,height:t.canvasHeight,color:t.color,imageUrl:t.backgroundImageUrl,puzzle:t.puzzle,isDirty:t.dirty,onPuzzleChanged:o=>{t.puzzle=o,y.redraw()}}),y(".actions",[y(ct,{puzzle:t.puzzle,width:t.canvasWidth,height:t.canvasHeight,color:t.color}),y(ht,{autoCheck:t.geometryProblems.autoCheck,problems:t.geometryProblems.problems,progressPercent:t.geometryProblems.progress,onCheckRequested:()=>{t.dirty||s(),y.redraw()},onAutocheckChanged:o=>{o!==t.geometryProblems.autoCheck&&(t.geometryProblems.autoCheck=o,y.redraw())}})])]),y(".controls",[y(".background-image",[y(dt,{label:"Background Image",onUpload:(o,l,c,h)=>{t.backgroundImageUrl&&URL.revokeObjectURL(t.backgroundImageUrl),t.canvasWidth=c,t.canvasHeight=h,t.aspectRatio=c/h,t.backgroundImageUrl=o,t.backgroundImageName=l,t.dirty=!0,y.redraw()}}),y("span.background-image-label",t.backgroundImageName)]),y(bt,{ratio:t.aspectRatio,disabled:t.backgroundImageUrl!==void 0,onChange:o=>{t.aspectRatio=o,t.canvasWidth=t.canvasHeight*o,t.dirty=!0,y.redraw()}}),y(pe,{config:{name:"seed",label:"Seed",type:"number"},value:t.seed,onChange:o=>{t.seed=o??0,t.dirty=!0,y.redraw()}}),y(pe,{config:{name:"pieceSize",label:"Piece size",type:"number"},value:t.distance,onChange:o=>{t.distance=o??0,t.dirty=!0,y.redraw()}}),y(yt,{label:"Piece color",color:t.color,size:"small",onUpdate:o=>{t.color=o,y.redraw()}}),...Object.entries(t.generators).map(([o,l])=>y("label",[l.label+":",y(mt,{generator:l.name,registry:l.registry,config:l.config,onGeneratorChange:c=>{c!=l.name&&(console.log(`${o} generator changed to ${c}`),l.name=c,t.generators[o].config=l.registry.getDefaultConfig(c,t.canvasWidth,t.canvasHeight),t.dirty=!0,y.redraw())},onConfigChange:(c,h)=>{console.log(`${o} generator config "${c}" changed to ${String(h)}`),l.config[c]=h,t.dirty=!0,y.redraw()}})]))])])])}};Xe("material",{resolver:a=>{const e=a.match(/^(.*?)(_(rounded|sharp))?$/);return e?`https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${e[3]??"outlined"}/${e[1]}.svg`:""},mutator:a=>a.setAttribute("fill","currentColor")});y.mount(document.body,fn);
//# sourceMappingURL=index-C9beCZzv.js.map
