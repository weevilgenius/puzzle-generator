{"version":3,"file":"index-DJcaiE7N.js","sources":["../../src/ui/GitHubCorner.ts","../../src/geometry/generators/Generator.ts","../../src/utils/mulberry.ts","../../src/geometry/PuzzleMaker.ts","../../src/ui/Puzzle.ts","../../src/utils/svg.ts","../../src/ui/DownloadPuzzleButton.ts","../../src/ui/GeometryCheckIndicator.ts","../../src/ui/UploadImageButton.ts","../../src/ui/inputs/BooleanInputControl.ts","../../src/ui/inputs/NumberInputControl.ts","../../src/ui/inputs/RangeInputControl.ts","../../src/ui/inputs/StringInputControl.ts","../../src/ui/GeneratorPicker.ts","../../src/ui/AspectRatioPicker.ts","../../src/ui/ColorPicker.ts","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/tiny-ndarray.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/sphere-random.js","../../node_modules/.pnpm/moore@1.0.0/node_modules/moore/index.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/neighbourhood.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/fixed-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/variable-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js","../../src/geometry/generators/point/PoissonPointGenerator.ts","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/delaunator@5.0.1/node_modules/delaunator/index.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/path.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/polygon.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/voronoi.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/delaunay.js","../../src/utils/UniqueId.ts","../../src/geometry/generators/piece/VoronoiPieceGenerator.ts","../../src/geometry/generators/tab/TraditionalTabGenerator.ts","../../src/geometry/serialization.ts","../../src/geometry/GeometryChecker.ts","../../src/geometry/generators/point/GridJitterPointGenerator.ts","../../src/geometry/generators/piece/RectangularPieceGenerator.ts","../../src/geometry/generators/tab/NullTabGenerator.ts","../../src/geometry/generators/tab/TriangleTabGenerator.ts","../../src/index.ts"],"sourcesContent":["// SVG rendering the GitHub Octocat in a corner with a link\n// adapted from https://github.com/tholman/github-corners/\nimport m from 'mithril';\n\n// include our CSS\nimport './GitHubCorner.css';\n\n// component attributes\nexport interface GitHubCornerAttrs extends m.Attributes {\n  /** Url to use when clicked */\n  link: string;\n}\n\n// Mithril component\nexport const GitHubCorner: m.Component<GitHubCornerAttrs, unknown> = {\n\n  view: ({ attrs }) => {\n\n    return m(\"a.github-corner\", {\n      href: attrs.link,\n      \"aria-label\": \"View source on GitHub\",\n      title: \"View source on GitHub\",\n      target: \"_blank\",\n    }, m(\"svg\", {\n      width: 80,\n      height: 80,\n      viewBox: \"0 0 250 250\",\n      \"aria-hidden\": \"true\",\n    }, [\n      m('path', {\n        d: \"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\",\n      }),\n      m('path.octo-arm', {\n        fill: \"currentColor\",\n        style: \"transform-origin: 130px 106px;\",\n        d: \"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\",\n      }),\n      m('path.octo-body', {\n        fill: \"currentColor\",\n        d: \"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\",\n      }),\n    ]));\n  },\n\n};\nexport default GitHubCorner;\n","import type { GeneratorUIMetadata } from '../ui_types';\n\n/** The name of a particular generator implementation. Must be unique. */\nexport type GeneratorName = string;\n\n/** Base configuration for any generator */\nexport interface GeneratorConfig {\n  /** The name of the generator to which this config belongs */\n  name: GeneratorName;\n  // additional fields specific to this generator\n  [key: string]: unknown;\n}\n\n/**\n * A generic interface for a function that creates a configured generator instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type GeneratorFactory<T> = (width: number, height: number, options: any) => T;\n\n\ninterface RegisteredGenerator<T> {\n  factory: GeneratorFactory<T>;\n  uiMetadata: GeneratorUIMetadata;\n}\n\n/**\n * A generic registry for creating instances of generates from configurations.\n * This allows for a pluggable system where generators can be added dynamically.\n *\n * @template T The base interface for this type of generator, e.g. `TabGenerator`\n */\nexport class GeneratorRegistry<T> {\n  private generators = new Map<GeneratorName, RegisteredGenerator<T>>();\n\n  /**\n   * Registers a new generator factory associated with a specific generator type.\n   * Intended to be called from within each generator's implementation file.\n   * @param name The unique string identifier for the generator, e.g. \"TraditionalTabGenerator\"\n   * @param factory A function that takes an options object and returns a generator\n   * @param uiMetadata A description of the UI needed to configure the generator\n   */\n  public register(name: GeneratorName, factory: GeneratorFactory<T>, uiMetadata: GeneratorUIMetadata): void {\n    if (this.generators.has(name)) {\n      console.warn(`Generator \"${name}\" is already registered, overwriting`);\n    }\n    this.generators.set(name, { factory, uiMetadata });\n  }\n\n  /**\n   * Creates an instance of a generator based on the provided configuration object.\n   * It looks up the correct factory using the `name` property from the config.\n   * @param config A configuration object for the generator\n   * @returns A configured instance of the requested generator\n   */\n  public create(width: number, height: number, config: GeneratorConfig): T {\n    const generator = this.generators.get(config.name);\n    if (!generator) {\n      throw new Error(`Unknown generator \"${config.name}\". Is it registered?`);\n    }\n    return generator.factory(width, height, config);\n  }\n\n  /**\n   * Returns a list of all available generators for populating a selector UI.\n   * @returns An array of objects with the name and human-readable display name.\n   */\n  public getAvailableGenerators(): { name: GeneratorName, displayName: string }[] {\n    return Array.from(this.generators.values())\n      .sort((a, b) => a.uiMetadata.sortHint - b.uiMetadata.sortHint)\n      .map((g) => ({\n        name: g.uiMetadata.name,\n        displayName: g.uiMetadata.displayName,\n      }));\n  }\n\n  /**\n   * Retrieves the full UI metadata for a single generator.\n   * @param name The name of the generator.\n   * @returns The UI metadata object, or undefined if not found.\n   */\n  public getUIMetadata(name: GeneratorName): GeneratorUIMetadata | undefined {\n    return this.generators.get(name)?.uiMetadata;\n  }\n\n  /**\n   * Builds a default (empty) config object for a given generator.\n   * @param name The name of the generator.\n   * @param width The width of the puzzle\n   * @param height The height of the puzzle\n   * @returns Default config object for the given generator\n   */\n  public getDefaultConfig(name: GeneratorName, width: number, height: number): GeneratorConfig {\n    const newConfig: GeneratorConfig = {\n      name: name,\n      width: width,\n      height: height,\n    };\n\n    const metadata = this.getUIMetadata(name);\n    if (metadata) {\n      for (const control of metadata.controls) {\n        newConfig[control.name] = control.defaultValue;\n      }\n    }\n\n    return newConfig;\n  }\n}\n\n/* ========================================================= *\\\n *  Public registeries                                       *\n\\* ========================================================= */\n\n// Public registry for PointGenerators\nimport { PointGenerator } from \"./point/PointGenerator\";\nexport const PointGeneratorRegistry = new GeneratorRegistry<PointGenerator>();\n\n// Public registry for PieceGenerators\nimport { PieceGenerator } from \"./piece/PieceGenerator\";\nexport const PieceGeneratorRegistry = new GeneratorRegistry<PieceGenerator>();\n\n// Public registry for TabGenerators\nimport { TabGenerator } from \"./tab/TabGenerator\";\nexport const TabGeneratorRegistry = new GeneratorRegistry<TabGenerator>();\n","\n/**\n * Simple seeded PRNG. The state space is 32 bits, so the period (the point at\n * which random numbers repeat for the same seed) is 2^32.\n * See https://github.com/cprosche/mulberry32 for more details.\n * @param seed seed number\n * @returns function which returns a random number each time it is called\n */\nexport function mulberry32(seed: number) {\n  return function() {\n    let t = seed += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nexport default mulberry32;\n","import type { PuzzleGeometry, Vec2 } from \"./types\";\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabGeneratorRegistry, type GeneratorConfig } from \"./generators/Generator\";\nimport mulberry32 from \"../utils/mulberry\";\n\n/**\n * Configuration options for the entire puzzle generation process.\n */\nexport interface PuzzleGenerationOptions {\n  /** Width of the puzzle */\n  width: number;\n  /** Height of the puzzle */\n  height: number;\n  /** A rough guide for piece size */\n  pieceSize: number;\n  /** Random seed to produce repeatable puzzles */\n  seed?: number;\n  /** How shoule the points that control the pieces get generated? */\n  pointConfig: GeneratorConfig;\n  /** How should the pieces get built? */\n  pieceConfig: GeneratorConfig;\n  /** How should tabs get constructed? */\n  tabConfig: GeneratorConfig;\n}\n\n/**\n * Orchestrates the procedural generation of a jigsaw puzzle\n * by coordinating various pluggable generators.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function buildPuzzle(options: PuzzleGenerationOptions): Promise<PuzzleGeometry> {\n  const { width, height, pieceSize } = options;\n  const { pointConfig, pieceConfig, tabConfig } = options;\n\n  console.log(`rebuilding puzzle with dimensions ${width}x${height}, piece size ${pieceSize}`);\n\n  // get and configure the necessary generators\n  const pointGenerator = PointGeneratorRegistry.create(width, height, pointConfig);\n  const pieceGenerator = PieceGeneratorRegistry.create(width, height, pieceConfig);\n  const tabGenerator = TabGeneratorRegistry.create(width, height, tabConfig);\n\n  // seeded PRNG used to generate repeatable random numbers\n  const seed = options.seed ?? new Date().getTime();\n  const random = mulberry32(seed);\n\n  // 1. Generate seed points for the pieces\n  const points = pointGenerator.generatePoints({ width, height, pieceSize, random });\n  console.log(`Generated ${points.length} points`);\n\n  // 2. Convert points to a puzzle topology (pieces and edges)\n  const topology = pieceGenerator.generatePieces(points, { random, pieceSize });\n  console.log(`Generated ${topology.pieces.size} pieces`);\n\n  // 3. Decorate internal edges with tabs\n  for (const edge of topology.edges.values()) {\n    // Only add tabs to internal edges (those with a left and right piece)\n    const isInternal = edge.heRight !== -1;\n    if (isInternal) {\n      tabGenerator.addTab(edge, { topology, random });\n    }\n  }\n\n  // 4. Assemble the final puzzle data structure\n  const puzzle: PuzzleGeometry = {\n    created: new Date().toISOString(),\n    seed,\n    width,\n    height,\n    vertices: topology.vertices,\n    boundary: topology.boundary,\n    pieces: topology.pieces,\n    edges: topology.edges,\n    halfEdges: topology.halfEdges,\n  };\n\n  return puzzle;\n}\n\n/** Draws puzzle geometry onto a canvas */\nexport function drawPuzzle(puzzle: PuzzleGeometry, canvas: HTMLCanvasElement, pieceColor: string, showPoints = false) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error(\"Could not get 2D context from canvas\");\n    return;\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // In debug mode, we draw each piece's full boundary in a different color.\n  // This helps visualize the ownership of each edge.\n  const debugMode = false;\n\n  if (debugMode) {\n    const debugColors = [\n      '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',\n      '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff',\n      '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',\n    ];\n    ctx.lineWidth = 2; // Use a thicker line for better visibility\n\n    let pieceIndex = 0;\n    for (const piece of puzzle.pieces.values()) {\n      const pieceColor = debugColors[pieceIndex % debugColors.length];\n      ctx.strokeStyle = pieceColor;\n      ctx.beginPath();\n      ctx.setLineDash([5, 5]); // use dashed lines\n\n      // Get the starting half-edge for this piece's boundary\n      let currentHe = puzzle.halfEdges.get(piece.halfEdge);\n      if (!currentHe) continue;\n\n      const startHeId = currentHe.id;\n      ctx.moveTo(currentHe.origin[0], currentHe.origin[1]);\n\n      // Traverse the boundary of the piece by following the 'next' pointers\n      // until we get back to the starting half-edge.\n      do {\n        if (currentHe.segments) {\n          // If the edge has a custom tab, draw its segments\n          for (const segment of currentHe.segments) {\n            switch (segment.type) {\n            case 'bezier':\n              ctx.bezierCurveTo(segment.p1[0], segment.p1[1], segment.p2[0], segment.p2[1], segment.p3[0], segment.p3[1]);\n              break;\n            case 'line':\n              ctx.lineTo(segment.p[0], segment.p[1]);\n              break;\n            }\n          }\n        } else {\n          // Otherwise, draw a straight line to the start of the next half-edge\n          const nextHe = puzzle.halfEdges.get(currentHe.next)!;\n          ctx.lineTo(nextHe.origin[0], nextHe.origin[1]);\n        }\n        // Move to the next half-edge in the loop\n        currentHe = puzzle.halfEdges.get(currentHe.next)!;\n      } while (currentHe.id !== startHeId);\n\n      ctx.stroke();\n      pieceIndex++;\n    }\n\n    // Reset line dash for subsequent drawing operations.\n    ctx.setLineDash([]);\n\n  } else {\n    // normal mode drawing, optimized for efficiency\n\n    // Style for piece boundaries\n    ctx.strokeStyle = pieceColor;\n    ctx.lineWidth = 1;\n\n    // it's more efficient to batch all paths together\n    ctx.beginPath();\n\n    // By iterating through all unique edges and drawing the curve for one of\n    // its half-edges, we ensure every cut is defined exactly once.\n    for (const edge of puzzle.edges.values()) {\n      // We consistently choose heLeft. The tab generator puts the \"outie\"\n      // or \"innie\" on this half-edge, and the twin gets the inverse.\n      const he = puzzle.halfEdges.get(edge.heLeft);\n      if (!he) continue; // should not happen\n\n      // move to the start of this edge segment\n      ctx.moveTo(he.origin[0], he.origin[1]);\n\n      if (he.segments) {\n        // if a custom tab is defined, draw each segment in order\n        for (const segment of he.segments) {\n          switch (segment.type) {\n          case 'bezier':\n            ctx.bezierCurveTo(\n              segment.p1[0], segment.p1[1],\n              segment.p2[0], segment.p2[1],\n              segment.p3[0], segment.p3[1]\n            );\n            break;\n          case 'line':\n            ctx.lineTo(segment.p[0], segment.p[1]);\n            break;\n          }\n        }\n      } else {\n        // no tab, draw a straight line to the edge's endpoint.\n        // The end point of a half-edge is the origin of its twin.\n        // For boundary edges, the twin is -1, so we find the end point\n        // by looking at the start of the next half-edge around the piece.\n        let destination: Vec2;\n        // For an internal edge, the destination is the origin of the twin half-edge.\n        if (he.twin !== -1) {\n          const twinHe = puzzle.halfEdges.get(he.twin)!;\n          destination = twinHe.origin;\n        } else {\n          // For a boundary edge, the destination is the origin of the next half-edge in the loop.\n          const nextHe = puzzle.halfEdges.get(he.next)!;\n          destination = nextHe.origin;\n        }\n        ctx.lineTo(destination[0], destination[1]);\n      }\n    }\n\n    // stroke the entire path containing all the unique puzzle edges\n    ctx.stroke();\n  }\n\n  // if the puzzle has problems like intersecting/overlapping pieces, highlight them\n  if (puzzle.problems && puzzle.problems.length > 0) {\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = 'red';\n    for (const problemPoint of puzzle.problems) {\n      const [x, y] = problemPoint;\n      ctx.beginPath();\n      ctx.arc(x, y, 8, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }\n\n  // draw the piece sites (original Voronoi points) for reference\n  if (showPoints) {\n    ctx.fillStyle = 'blue';\n    for (const piece of puzzle.pieces.values()) {\n      const [x, y] = piece.site;\n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n}\n","import m from 'mithril';\nimport { drawPuzzle } from \"../geometry/PuzzleMaker\";\nimport type { PuzzleGeometry } from '../geometry/types';\n\n// include our CSS\nimport './Puzzle.css';\n\n// component attributes\nexport interface PuzzleAttrs extends m.Attributes {\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Generated puzzle geometry */\n  puzzle: PuzzleGeometry,\n  /** If true, geometry is being regenerated */\n  isDirty: boolean;\n  /** User uploaded image */\n  imageUrl?: string;\n}\n\n// Mithril component\nexport const Puzzle: m.ClosureComponent<PuzzleAttrs> = () => {\n\n  // component state\n  const state = {\n    /** Canvas HTML element */\n    canvas: null as HTMLCanvasElement | null,\n  };\n\n  return {\n    // component lifecycle: called after our DOM element is created and attached\n    oncreate: ({ dom, attrs }) => {\n      state.canvas = dom.querySelector<HTMLCanvasElement>(\"canvas.puzzle\");\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color);\n      }\n    },\n\n    onupdate: ({ attrs }) => {\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color);\n      }\n    },\n\n    // component lifecycle: render our output\n    view: ({ attrs }) => {\n\n      return m(\".puzzle-stack\", [\n        // user uploaded image\n        m(\"img.background\", {\n          width: attrs.width,\n          height: attrs.height,\n          src: attrs.imageUrl,\n        }),\n        // canvas for rendering the current puzzle\n        m('canvas.puzzle', {\n          width: attrs.width,\n          height: attrs.height,\n          style: {\n            width: `${attrs.width}px`,\n            height: `${attrs.height}px`,\n          },\n        }),\n      ]);\n    },\n\n  };\n};\nexport default Puzzle;\n\n","import { PuzzleTopology, Vec2 } from \"../geometry/types\";\n\n/**\n * Generates an SVG string representation of the puzzle's cut lines.\n *\n * @param topology - The puzzle topology containing the geometric data.\n * @param width - The width of the SVG viewport.\n * @param height - The height of the SVG viewport.\n * @param pieceColor - Optional color to draw the pieces (default black)\n * @returns A string containing the complete SVG markup.\n */\nexport function createSVG(topology: PuzzleTopology, width: number, height: number, pieceColor = \"black\"): string {\n  // how many digits to preserve when converting decimal numbers to SVG string\n  const precisionDigits = 3;\n\n  // Array to hold the individual path commands (e.g., \"M 10 10\", \"L 100 100\").\n  const pathData: string[] = [];\n\n  // Iterate over each unique edge, ensuring each cut is only defined once.\n  for (const edge of topology.edges.values()) {\n    const he = topology.halfEdges.get(edge.heLeft);\n    if (!he) continue;\n\n    // SVG Path Command: \"M\" - move to the starting point of the half-edge.\n    pathData.push(`M ${he.origin[0].toFixed(precisionDigits)} ${he.origin[1].toFixed(precisionDigits)}`);\n\n    if (he.segments) {\n      // if a custom tab is defined, draw each segment in order\n      for (const segment of he.segments) {\n        switch (segment.type) {\n        case 'bezier':\n          // SVG Path Command: \"C\" - draw a cubic Bézier curve.\n          pathData.push(\n            `C ${segment.p1[0].toFixed(precisionDigits)} ${segment.p1[1].toFixed(precisionDigits)}, ` +\n            `${segment.p2[0].toFixed(precisionDigits)} ${segment.p2[1].toFixed(precisionDigits)}, ` +\n            `${segment.p3[0].toFixed(precisionDigits)} ${segment.p3[1].toFixed(precisionDigits)}`\n          );\n          break;\n        case 'line':\n          // SVG Path Command: \"L\" - draw a straight line to the destination.\n          pathData.push(`L ${segment.p[0].toFixed(precisionDigits)} ${segment.p[1].toFixed(precisionDigits)}`);\n          break;\n        }\n      }\n    } else {\n      // SVG Path Command: \"L\" - draw a straight line to the destination.\n      let destination: Vec2;\n      if (he.twin !== -1) {\n        // Internal edge: destination is the start of the twin half-edge.\n        const twinHe = topology.halfEdges.get(he.twin)!;\n        destination = twinHe.origin;\n      } else {\n        // Boundary edge: destination is the start of the next half-edge.\n        const nextHe = topology.halfEdges.get(he.next)!;\n        destination = nextHe.origin;\n      }\n      pathData.push(`L ${destination[0].toFixed(precisionDigits)} ${destination[1].toFixed(precisionDigits)}`);\n    }\n  }\n\n  // Join all path commands into a single string for the 'd' attribute.\n  const pathD = pathData.join(' ');\n\n  // Construct the final SVG markup.\n  // The <path> element uses vector-effect=\"non-scaling-stroke\" which is a best\n  // practice for laser cutting files, as it ensures the line width remains\n  // constant regardless of scaling.\n  const svgString = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg\n  width=\"${width}\"\n  height=\"${height}\"\n  viewBox=\"0 0 ${width} ${height}\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  version=\"1.1\"\n>\n  <path\n    d=\"${pathD}\"\n    fill=\"none\"\n    stroke=\"${pieceColor}\"\n    stroke-width=\"1\"\n    vector-effect=\"non-scaling-stroke\"\n  />\n</svg>`\n    .trim() // strip leading and trailing whitespace\n    .replace(/\\r\\n/g, '\\n'); // use unix line endings for max compatibility\n\n  return svgString;\n}\n\n\n/**\n * Offers a SVG file for download\n * @param svg SVG string as generated by drawSVG()\n * @param filename Optional name of file for download\n */\nexport function downloadSvg(svg: string, filename = \"puzzle.svg\") {\n  // create a blob from the SVG string\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n\n  // create a temporary object URL for the blob\n  const url = URL.createObjectURL(blob);\n\n  // create a hidden <a> element with the download attribute\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  a.hidden = true;\n\n  // click it\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n\n  // clean up\n  setTimeout(() => URL.revokeObjectURL(url), 100);\n}\n","// UI component that offers a SVG download when clicked\nimport m from 'mithril';\nimport { createSVG, downloadSvg } from '../utils/svg';\nimport type { PuzzleTopology } from '../geometry/types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/button/button.js';\n\nexport interface DownloadPuzzleButtonAttrs extends m.Attributes {\n  /** Generated puzzle geometry */\n  puzzle: PuzzleTopology;\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Optional filename for the download */\n  filename?: string;\n}\n\nexport const DownloadPuzzleButton: m.Component<DownloadPuzzleButtonAttrs> = {\n  view: ({ attrs }) => {\n    return m('sl-button.download-svg', {\n      onclick: () => {\n        // convert the puzzle geometry into a SVG string\n        const svg = createSVG(attrs.puzzle, attrs.width, attrs.height, attrs.color);\n        // offer it as a download\n        downloadSvg(svg, attrs.filename ?? 'puzzle.svg');\n      },\n    }, 'Download SVG');\n  },\n};\nexport default DownloadPuzzleButton;\n","// UI component to initiate and display geometry checks\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/badge/badge.js';\nimport '@shoelace-style/shoelace/dist/components/checkbox/checkbox.js';\nimport type { SlCheckbox } from '@shoelace-style/shoelace';\nimport '@shoelace-style/shoelace/dist/components/icon-button/icon-button.js';\nimport '@shoelace-style/shoelace/dist/components/progress-bar/progress-bar.js';\nimport '@shoelace-style/shoelace/dist/components/tooltip/tooltip.js';\n\n// component CSS\nimport './GeometryCheckIndicator.css';\n\n// component attributes\nexport interface GeometryCheckIndicatorAttrs extends m.Attributes {\n  /** If true, the auto check box is checked */\n  autoCheck: boolean;\n  /** If present, represents the number of geometry problems found in the most recent check */\n  problems?: number;\n  /** If present represents the percent complete of the current geometry check */\n  progressPercent?: number;\n  /** Handler called when user clicks the check now button */\n  onCheckRequested?: () => void;\n  /** Called when the user toggles the auto check on or off */\n  onAutocheckChanged?: (autocheck: boolean) => void;\n};\n\n// component\nexport const GeometryCheckIndicator: m.Component<GeometryCheckIndicatorAttrs> = {\n  view: ({ attrs }) => {\n    const showProgress = attrs.progressPercent !== undefined && attrs.progressPercent < 100;\n    const showOKBadge = !showProgress && attrs.problems !== undefined && attrs.problems == 0;\n    const showProblemBadge = !showProgress && attrs.problems !== undefined && attrs.problems > 0;\n\n    console.log(`showProgress is ${showProgress}, showOKBadge is ${showOKBadge}, showProblemBadge is ${showProblemBadge}`);\n\n    return m('.geometry-check-indicator', [\n\n      // label\n      m('.label', \"Geometry Check:\"),\n\n      // run now button\n      m('sl-tooltip', { content: 'Check geometry now' },\n        m('sl-icon-button.check-now', {\n          library: 'material',\n          name: 'editor_choice',\n          label: 'Check geometry now',\n          disabled: showProgress,\n          onclick: (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            attrs.onCheckRequested?.();\n          },\n        })\n      ),\n\n      // auto checkbox\n      m('sl-tooltip', { content: 'Check geometry after every change' },\n        m('sl-checkbox', {\n          checked: attrs.autoCheck,\n          disabled: showProgress,\n          size: 'small',\n          'onsl-change': (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            const checkbox = e.target as SlCheckbox;\n            attrs.onAutocheckChanged?.(checkbox.checked);\n          },\n        }, 'auto check'),\n      ),\n\n      // progress indicator\n      showProgress && m('sl-progress-bar', {\n        label: 'Geometry check progress',\n        value: attrs.progressPercent ?? 0,\n      }),\n\n      // OK badge\n      showOKBadge && m('sl-badge', {\n        variant: 'success',\n        pill: true,\n      }, 'OK'),\n\n      // Problems badge\n      showProblemBadge && m('sl-badge', {\n        variant: 'danger',\n        pill: true,\n      }, `${attrs.problems} issues`),\n\n    ]);\n  },\n};\nexport default GeometryCheckIndicator;\n","// UI component that allows the user to select an image to upload when clicked\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/button/button.js';\n\n// component attributes\nexport interface UploadImageAttrs extends m.Attributes {\n  /** Optional label for the button, default \"Upload Image\" */\n  label?: string;\n  /** If true, the button will be disabled */\n  disabled?: boolean;\n  /**\n   * Called when the user uploads an image. The caller is responsible for\n   * cleaning up the returned image URL.\n   */\n  onUpload: (imageUrl: string, filename: string, width: number, height: number) => void;\n};\n\n// utility to determine display dimensions that are the same aspect ratio\nfunction calculateDisplayDimensions(originalWidth: number, originalHeight: number, maxWidth = 800): {\n  width: number;\n  height: number;\n} {\n  if (originalWidth <= maxWidth) {\n    return {\n      width: originalWidth,\n      height: originalHeight,\n    };\n  }\n\n  const aspectRatio = originalHeight / originalWidth;\n  return {\n    width: maxWidth,\n    height: Math.round(maxWidth * aspectRatio),\n  };\n}\n\n// component\nexport const UploadImageButton: m.ClosureComponent<UploadImageAttrs> = () => {\n\n  // component state\n  const state = {\n    inputElement: undefined as HTMLInputElement | undefined,\n  };\n\n  return {\n\n    view: ({ attrs }) => {\n      return [\n\n        // button for display\n        m('sl-button.upload-button', {\n          disabled: attrs.disabled === true,\n          onclick: () => {\n            if (state.inputElement) {\n              state.inputElement.click();\n            }\n          },\n        }, attrs.label ?? 'Upload Image'),\n\n        // hidden file input that does the work\n        m('input[type=file]', {\n          style: { display: 'none' },\n          accept: 'image/*',\n          oncreate: ({ dom }) => {\n            state.inputElement = dom as HTMLInputElement;\n          },\n          onchange: (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            if (state.inputElement) {\n              const file = state.inputElement.files?.[0];\n              if (file?.type.startsWith('image/')) {\n                createImageBitmap(file)\n                  .then((bitmap) => {\n                    // get the image dimensions, scaled to fit in the display area\n                    const { width, height } = calculateDisplayDimensions(bitmap.width, bitmap.height);\n                    const uploadUrl = URL.createObjectURL(file);\n                    bitmap.close();\n                    attrs.onUpload(uploadUrl, file.name, width, height);\n                  })\n                  .catch((err) => {\n                    console.error('could not create a bitmap image: ', err);\n                  });\n              }\n            }\n          },\n        }),\n      ];\n    },\n  };\n};\nexport default UploadImageButton;\n","// UI component to take boolean input\nimport m from 'mithril';\nimport type { BooleanUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/checkbox/checkbox.js';\nimport type { SlCheckbox } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface BooleanInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: BooleanUIControl;\n  /** Current value */\n  value: boolean;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: boolean) => void;\n}\n\n// component\nexport const BooleanInputControl: m.ClosureComponent<BooleanInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-checkbox.boolean-input', {\n        \"help-text\": attrs.config.helpText,\n        disabled: attrs.disabled,\n        checked: attrs.value,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlCheckbox;\n          const newValue = input.checked;\n          attrs.onChange(newValue);\n        },\n      }, attrs.config.label);\n    },\n  };\n};\nexport default BooleanInputControl;\n","// UI component to take a number input\nimport m from 'mithril';\nimport type { NumberUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/input/input.js';\nimport type { SlInput } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface NumberInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: NumberUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const NumberInputControl: m.ClosureComponent<NumberInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-input.number-input', {\n        label: attrs.config.label,\n        \"help-text\": attrs.config.helpText,\n        type: \"number\",\n        inputmode: \"numeric\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlInput;\n          const newValue = input.valueAsNumber;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default NumberInputControl;\n","// UI component to take number input from a slider\nimport m from 'mithril';\nimport type { RangeUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/range/range.js';\nimport type { SlRange } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface RangeInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: RangeUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const RangeInputControl: m.ClosureComponent<RangeInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-range.range-input', {\n        label: attrs.config.label,\n        \"help-text\": attrs.config.helpText,\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        step: attrs.config.step,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlRange;\n          const newValue = input.value;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default RangeInputControl;\n","// UI component to take string input\nimport m from 'mithril';\nimport type { StringUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/input/input.js';\nimport type { SlInput } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface StringInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: StringUIControl;\n  /** Current value */\n  value?: string;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: string | undefined) => void;\n}\n\n// component\nexport const StringInputControl: m.ClosureComponent<StringInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-input.string-input', {\n        label: attrs.config.label,\n        \"help-text\": attrs.config.helpText,\n        type: \"text\",\n        inputmode: \"text\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlInput;\n          const newValue = input.value;\n          attrs.onChange(newValue.length > 0 ? newValue : undefined);\n        },\n      });\n    },\n  };\n};\nexport default StringInputControl;\n","// UI component that lets the user pick and configure a generator\nimport m from 'mithril';\nimport type { GeneratorRegistry, GeneratorConfig, GeneratorName } from '../geometry/generators/Generator';\nimport BooleanInputControl from './inputs/BooleanInputControl';\nimport NumberInputControl from './inputs/NumberInputControl';\nimport RangeInputControl from './inputs/RangeInputControl';\nimport StringInputControl from './inputs/StringInputControl';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/tab/tab.js';\nimport '@shoelace-style/shoelace/dist/components/tab-group/tab-group.js';\nimport '@shoelace-style/shoelace/dist/components/tab-panel/tab-panel.js';\nimport type { SlTabShowEvent, SlTabGroup } from '@shoelace-style/shoelace';\n\n\n// include our CSS\nimport './GeneratorPicker.css';\n\n// component attributes\nexport interface GeneratorPickerAttrs<C extends GeneratorConfig = GeneratorConfig> extends m.Attributes {\n  /** Currently selected generator for this type */\n  generator: GeneratorName;\n  /** All the registered generators for this type */\n  registry: GeneratorRegistry<unknown>;\n  /** Current configuration for the selected generator */\n  config: C;\n  /** Called when the selected generator changes */\n  onGeneratorChange: (generatorName: string) => void;\n  /** Called when any config value changes */\n  onConfigChange: <K extends keyof C>(key: K, value: C[K]) => void;\n}\n\n// component\nexport const GeneratorPicker: m.ClosureComponent<GeneratorPickerAttrs> = () => {\n\n  // no component state\n\n  // component\n  return {\n    oncreate: ({ dom, attrs }) => {\n      const tabGroup = dom.querySelector('sl-tab-group') as SlTabGroup;\n      tabGroup.show(attrs.generator);\n    },\n\n    onupdate: ({ dom, attrs }) => {\n      const tabGroup = dom.querySelector('sl-tab-group') as SlTabGroup;\n      tabGroup.show(attrs.generator);\n    },\n\n    view: ({ attrs }) => {\n\n      const generators = attrs.registry.getAvailableGenerators();\n\n      return m(\".generator-picker\",\n        m('sl-tab-group', {\n          // custom Shoelace event triggered when a new tab panel is shown\n          'onsl-tab-show': (e: SlTabShowEvent) => {\n            const newSelected = e.detail.name;\n            if (attrs.generator !== newSelected) {\n              attrs.onGeneratorChange(newSelected);\n            }\n          },\n        }, [\n          ...generators.map((generator) => {\n            // get the UI metadata associated with this generator\n            const uiMetadata = attrs.registry.getUIMetadata(generator.name);\n\n            // tab contains name of generator\n            const tab = m('sl-tab', {\n              slot: \"nav\",\n              panel: generator.name,\n            }, generator.displayName);\n\n            // matching panel contains controls specific to that generator\n            const panel = m('sl-tab-panel', {\n              name: generator.name,\n            }, m('.controls',\n              [\n                // detailed description of the generator if available\n                uiMetadata?.description ? m('p', uiMetadata.description) : null,\n\n                // UI controls defined by the generator\n                ...uiMetadata?.controls.map((control) => {\n                  switch(control.type) {\n                  case \"range\":\n                    return m(RangeInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"boolean\":\n                    return m(BooleanInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) === true,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"number\":\n                    return m(NumberInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"string\":\n                    return m(StringInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as string | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  }\n                }) ?? [],\n\n                // no controls message when appropriate\n                (!uiMetadata?.description && uiMetadata?.controls.length == 0) ? m('p', 'No controls for this strategy.') : null,\n              ])\n            );\n            return [tab, panel];\n          }),\n        ])\n      );\n    },\n  };\n};\nexport default GeneratorPicker;\n","// UI component to let the user select an aspect ratio\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/option/option.js';\nimport '@shoelace-style/shoelace/dist/components/range/range.js';\nimport '@shoelace-style/shoelace/dist/components/select/select.js';\nimport type { SlRange, SlSelect } from '@shoelace-style/shoelace';\n\n// this component's CSS\nimport './AspectRatioPicker.css';\n\n// component attributes\nexport interface AspectRatioPickerAttr extends m.Attributes {\n  /** Current ratio */\n  ratio: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current ratio */\n  onChange: (ratio: number) => void;\n}\n\n// data\nconst commonAspectRatios: [string, string, number][] = [\n  [\"Square\",           \"1:1\",    1],\n\n  // --- Landscape ---\n  [\"Classic Photo\",    \"5:4\",    5/4],\n  [\"Standard Photo\",   \"4:3\",    4/3],\n  [\"35mm/DSLR\",        \"3:2\",    3/2],\n  [\"Widescreen\",       \"16:9\",   16/9],\n  [\"UltraWide\",        \"21:9\",   21/9],\n  [\"Panorama\",         \"2:1\",    2/1],\n\n  // --- Portrait ---\n  [\"Instagram Portrait\",       \"4:5\",    4/5],\n  [\"Classic Portrait\",         \"3:4\",    3/4],\n  [\"DSLR Portrait\",            \"2:3\",    2/3],\n  [\"Phone Portrait\",           \"9:16\",   9/16],\n  [\"Tall Poster\",              \"9:21\",   9/21],\n  [\"Tall Panorama\",            \"1:2\",    1/2],\n];\n\n// component\nexport const AspectRatioPicker: m.Component<AspectRatioPickerAttr> = {\n  view: ({ attrs }) => {\n\n    // Determine if the current ratio is a custom value (not in our predefined list)\n    const isCustom = !commonAspectRatios.some(([, , value]) => value === attrs.ratio);\n\n    // Generate the list of <sl-option> elements\n    const selectOptions = commonAspectRatios.map(([name, ratioStr, value]) =>\n      m('sl-option', {\n        value: String(value), // select values are strings\n      }, `${name} [${ratioStr}]`)\n    );\n\n    // If the ratio is custom, add a temporary \"Custom\" option to the start of the list\n    if (isCustom) {\n      selectOptions.unshift(m('sl-option', { value: 'custom' }, 'Custom'));\n    }\n\n    return m('.aspect-ratio-picker', [\n\n      // drop down with common ratios\n      m('sl-select', {\n        label: 'Aspect Ratio',\n        size: 'small',\n        disabled: attrs.disabled,\n        value: isCustom ? 'custom' : String(attrs.ratio),\n        'onsl-change': (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const select = e.target as SlSelect;\n          const selectedValue = select.value as string;\n\n          // 'custom' is a placeholder, so we only trigger onChange for actual numeric values.\n          if (selectedValue && selectedValue !== 'custom') {\n            attrs.onChange(Number(selectedValue));\n          }\n        },\n      }, selectOptions),\n\n      // slider for any ratio\n      m('sl-range', {\n        // allow ratios from 1:4 (0.25) to 4:1 (4.0)\n        min: 0.25,\n        max: 4,\n        step: 0.01,\n        disabled: attrs.disabled,\n        value: attrs.ratio,\n        'onsl-change': (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const range = e.target as SlRange;\n          attrs.onChange(range.value);\n        },\n      }),\n    ]);\n  },\n};\nexport default AspectRatioPicker;\n","// UI component to let the user select a color\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/color-picker/color-picker.js';\nimport type { SlColorPicker } from '@shoelace-style/shoelace';\n\n// this component's CSS\nimport './ColorPicker.css';\n\n// component attributes\nexport interface ColorPickerAttrs extends m.Attributes {\n  /** Label to display next to the color picker */\n  label: string;\n  /** Current color */\n  color: string;\n  /** Optional size of picker trigger area */\n  size?: \"small\" | \"medium\" | \"large\";\n  /** Called when the user changes the color */\n  onUpdate: (newColor: string) => void;\n};\n\n// component with no state\nexport const ColorPicker: m.Component<ColorPickerAttrs> = {\n  view: ({ attrs }) => {\n    return m('.color-picker', [\n      m('.label', attrs.label),\n      m('sl-color-picker', {\n        label: 'Select a color', // used by assistive devices\n        value: attrs.color,\n        size: attrs.size ?? \"medium\",\n        format: 'rgb',\n        'onsl-change': (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const input = e.target as SlColorPicker;\n          attrs.onUpdate(input.value);\n        },\n      }),\n    ]);\n  },\n};\nexport default ColorPicker;\n","\"use strict\";\n\nfunction tinyNDArrayOfInteger (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        dimension;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    return {\n        stride: stride,\n        data: new Uint32Array(totalLength)\n    };\n}\n\nfunction tinyNDArrayOfArray (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        data = [],\n        dimension, index;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    for (index = 0; index < totalLength; index++) {\n        data.push([]);\n    }\n\n    return {\n        stride: stride,\n        data: data\n    };\n}\n\nmodule.exports = {\n    integer: tinyNDArrayOfInteger,\n    array: tinyNDArrayOfArray\n};","\"use strict\";\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n","module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n","\"use strict\";\n\nvar moore = require('moore');\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    // filter out neighbours who are too far from the center cell\n    // the impact of this, performance wise, is surprisingly small, even in 3d and higher dimensions\n    neighbourhood = neighbourhood.filter(function (n) {\n        var dist = 0;\n\n        for (var d = 0; d < dimensionNumber; d++) {\n            dist += Math.pow(Math.max(0, Math.abs(n[d]) - 1), 2);\n        }\n\n        return dist < dimensionNumber; // cellSize = Math.sqrt(this.dimension)\n    });\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0,\n            dimension;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n}\n\nvar neighbourhoodCache = {};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhoodMemoized (dimensionNumber) {\n    if (!neighbourhoodCache[dimensionNumber]) {\n        neighbourhoodCache[dimensionNumber] = getNeighbourhood(dimensionNumber);\n    }\n\n    return neighbourhoodCache[dimensionNumber];\n}\n\nmodule.exports = getNeighbourhoodMemoized;","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').integer,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nfunction squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n}\n\n/**\n * FixedDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction FixedDensityPDS (options, rng) {\n    if (typeof options.distanceFunction === 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.squaredMinDistance = this.minDistance * this.minDistance;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.minDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints\n}\n\nFixedDensityPDS.prototype.shape = null;\nFixedDensityPDS.prototype.dimension = null;\nFixedDensityPDS.prototype.minDistance = null;\nFixedDensityPDS.prototype.maxDistance = null;\nFixedDensityPDS.prototype.minDistancePlusEpsilon = null;\nFixedDensityPDS.prototype.squaredMinDistance = null;\nFixedDensityPDS.prototype.deltaDistance = null;\nFixedDensityPDS.prototype.cellSize = null;\nFixedDensityPDS.prototype.maxTries = null;\nFixedDensityPDS.prototype.rng = null;\nFixedDensityPDS.prototype.neighbourhood = null;\n\nFixedDensityPDS.prototype.currentPoint = null;\nFixedDensityPDS.prototype.processList = null;\nFixedDensityPDS.prototype.samplePoints = null;\nFixedDensityPDS.prototype.gridShape = null;\nFixedDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nFixedDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nFixedDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nFixedDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nFixedDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nFixedDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will always throw an error.\n */\nFixedDensityPDS.prototype.getAllPointsWithDistance = function () {\n    throw new Error('PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation');\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nFixedDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = FixedDensityPDS;\n","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').array,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Euclidean distance\n */\nfunction euclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return Math.sqrt(result);\n}\n\n/**\n * VariableDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function} options.distanceFunction Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {float} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} rng RNG function, defaults to Math.random\n * @constructor\n */\nfunction VariableDensityPDS (options, rng) {\n    if (typeof options.distanceFunction !== 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n    this.distanceFunction = options.distanceFunction;\n    this.bias = Math.max(0, Math.min(1, options.bias || 0));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.maxDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.currentDistance = 0;\n    this.processList = [];\n    this.samplePoints = [];\n    this.sampleDistance = []; // used to store the distance for a given point\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints and sampleDistance\n}\n\nVariableDensityPDS.prototype.shape = null;\nVariableDensityPDS.prototype.dimension = null;\nVariableDensityPDS.prototype.minDistance = null;\nVariableDensityPDS.prototype.maxDistance = null;\nVariableDensityPDS.prototype.minDistancePlusEpsilon = null;\nVariableDensityPDS.prototype.deltaDistance = null;\nVariableDensityPDS.prototype.cellSize = null;\nVariableDensityPDS.prototype.maxTries = null;\nVariableDensityPDS.prototype.distanceFunction = null;\nVariableDensityPDS.prototype.bias = null;\nVariableDensityPDS.prototype.rng = null;\nVariableDensityPDS.prototype.neighbourhood = null;\n\nVariableDensityPDS.prototype.currentPoint = null;\nVariableDensityPDS.prototype.currentDistance = null;\nVariableDensityPDS.prototype.processList = null;\nVariableDensityPDS.prototype.samplePoints = null;\nVariableDensityPDS.prototype.sampleDistance = null;\nVariableDensityPDS.prototype.gridShape = null;\nVariableDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nVariableDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nVariableDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nVariableDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        pointIndex = this.samplePoints.length,\n        dimension;\n\n    this.processList.push(pointIndex);\n    this.samplePoints.push(point);\n    this.sampleDistance.push(this.distanceFunction(point));\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex].push(pointIndex); // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nVariableDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint,\n        existingPointDistance;\n\n    var pointDistance = this.distanceFunction(point);\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex].length > 0) {\n            for (var i = 0; i < this.grid.data[internalArrayIndex].length; i++) {\n                existingPoint = this.samplePoints[this.grid.data[internalArrayIndex][i]];\n                existingPointDistance = this.sampleDistance[this.grid.data[internalArrayIndex][i]];\n\n                var minDistance = Math.min(existingPointDistance, pointDistance);\n                var maxDistance = Math.max(existingPointDistance, pointDistance);\n                var dist = minDistance + (maxDistance - minDistance) * this.bias;\n\n                if (euclideanDistance(point, existingPoint) < this.minDistance + this.deltaDistance * dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nVariableDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        currentDistance,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            var sampleIndex = this.processList.shift();\n            this.currentPoint = this.samplePoints[sampleIndex];\n            this.currentDistance = this.sampleDistance[sampleIndex];\n        }\n\n        currentPoint = this.currentPoint;\n        currentDistance = this.currentDistance;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * (currentDistance + (1 - currentDistance) * this.bias);\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @returns {Array[]} Sample points with their distance function result\n */\nVariableDensityPDS.prototype.getAllPointsWithDistance = function () {\n    var result = new Array(this.samplePoints.length),\n        i = 0,\n        dimension = 0,\n        point;\n\n    for (i = 0; i < this.samplePoints.length; i++) {\n        point = new Array(this.dimension + 1);\n\n        for (dimension = 0; dimension < this.dimension; dimension++) {\n            point[dimension] = this.samplePoints[i][dimension];\n        }\n\n        point[this.dimension] = this.sampleDistance[i];\n\n        result[i] = point;\n    }\n\n    return result;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nVariableDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = [];\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = VariableDensityPDS;\n","\"use strict\";\n\nvar FixedDensityPDS = require('./implementations/fixed-density');\nvar VariableDensityPDS = require('./implementations/variable-density');\n\n/**\n * PoissonDiskSampling constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [options.distanceFunction] Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {function|null} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction PoissonDiskSampling (options, rng) {\n    this.shape = options.shape;\n\n    if (typeof options.distanceFunction === 'function') {\n        this.implementation = new VariableDensityPDS(options, rng);\n    } else {\n        this.implementation = new FixedDensityPDS(options, rng);\n    }\n}\n\nPoissonDiskSampling.prototype.implementation = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    return this.implementation.addRandomPoint();\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    return this.implementation.addPoint(point);\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    return this.implementation.next();\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    return this.implementation.fill();\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.implementation.getAllPoints();\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will throw an error if a distance function was not provided to the constructor.\n * @returns {Array[]} Sample points with their distance function result\n */\nPoissonDiskSampling.prototype.getAllPointsWithDistance = function () {\n    return this.implementation.getAllPointsWithDistance();\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    this.implementation.reset();\n};\n\nmodule.exports = PoissonDiskSampling;\n","import PoissonDiskSampling from 'poisson-disk-sampling';\nimport type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype PoissonPointGeneratorName = \"PoissonPointGenerator\";\nexport const Name: PoissonPointGeneratorName = \"PoissonPointGenerator\";\n\n/** Required config for this generator */\nexport interface PoissonPointGeneratorConfig extends GeneratorConfig {\n  name: PoissonPointGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const PoissonPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Poisson\",\n  description: \"Generate seed points using Poisson disk sampling. \" +\n    \"The algorithm produces points that are tightly-packed, but no closer to \" +\n    \"each other than a specified minimum distance (the piece size), resulting \" +\n    \"in a natural, organic look.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A point generator that uses Poisson disk sampling to create a more organic\n * distribution of random points. `pieceSize` is interpreted as the minimum\n * distance between generated points.\n */\nexport const PoissonPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_width: number, _height: number, _config: PoissonPointGeneratorConfig) => {\n  const PoissonPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      // generate points randomly in a Poisson disk sampling\n      const poisson = new PoissonDiskSampling(\n        {\n          shape: [width, height], // clamps generated points within bounds\n          minDistance: pieceSize,\n          tries: 20,\n        },\n        random\n      );\n\n      // have to cast because @types/PoissonDiskSampling is not correct for fill()\n      const points = poisson.fill() as unknown as Vec2[];\n      return points;\n    },\n  };\n  return PoissonPointGenerator;\n};\nexport default PoissonPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, PoissonPointGeneratorFactory, PoissonPointUIMetadata);\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const {delaunay: {points, hull, triangles}, vectors} = this;\n    let bx, by; // lazily computed barycenter of the hull\n\n    // Compute circumcenters.\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const ex = x3 - x1;\n      const ey = y3 - y1;\n      const ab = (dx * ey - dy * ex) * 2;\n\n      if (Math.abs(ab) < 1e-9) {\n        // For a degenerate triangle, the circumcenter is at the infinity, in a\n        // direction orthogonal to the halfedge and away from the “center” of\n        // the diagram <bx, by>, defined as the hull’s barycenter.\n        if (bx === undefined) {\n          bx = by = 0;\n          for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];\n          bx /= hull.length, by /= hull.length;\n        }\n        const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);\n        x = (x1 + x3) / 2 - a * ey;\n        y = (y1 + y3) / 2 + a * ex;\n      } else {\n        const d = 1 / ab;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x = x1 + (ey * bl - dy * cl) * d;\n        y = y1 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x;\n      circumcenters[j + 1] = y;\n    }\n\n    // Compute exterior cell rays.\n    let h = hull[hull.length - 1];\n    let p0, p1 = h * 4;\n    let x0, x1 = points[2 * h];\n    let y0, y1 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull.length; ++i) {\n      h = hull[i];\n      p0 = p1, x0 = x1, y0 = y1;\n      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;\n    if (hull.length <= 1) return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull[hull.length - 1];\n    for (let i = 0; i < hull.length; ++i) {\n      h0 = h1, h1 = hull[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = h0 * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null || !points.length) return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;\n    for (let i = 2; i < n; i += 2) {\n      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])\n        context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) cell.index = i, yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci) for (const j of this.delaunay.neighbors(i)) {\n      const cj = this._clip(j);\n      // find the common edge\n      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n          if (ci[ai] === cj[aj]\n              && ci[ai + 1] === cj[aj + 1]\n              && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]\n              && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {\n            yield j;\n            break loop;\n          }\n        }\n      }\n    }\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    // degenerate case (1 valid point: return the box)\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return this._simplify(V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points));\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    // for more robustness, always consider the segment in the same order\n    const flip = c0 < c1;\n    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];\n    while (true) {\n      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n      // undefined, the conditional statement will be executed.\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n  _simplify(P) {\n    if (P && P.length > 4) {\n      for (let i = 0; i < P.length; i+= 2) {\n        const j = (i + 2) % P.length, k = (i + 4) % P.length;\n        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n          P.splice(j, 2), i -= 2;\n        }\n      }\n      if (!P.length) P = null;\n    }\n    return P;\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n","\nexport type UniqueId = number;\n\nlet id = 0;\nexport function getUniqueId(): UniqueId {\n  return id++;\n}\n","import { Delaunay } from 'd3-delaunay';\nimport { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  AABB,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { getUniqueId } from '../../../utils/UniqueId';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\nexport const Name: VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\n\n/** Required config for this generator */\nexport interface VoronoiPieceGeneratorConfig extends GeneratorConfig {\n  name: VoronoiPieceGeneratorName;\n  // no special config\n}\n\n/** UI metadata needed for this generator */\nexport const VoronoiPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Voronoi\",\n  description: \"Construct pieces by building a Voronoi diagram from the seed points. \" +\n    \"Each piece consists of all area of the plane closer to its seed point than \" +\n    \"any other seed point. In practice, this creates irregular polygons with 3-8 \" +\n    \"sides.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a given polygon.\n * @param polygon - An array of vertices representing the polygon.\n * @returns The AABB as `[xmin, ymin, xmax, ymax]`. Returns a zero-area\n * box at the origin if the polygon is empty.\n */\nfunction calculateBoundingBox(polygon: Vec2[]): AABB {\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = polygon[0][0];\n  let minY = polygon[0][1];\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 1; i < polygon.length; i++) {\n    const p = polygon[i];\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n\n/**\n * Links the `next` and `prev` properties of a circular list of half-edges for a single piece.\n * @param ids The array of half-edge IDs belonging to a piece.\n * @param map The map containing all half-edge objects.\n */\nfunction linkPieceHalfEdges(ids: HalfEdgeID[], map: Map<HalfEdgeID, HalfEdge>): void {\n  const len = ids.length;\n  for (let i = 0; i < len; i++) {\n    const he = map.get(ids[i])!;\n    he.next = ids[(i + 1) % len];\n    he.prev = ids[(i - 1 + len) % len];\n  }\n}\n\n/**\n * Creates a consistent string key for a point, handling floating point inaccuracies.\n * @param p The point.\n * @returns A string key.\n */\nfunction pointToKey(p: Vec2): string {\n  return `${p[0].toPrecision(7)},${p[1].toPrecision(7)}`;\n}\n\n/**\n * Checks if two points are effectively at the same location.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns `true` if points are equal.\n */\nfunction arePointsEqual(p1: Vec2, p2: Vec2): boolean {\n  return Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6;\n}\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const VoronoiPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (width: number, height: number, _config: VoronoiPieceGeneratorConfig) => {\n  const VoronoiPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param points The seed points for the centers of the puzzle pieces.\n     * @param _runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(points: Vec2[], _runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n\n      // Note: Lloyd's relaxation could be performed here to create more uniform\n      // piece shapes. This would involve creating the Voronoi diagram, calculating\n      // the centroid of each cell, moving the input point to that centroid, and\n      // repeating for a number of iterations before proceeding.\n\n      console.log(`VoronoiPieceGenerator using dimensions ${width}x${height}`);\n      // 1. Generate Voronoi diagram from points, clipped to the puzzle bounds.\n      const delaunay = Delaunay.from(points);\n      const voronoi = delaunay.voronoi([0, 0, width, height]);\n\n      // 2. Initialize data structures for the topology.\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n      };\n\n      // A map to find a half-edge's twin, keyed by its start and end vertex coordinates.\n      const halfEdgeEndpointMap = new Map<string, HalfEdgeID>();\n\n      // 3. First pass: Create Piece and HalfEdge objects for each cell.\n      // At this stage, the half-edges are not yet linked (next, prev, twin).\n      for (let i = 0; i < points.length; i++) {\n        const site = points[i];\n        const polygon = voronoi.cellPolygon(i);\n\n        if (!polygon) continue;\n\n        const piece: Piece = {\n          id: i,\n          site,\n          halfEdge: -1, // Placeholder, will be set after creating half-edges.\n          bbox: calculateBoundingBox(polygon),\n        };\n\n        const pieceHalfEdgeIds: HalfEdgeID[] = [];\n\n        // Create a half-edge for each segment of the piece's polygon boundary.\n        for (let j = 0; j < polygon.length - 1; j++) {\n          const p1 = polygon[j];\n          const p2 = polygon[j + 1];\n\n          // Skip zero-length edges that can sometimes occur at the boundary.\n          if (arePointsEqual(p1, p2)) continue;\n\n          const he: HalfEdge = {\n            id: getUniqueId(),\n            origin: p1,\n            twin: -1, // To be linked in the second pass.\n            next: -1, // To be linked next.\n            prev: -1, // To be linked next.\n            piece: i,\n          };\n\n          topology.halfEdges.set(he.id, he);\n          pieceHalfEdgeIds.push(he.id);\n\n          // Store the half-edge in a map to easily find its twin later.\n          // The key is a string representation of its start and end points.\n          const key = `${pointToKey(p1)}-${pointToKey(p2)}`;\n          halfEdgeEndpointMap.set(key, he.id);\n        }\n\n        if (pieceHalfEdgeIds.length === 0) continue;\n\n        // Link the `next` and `prev` pointers for the half-edges of the current piece.\n        linkPieceHalfEdges(pieceHalfEdgeIds, topology.halfEdges);\n\n        // Set a starting half-edge for the piece and save it.\n        piece.halfEdge = pieceHalfEdgeIds[0];\n        topology.pieces.set(i, piece);\n      }\n\n      // 4. Second pass: Link twins and create the undirected Edge objects.\n      for (const he1 of topology.halfEdges.values()) {\n        // If twin is already set, it was handled when we processed its pair.\n        if (he1.twin !== -1) continue;\n\n        const he1_next = topology.halfEdges.get(he1.next)!;\n        const p1 = he1.origin;\n        const p2 = he1_next.origin;\n\n        const keyForTwin = `${pointToKey(p2)}-${pointToKey(p1)}`;\n        const twinId = halfEdgeEndpointMap.get(keyForTwin);\n\n        const edgeId = getUniqueId();\n        let edge: Edge;\n\n        if (twinId !== undefined) {\n          // This is an internal edge with a twin.\n          const he2 = topology.halfEdges.get(twinId)!;\n          he1.twin = he2.id;\n          he2.twin = he1.id;\n\n          // he1 is the \"left\" half-edge when looking from p1 to p2.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id,\n            heRight: he2.id,\n          };\n        } else {\n          // This is a boundary edge with no twin.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id, // The one existing half-edge.\n            heRight: -1,     // Sentinel for no half-edge.\n          };\n          topology.boundary.push(edgeId);\n        }\n\n        topology.edges.set(edgeId, edge);\n      }\n\n      // 5. Final step: Collect all unique vertices.\n      const vertexSet = new Map<string, Vec2>();\n      for (const he of topology.halfEdges.values()) {\n        const key = pointToKey(he.origin);\n        if (!vertexSet.has(key)) {\n          vertexSet.set(key, he.origin);\n        }\n      }\n      topology.vertices = Array.from(vertexSet.values());\n\n      return topology;\n    },\n  };\n  return VoronoiPieceGenerator;\n};\nexport default VoronoiPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, VoronoiPieceGeneratorFactory, VoronoiPieceGeneratorUIMetadata);\n","import type { TabGenerator, TabGeneratorRuntimeOptions } from \"./TabGenerator\";\nimport type { CurveTo, Edge, EdgeSegment, RandomFn, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\nexport const Name: TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TraditionalTabGeneratorConfig extends GeneratorConfig {\n  name: TraditionalTabGeneratorName;\n  /** Size of the tab relative to its edge as a percent (1-100) */\n  size?: number;\n  /** Amount of randomness to apply to each tab (0-100) */\n  jitter?: number;\n  /** If provided, tabs will not generate on edges shorter than this value */\n  minTabSize?: number;\n  /** If provided, the width of a tab's features will be clamped to this value */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TraditionalTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Traditional\",\n  description: \"Creates a traditional rounded tab for each (internal) piece edge.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'size',\n      label: 'Tab Size',\n      defaultValue: 20,\n      min: 1,\n      max: 100,\n      step: 1,\n      helpText: 'Size of each tab as a percent relative to its edge length',\n    },\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      defaultValue: 8,\n      min: 0,\n      max: 100,\n      step: 1,\n      helpText: 'Adds randomness to the tab shape. 0 means completely uniform tabs',\n    },\n    {\n      type: 'number',\n      name: 'minTabSize',\n      label: 'Minimum Tab Size',\n      defaultValue: 20,\n      optional: true,\n      helpText: 'If provided, tabs will not generate on edges shorter than this value',\n    },\n    {\n      type: 'number',\n      name: 'maxTabSize',\n      label: 'Maximum Tab Width',\n      optional: true,\n      helpText: 'If provided, the width of a tab\\'s features will be clamped to this value',\n    },\n  ],\n};\n\n\n/**\n * Build a puzzle nub using three cubic Bézier segments that replace a straight\n * edge AB. Curve 1 is a gentle S-curve up to the nub edge, Curve 2 is the arch\n * across the top of the nub, Curve 3 is the mirror of curve 1 back to the baseline.\n *   - the edge is parameterised from 0.0 → 1.0 along its length;\n *   - the nub is centred roughly at s = 0.5 and spans ≈ 4 · t of the edge;\n *   - the peak of the nub reaches ± 3 · t away from the baseline.\n *\n * @param a         Edge start point.\n * @param b         Edge end point.\n * @param sizePct   “Tab size” slider value (0–100 %).\n * @param jitterPct “Jitter” slider value (0–100 %).\n * @param random    Seeded RNG so callers can reproduce shapes.\n * @param inward    If true the nub is an **indent**; otherwise a **bump**.\n * @param maxTabSize Optional maximum absolute width for the tab.\n *\n * @returns Three cubic Bézier segments, ordered from a→b.\n */\nfunction createTraditionalTab(\n  a: Vec2,\n  b: Vec2,\n  sizePct: number,\n  jitterPct: number,\n  random: RandomFn,\n  inward = false,\n  maxTabSize?: number\n): EdgeSegment[] {\n  /* --- 1.  Work in a local (u,v) coordinate frame ---------------------- */\n\n  const ux = b[0] - a[0];\n  const uy = b[1] - a[1];\n  const len = Math.hypot(ux, uy);\n  if (len === 0) throw new Error(\"Edge has zero length\");\n\n  // Basis vectors:  u along the edge, v = +90° (right-hand rule).\n  const u: Vec2 = [ux / len, uy / len];\n  const v: Vec2 = [-u[1], u[0]]; // perpendicular\n\n  /** Convert (s,w) → world coordinates.  Both s and w are normalised by len. */\n  const P = (s: number, w: number): Vec2 => [\n    a[0] + (u[0] * s + v[0] * w) * len,\n    a[1] + (u[1] * s + v[1] * w) * len,\n  ];\n\n  /* --- 2.  Derive the five random perturbations a…e -------------------- */\n\n  const j = jitterPct / 100;\n  const rng = () => (random() * 2 - 1) * j; // uniform(-j, +j)\n\n  const A = rng(); // entry handle offset\n  const B = rng(); // l-shift of whole nub\n  const C = rng(); // vertical wobble of apex\n  const D = rng(); // anti-sym tweak\n  const E = rng(); // exit handle offset\n\n  /* --- 3.  Fixed shape constants -------------------------------------- */\n\n  let t = sizePct / 200; // tab “radius” in edge-length units\n\n  if (maxTabSize) {\n    const absoluteTabWidth = 4 * t * len;\n    if (absoluteTabWidth > maxTabSize) {\n      // recalculate t so that the tab width equals the max size, camping it\n      t = maxTabSize / (4 * len);\n    }\n  }\n\n  const dir = inward ? -1 : 1; // bump (+) or hole (-)\n\n  /* --- 4.  Anchor & control points in (s,w) ---------------------------- */\n\n  const pointsSW: Vec2[] = [\n    [0.0               ,           0],\n    [0.2               ,           A],\n    [0.5 + B + D       , dir * (-t + C)],\n    [0.5 - t + B       , dir * ( t + C)],\n    [0.5 - 2*t + B - D , dir * (3*t + C)],\n    [0.5 + 2*t + B - D , dir * (3*t + C)],\n    [0.5 + t + B       , dir * ( t + C)],\n    [0.5 + B + D       , dir * (-t + C)],\n    [0.8               ,           E],\n    [1.0               ,           0],\n  ];\n\n  /* --- 5.  Map to world coords and split into 3 Béziers ---------------- */\n\n  const points: Vec2[] = pointsSW.map(([s, w]) => P(s, w));\n\n  const bez1: CurveTo = { type: 'bezier', p1: points[1], p2: points[2], p3: points[3] };\n  const bez2: CurveTo = { type: 'bezier', p1: points[4], p2: points[5], p3: points[6] };\n  const bez3: CurveTo = { type: 'bezier', p1: points[7], p2: points[8], p3: points[9] };\n\n  return [bez1, bez2, bez3];\n}\n\n/**\n * Helper function to reverse a single Bézier curve segment.\n * The new curve starts where the old one ended and vice-versa.\n */\nfunction invertCurve(segment: CurveTo, newEndPoint: Vec2): CurveTo {\n  return {\n    type: 'bezier',\n    p1: segment.p2, // Control points are swapped\n    p2: segment.p1,\n    p3: newEndPoint, // The new end point is the start point of the original\n  };\n}\n\n/**\n * A factory that creates a TabGenerator for creating traditional, smoothly curved\n * puzzle piece tabs using a provided geometry function. The nub is built using\n * three cubic Bézier segments that replace a straight edge AB. Curve 1 is a\n * gentle S-curve up to the nub edge, Curve 2 is the arch across the top of the\n * nub, Curve 3 is the mirror of curve 1 back to the baseline.\n */\nexport const TraditionalTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number, config: TraditionalTabGeneratorConfig): TabGenerator => {\n  const { size = 20, jitter = 8, minTabSize, maxTabSize } = config;\n\n  const TraditionalTabGenerator: TabGenerator = {\n    addTab(edge: Edge, runtimeOpts: TabGeneratorRuntimeOptions) {\n      const { topology, random } = runtimeOpts;\n      const he1 = topology.halfEdges.get(edge.heLeft);\n      const he2 = topology.halfEdges.get(edge.heRight);\n\n      if (!he1 || !he2) return;\n\n      const a = he1.origin;\n      const b = he2.origin;\n\n      if (minTabSize) {\n        const len = Math.hypot(b[0] - a[0], b[1] - a[1]);\n        if (len < minTabSize) {\n          return; // this tab would be too small\n        }\n      }\n\n      const he1IsInward = random() > 0.5;\n\n      const he1Segments = createTraditionalTab(a, b, size, jitter, random, he1IsInward, maxTabSize);\n      if (he1Segments.length === 0) return;\n\n      // Create the exact inverse path for the twin half-edge. This is critical\n      // for a perfect fit and cannot be done by just calling the function again\n      // due to the random perturbations.\n      const he2Segments: EdgeSegment[] = [];\n      for (let i = he1Segments.length - 1; i >= 0; i--) {\n        const currentSegment = he1Segments[i] as CurveTo; // We know they are curves\n        // The new end point is the start point of the original segment.\n        const originOfOriginal = (i > 0) ? (he1Segments[i-1] as CurveTo).p3 : a;\n        he2Segments.push(invertCurve(currentSegment, originOfOriginal));\n      }\n\n      he1.segments = he1Segments;\n      he2.segments = he2Segments;\n    },\n  };\n  return TraditionalTabGenerator;\n};\nexport default TraditionalTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TraditionalTabGeneratorFactory, TraditionalTabUIMetadata);\n","// utility to serialize PuzzleTopology for use with a web worker\nimport type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vertex,\n} from \"./types\";\n\n/** Serializable version of PuzzleTopology */\nexport interface PuzzleTopologySerializable {\n  vertices: Vertex[];\n  pieces: [PieceID, Piece][];\n  edges: [EdgeID, Edge][];\n  halfEdges: [HalfEdgeID, HalfEdge][];\n  boundary: EdgeID[];\n}\n\n/**\n * Converts a PuzzleTopology with Maps to a plain object representation. Note that\n * modern browsers support Map with structuredClone(), but older browsers do not,\n * so it is safer to manually serialize.\n */\nexport function serializeTopology(topology: PuzzleTopology): PuzzleTopologySerializable {\n  return {\n    vertices: topology.vertices,\n    pieces: Array.from(topology.pieces.entries()),\n    edges: Array.from(topology.edges.entries()),\n    halfEdges: Array.from(topology.halfEdges.entries()),\n    boundary: topology.boundary,\n  };\n}\n\n\n/** Revives a serialized topology back into a PuzzleTopology with Maps. */\nexport function deserializeTopology(serialized: PuzzleTopologySerializable): PuzzleTopology {\n  return {\n    vertices: serialized.vertices,\n    pieces: new Map(serialized.pieces),\n    edges: new Map(serialized.edges),\n    halfEdges: new Map(serialized.halfEdges),\n    boundary: serialized.boundary,\n  };\n}\n","import {\n  AABB,\n  EdgeSegment,\n  LineTo,\n  Piece,\n  PuzzleTopology,\n  Vec2,\n} from \"./types\";\nimport { serializeTopology } from \"./serialization\";\nimport type { CheckGeometryWorkerInput, CheckGeometryWorkerOutput } from '../workers/CheckGeometryWorker';\nimport { Bezier } from 'bezier-js';\n\n// import the worker script\nimport CheckGeometryWorker from '../workers/CheckGeometryWorker?worker';\n\n/** An internal structure to hold a segment and its pre-calculated properties. */\ninterface BoundarySegment {\n  /** The geometric definition of the segment. */\n  segment: EdgeSegment;\n  /** The starting point of this segment. */\n  startPoint: Vec2;\n  /** The pre-calculated bounding box for this segment. */\n  bbox: AABB;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a single edge segment.\n * @param segment - The line or curve segment.\n * @param startPoint - The starting coordinate of the segment.\n * @returns An AABB tuple: [xmin, ymin, xmax, ymax].\n */\nfunction calculateSegmentAABB(segment: EdgeSegment, startPoint: Vec2): AABB {\n  const points: Vec2[] = [startPoint];\n\n  if (segment.type === 'line') {\n    points.push(segment.p);\n  } else { // 'bezier'\n    points.push(segment.p1, segment.p2, segment.p3);\n  }\n\n  const xCoords = points.map((p) => p[0]);\n  const yCoords = points.map((p) => p[1]);\n\n  return [\n    Math.min(...xCoords),\n    Math.min(...yCoords),\n    Math.max(...xCoords),\n    Math.max(...yCoords),\n  ];\n}\n\n// helper to calculate the squared distance between two points.\nfunction distanceSq(p1: Vec2, p2: Vec2): number {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n};\n\n// helper to gets the end point of a segment.\nfunction getEndPoint(s: BoundarySegment) {\n  return s.segment.type === 'line' ? s.segment.p : s.segment.p3;\n}\n\n// helper to get a Bezier object for use with bezier-js\nfunction boundaryToBezier(boundary: BoundarySegment): Bezier {\n  if (boundary.segment.type !== 'bezier') {\n    throw new Error('Boundary segment is not a Bezier curve');\n  }\n  const { startPoint } = boundary;\n  const { p1, p2, p3 } = boundary.segment;\n  return new Bezier(\n    { x: startPoint[0], y: startPoint[1] },\n    { x: p1[0], y: p1[1] },\n    { x: p2[0], y: p2[1] },\n    { x: p3[0], y: p3[1] }\n  );\n}\n\n/**\n * Traverses a piece's boundary and collects all its geometric segments.\n * @param piece - The piece to process.\n * @param puzzle - The full puzzle geometry, for half-edge lookups.\n * @returns An ordered array of BoundarySegment objects.\n */\nfunction getPieceBoundary(piece: Piece, puzzle: PuzzleTopology): BoundarySegment[] {\n  const boundary: BoundarySegment[] = [];\n  const startHeId = piece.halfEdge;\n  let currentHeId = startHeId;\n\n  do {\n    const he = puzzle.halfEdges.get(currentHeId);\n    if (!he) {\n      console.error(`Could not find half-edge with ID: ${currentHeId}`);\n      break;\n    }\n\n    let startPoint = he.origin;\n\n    if (he.segments && he.segments.length > 0) {\n      // Add segments from the half-edge definition\n      for (const segment of he.segments) {\n        boundary.push({\n          segment,\n          startPoint,\n          bbox: calculateSegmentAABB(segment, startPoint),\n        });\n        // The next segment starts where the current one ends\n        startPoint = segment.type === 'line' ? segment.p : segment.p3;\n      }\n    } else {\n      // If no segments, it's a straight line to the next half-edge's origin\n      const nextHe = puzzle.halfEdges.get(he.next);\n      if (!nextHe) {\n        console.error(`Could not find next half-edge for ID: ${he.next}`);\n        continue;\n      }\n      const lineSegment: LineTo = { type: 'line', p: nextHe.origin };\n      boundary.push({\n        segment: lineSegment,\n        startPoint: startPoint,\n        bbox: calculateSegmentAABB(lineSegment, startPoint),\n      });\n    }\n\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId);\n\n  return boundary;\n}\n\n/**\n * Checks if two Axis-Aligned Bounding Boxes intersect.\n * @param a - The first AABB.\n * @param b - The second AABB.\n * @returns `true` if they overlap, `false` otherwise.\n */\nfunction doAABBsIntersect(a: AABB, b: AABB): boolean {\n  // x-axis check\n  if (a[2] < b[0] || a[0] > b[2]) {\n    return false;\n  }\n  // y-axis check\n  if (a[3] < b[1] || a[1] > b[3]) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Performs precise intersection detection between two geometric segments.\n * This function handles Line/Line, Line/Curve, and Curve/Curve cases.\n *\n * @param s1 - The first boundary segment.\n * @param s2 - The second boundary segment.\n * @param adjacent - True of the segments are next to each other on the boundary.\n * @returns An array of Vec2 points representing all found intersections.\n */\nfunction narrowPhaseDetection(s1: BoundarySegment, s2: BoundarySegment, adjacent: boolean): Promise<Vec2[]> {\n  return new Promise<Vec2[]>((resolve) => {\n\n    const intersections: Vec2[] = [];\n    const type1 = s1.segment.type;\n    const type2 = s2.segment.type;\n\n    // Bezier vs. Bezier\n    if (type1 === 'bezier' && type2 === 'bezier') {\n      const bezier1 = boundaryToBezier(s1);\n      const bezier2 = boundaryToBezier(s2);\n\n      // intersects() returns an array of strings that look like \"float/float\"\n      const pairs = bezier1.intersects(bezier2) as string[];\n\n      pairs.forEach((pair) => {\n        const tValues = pair.split('/');\n        const t1 = parseFloat(tValues[0]);\n        const t2 = parseFloat(tValues[1]);\n\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const tolerance = 0.01;\n          const isConnectionPoint = t1 > (1.0 - tolerance) && t2 < tolerance || t1 < tolerance && t2 > (1.0 - tolerance);\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n\n        // extract the intersection point\n        const p = bezier1.get(t1);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Bezier vs. Line\n    else if (type1 === 'bezier' || type2 === 'bezier') {\n      const curveBoundary = type1 === 'bezier' ? s1 : s2;\n      const lineBoundary = type1 === 'line' ? s1 : s2;\n\n      const curve = boundaryToBezier(curveBoundary);\n      const line = {\n        p1: { x: lineBoundary.startPoint[0], y: lineBoundary.startPoint[1] },\n        p2: { x: (lineBoundary.segment as LineTo).p[0], y: (lineBoundary.segment as LineTo).p[1] },\n      };\n\n      // intersects() returns an array of t-values on the curve\n      const tValues = curve.intersects(line) as number[]; // always numbers when comparing to line\n      tValues.forEach((t) => {\n        const p = curve.get(t);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Line vs. Line\n    else {\n      const p1 = s1.startPoint;\n      const p2 = s1.segment.p;\n      const p3 = s2.startPoint;\n      const p4 = s2.segment.p;\n\n      const [x1, y1] = p1;\n      const [x2, y2] = p2;\n      const [x3, y3] = p3;\n      const [x4, y4] = p4;\n\n      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n      if (den !== 0) { // Ensure lines are not parallel or collinear\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n\n        // If an intersection exists on both line segments\n        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n          const intersectX = x1 + t * (x2 - x1);\n          const intersectY = y1 + t * (y2 - y1);\n          intersections.push([intersectX, intersectY]);\n        }\n      }\n    }\n\n    resolve(intersections);\n  });\n}\n\n/**\n * Detects self-intersections within each piece of a puzzle geometry.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @param onProgress - Optional callback invoked to report progress.\n * @returns An array of Vec2 points, where each point is an overlap.\n */\nasync function detectIntersections(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  const intersections: Vec2[] = [];\n  const EPSILON_SQUARED = 1e-8; // Tolerance for floating point comparisons\n\n  const pieces = Array.from(puzzle.pieces.values());\n  const totalPieces = pieces.length;\n  let processedCount = 0;\n\n  // 1. Iterate through each piece\n  for (const piece of puzzle.pieces.values()) {\n\n    // report progress\n    onProgress?.(processedCount, totalPieces);\n\n    const boundary = getPieceBoundary(piece, puzzle);\n    const numSegments = boundary.length;\n    if (numSegments < 2) {\n      processedCount++;\n      continue;\n    }\n\n    // 2. Compare every segment with every other segment that comes after it\n    for (let i = 0; i < numSegments; i++) {\n      for (let j = i + 1; j < numSegments; j++) {\n        const seg1 = boundary[i];\n        const seg2 = boundary[j];\n\n        // 3. Broad-phase detection using bounding boxes\n        if (!doAABBsIntersect(seg1.bbox, seg2.bbox)) {\n          // no intersections\n          continue;\n        }\n\n        // 4. Distinguish between adjacent and non-adjacent intersections\n        const areAdjacent = (j === i + 1) || (i === 0 && j === numSegments - 1);\n\n        // 5. Narrow-phase detection (using a bezier library)\n        const potentialPoints = await narrowPhaseDetection(seg1, seg2, areAdjacent);\n\n        if (potentialPoints.length === 0) {\n          // no intersections\n          continue;\n        }\n\n        if (areAdjacent) {\n          const connectionPoint = (i === 0 && j === numSegments - 1)\n            ? seg1.startPoint // we're comparing the final segment with the first segment\n            : getEndPoint(seg1); // we're comparing adjacent segments\n\n          for (const point of potentialPoints) {\n            // An intersection is only an error if it's NOT at the connection point.\n            if (distanceSq(point, connectionPoint) > EPSILON_SQUARED) {\n              intersections.push(point);\n            }\n          }\n        } else {\n          // For non-adjacent segments, ANY intersection is an error.\n          intersections.push(...potentialPoints);\n        }\n      }\n    }\n    processedCount++;\n  }\n\n  // final call to signify completion\n  onProgress?.(totalPieces, totalPieces);\n\n  console.log(`detected ${intersections.length} intersections in ${puzzle.pieces.size} pieces`);\n  return intersections;\n}\n\n\n/**\n * Checks a puzzle for geometry issues such as intersecting pieces or too narrow geometry.\n * @param puzzle - Geometry to check\n * @param onProgress - Optional callpack for managing a progress bar\n * @returns A Promise for coordinates that have problem geometry\n */\nexport async function checkGeometry(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  // find points where pieces intersect/overlap\n  const intersections = await detectIntersections(puzzle, onProgress);\n\n  if (intersections.length < 2) {\n    return intersections;\n  }\n\n  // Note: the intersection algorithm can return multiple points clustered very\n  // closely, which is confusing for the user, so here we filter them out\n  const MIN_DISTANCE = 1;\n  const filtered: Vec2[] = [intersections[0]];\n\n  for (let i = 1; i < intersections.length; i++) {\n    const current = intersections[i];\n    const last = filtered[filtered.length - 1];\n    if (distanceSq(current, last) > MIN_DISTANCE * MIN_DISTANCE) {\n      filtered.push(current);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Wraps the `checkGeometry` function in a web worker to run it off the main thread,\n * preventing the UI from freezing during intensive calculations.\n *\n * @param puzzle - The puzzle topology to check.\n * @param onProgress - An optional callback to receive progress updates.\n * @returns A promise that resolves with an array of intersection points or rejects on error.\n */\nexport function checkGeometryInWorker(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n  return new Promise((resolve, reject) => {\n    const worker = new CheckGeometryWorker();\n\n    // Handle messages received from the worker\n    worker.onmessage = (event: MessageEvent<CheckGeometryWorkerOutput>) => {\n      const data = event.data;\n\n      switch (data.type) {\n      case 'progress':\n        onProgress?.(data.processed, data.total);\n        break;\n      case 'done':\n        resolve(data.results);\n        worker.terminate();\n        break;\n      case 'error':\n        reject(new Error(data.message));\n        worker.terminate();\n        break;\n      }\n    };\n\n    // Handle any critical errors with the worker itself\n    worker.onerror = (error: ErrorEvent) => {\n      reject(new Error(error.message));\n      worker.terminate();\n    };\n\n    // serialize the puzzle topology and send it to the worker to kick off the process\n    const message: CheckGeometryWorkerInput = {\n      topology: serializeTopology(puzzle),\n    };\n    worker.postMessage(message);\n  });\n}","import type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\nexport const Name: GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\n\n/** Required config for this generator */\nexport interface GridJitterPointGeneratorConfig extends GeneratorConfig {\n  name: GridJitterPointGeneratorName;\n  /** Amount of random jitter (0 to 100) */\n  jitter: number;\n}\n\n/** UI metadata needed for this generator */\nexport const GridJitterPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Grid\",\n  description: \"Generate seed points using a grid with optional random jitter. \" +\n    \"Has a uniform, regular look, especially with low randomness values.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n      helpText: 'Amount of jitter to apply to each grid point (0 to 100%)',\n    },\n  ],\n};\n\n/**\n * A point generator that uses grid + random jitter. `jitter` represents the\n * strength of jitter applied to each point, from 0 (straight grid) to 1\n * (completely random).\n */\nexport const GridJitterPointGeneratorFactory: GeneratorFactory<PointGenerator> = (width: number, height: number, config: GridJitterPointGeneratorConfig) => {\n  const { jitter = 50 } = config;\n\n  const GridJitterPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      const points: Vec2[] = [];\n      // assemble a grid\n      for (let x = 0; x < width; x += pieceSize) {\n        for (let y = 0; y < height; y += pieceSize) {\n          // initial position is the center of each grid cell\n          const point: Vec2 = [x + pieceSize / 2, y + pieceSize / 2];\n          // add random jitter\n          if (jitter > 0) {\n            point[0] += (random() - 0.5) * (jitter / 100) * pieceSize;\n            point[1] += (random() - 0.5) * (jitter / 100)  * pieceSize;\n          }\n          points.push(point);\n        }\n      }\n      return points;\n    },\n  };\n  return GridJitterPointGenerator;\n};\nexport default GridJitterPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, GridJitterPointGeneratorFactory, GridJitterPointUIMetadata);\n","import { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  AABB,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { getUniqueId } from '../../../utils/UniqueId';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\nexport const Name: RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\n\n/** Required config for this generator */\nexport interface RectangularPieceGeneratorConfig extends GeneratorConfig {\n  name: RectangularPieceGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const RectangularPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Rectangular\",\n  description: \"Construct pieces from a regular grid. All pieces have 4 sides \" +\n    \"and are the same size. This generator ignores seed points.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const RectangularPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (width: number, height: number, _config: RectangularPieceGeneratorConfig) => {\n\n  const RectangularPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param _points The seed points. Ignored by this generator.\n     * @param runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(_points: Vec2[], runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n      const { pieceSize } = runtimeOpts;\n\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n      };\n\n      // --- 1. Calculate Grid Dimensions ---\n      // Determine the number of rows and columns based on the desired piece size.\n      const cols = Math.ceil(width / pieceSize);\n      const rows = Math.ceil(height / pieceSize);\n\n      // Calculate the actual width and height of each cell\n      const cellWidth = Math.round(width / cols);\n      const cellHeight = Math.round(height / rows);\n\n      // --- 2. Create Vertices ---\n      // A 2D array to hold all vertex points for easy lookup by grid index.\n      const gridVertices: Vec2[][] = [];\n      for (let r = 0; r <= rows; r++) {\n        const rowVertices: Vec2[] = [];\n        for (let c = 0; c <= cols; c++) {\n          const x = c * cellWidth;\n          const y = r * cellHeight;\n          rowVertices.push([x, y]);\n        }\n        gridVertices.push(rowVertices);\n      }\n      // Flatten the 2D array into the final list for the topology.\n      topology.vertices = gridVertices.flat();\n\n      // --- 3. Create Pieces and Half-Edges ---\n      // This map will help us find the twin of a half-edge. The key is a string\n      // representing the start and end vertices of an edge, e.g., \"x1,y1-x2,y2\".\n      const halfEdgeTwinMap = new Map<string, HalfEdgeID>();\n\n      // NOTE: Using a string key based on floating point coordinates can be very\n      // fragile. Tiny precision errors can cause lookups to fail. This approach\n      // is safe here because the grid coordinates are normalized to integers.\n      // For a generator with less regular vertex points it is more robust to\n      // assign a unique ID to each vertex and use those IDs to build the key,\n      // or to use a helper function to perform an approximate \"epsilon\" comparison.\n\n      // build each piece\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          const pieceId = r * cols + c;\n\n          // Get the four corner vertices for the current piece.\n          const topLeft = gridVertices[r][c];\n          const topRight = gridVertices[r][c + 1];\n          const bottomLeft = gridVertices[r + 1][c];\n          const bottomRight = gridVertices[r + 1][c + 1];\n\n          // Define the four half-edges for this piece in counter-clockwise (CCW) order.\n          const he_top: HalfEdge =    { id: getUniqueId(), origin: topLeft,     twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_right: HalfEdge =  { id: getUniqueId(), origin: topRight,    twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_bottom: HalfEdge = { id: getUniqueId(), origin: bottomRight, twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_left: HalfEdge =   { id: getUniqueId(), origin: bottomLeft,  twin: -1, next: -1, prev: -1, piece: pieceId };\n\n          // Link the half-edges for this piece in a circular loop.\n          he_top.next = he_right.id;\n          he_right.next = he_bottom.id;\n          he_bottom.next = he_left.id;\n          he_left.next = he_top.id;\n\n          he_top.prev = he_left.id;\n          he_left.prev = he_bottom.id;\n          he_bottom.prev = he_right.id;\n          he_right.prev = he_top.id;\n\n          // Add the half-edges to the main topology map.\n          topology.halfEdges.set(he_top.id, he_top);\n          topology.halfEdges.set(he_right.id, he_right);\n          topology.halfEdges.set(he_bottom.id, he_bottom);\n          topology.halfEdges.set(he_left.id, he_left);\n\n          // Create and add the piece to the topology.\n          const piece: Piece = {\n            id: pieceId,\n            site: [ (topLeft[0] + bottomRight[0]) / 2, (topLeft[1] + bottomRight[1]) / 2 ], // Site is the center\n            halfEdge: he_top.id, // Point to any half-edge on its boundary\n            bbox: [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]] as AABB,\n          };\n          topology.pieces.set(pieceId, piece);\n\n          // --- 4. Link Twins and Create Edges ---\n          // An edge is defined by its start and end points. We create a consistent key\n          // to look up potential twins created by neighboring pieces.\n          const key = (p1: Vec2, p2: Vec2) => `${p1[0]},${p1[1]}-${p2[0]},${p2[1]}`;\n\n          const edgesToProcess = [\n            { he: he_top,    p1: topLeft,     p2: topRight,    isBoundary: r === 0 },\n            { he: he_right,  p1: topRight,    p2: bottomRight, isBoundary: c === cols - 1 },\n            { he: he_bottom, p1: bottomRight, p2: bottomLeft,  isBoundary: r === rows - 1 },\n            { he: he_left,   p1: bottomLeft,  p2: topLeft,     isBoundary: c === 0 },\n          ];\n\n          for (const edgeInfo of edgesToProcess) {\n            const twinKey = key(edgeInfo.p2, edgeInfo.p1);\n            const twinId = halfEdgeTwinMap.get(twinKey);\n\n            const edgeId = getUniqueId();\n            let edge: Edge;\n\n            if (twinId !== undefined) {\n              // Found a twin! This is an internal edge.\n              const twinHe = topology.halfEdges.get(twinId)!;\n              edgeInfo.he.twin = twinHe.id;\n              twinHe.twin = edgeInfo.he.id;\n\n              // The half-edge from the neighbor is the \"left\" one, ours is the \"right\".\n              edge = { id: edgeId, heLeft: twinHe.id, heRight: edgeInfo.he.id };\n              halfEdgeTwinMap.delete(twinKey); // Clean up map\n            } else {\n              // No twin found. This could be a boundary edge or its twin hasn't been created yet.\n              // We add it to the map to be found by a future neighbor.\n              const selfKey = key(edgeInfo.p1, edgeInfo.p2);\n              halfEdgeTwinMap.set(selfKey, edgeInfo.he.id);\n\n              // If we know it's on the boundary, create the edge now.\n              if (edgeInfo.isBoundary) {\n                edge = { id: edgeId, heLeft: edgeInfo.he.id, heRight: -1 };\n                topology.boundary.push(edgeId);\n              } else {\n                continue; // It's an internal edge, wait for its twin to create the Edge object.\n              }\n            }\n            topology.edges.set(edgeId, edge);\n          }\n        }\n      }\n\n      return topology;\n    },\n  };\n  return RectangularPieceGenerator;\n};\nexport default RectangularPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, RectangularPieceGeneratorFactory, RectangularPieceGeneratorUIMetadata);\n","import type { TabGenerator, TabGeneratorRuntimeOptions } from \"./TabGenerator\";\nimport type { Edge } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other TabGenerators\ntype NullTabGeneratorName = \"NullTabGenerator\";\nexport const Name: NullTabGeneratorName = \"NullTabGenerator\";\n\n/** This generator doesn't take any special config */\nexport interface NullTabGeneratorConfig extends GeneratorConfig {\n  name: NullTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const NullTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"None\",\n  description: \"Do not generate tabs. All pieces have straight edges.\",\n  sortHint: 3,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/** Tab generator that does nothing, piece edges remain straight lines */\nexport const NullTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number,_config: NullTabGeneratorConfig) => {\n  const NullTabGenerator: TabGenerator = {\n    addTab(_edge: Edge, _runtimeOpts: TabGeneratorRuntimeOptions) {\n      // noop\n    },\n  };\n  return NullTabGenerator;\n};\nexport default NullTabGeneratorFactory;\n\n// register the generator\nTabGeneratorRegistry.register(Name, NullTabGeneratorFactory, NullTabUIMetadata);\n\n","import type { TabGeneratorRuntimeOptions, TabGenerator } from \"./TabGenerator\";\nimport type { CurveTo, Edge, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TriangleTabGeneratorName = \"TriangleTabGenerator\";\nexport const Name: TriangleTabGeneratorName = \"TriangleTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TriangleTabGeneratorConfig extends GeneratorConfig {\n  name: TriangleTabGeneratorName;\n  /** Determines how \"tall\" the tab is relative to the length of the edge as a percent, default 20% */\n  tabHeightRatio?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TriangleTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Triangle\",\n  description: \"Creates a simple triangle between each (internal) piece edge.\",\n  sortHint: 2,\n  // these have to match the config above\n  controls: [\n    {\n      type: 'range',\n      name: 'tabHeightRatio',\n      label: 'Tab Height',\n      optional: true,\n      min: 0,\n      max: 100,\n      step: 1,\n      defaultValue: 20,\n      helpText: 'Determines how \"tall\" the tab is relative to the length of the edge as a percent',\n    },\n  ],\n};\n\n/**\n * A simple TabGenerator that adds a triangular \"nub\" to an edge.\n *\n * This generator serves as a straightforward example of how to implement the\n * TabGenerator interface. It modifies the two half-edges of a given edge,\n * adding a Bézier curve that forms a triangular tab. One half-edge gets an\n * \"outie\" (convex) tab, and its twin gets a corresponding \"innie\" (concave)\n * tab, ensuring the pieces will fit together.\n */\nexport const TriangleTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number,config: TriangleTabGeneratorConfig) => {\n  const { tabHeightRatio = 20 } = config;\n\n  const TriangleTabGenerator: TabGenerator = {\n    addTab(edge: Edge, runtimeOpts: TabGeneratorRuntimeOptions) {\n      const { topology, random } = runtimeOpts;\n\n      // 1. Get the half-edges from the topology.\n      // We need the full objects to modify them.\n      const he1 = topology.halfEdges.get(edge.heLeft);\n      const he2 = topology.halfEdges.get(edge.heRight);\n\n      // Ensure both half-edges exist (which they should for an internal edge).\n      if (!he1 || !he2) {\n        console.warn(\"Could not find half-edges for a given internal edge:\", edge.id);\n        return;\n      }\n\n      // 2. Define the edge's start and end points.\n      // The edge for he1 goes from p0 -> p3.\n      // The twin edge (he2) goes from p3 -> p0.\n      const p0 = he1.origin;\n      const p3 = he2.origin;\n\n      // 3. Calculate edge vectors and properties.\n      const edgeVector: Vec2 = [p3[0] - p0[0], p3[1] - p0[1]];\n      const edgeLength = Math.sqrt(edgeVector[0] ** 2 + edgeVector[1] ** 2);\n      if (edgeLength < 1e-6) return; // Avoid creating tabs on zero-length edges.\n\n      // Calculate a perpendicular vector (normal) to the edge.\n      // The direction of this normal is consistent relative to he1.\n      const edgeDir: Vec2 = [edgeVector[0] / edgeLength, edgeVector[1] / edgeLength];\n      const normalDir: Vec2 = [-edgeDir[1], edgeDir[0]];\n\n      // 4. Calculate the position of the tab's peak.\n      // Find the midpoint of the edge.\n      const midPoint: Vec2 = [p0[0] + edgeVector[0] / 2, p0[1] + edgeVector[1] / 2];\n\n      // Randomly decide if the tab goes \"out\" or \"in\" for he1.\n      const direction = random() > 0.5 ? 1 : -1;\n      const tabHeight = edgeLength * (tabHeightRatio / 100) * direction;\n\n      // Calculate the nub point by moving from the midpoint along the normal.\n      const nubPoint: Vec2 = [\n        midPoint[0] + normalDir[0] * tabHeight,\n        midPoint[1] + normalDir[1] * tabHeight,\n      ];\n\n      // 5. Create the Bézier curve for he1's tab.\n      // We create a \"sharp\" triangular point by setting both control points\n      // to be the same as the nub's peak. This creates two straight lines\n      // (p0 -> nubPoint -> p3) and is a simple way to represent a triangle\n      // with the CubicBezier interface.\n      const tab1: CurveTo = {\n        type: 'bezier',\n        p1: nubPoint,\n        p2: nubPoint,\n        p3: p3,\n      };\n\n      // 6. Create the corresponding inverse tab for the twin half-edge (he2).\n      // The start and end points are swapped, and the nub is on the opposite side.\n      const nubPointTwin: Vec2 = [\n        midPoint[0] - normalDir[0] * tabHeight, // Invert the nub direction\n        midPoint[1] - normalDir[1] * tabHeight,\n      ];\n      const tab2: CurveTo = {\n        type: 'bezier',\n        p1: nubPointTwin,\n        p2: nubPointTwin,\n        p3: p0,\n      };\n\n      // 7. Attach the generated tabs to the half-edge objects in the topology.\n      he1.segments = [tab1];\n      he2.segments = [tab2];\n    },\n  };\n  return TriangleTabGenerator;\n};\nexport default TriangleTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TriangleTabGeneratorFactory, TriangleTabUIMetadata);\n","// component that renders single page application for generating puzzles\nimport m from 'mithril';\n\n// UI parts\nimport GitHubCorner from './ui/GitHubCorner';\nimport Puzzle from './ui/Puzzle';\nimport DownloadPuzzleButton from './ui/DownloadPuzzleButton';\nimport GeometryCheckIndicator from './ui/GeometryCheckIndicator';\nimport UploadImageButton from './ui/UploadImageButton';\nimport GeneratorPicker from './ui/GeneratorPicker';\nimport NumberInputControl from './ui/inputs/NumberInputControl';\nimport AspectRatioPicker from './ui/AspectRatioPicker';\nimport ColorPicker from './ui/ColorPicker';\n\n// geometry parts\nimport type { PuzzleGeometry } from './geometry/types';\nimport type { GeneratorConfig, GeneratorName, GeneratorRegistry } from './geometry/generators/Generator';\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabGeneratorRegistry } from './geometry/generators/Generator';\nimport { Name as PoissonGeneratorName } from './geometry/generators/point/PoissonPointGenerator';\nimport { Name as VoronoiGeneratorName } from './geometry/generators/piece/VoronoiPieceGenerator';\nimport { Name as TraditionalTabGeneratorName } from './geometry/generators/tab/TraditionalTabGenerator';\nimport { buildPuzzle } from './geometry/PuzzleMaker';\nimport { checkGeometryInWorker } from './geometry/GeometryChecker';\n\n// register generators\nimport \"./geometry/generators/point/GridJitterPointGenerator\";\nimport \"./geometry/generators/point/PoissonPointGenerator\";\nimport \"./geometry/generators/piece/VoronoiPieceGenerator\";\nimport \"./geometry/generators/piece/RectangularPieceGenerator\";\nimport \"./geometry/generators/tab/NullTabGenerator\";\nimport \"./geometry/generators/tab/TriangleTabGenerator\";\nimport \"./geometry/generators/tab/TraditionalTabGenerator\";\n\n// Shoelace components\nimport { registerIconLibrary } from '@shoelace-style/shoelace/dist/utilities/icon-library.js';\nimport '@shoelace-style/shoelace/dist/themes/light.css';\nimport '@shoelace-style/shoelace/dist/themes/dark.css';\n\n// CSS for this component\nimport './index.css';\n\n// component that draws the page\nconst Page: m.ClosureComponent<unknown> = () => {\n\n  const defaultWidth = 800;\n  const defaultHeight = 600;\n\n  const defaultPointGenerator = PoissonGeneratorName;\n  const defaultPieceGenerator = VoronoiGeneratorName;\n  const defaultTabGenerator = TraditionalTabGeneratorName;\n\n  /** State tracked for each type of generator */\n  interface GeneratorState<C extends GeneratorConfig = GeneratorConfig> {\n    label: string;\n    registry: GeneratorRegistry<unknown>;\n    name : GeneratorName;\n    config: C;\n  }\n\n  interface PageState {\n    /** Random seed */\n    seed: number;\n    /** Width of canvas in pixels */\n    canvasWidth: number;\n    /** Height of canvas in pixels */\n    canvasHeight: number;\n    /** Aspect ratio of canvas, width/height */\n    aspectRatio: number;\n    /** Minimum distance between control points (pixels) */\n    distance: number;\n    /** Color of pieces */\n    color: string;\n    /** Problems found by the geometry check algorithms */\n    geometryProblems: {\n      /** If true, the geometry will be re-checked whenever a new puzzle is generated */\n      autoCheck: boolean;\n      /** Count of problems found in the last check */\n      problems?: number;\n      /** Percent complete of in-progress geometry check */\n      progress?: number;\n    },\n    /** Dirty flag that keeps us from hitting the puzzle generation function too hard */\n    dirty: boolean;\n    /** Currently selected and configured generators for each part of puzzle generation */\n    generators: Record<string, GeneratorState>;\n    /** Generated puzzle geometry */\n    puzzle?: PuzzleGeometry;\n    /** User uploaded image */\n    backgroundImageUrl?: string;\n    /** Name of uploaded image */\n    backgroundImageName: string;\n  };\n\n  // component state\n  const state: PageState = {\n    seed: new Date().getTime() % 10240,\n    canvasWidth: defaultWidth,\n    canvasHeight: defaultHeight,\n    aspectRatio: defaultWidth / defaultHeight,\n    distance: 40,\n    color: \"#333333\",\n    geometryProblems: {\n      autoCheck: false,\n      problems: undefined,\n      progress: undefined,\n    },\n    dirty: true,\n    generators: {\n      /** Strategy for creating points (which influences piece generation) */\n      point: {\n        label: \"Seed Points\",\n        registry: PointGeneratorRegistry,\n        name: defaultPointGenerator,\n        config: PointGeneratorRegistry.getDefaultConfig(defaultPointGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for turning points into puzzle pieces */\n      piece: {\n        label: \"Piece Generation\",\n        registry: PieceGeneratorRegistry,\n        name: defaultPieceGenerator,\n        config: PieceGeneratorRegistry.getDefaultConfig(defaultPieceGenerator, defaultWidth, defaultHeight),\n      },\n      /** Style of tabs to generate */\n      tab: {\n        label: \"Tabs\",\n        registry: TabGeneratorRegistry,\n        name: defaultTabGenerator,\n        config: TabGeneratorRegistry.getDefaultConfig(defaultTabGenerator, defaultWidth, defaultHeight),\n      },\n    },\n    puzzle: undefined,\n    backgroundImageUrl: undefined,\n    backgroundImageName: '',\n  };\n\n  // utility to invoke the geometry checks\n  function handleCheckGeometry() {\n    if (!state.puzzle) return;\n\n    state.geometryProblems.progress = 0;\n    m.redraw();\n\n    // this uses a web worker to not block the main thread\n    checkGeometryInWorker(state.puzzle, (processed, total) => {\n      state.geometryProblems.progress = (processed / total) * 100;\n      m.redraw();\n    }).then((problems) => {\n      state.geometryProblems.problems = problems.length;\n      state.geometryProblems.progress = undefined;\n      if (state.puzzle) {\n        state.puzzle.problems = problems;\n      }\n      m.redraw();\n    }).catch((err) => {\n      state.geometryProblems.progress = undefined;\n      console.error(err);\n      m.redraw();\n    });\n  }\n\n  // Mithril component\n  return {\n\n    oncreate: () => {\n      buildPuzzle({\n        width: state.canvasWidth,\n        height: state.canvasHeight,\n        pieceSize: state.distance,\n        pointConfig: state.generators.point.config,\n        pieceConfig: state.generators.piece.config,\n        tabConfig: state.generators.tab.config,\n        seed: state.seed,\n      }).then((puzzle) => {\n        state.puzzle = puzzle;\n        m.redraw();\n        if (state.geometryProblems.autoCheck) {\n          handleCheckGeometry();\n        }\n      }).catch((err) => {\n        console.error(err);\n      });\n    },\n\n    onupdate: () => {\n      if (state.dirty) {\n        state.dirty = false;\n        // rebuild the puzzle geometry\n        buildPuzzle({\n          width: state.canvasWidth,\n          height: state.canvasHeight,\n          pieceSize: state.distance,\n          pointConfig: state.generators.point.config,\n          pieceConfig: state.generators.piece.config,\n          tabConfig: state.generators.tab.config,\n          seed: state.seed,\n        }).then((puzzle) => {\n          state.geometryProblems.problems = undefined;\n          state.geometryProblems.progress = undefined;\n          state.puzzle = puzzle;\n          m.redraw();\n          if (state.geometryProblems.autoCheck) {\n            handleCheckGeometry();\n          }\n        }).catch((err) => {\n          console.error(err);\n        });\n      }\n    },\n\n    onremove: () => {\n      if (state.backgroundImageUrl) {\n        // clean up memory\n        URL.revokeObjectURL(state.backgroundImageUrl);\n        state.backgroundImageUrl = undefined;\n      }\n    },\n\n    // component lifecycle: render our output\n    view: () => {\n\n      return m(\".page\", [\n        m(GitHubCorner, {\n          link: \"https://github.com/weevilgenius/puzzle-generator\",\n        }),\n        m(\"h1\", \"Puzzle Generator\"),\n        m(\".container\", [\n\n          state.puzzle && m('.puzzle-stack', [\n\n            // main puzzle display\n            m(Puzzle, {\n              width: state.canvasWidth,\n              height: state.canvasHeight,\n              color: state.color,\n              imageUrl: state.backgroundImageUrl,\n              puzzle: state.puzzle,\n              isDirty: state.dirty,\n            }),\n\n            m('.actions', [\n\n              // SVG download button\n              m(DownloadPuzzleButton, {\n                puzzle: state.puzzle,\n                width: state.canvasWidth,\n                height: state.canvasHeight,\n                color: state.color,\n              }),\n\n              // Geometry check display\n              m(GeometryCheckIndicator, {\n                autoCheck: state.geometryProblems.autoCheck,\n                problems: state.geometryProblems.problems,\n                progressPercent: state.geometryProblems.progress,\n                onCheckRequested: () => {\n                  if (!state.dirty) {\n                    handleCheckGeometry();\n                  }\n                  m.redraw();\n                },\n                onAutocheckChanged: (autocheck) => {\n                  if (autocheck !== state.geometryProblems.autoCheck) {\n                    state.geometryProblems.autoCheck = autocheck;\n                    m.redraw();\n                  }\n                },\n              }),\n\n            ]),\n          ]),\n\n          // puzzle generation controls\n          m(\".controls\", [\n\n            // background image\n            m('.background-image', [\n              m(UploadImageButton, {\n                label: \"Background Image\",\n                onUpload: (imageUrl, filename, width, height) => {\n                  // clear any previous image\n                  if (state.backgroundImageUrl) {\n                    URL.revokeObjectURL(state.backgroundImageUrl);\n                  }\n                  state.canvasWidth = width;\n                  state.canvasHeight = height;\n                  state.aspectRatio = width / height;\n                  state.backgroundImageUrl = imageUrl;\n                  state.backgroundImageName = filename;\n                  state.dirty = true;\n                  m.redraw();\n                },\n              }),\n              m('span.background-image-label', state.backgroundImageName),\n            ]),\n\n            // Puzzle aspect ratio\n            m(AspectRatioPicker, {\n              ratio: state.aspectRatio,\n              disabled: state.backgroundImageUrl !== undefined,\n              onChange: (ratio) => {\n                state.aspectRatio = ratio;\n                state.canvasWidth = state.canvasHeight * ratio;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Random number seed\n            m(NumberInputControl, {\n              config: {\n                name: 'seed',\n                label: 'Seed',\n                type: 'number',\n              },\n              value: state.seed,\n              onChange: (value) => {\n                state.seed = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece size\n            m(NumberInputControl, {\n              config: {\n                name: 'pieceSize',\n                label: 'Piece size',\n                type: 'number',\n              },\n              value: state.distance,\n              onChange: (value) => {\n                state.distance = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece color\n            m(ColorPicker, {\n              label: 'Piece color',\n              color: state.color,\n              size: \"small\",\n              onUpdate: (newColor) => {\n                state.color = newColor;\n                m.redraw();\n              },\n            }),\n\n            // render a generator picker for each type of generator\n            ...Object.entries(state.generators).map(([type, generator]) => {\n              return m(\"label\", [\n                generator.label + ':',\n                m(GeneratorPicker, {\n                  generator: generator.name,\n                  registry: generator.registry,\n                  config: generator.config,\n                  onGeneratorChange: (generatorName) => {\n                    if (generatorName != generator.name) {\n                      console.log(`${type} generator changed to ${generatorName}`);\n                      generator.name = generatorName;\n                      // generator changed, we need a new blank config\n                      state.generators[type].config = generator.registry.getDefaultConfig(generatorName, state.canvasWidth, state.canvasHeight);\n                      state.dirty = true;\n                      m.redraw();\n                    }\n                  },\n                  onConfigChange: (key, value) => {\n                    console.log(`${type} generator config \"${key}\" changed to ${String(value)}`);\n                    generator.config[key] = value;\n                    state.dirty = true;\n                    m.redraw();\n                  },\n                }),\n              ]);\n            }),\n\n          ]), // .controls\n\n        ]), // .container\n\n      ]);\n    }, // view()\n  };\n};\n\n// configure Shoelace icons to use Material Symbols\nregisterIconLibrary('material', {\n  resolver: (name) => {\n    const match = name.match(/^(.*?)(_(rounded|sharp))?$/);\n    if (match) {\n      return `https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${match[3] ?? 'outlined'}/${match[1]}.svg`;\n    }\n    return '';\n  },\n});\n\n// Ask Mithril to render the page, our componet gets placed into the root element.\n// Mithril will rerender automatically after DOM event handlers defined in component\n// views and also whenever m.redraw() is called.\nm.mount(document.body, Page);\n"],"names":["GitHubCorner","attrs","m","GeneratorRegistry","name","factory","uiMetadata","width","height","config","generator","a","b","g","newConfig","metadata","control","PointGeneratorRegistry","PieceGeneratorRegistry","TabGeneratorRegistry","mulberry32","seed","t","buildPuzzle","options","pieceSize","pointConfig","pieceConfig","tabConfig","pointGenerator","pieceGenerator","tabGenerator","random","points","topology","edge","drawPuzzle","puzzle","canvas","pieceColor","showPoints","ctx","he","segment","destination","problemPoint","x","y","piece","Puzzle","state","dom","createSVG","pathData","pathD","downloadSvg","svg","filename","blob","url","DownloadPuzzleButton","GeometryCheckIndicator","showProgress","showOKBadge","showProblemBadge","e","checkbox","calculateDisplayDimensions","originalWidth","originalHeight","maxWidth","aspectRatio","UploadImageButton","file","bitmap","uploadUrl","err","BooleanInputControl","newValue","NumberInputControl","RangeInputControl","StringInputControl","GeneratorPicker","generators","newSelected","tab","panel","value","commonAspectRatios","AspectRatioPicker","isCustom","selectOptions","ratioStr","selectedValue","range","ColorPicker","input","tinyNDArrayOfInteger","gridShape","dimensions","totalLength","stride","dimension","tinyNDArrayOfArray","data","index","tinyNdarray","sphereRandom","sampleSphere","d","rng","v","d2","r2","rr","r","theta","i","moore","size","length","neighbors","neighbor","require$$0","getNeighbourhood","dimensionNumber","neighbourhood","origin","n","dist","n1","n2","squareDist1","squareDist2","neighbourhoodCache","getNeighbourhoodMemoized","tinyNDArray","require$$1","require$$2","squaredEuclideanDistance","point1","point2","result","FixedDensityPDS","maxShape","floatPrecisionMitigation","epsilonDistance","point","valid","internalArrayIndex","neighbourIndex","currentDimensionValue","existingPoint","tries","angle","distance","currentPoint","newPoint","inShape","gridData","fixedDensity","euclideanDistance","VariableDensityPDS","pointIndex","existingPointDistance","pointDistance","minDistance","maxDistance","currentDistance","sampleIndex","variableDensity","PoissonDiskSampling","poissonDiskSampling","Name","PoissonPointUIMetadata","PoissonPointGeneratorFactory","_width","_height","_config","runtimeOpts","epsilon","splitter","resulterrbound","sum","elen","flen","f","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","EPSILON","EDGE_STACK","Delaunator","getX","defaultGetX","getY","defaultGetY","coords","p","maxTriangles","hullPrev","hullNext","hullTri","hullHash","minX","minY","maxX","maxY","i0","i1","i2","minDist","i0x","i0y","i1x","i1y","minRadius","circumradius","i2x","i2y","quicksort","hull","j","d0","id","center","circumcenter","hullSize","k","xp","yp","start","key","q","pseudoAngle","triangles","halfedges","ar","a0","b0","al","bl","p0","pr","pl","p1","inCircle","hbl","br","dx","dy","px","py","ex","ey","fx","fy","ap","bp","cp","cl","ids","dists","left","right","temp","tempDist","median","swap","arr","tmp","Path","x0","y0","w","Polygon","Voronoi","delaunay","xmin","ymin","xmax","ymax","vectors","circumcenters","t2","t3","x1","y1","x2","y2","x3","y3","ab","context","buffer","inedges","ti","tj","xi","yi","xj","yj","h0","h1","cell","polygon","S","c0","c1","ci","cj","loop","ai","li","aj","lj","e0","V","P","e1","sx0","sy0","sx1","sy1","flip","vx0","vy0","vxn","vyn","vx","vy","tau","pow","pointX","pointY","collinear","jitter","Delaunay","that","flatArray","flatIterable","_","bounds","hullIndex","_hullIndex","l","dc","dt","array","getUniqueId","VoronoiPieceGeneratorUIMetadata","calculateBoundingBox","linkPieceHalfEdges","map","len","pointToKey","arePointsEqual","p2","VoronoiPieceGeneratorFactory","_runtimeOpts","voronoi","halfEdgeEndpointMap","site","pieceHalfEdgeIds","he1","he1_next","keyForTwin","twinId","edgeId","he2","vertexSet","TraditionalTabUIMetadata","createTraditionalTab","sizePct","jitterPct","inward","maxTabSize","ux","uy","s","A","C","E","dir","bez1","bez2","bez3","invertCurve","newEndPoint","TraditionalTabGeneratorFactory","minTabSize","he1IsInward","he1Segments","he2Segments","currentSegment","originOfOriginal","serializeTopology","checkGeometryInWorker","onProgress","resolve","reject","worker","CheckGeometryWorker","event","error","message","GridJitterPointUIMetadata","GridJitterPointGeneratorFactory","RectangularPieceGeneratorUIMetadata","RectangularPieceGeneratorFactory","_points","cols","rows","cellWidth","cellHeight","gridVertices","rowVertices","halfEdgeTwinMap","pieceId","topLeft","topRight","bottomLeft","bottomRight","he_top","he_right","he_bottom","he_left","edgesToProcess","edgeInfo","twinKey","twinHe","selfKey","NullTabUIMetadata","NullTabGeneratorFactory","_edge","TriangleTabUIMetadata","TriangleTabGeneratorFactory","tabHeightRatio","p3","edgeVector","edgeLength","edgeDir","normalDir","midPoint","direction","tabHeight","nubPoint","tab1","nubPointTwin","tab2","Page","defaultPointGenerator","PoissonGeneratorName","defaultPieceGenerator","VoronoiGeneratorName","defaultTabGenerator","TraditionalTabGeneratorName","handleCheckGeometry","processed","total","problems","autocheck","imageUrl","ratio","newColor","type","generatorName","registerIconLibrary","match"],"mappings":"oyBAcO,MAAMA,GAAwD,CAEnE,KAAM,CAAC,CAAE,MAAAC,KAEAC,EAAE,kBAAmB,CAC1B,KAAMD,EAAM,KACZ,aAAc,wBACd,MAAO,wBACP,OAAQ,QAAA,EACPC,EAAE,MAAO,CACV,MAAO,GACP,OAAQ,GACR,QAAS,cACT,cAAe,MAAA,EACd,CACDA,EAAE,OAAQ,CACR,EAAG,mDAAA,CACJ,EACDA,EAAE,gBAAiB,CACjB,KAAM,eACN,MAAO,iCACP,EAAG,0LAAA,CACJ,EACDA,EAAE,iBAAkB,CAClB,KAAM,eACN,EAAG,qhBAAA,CACJ,CAAA,CACF,CAAC,CAGN,ECbO,MAAMC,EAAqB,CACxB,eAAiB,IASlB,SAASC,EAAqBC,EAA8BC,EAAuC,CACpG,KAAK,WAAW,IAAIF,CAAI,GAC1B,QAAQ,KAAK,cAAcA,CAAI,sCAAsC,EAEvE,KAAK,WAAW,IAAIA,EAAM,CAAE,QAAAC,EAAS,WAAAC,EAAY,CACnD,CAQO,OAAOC,EAAeC,EAAgBC,EAA4B,CACvE,MAAMC,EAAY,KAAK,WAAW,IAAID,EAAO,IAAI,EACjD,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,sBAAsBD,EAAO,IAAI,sBAAsB,EAEzE,OAAOC,EAAU,QAAQH,EAAOC,EAAQC,CAAM,CAChD,CAMO,wBAAyE,CAC9E,OAAO,MAAM,KAAK,KAAK,WAAW,QAAQ,EACvC,KAAK,CAACE,EAAGC,IAAMD,EAAE,WAAW,SAAWC,EAAE,WAAW,QAAQ,EAC5D,IAAKC,IAAO,CACX,KAAMA,EAAE,WAAW,KACnB,YAAaA,EAAE,WAAW,WAAA,EAC1B,CACN,CAOO,cAAcT,EAAsD,CACzE,OAAO,KAAK,WAAW,IAAIA,CAAI,GAAG,UACpC,CASO,iBAAiBA,EAAqBG,EAAeC,EAAiC,CAC3F,MAAMM,EAA6B,CACjC,KAAAV,EACA,MAAAG,EACA,OAAAC,CAAA,EAGIO,EAAW,KAAK,cAAcX,CAAI,EACxC,GAAIW,EACF,UAAWC,KAAWD,EAAS,SAC7BD,EAAUE,EAAQ,IAAI,EAAIA,EAAQ,aAItC,OAAOF,CACT,CACF,CAQO,MAAMG,EAAyB,IAAId,GAI7Be,EAAyB,IAAIf,GAI7BgB,EAAuB,IAAIhB,GCnHjC,SAASiB,GAAWC,EAAc,CACvC,OAAO,UAAW,CAChB,IAAIC,EAAID,GAAQ,WAChB,OAAAC,EAAI,KAAK,KAAKA,EAAIA,IAAM,GAAIA,EAAI,CAAC,EACjCA,GAAKA,EAAI,KAAK,KAAKA,EAAIA,IAAM,EAAGA,EAAI,EAAE,IAC7BA,EAAIA,IAAM,MAAQ,GAAK,UAClC,CACF,CCcA,eAAsBC,GAAYC,EAA2D,CAC3F,KAAM,CAAE,MAAAjB,EAAO,OAAAC,EAAQ,UAAAiB,CAAA,EAAcD,EAC/B,CAAE,YAAAE,EAAa,YAAAC,EAAa,UAAAC,CAAA,EAAcJ,EAEhD,QAAQ,IAAI,qCAAqCjB,CAAK,IAAIC,CAAM,gBAAgBiB,CAAS,EAAE,EAG3F,MAAMI,EAAiBZ,EAAuB,OAAOV,EAAOC,EAAQkB,CAAW,EACzEI,EAAiBZ,EAAuB,OAAOX,EAAOC,EAAQmB,CAAW,EACzEI,EAAeZ,EAAqB,OAAOZ,EAAOC,EAAQoB,CAAS,EAGnEP,EAAOG,EAAQ,MAAQ,IAAI,KAAA,EAAO,QAAA,EAClCQ,EAASZ,GAAWC,CAAI,EAGxBY,EAASJ,EAAe,eAAe,CAAE,MAAAtB,EAAO,OAAAC,EAAQ,UAAAiB,EAAW,OAAAO,EAAQ,EACjF,QAAQ,IAAI,aAAaC,EAAO,MAAM,SAAS,EAG/C,MAAMC,EAAWJ,EAAe,eAAeG,EAAQ,CAAE,OAAAD,EAAQ,UAAAP,EAAW,EAC5E,QAAQ,IAAI,aAAaS,EAAS,OAAO,IAAI,SAAS,EAGtD,UAAWC,KAAQD,EAAS,MAAM,OAAA,EAEbC,EAAK,UAAY,IAElCJ,EAAa,OAAOI,EAAM,CAAE,SAAAD,EAAU,OAAAF,EAAQ,EAiBlD,MAZ+B,CAC7B,QAAS,IAAI,KAAA,EAAO,YAAA,EACpB,KAAAX,EACA,MAAAd,EACA,OAAAC,EACA,SAAU0B,EAAS,SACnB,SAAUA,EAAS,SACnB,OAAQA,EAAS,OACjB,MAAOA,EAAS,MAChB,UAAWA,EAAS,SAAA,CAIxB,CAGO,SAASE,GAAWC,EAAwBC,EAA2BC,EAAoBC,EAAa,GAAO,CACpH,MAAMC,EAAMH,EAAO,WAAW,IAAI,EAClC,GAAI,CAACG,EAAK,CACR,QAAQ,MAAM,sCAAsC,EACpD,MACF,CAEAA,EAAI,UAAU,EAAG,EAAGH,EAAO,MAAOA,EAAO,MAAM,EA2DxC,CAILG,EAAI,YAAcF,EAClBE,EAAI,UAAY,EAGhBA,EAAI,UAAA,EAIJ,UAAWN,KAAQE,EAAO,MAAM,OAAA,EAAU,CAGxC,MAAMK,EAAKL,EAAO,UAAU,IAAIF,EAAK,MAAM,EAC3C,GAAKO,EAKL,GAFAD,EAAI,OAAOC,EAAG,OAAO,CAAC,EAAGA,EAAG,OAAO,CAAC,CAAC,EAEjCA,EAAG,SAEL,UAAWC,KAAWD,EAAG,SACvB,OAAQC,EAAQ,KAAA,CAChB,IAAK,SACHF,EAAI,cACFE,EAAQ,GAAG,CAAC,EAAGA,EAAQ,GAAG,CAAC,EAC3BA,EAAQ,GAAG,CAAC,EAAGA,EAAQ,GAAG,CAAC,EAC3BA,EAAQ,GAAG,CAAC,EAAGA,EAAQ,GAAG,CAAC,CAAA,EAE7B,MACF,IAAK,OACHF,EAAI,OAAOE,EAAQ,EAAE,CAAC,EAAGA,EAAQ,EAAE,CAAC,CAAC,EACrC,KAAA,KAGC,CAKL,IAAIC,EAEAF,EAAG,OAAS,GAEdE,EADeP,EAAO,UAAU,IAAIK,EAAG,IAAI,EACtB,OAIrBE,EADeP,EAAO,UAAU,IAAIK,EAAG,IAAI,EACtB,OAEvBD,EAAI,OAAOG,EAAY,CAAC,EAAGA,EAAY,CAAC,CAAC,CAC3C,CACF,CAGAH,EAAI,OAAA,CACN,CAGA,GAAIJ,EAAO,UAAYA,EAAO,SAAS,OAAS,EAAG,CACjDI,EAAI,UAAY,EAChBA,EAAI,YAAc,MAClB,UAAWI,KAAgBR,EAAO,SAAU,CAC1C,KAAM,CAACS,EAAGC,CAAC,EAAIF,EACfJ,EAAI,UAAA,EACJA,EAAI,IAAIK,EAAGC,EAAG,EAAG,EAAG,EAAI,KAAK,EAAE,EAC/BN,EAAI,OAAA,CACN,CACF,CAGA,GAAID,EAAY,CACdC,EAAI,UAAY,OAChB,UAAWO,KAASX,EAAO,OAAO,OAAA,EAAU,CAC1C,KAAM,CAACS,EAAGC,CAAC,EAAIC,EAAM,KACrBP,EAAI,UAAA,EACJA,EAAI,IAAIK,EAAGC,EAAG,EAAG,EAAG,EAAI,KAAK,EAAE,EAC/BN,EAAI,KAAA,CACN,CACF,CACF,CC1MO,MAAMQ,GAA0C,IAAM,CAG3D,MAAMC,EAAQ,CAEZ,OAAQ,IAAA,EAGV,MAAO,CAEL,SAAU,CAAC,CAAE,IAAAC,EAAK,MAAAlD,KAAY,CAE5B,GADAiD,EAAM,OAASC,EAAI,cAAiC,eAAe,EAC/D,CAACD,EAAM,OAAQ,CACjB,QAAQ,IAAI,6BAA8B,EAC1C,MACF,CACKjD,EAAM,SACTmC,GAAWnC,EAAM,OAAQiD,EAAM,OAAQjD,EAAM,KAAK,CAEtD,EAEA,SAAU,CAAC,CAAE,MAAAA,KAAY,CACvB,GAAI,CAACiD,EAAM,OAAQ,CACjB,QAAQ,IAAI,6BAA8B,EAC1C,MACF,CACKjD,EAAM,SACTmC,GAAWnC,EAAM,OAAQiD,EAAM,OAAQjD,EAAM,KAAK,CAEtD,EAGA,KAAM,CAAC,CAAE,MAAAA,KAEAC,EAAE,gBAAiB,CAExBA,EAAE,iBAAkB,CAClB,MAAOD,EAAM,MACb,OAAQA,EAAM,OACd,IAAKA,EAAM,QAAA,CACZ,EAEDC,EAAE,gBAAiB,CACjB,MAAOD,EAAM,MACb,OAAQA,EAAM,OACd,MAAO,CACL,MAAO,GAAGA,EAAM,KAAK,KACrB,OAAQ,GAAGA,EAAM,MAAM,IAAA,CACzB,CACD,CAAA,CACF,CACH,CAGJ,ECnEO,SAASmD,GAAUlB,EAA0B3B,EAAeC,EAAgB+B,EAAa,QAAiB,CAK/G,MAAMc,EAAqB,CAAA,EAG3B,UAAWlB,KAAQD,EAAS,MAAM,OAAA,EAAU,CAC1C,MAAMQ,EAAKR,EAAS,UAAU,IAAIC,EAAK,MAAM,EAC7C,GAAKO,EAKL,GAFAW,EAAS,KAAK,KAAKX,EAAG,OAAO,CAAC,EAAE,QAAQ,CAAe,CAAC,IAAIA,EAAG,OAAO,CAAC,EAAE,QAAQ,CAAe,CAAC,EAAE,EAE/FA,EAAG,SAEL,UAAWC,KAAWD,EAAG,SACvB,OAAQC,EAAQ,KAAA,CAChB,IAAK,SAEHU,EAAS,KACP,KAAKV,EAAQ,GAAG,CAAC,EAAE,QAAQ,CAAe,CAAC,IAAIA,EAAQ,GAAG,CAAC,EAAE,QAAQ,CAAe,CAAC,KAClFA,EAAQ,GAAG,CAAC,EAAE,QAAQ,CAAe,CAAC,IAAIA,EAAQ,GAAG,CAAC,EAAE,QAAQ,CAAe,CAAC,KAChFA,EAAQ,GAAG,CAAC,EAAE,QAAQ,CAAe,CAAC,IAAIA,EAAQ,GAAG,CAAC,EAAE,QAAQ,CAAe,CAAC,EAAA,EAErF,MACF,IAAK,OAEHU,EAAS,KAAK,KAAKV,EAAQ,EAAE,CAAC,EAAE,QAAQ,CAAe,CAAC,IAAIA,EAAQ,EAAE,CAAC,EAAE,QAAQ,CAAe,CAAC,EAAE,EACnG,KAAA,KAGC,CAEL,IAAIC,EACAF,EAAG,OAAS,GAGdE,EADeV,EAAS,UAAU,IAAIQ,EAAG,IAAI,EACxB,OAIrBE,EADeV,EAAS,UAAU,IAAIQ,EAAG,IAAI,EACxB,OAEvBW,EAAS,KAAK,KAAKT,EAAY,CAAC,EAAE,QAAQ,CAAe,CAAC,IAAIA,EAAY,CAAC,EAAE,QAAQ,CAAe,CAAC,EAAE,CACzG,CACF,CAGA,MAAMU,EAAQD,EAAS,KAAK,GAAG,EA2B/B,MArBkB;AAAA;AAAA;AAAA;AAAA,WAIT9C,CAAK;AAAA,YACJC,CAAM;AAAA,iBACDD,CAAK,IAAIC,CAAM;AAAA;AAAA;AAAA;AAAA;AAAA,SAKvB8C,CAAK;AAAA;AAAA,cAEAf,CAAU;AAAA;AAAA;AAAA;AAAA,QAKnB,KAAA,EACA,QAAQ,QAAS;AAAA,CAAI,CAG1B,CAQO,SAASgB,GAAYC,EAAaC,EAAW,aAAc,CAEhE,MAAMC,EAAO,IAAI,KAAK,CAACF,CAAG,EAAG,CAAE,KAAM,gBAAiB,EAGhDG,EAAM,IAAI,gBAAgBD,CAAI,EAG9B/C,EAAI,SAAS,cAAc,GAAG,EACpCA,EAAE,KAAOgD,EACThD,EAAE,SAAW8C,EACb9C,EAAE,OAAS,GAGX,SAAS,KAAK,YAAYA,CAAC,EAC3BA,EAAE,MAAA,EACF,SAAS,KAAK,YAAYA,CAAC,EAG3B,WAAW,IAAM,IAAI,gBAAgBgD,CAAG,EAAG,GAAG,CAChD,CChGO,MAAMC,GAA+D,CAC1E,KAAM,CAAC,CAAE,MAAA3D,KACAC,EAAE,yBAA0B,CACjC,QAAS,IAAM,CAEb,MAAMsD,EAAMJ,GAAUnD,EAAM,OAAQA,EAAM,MAAOA,EAAM,OAAQA,EAAM,KAAK,EAE1EsD,GAAYC,EAAKvD,EAAM,UAAY,YAAY,CACjD,CAAA,EACC,cAAc,CAErB,ECFa4D,GAAmE,CAC9E,KAAM,CAAC,CAAE,MAAA5D,KAAY,CACnB,MAAM6D,EAAe7D,EAAM,kBAAoB,QAAaA,EAAM,gBAAkB,IAC9E8D,EAAc,CAACD,GAAgB7D,EAAM,WAAa,QAAaA,EAAM,UAAY,EACjF+D,EAAmB,CAACF,GAAgB7D,EAAM,WAAa,QAAaA,EAAM,SAAW,EAE3F,eAAQ,IAAI,mBAAmB6D,CAAY,oBAAoBC,CAAW,yBAAyBC,CAAgB,EAAE,EAE9G9D,EAAE,4BAA6B,CAGpCA,EAAE,SAAU,iBAAiB,EAG7BA,EAAE,aAAc,CAAE,QAAS,oBAAA,EACzBA,EAAE,2BAA4B,CAC5B,QAAS,WACT,KAAM,gBACN,MAAO,qBACP,SAAU4D,EACV,QAAUG,GAAgC,CACxCA,EAAE,OAAS,GACXhE,EAAM,mBAAA,CACR,CAAA,CACD,CAAA,EAIHC,EAAE,aAAc,CAAE,QAAS,mCAAA,EACzBA,EAAE,cAAe,CACf,QAASD,EAAM,UACf,SAAU6D,EACV,KAAM,QACN,cAAgBG,GAAgC,CAC9CA,EAAE,OAAS,GACX,MAAMC,EAAWD,EAAE,OACnBhE,EAAM,qBAAqBiE,EAAS,OAAO,CAC7C,CAAA,EACC,YAAY,CAAA,EAIjBJ,GAAgB5D,EAAE,kBAAmB,CACnC,MAAO,0BACP,MAAOD,EAAM,iBAAmB,CAAA,CACjC,EAGD8D,GAAe7D,EAAE,WAAY,CAC3B,QAAS,UACT,KAAM,EAAA,EACL,IAAI,EAGP8D,GAAoB9D,EAAE,WAAY,CAChC,QAAS,SACT,KAAM,EAAA,EACL,GAAGD,EAAM,QAAQ,SAAS,CAAA,CAE9B,CACH,CACF,ECtEA,SAASkE,GAA2BC,EAAuBC,EAAwBC,EAAW,IAG5F,CACA,GAAIF,GAAiBE,EACnB,MAAO,CACL,MAAOF,EACP,OAAQC,CAAA,EAIZ,MAAME,EAAcF,EAAiBD,EACrC,MAAO,CACL,MAAOE,EACP,OAAQ,KAAK,MAAMA,EAAWC,CAAW,CAAA,CAE7C,CAGO,MAAMC,GAA0D,IAAM,CAG3E,MAAMtB,EAAQ,CACZ,aAAc,MAAA,EAGhB,MAAO,CAEL,KAAM,CAAC,CAAE,MAAAjD,KACA,CAGLC,EAAE,0BAA2B,CAC3B,SAAUD,EAAM,WAAa,GAC7B,QAAS,IAAM,CACTiD,EAAM,cACRA,EAAM,aAAa,MAAA,CAEvB,CAAA,EACCjD,EAAM,OAAS,cAAc,EAGhCC,EAAE,mBAAoB,CACpB,MAAO,CAAE,QAAS,MAAA,EAClB,OAAQ,UACR,SAAU,CAAC,CAAE,IAAAiD,KAAU,CACrBD,EAAM,aAAeC,CACvB,EACA,SAAWc,GAAgC,CAEzC,GADAA,EAAE,OAAS,GACPf,EAAM,aAAc,CACtB,MAAMuB,EAAOvB,EAAM,aAAa,QAAQ,CAAC,EACrCuB,GAAM,KAAK,WAAW,QAAQ,GAChC,kBAAkBA,CAAI,EACnB,KAAMC,GAAW,CAEhB,KAAM,CAAE,MAAAnE,EAAO,OAAAC,GAAW2D,GAA2BO,EAAO,MAAOA,EAAO,MAAM,EAC1EC,EAAY,IAAI,gBAAgBF,CAAI,EAC1CC,EAAO,MAAA,EACPzE,EAAM,SAAS0E,EAAWF,EAAK,KAAMlE,EAAOC,CAAM,CACpD,CAAC,EACA,MAAOoE,GAAQ,CACd,QAAQ,MAAM,oCAAqCA,CAAG,CACxD,CAAC,CAEP,CACF,CAAA,CACD,CAAA,CAEL,CAEJ,ECvEaC,GAAmE,KAIvE,CACL,KAAM,CAAC,CAAE,MAAA5E,KAEAC,EAAE,4BAA6B,CACpC,YAAaD,EAAM,OAAO,SAC1B,SAAUA,EAAM,SAChB,QAASA,EAAM,MACf,cAAgB,GAAa,CAE3B,MAAM6E,EADQ,EAAE,OACO,QACvB7E,EAAM,SAAS6E,CAAQ,CACzB,CAAA,EACC7E,EAAM,OAAO,KAAK,CACvB,GCjBS8E,GAAiE,KAIrE,CACL,KAAM,CAAC,CAAE,MAAA9E,KAEAC,EAAE,wBAAyB,CAChC,MAAOD,EAAM,OAAO,MACpB,YAAaA,EAAM,OAAO,SAC1B,KAAM,SACN,UAAW,UACX,KAAM,QACN,SAAUA,EAAM,SAChB,MAAOA,EAAM,MACb,IAAKA,EAAM,OAAO,IAClB,IAAKA,EAAM,OAAO,IAClB,cAAgB,GAAa,CAE3B,MAAM6E,EADQ,EAAE,OACO,cACvB7E,EAAM,SAAS,MAAM6E,CAAQ,EAAI,OAAYA,CAAQ,CACvD,CAAA,CACD,CACH,GCvBSE,GAA+D,KAInE,CACL,KAAM,CAAC,CAAE,MAAA/E,KAEAC,EAAE,uBAAwB,CAC/B,MAAOD,EAAM,OAAO,MACpB,YAAaA,EAAM,OAAO,SAC1B,SAAUA,EAAM,SAChB,MAAOA,EAAM,MACb,IAAKA,EAAM,OAAO,IAClB,IAAKA,EAAM,OAAO,IAClB,KAAMA,EAAM,OAAO,KACnB,cAAgB,GAAa,CAE3B,MAAM6E,EADQ,EAAE,OACO,MACvB7E,EAAM,SAAS,MAAM6E,CAAQ,EAAI,OAAYA,CAAQ,CACvD,CAAA,CACD,CACH,GCrBSG,GAAiE,KAIrE,CACL,KAAM,CAAC,CAAE,MAAAhF,KAEAC,EAAE,wBAAyB,CAChC,MAAOD,EAAM,OAAO,MACpB,YAAaA,EAAM,OAAO,SAC1B,KAAM,OACN,UAAW,OACX,KAAM,QACN,SAAUA,EAAM,SAChB,MAAOA,EAAM,MACb,cAAgB,GAAa,CAE3B,MAAM6E,EADQ,EAAE,OACO,MACvB7E,EAAM,SAAS6E,EAAS,OAAS,EAAIA,EAAW,MAAS,CAC3D,CAAA,CACD,CACH,GCTSI,GAA4D,KAKhE,CACL,SAAU,CAAC,CAAE,IAAA/B,EAAK,MAAAlD,KAAY,CACXkD,EAAI,cAAc,cAAc,EACxC,KAAKlD,EAAM,SAAS,CAC/B,EAEA,SAAU,CAAC,CAAE,IAAAkD,EAAK,MAAAlD,KAAY,CACXkD,EAAI,cAAc,cAAc,EACxC,KAAKlD,EAAM,SAAS,CAC/B,EAEA,KAAM,CAAC,CAAE,MAAAA,KAAY,CAEnB,MAAMkF,EAAalF,EAAM,SAAS,uBAAA,EAElC,OAAOC,EAAE,oBACPA,EAAE,eAAgB,CAEhB,gBAAkB+D,GAAsB,CACtC,MAAMmB,EAAcnB,EAAE,OAAO,KACzBhE,EAAM,YAAcmF,GACtBnF,EAAM,kBAAkBmF,CAAW,CAEvC,CAAA,EACC,CACD,GAAGD,EAAW,IAAKzE,GAAc,CAE/B,MAAMJ,EAAaL,EAAM,SAAS,cAAcS,EAAU,IAAI,EAGxD2E,EAAMnF,EAAE,SAAU,CACtB,KAAM,MACN,MAAOQ,EAAU,IAAA,EAChBA,EAAU,WAAW,EAGlB4E,EAAQpF,EAAE,eAAgB,CAC9B,KAAMQ,EAAU,IAAA,EACfR,EAAE,YACH,CAEEI,GAAY,YAAcJ,EAAE,IAAKI,EAAW,WAAW,EAAI,KAG3D,GAAGA,GAAY,SAAS,IAAKU,GAAY,CACvC,OAAOA,EAAQ,KAAA,CACf,IAAK,QACH,OAAOd,EAAE8E,GAAmB,CAC1B,OAAQhE,EACR,MAAQf,EAAM,SAASe,EAAQ,IAAI,GAAKA,EAAQ,aAChD,SAAWuE,GAAU,CACnBtF,EAAM,eAAee,EAAQ,KAAMuE,CAAK,CAC1C,CAAA,CACD,EACH,IAAK,UACH,OAAOrF,EAAE2E,GAAqB,CAC5B,OAAQ7D,EACR,OAAQf,EAAM,SAASe,EAAQ,IAAI,GAAKA,EAAQ,gBAAkB,GAClE,SAAWuE,GAAU,CACnBtF,EAAM,eAAee,EAAQ,KAAMuE,CAAK,CAC1C,CAAA,CACD,EACH,IAAK,SACH,OAAOrF,EAAE6E,GAAoB,CAC3B,OAAQ/D,EACR,MAAQf,EAAM,SAASe,EAAQ,IAAI,GAAKA,EAAQ,aAChD,SAAWuE,GAAU,CACnBtF,EAAM,eAAee,EAAQ,KAAMuE,CAAK,CAC1C,CAAA,CACD,EACH,IAAK,SACH,OAAOrF,EAAE+E,GAAoB,CAC3B,OAAQjE,EACR,MAAQf,EAAM,SAASe,EAAQ,IAAI,GAAKA,EAAQ,aAChD,SAAWuE,GAAU,CACnBtF,EAAM,eAAee,EAAQ,KAAMuE,CAAK,CAC1C,CAAA,CACD,CAAA,CAEL,CAAC,GAAK,CAAA,EAGL,CAACjF,GAAY,aAAeA,GAAY,SAAS,QAAU,EAAKJ,EAAE,IAAK,gCAAgC,EAAI,IAAA,CAC9G,CAAC,EAEH,MAAO,CAACmF,EAAKC,CAAK,CACpB,CAAC,CAAA,CACF,CAAA,CAEL,CAAA,GCvGEE,GAAiD,CACrD,CAAC,SAAoB,MAAU,CAAC,EAGhC,CAAC,gBAAoB,MAAU,EAAE,CAAC,EAClC,CAAC,iBAAoB,MAAU,EAAE,CAAC,EAClC,CAAC,YAAoB,MAAU,EAAE,CAAC,EAClC,CAAC,aAAoB,OAAU,GAAG,CAAC,EACnC,CAAC,YAAoB,OAAU,GAAG,CAAC,EACnC,CAAC,WAAoB,MAAU,EAAE,CAAC,EAGlC,CAAC,qBAA4B,MAAU,EAAE,CAAC,EAC1C,CAAC,mBAA4B,MAAU,EAAE,CAAC,EAC1C,CAAC,gBAA4B,MAAU,EAAE,CAAC,EAC1C,CAAC,iBAA4B,OAAU,EAAE,EAAE,EAC3C,CAAC,cAA4B,OAAU,EAAE,EAAE,EAC3C,CAAC,gBAA4B,MAAU,EAAE,CAAC,CAC5C,EAGaC,GAAwD,CACnE,KAAM,CAAC,CAAE,MAAAxF,KAAY,CAGnB,MAAMyF,EAAW,CAACF,GAAmB,KAAK,CAAC,CAAA,CAAA,CAAKD,CAAK,IAAMA,IAAUtF,EAAM,KAAK,EAG1E0F,EAAgBH,GAAmB,IAAI,CAAC,CAACpF,EAAMwF,EAAUL,CAAK,IAClErF,EAAE,YAAa,CACb,MAAO,OAAOqF,CAAK,CAAA,EAClB,GAAGnF,CAAI,KAAKwF,CAAQ,GAAG,CAAA,EAI5B,OAAIF,GACFC,EAAc,QAAQzF,EAAE,YAAa,CAAE,MAAO,QAAA,EAAY,QAAQ,CAAC,EAG9DA,EAAE,uBAAwB,CAG/BA,EAAE,YAAa,CACb,MAAO,eACP,KAAM,QACN,SAAUD,EAAM,SAChB,MAAOyF,EAAW,SAAW,OAAOzF,EAAM,KAAK,EAC/C,cAAgBgE,GAAgC,CAC9CA,EAAE,OAAS,GAEX,MAAM4B,EADS5B,EAAE,OACY,MAGzB4B,GAAiBA,IAAkB,UACrC5F,EAAM,SAAS,OAAO4F,CAAa,CAAC,CAExC,CAAA,EACCF,CAAa,EAGhBzF,EAAE,WAAY,CAEZ,IAAK,IACL,IAAK,EACL,KAAM,IACN,SAAUD,EAAM,SAChB,MAAOA,EAAM,MACb,cAAgBgE,GAAgC,CAC9CA,EAAE,OAAS,GACX,MAAM6B,EAAQ7B,EAAE,OAChBhE,EAAM,SAAS6F,EAAM,KAAK,CAC5B,CAAA,CACD,CAAA,CACF,CACH,CACF,EC3EaC,GAA6C,CACxD,KAAM,CAAC,CAAE,MAAA9F,KACAC,EAAE,gBAAiB,CACxBA,EAAE,SAAUD,EAAM,KAAK,EACvBC,EAAE,kBAAmB,CACnB,MAAO,iBACP,MAAOD,EAAM,MACb,KAAMA,EAAM,MAAQ,SACpB,OAAQ,MACR,cAAgB,GAAgC,CAC9C,EAAE,OAAS,GACX,MAAM+F,EAAQ,EAAE,OAChB/F,EAAM,SAAS+F,EAAM,KAAK,CAC5B,CAAA,CACD,CAAA,CACF,CAEL,+CCvCA,SAASC,EAAsBC,EAAW,CACtC,IAAIC,EAAaD,EAAU,OACvBE,EAAc,EACdC,EAAS,IAAI,MAAMF,CAAU,EAC7BG,EAEJ,IAAKA,EAAYH,EAAYG,EAAY,EAAGA,IACxCD,EAAOC,EAAY,CAAC,EAAIF,EACxBA,EAAcA,EAAcF,EAAUI,EAAY,CAAC,EAGvD,MAAO,CACH,OAAQD,EACR,KAAM,IAAI,YAAYD,CAAW,EAEzC,CAEA,SAASG,EAAoBL,EAAW,CACpC,IAAIC,EAAaD,EAAU,OACvBE,EAAc,EACdC,EAAS,IAAI,MAAMF,CAAU,EAC7BK,EAAO,CAAA,EACPF,EAAWG,EAEf,IAAKH,EAAYH,EAAYG,EAAY,EAAGA,IACxCD,EAAOC,EAAY,CAAC,EAAIF,EACxBA,EAAcA,EAAcF,EAAUI,EAAY,CAAC,EAGvD,IAAKG,EAAQ,EAAGA,EAAQL,EAAaK,IACjCD,EAAK,KAAK,EAAE,EAGhB,MAAO,CACH,OAAQH,EACR,KAAMG,EAEd,CAEA,OAAAE,GAAiB,CACb,QAAST,EACT,MAAOM,mDCtCXI,GAAiBC,EAOjB,SAASA,EAAaC,EAAGC,EAAK,CAC1B,IAAIC,EAAI,IAAI,MAAMF,CAAC,EACfG,EAAK,KAAK,MAAMH,EAAE,CAAC,GAAK,EACxBI,EAAK,EACLC,EACAC,EACAC,EACA,EACAC,EAEJ,IAAKA,EAAI,EAAGA,EAAIL,EAAIK,GAAK,EACrBH,EAAK,GAAO,KAAK,IAAIJ,EAAG,CAAE,EAC1BK,EAAK,KAAK,KAAKD,CAAE,EACjBE,EAAQ,EAAM,KAAK,GAAKN,EAAG,EAE3BG,GAAKC,EACLH,EAAEM,CAAC,EAAIF,EAAI,KAAK,IAAIC,CAAK,EACzBL,EAAEM,EAAE,CAAC,EAAIF,EAAI,KAAK,IAAIC,CAAK,EAG/B,GAAIP,EAAI,EAAG,CACP,IAAI/D,EAAI,KAAK,KAAK,GAAO,KAAK,IAAIgE,EAAG,CAAE,CAAC,EAAI,KAAK,IAAI,EAAM,KAAK,GAAKA,GAAK,EAC1EC,EAAEF,EAAI,CAAC,EAAI/D,EACXmE,GAAK,KAAK,IAAInE,EAAG,CAAC,CAC1B,CAII,IAFA,EAAI,EAAM,KAAK,KAAKmE,CAAE,EAEjBI,EAAI,EAAGA,EAAIR,EAAG,EAAEQ,EACjBN,EAAEM,CAAC,GAAK,EAGZ,OAAON,CACX,oDC7CAO,GAAiB,SAAexB,EAAOK,EAAY,CACjDL,EAAQA,GAAS,EACjBK,EAAaA,GAAc,EAM3B,QAJIoB,EAAOzB,EAAQ,EAAI,EACnB0B,EAAS,KAAK,IAAID,EAAMpB,CAAU,EAAI,EACtCsB,EAAY,IAAI,MAAMD,CAAM,EAEvBH,EAAI,EAAGA,EAAIG,EAAQH,IAG1B,QAFIK,EAAWD,EAAUJ,CAAC,EAAI,IAAI,MAAMlB,CAAU,EAC9CM,EAAQY,EAAIG,EAAS,EAAIH,EAAIA,EAAI,EAC5Bf,EAAY,EAAGA,GAAaH,EAAYG,IAAa,CAC5D,IAAIf,EAAQkB,EAAQ,KAAK,IAAIc,EAAMjB,CAAS,EAC5CoB,EAASpB,EAAY,CAAC,EAAIf,EAAQ,KAAK,IAAIgC,EAAMjB,EAAY,CAAC,EAAIR,EAClEW,GAASlB,CACf,CAGE,OAAOkC,CACT,mDCjBA,IAAIH,EAAQK,GAAA,EAOZ,SAASC,EAAkBC,EAAiB,CACxC,IAAIC,EAAgBR,EAAM,EAAGO,CAAe,EACxCE,EAAS,CAAA,EACTzB,EAcJ,IAVAwB,EAAgBA,EAAc,OAAO,SAAUE,EAAG,CAG9C,QAFIC,EAAO,EAEFpB,EAAI,EAAGA,EAAIgB,EAAiBhB,IACjCoB,GAAQ,KAAK,IAAI,KAAK,IAAI,EAAG,KAAK,IAAID,EAAEnB,CAAC,CAAC,EAAI,CAAC,EAAG,CAAC,EAGvD,OAAOoB,EAAOJ,CACtB,CAAK,EAEIvB,EAAY,EAAGA,EAAYuB,EAAiBvB,IAC7CyB,EAAO,KAAK,CAAC,EAGjB,OAAAD,EAAc,KAAKC,CAAM,EAKzBD,EAAc,KAAK,SAAUI,EAAIC,EAAI,CACjC,IAAIC,EAAc,EACdC,EAAc,EACd/B,EAEJ,IAAKA,EAAY,EAAGA,EAAYuB,EAAiBvB,IAC7C8B,GAAe,KAAK,IAAIF,EAAG5B,CAAS,EAAG,CAAC,EACxC+B,GAAe,KAAK,IAAIF,EAAG7B,CAAS,EAAG,CAAC,EAG5C,OAAI8B,EAAcC,EACP,GACDD,EAAcC,EACb,EAEA,CAEnB,CAAK,EAEMP,CACX,CAEA,IAAIQ,EAAqB,CAAA,EAOzB,SAASC,EAA0BV,EAAiB,CAChD,OAAKS,EAAmBT,CAAe,IACnCS,EAAmBT,CAAe,EAAID,EAAiBC,CAAe,GAGnES,EAAmBT,CAAe,CAC7C,CAEA,OAAAC,GAAiBS,kDCtEjB,IAAIC,EAAcb,GAAA,EAA6B,QAC3ChB,EAAe8B,GAAA,EACfb,EAAmBc,GAAA,EAQvB,SAASC,EAA0BC,EAAQC,EAAQ,CAI/C,QAHIC,EAAS,EACTzB,EAAI,EAEDA,EAAIuB,EAAO,OAAQvB,IACtByB,GAAU,KAAK,IAAIF,EAAOvB,CAAC,EAAIwB,EAAOxB,CAAC,EAAG,CAAC,EAG/C,OAAOyB,CACX,CAYA,SAASC,EAAiBvH,EAASsF,EAAK,CACpC,GAAI,OAAOtF,EAAQ,kBAAqB,WACpC,MAAM,IAAI,MAAM,oGAAoG,EAGxH,KAAK,MAAQA,EAAQ,MACrB,KAAK,YAAcA,EAAQ,YAC3B,KAAK,YAAcA,EAAQ,aAAeA,EAAQ,YAAc,EAChE,KAAK,SAAW,KAAK,KAAK,KAAK,IAAI,EAAGA,EAAQ,OAAS,EAAE,CAAC,EAE1D,KAAK,IAAMsF,GAAO,KAAK,OAIvB,QADIkC,EAAW,EACN3B,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQA,IACnC2B,EAAW,KAAK,IAAIA,EAAU,KAAK,MAAM3B,CAAC,CAAC,EAE/C,IAAI4B,EAA2B,KAAK,IAAI,EAAGD,EAAW,IAAM,CAAC,EACzDE,EAAkB,MAAQD,EAE9B,KAAK,UAAY,KAAK,MAAM,OAC5B,KAAK,mBAAqB,KAAK,YAAc,KAAK,YAClD,KAAK,uBAAyB,KAAK,YAAcC,EACjD,KAAK,cAAgB,KAAK,IAAI,EAAG,KAAK,YAAc,KAAK,sBAAsB,EAC/E,KAAK,SAAW,KAAK,YAAc,KAAK,KAAK,KAAK,SAAS,EAE3D,KAAK,cAAgBtB,EAAiB,KAAK,SAAS,EAEpD,KAAK,aAAe,KACpB,KAAK,YAAc,CAAA,EACnB,KAAK,aAAe,CAAA,EAIpB,KAAK,UAAY,CAAA,EAEjB,QAASP,EAAI,EAAGA,EAAI,KAAK,UAAWA,IAChC,KAAK,UAAU,KAAK,KAAK,KAAK,KAAK,MAAMA,CAAC,EAAI,KAAK,QAAQ,CAAC,EAGhE,KAAK,KAAOmB,EAAY,KAAK,SAAS,CAC1C,CAEA,OAAAO,EAAgB,UAAU,MAAQ,KAClCA,EAAgB,UAAU,UAAY,KACtCA,EAAgB,UAAU,YAAc,KACxCA,EAAgB,UAAU,YAAc,KACxCA,EAAgB,UAAU,uBAAyB,KACnDA,EAAgB,UAAU,mBAAqB,KAC/CA,EAAgB,UAAU,cAAgB,KAC1CA,EAAgB,UAAU,SAAW,KACrCA,EAAgB,UAAU,SAAW,KACrCA,EAAgB,UAAU,IAAM,KAChCA,EAAgB,UAAU,cAAgB,KAE1CA,EAAgB,UAAU,aAAe,KACzCA,EAAgB,UAAU,YAAc,KACxCA,EAAgB,UAAU,aAAe,KACzCA,EAAgB,UAAU,UAAY,KACtCA,EAAgB,UAAU,KAAO,KAMjCA,EAAgB,UAAU,eAAiB,UAAY,CAGnD,QAFII,EAAQ,IAAI,MAAM,KAAK,SAAS,EAE3B9B,EAAI,EAAGA,EAAI,KAAK,UAAWA,IAChC8B,EAAM9B,CAAC,EAAI,KAAK,IAAG,EAAK,KAAK,MAAMA,CAAC,EAGxC,OAAO,KAAK,eAAe8B,CAAK,CACpC,EAOAJ,EAAgB,UAAU,SAAW,SAAUI,EAAO,CAClD,IAAI7C,EACA8C,EAAQ,GAEZ,GAAID,EAAM,SAAW,KAAK,UACtB,IAAK7C,EAAY,EAAGA,EAAY,KAAK,WAAa8C,EAAO9C,IACrD8C,EAASD,EAAM7C,CAAS,GAAK,GAAK6C,EAAM7C,CAAS,EAAI,KAAK,MAAMA,CAAS,OAG7E8C,EAAQ,GAGZ,OAAOA,EAAQ,KAAK,eAAeD,CAAK,EAAI,IAChD,EAQAJ,EAAgB,UAAU,eAAiB,SAAUI,EAAO,CACxD,IAAIE,EAAqB,EACrBhD,EAAS,KAAK,KAAK,OACnBC,EAKJ,IAHA,KAAK,YAAY,KAAK6C,CAAK,EAC3B,KAAK,aAAa,KAAKA,CAAK,EAEvB7C,EAAY,EAAGA,EAAY,KAAK,UAAWA,IAC5C+C,IAAwBF,EAAM7C,CAAS,EAAI,KAAK,SAAY,GAAKD,EAAOC,CAAS,EAGrF,YAAK,KAAK,KAAK+C,CAAkB,EAAI,KAAK,aAAa,OAEhDF,CACX,EAQAJ,EAAgB,UAAU,gBAAkB,SAAUI,EAAO,CACzD,IAAItB,EAAkB,KAAK,UACvBxB,EAAS,KAAK,KAAK,OACnBiD,EACAD,EACA/C,EACAiD,EACAC,EAEJ,IAAKF,EAAiB,EAAGA,EAAiB,KAAK,cAAc,OAAQA,IAAkB,CAGnF,IAFAD,EAAqB,EAEhB/C,EAAY,EAAGA,EAAYuB,EAAiBvB,IAAa,CAG1D,GAFAiD,GAA0BJ,EAAM7C,CAAS,EAAI,KAAK,SAAY,GAAK,KAAK,cAAcgD,CAAc,EAAEhD,CAAS,EAE3GiD,EAAwB,GAAKA,GAAyB,KAAK,UAAUjD,CAAS,EAAG,CACjF+C,EAAqB,GACrB,KAChB,CAEYA,GAAsBE,EAAwBlD,EAAOC,CAAS,CAC1E,CAEQ,GAAI+C,IAAuB,IAAM,KAAK,KAAK,KAAKA,CAAkB,IAAM,IACpEG,EAAgB,KAAK,aAAa,KAAK,KAAK,KAAKH,CAAkB,EAAI,CAAC,EAEpEV,EAAyBQ,EAAOK,CAAa,EAAI,KAAK,oBACtD,MAAO,EAGvB,CAEI,MAAO,EACX,EAMAT,EAAgB,UAAU,KAAO,UAAY,CASzC,QARIU,EACAC,EACAC,EACAC,EACAC,EACAC,EACAzC,EAEG,KAAK,YAAY,OAAS,GAAG,CAOhC,IANI,KAAK,eAAiB,OACtB,KAAK,aAAe,KAAK,YAAY,MAAK,GAG9CuC,EAAe,KAAK,aAEfH,EAAQ,EAAGA,EAAQ,KAAK,SAAUA,IAAS,CAc5C,IAbAK,EAAU,GACVH,EAAW,KAAK,uBAAyB,KAAK,cAAgB,KAAK,IAAG,EAElE,KAAK,YAAc,GACnBD,EAAQ,KAAK,IAAG,EAAK,KAAK,GAAK,EAC/BG,EAAW,CACP,KAAK,IAAIH,CAAK,EACd,KAAK,IAAIA,CAAK,IAGlBG,EAAWlD,EAAa,KAAK,UAAW,KAAK,GAAG,EAG/CU,EAAI,EAAGyC,GAAWzC,EAAI,KAAK,UAAWA,IACvCwC,EAASxC,CAAC,EAAIuC,EAAavC,CAAC,EAAIwC,EAASxC,CAAC,EAAIsC,EAC9CG,EAAWD,EAASxC,CAAC,GAAK,GAAKwC,EAASxC,CAAC,EAAI,KAAK,MAAMA,CAAC,EAG7D,GAAIyC,GAAW,CAAC,KAAK,gBAAgBD,CAAQ,EACzC,OAAO,KAAK,eAAeA,CAAQ,CAEnD,CAEYJ,IAAU,KAAK,WACf,KAAK,aAAe,KAEhC,CAEI,OAAO,IACX,EAOAV,EAAgB,UAAU,KAAO,UAAY,CAKzC,IAJI,KAAK,aAAa,SAAW,GAC7B,KAAK,eAAc,EAGjB,KAAK,KAAI,GAAI,CAEnB,OAAO,KAAK,YAChB,EAMAA,EAAgB,UAAU,aAAe,UAAY,CACjD,OAAO,KAAK,YAChB,EAMAA,EAAgB,UAAU,yBAA2B,UAAY,CAC7D,MAAM,IAAI,MAAM,kGAAkG,CACtH,EAKAA,EAAgB,UAAU,MAAQ,UAAY,CAC1C,IAAIgB,EAAW,KAAK,KAAK,KACrB1C,EAAI,EAGR,IAAKA,EAAI,EAAGA,EAAI0C,EAAS,OAAQ1C,IAC7B0C,EAAS1C,CAAC,EAAI,EAIlB,KAAK,aAAe,CAAA,EAGpB,KAAK,aAAe,KACpB,KAAK,YAAY,OAAS,CAC9B,EAEA2C,GAAiBjB,kDCrSjB,IAAIP,EAAcb,GAAA,EAA6B,MAC3ChB,EAAe8B,GAAA,EACfb,EAAmBc,GAAA,EAQvB,SAASuB,EAAmBrB,EAAQC,EAAQ,CAIxC,QAHIC,EAAS,EACTzB,EAAI,EAEDA,EAAIuB,EAAO,OAAQvB,IACtByB,GAAU,KAAK,IAAIF,EAAOvB,CAAC,EAAIwB,EAAOxB,CAAC,EAAG,CAAC,EAG/C,OAAO,KAAK,KAAKyB,CAAM,CAC3B,CAcA,SAASoB,EAAoB1I,EAASsF,EAAK,CACvC,GAAI,OAAOtF,EAAQ,kBAAqB,WACpC,MAAM,IAAI,MAAM,0GAA0G,EAG9H,KAAK,MAAQA,EAAQ,MACrB,KAAK,YAAcA,EAAQ,YAC3B,KAAK,YAAcA,EAAQ,aAAeA,EAAQ,YAAc,EAChE,KAAK,SAAW,KAAK,KAAK,KAAK,IAAI,EAAGA,EAAQ,OAAS,EAAE,CAAC,EAC1D,KAAK,iBAAmBA,EAAQ,iBAChC,KAAK,KAAO,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGA,EAAQ,MAAQ,CAAC,CAAC,EAEtD,KAAK,IAAMsF,GAAO,KAAK,OAIvB,QADIkC,EAAW,EACN3B,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQA,IACnC2B,EAAW,KAAK,IAAIA,EAAU,KAAK,MAAM3B,CAAC,CAAC,EAE/C,IAAI4B,EAA2B,KAAK,IAAI,EAAGD,EAAW,IAAM,CAAC,EACzDE,EAAkB,MAAQD,EAE9B,KAAK,UAAY,KAAK,MAAM,OAC5B,KAAK,uBAAyB,KAAK,YAAcC,EACjD,KAAK,cAAgB,KAAK,IAAI,EAAG,KAAK,YAAc,KAAK,sBAAsB,EAC/E,KAAK,SAAW,KAAK,YAAc,KAAK,KAAK,KAAK,SAAS,EAE3D,KAAK,cAAgBtB,EAAiB,KAAK,SAAS,EAEpD,KAAK,aAAe,KACpB,KAAK,gBAAkB,EACvB,KAAK,YAAc,CAAA,EACnB,KAAK,aAAe,CAAA,EACpB,KAAK,eAAiB,GAItB,KAAK,UAAY,CAAA,EAEjB,QAASP,EAAI,EAAGA,EAAI,KAAK,UAAWA,IAChC,KAAK,UAAU,KAAK,KAAK,KAAK,KAAK,MAAMA,CAAC,EAAI,KAAK,QAAQ,CAAC,EAGhE,KAAK,KAAOmB,EAAY,KAAK,SAAS,CAC1C,CAEA,OAAA0B,EAAmB,UAAU,MAAQ,KACrCA,EAAmB,UAAU,UAAY,KACzCA,EAAmB,UAAU,YAAc,KAC3CA,EAAmB,UAAU,YAAc,KAC3CA,EAAmB,UAAU,uBAAyB,KACtDA,EAAmB,UAAU,cAAgB,KAC7CA,EAAmB,UAAU,SAAW,KACxCA,EAAmB,UAAU,SAAW,KACxCA,EAAmB,UAAU,iBAAmB,KAChDA,EAAmB,UAAU,KAAO,KACpCA,EAAmB,UAAU,IAAM,KACnCA,EAAmB,UAAU,cAAgB,KAE7CA,EAAmB,UAAU,aAAe,KAC5CA,EAAmB,UAAU,gBAAkB,KAC/CA,EAAmB,UAAU,YAAc,KAC3CA,EAAmB,UAAU,aAAe,KAC5CA,EAAmB,UAAU,eAAiB,KAC9CA,EAAmB,UAAU,UAAY,KACzCA,EAAmB,UAAU,KAAO,KAMpCA,EAAmB,UAAU,eAAiB,UAAY,CAGtD,QAFIf,EAAQ,IAAI,MAAM,KAAK,SAAS,EAE3B9B,EAAI,EAAGA,EAAI,KAAK,UAAWA,IAChC8B,EAAM9B,CAAC,EAAI,KAAK,IAAG,EAAK,KAAK,MAAMA,CAAC,EAGxC,OAAO,KAAK,eAAe8B,CAAK,CACpC,EAOAe,EAAmB,UAAU,SAAW,SAAUf,EAAO,CACrD,IAAI7C,EACA8C,EAAQ,GAEZ,GAAID,EAAM,SAAW,KAAK,UACtB,IAAK7C,EAAY,EAAGA,EAAY,KAAK,WAAa8C,EAAO9C,IACrD8C,EAASD,EAAM7C,CAAS,GAAK,GAAK6C,EAAM7C,CAAS,EAAI,KAAK,MAAMA,CAAS,OAG7E8C,EAAQ,GAGZ,OAAOA,EAAQ,KAAK,eAAeD,CAAK,EAAI,IAChD,EAQAe,EAAmB,UAAU,eAAiB,SAAUf,EAAO,CAC3D,IAAIE,EAAqB,EACrBhD,EAAS,KAAK,KAAK,OACnB8D,EAAa,KAAK,aAAa,OAC/B7D,EAMJ,IAJA,KAAK,YAAY,KAAK6D,CAAU,EAChC,KAAK,aAAa,KAAKhB,CAAK,EAC5B,KAAK,eAAe,KAAK,KAAK,iBAAiBA,CAAK,CAAC,EAEhD7C,EAAY,EAAGA,EAAY,KAAK,UAAWA,IAC5C+C,IAAwBF,EAAM7C,CAAS,EAAI,KAAK,SAAY,GAAKD,EAAOC,CAAS,EAGrF,YAAK,KAAK,KAAK+C,CAAkB,EAAE,KAAKc,CAAU,EAE3ChB,CACX,EAQAe,EAAmB,UAAU,gBAAkB,SAAUf,EAAO,CAC5D,IAAItB,EAAkB,KAAK,UACvBxB,EAAS,KAAK,KAAK,OACnBiD,EACAD,EACA/C,EACAiD,EACAC,EACAY,EAEAC,EAAgB,KAAK,iBAAiBlB,CAAK,EAE/C,IAAKG,EAAiB,EAAGA,EAAiB,KAAK,cAAc,OAAQA,IAAkB,CAGnF,IAFAD,EAAqB,EAEhB/C,EAAY,EAAGA,EAAYuB,EAAiBvB,IAAa,CAG1D,GAFAiD,GAA0BJ,EAAM7C,CAAS,EAAI,KAAK,SAAY,GAAK,KAAK,cAAcgD,CAAc,EAAEhD,CAAS,EAE3GiD,EAAwB,GAAKA,GAAyB,KAAK,UAAUjD,CAAS,EAAG,CACjF+C,EAAqB,GACrB,KAChB,CAEYA,GAAsBE,EAAwBlD,EAAOC,CAAS,CAC1E,CAEQ,GAAI+C,IAAuB,IAAM,KAAK,KAAK,KAAKA,CAAkB,EAAE,OAAS,EACzE,QAAShC,EAAI,EAAGA,EAAI,KAAK,KAAK,KAAKgC,CAAkB,EAAE,OAAQhC,IAAK,CAChEmC,EAAgB,KAAK,aAAa,KAAK,KAAK,KAAKH,CAAkB,EAAEhC,CAAC,CAAC,EACvE+C,EAAwB,KAAK,eAAe,KAAK,KAAK,KAAKf,CAAkB,EAAEhC,CAAC,CAAC,EAEjF,IAAIiD,EAAc,KAAK,IAAIF,EAAuBC,CAAa,EAC3DE,EAAc,KAAK,IAAIH,EAAuBC,CAAa,EAC3DpC,EAAOqC,GAAeC,EAAcD,GAAe,KAAK,KAE5D,GAAIL,EAAkBd,EAAOK,CAAa,EAAI,KAAK,YAAc,KAAK,cAAgBvB,EAClF,MAAO,EAE3B,CAEA,CAEI,MAAO,EACX,EAMAiC,EAAmB,UAAU,KAAO,UAAY,CAU5C,QATIT,EACAC,EACAC,EACAC,EACAY,EACAX,EACAC,EACAzC,EAEG,KAAK,YAAY,OAAS,GAAG,CAChC,GAAI,KAAK,eAAiB,KAAM,CAC5B,IAAIoD,EAAc,KAAK,YAAY,MAAK,EACxC,KAAK,aAAe,KAAK,aAAaA,CAAW,EACjD,KAAK,gBAAkB,KAAK,eAAeA,CAAW,CAClE,CAKQ,IAHAb,EAAe,KAAK,aACpBY,EAAkB,KAAK,gBAElBf,EAAQ,EAAGA,EAAQ,KAAK,SAAUA,IAAS,CAc5C,IAbAK,EAAU,GACVH,EAAW,KAAK,uBAAyB,KAAK,eAAiBa,GAAmB,EAAIA,GAAmB,KAAK,MAE1G,KAAK,YAAc,GACnBd,EAAQ,KAAK,IAAG,EAAK,KAAK,GAAK,EAC/BG,EAAW,CACP,KAAK,IAAIH,CAAK,EACd,KAAK,IAAIA,CAAK,IAGlBG,EAAWlD,EAAa,KAAK,UAAW,KAAK,GAAG,EAG/CU,EAAI,EAAGyC,GAAWzC,EAAI,KAAK,UAAWA,IACvCwC,EAASxC,CAAC,EAAIuC,EAAavC,CAAC,EAAIwC,EAASxC,CAAC,EAAIsC,EAC9CG,EAAWD,EAASxC,CAAC,GAAK,GAAKwC,EAASxC,CAAC,EAAI,KAAK,MAAMA,CAAC,EAG7D,GAAIyC,GAAW,CAAC,KAAK,gBAAgBD,CAAQ,EACzC,OAAO,KAAK,eAAeA,CAAQ,CAEnD,CAEYJ,IAAU,KAAK,WACf,KAAK,aAAe,KAEhC,CAEI,OAAO,IACX,EAOAS,EAAmB,UAAU,KAAO,UAAY,CAK5C,IAJI,KAAK,aAAa,SAAW,GAC7B,KAAK,eAAc,EAGjB,KAAK,KAAI,GAAI,CAEnB,OAAO,KAAK,YAChB,EAMAA,EAAmB,UAAU,aAAe,UAAY,CACpD,OAAO,KAAK,YAChB,EAMAA,EAAmB,UAAU,yBAA2B,UAAY,CAChE,IAAIpB,EAAS,IAAI,MAAM,KAAK,aAAa,MAAM,EAC3CzB,EAAI,EACJf,EAAY,EACZ6C,EAEJ,IAAK9B,EAAI,EAAGA,EAAI,KAAK,aAAa,OAAQA,IAAK,CAG3C,IAFA8B,EAAQ,IAAI,MAAM,KAAK,UAAY,CAAC,EAE/B7C,EAAY,EAAGA,EAAY,KAAK,UAAWA,IAC5C6C,EAAM7C,CAAS,EAAI,KAAK,aAAae,CAAC,EAAEf,CAAS,EAGrD6C,EAAM,KAAK,SAAS,EAAI,KAAK,eAAe9B,CAAC,EAE7CyB,EAAOzB,CAAC,EAAI8B,CACpB,CAEI,OAAOL,CACX,EAKAoB,EAAmB,UAAU,MAAQ,UAAY,CAC7C,IAAIH,EAAW,KAAK,KAAK,KACrB1C,EAAI,EAGR,IAAKA,EAAI,EAAGA,EAAI0C,EAAS,OAAQ1C,IAC7B0C,EAAS1C,CAAC,EAAI,CAAA,EAIlB,KAAK,aAAe,CAAA,EAGpB,KAAK,aAAe,KACpB,KAAK,YAAY,OAAS,CAC9B,EAEAqD,GAAiBR,kDC9UjB,IAAInB,EAAkBpB,GAAA,EAClBuC,EAAqBzB,GAAA,EAczB,SAASkC,EAAqBnJ,EAASsF,EAAK,CACxC,KAAK,MAAQtF,EAAQ,MAEjB,OAAOA,EAAQ,kBAAqB,WACpC,KAAK,eAAiB,IAAI0I,EAAmB1I,EAASsF,CAAG,EAEzD,KAAK,eAAiB,IAAIiC,EAAgBvH,EAASsF,CAAG,CAE9D,CAEA,OAAA6D,EAAoB,UAAU,eAAiB,KAM/CA,EAAoB,UAAU,eAAiB,UAAY,CACvD,OAAO,KAAK,eAAe,eAAc,CAC7C,EAOAA,EAAoB,UAAU,SAAW,SAAUxB,EAAO,CACtD,OAAO,KAAK,eAAe,SAASA,CAAK,CAC7C,EAMAwB,EAAoB,UAAU,KAAO,UAAY,CAC7C,OAAO,KAAK,eAAe,KAAI,CACnC,EAOAA,EAAoB,UAAU,KAAO,UAAY,CAC7C,OAAO,KAAK,eAAe,KAAI,CACnC,EAMAA,EAAoB,UAAU,aAAe,UAAY,CACrD,OAAO,KAAK,eAAe,aAAY,CAC3C,EAOAA,EAAoB,UAAU,yBAA2B,UAAY,CACjE,OAAO,KAAK,eAAe,yBAAwB,CACvD,EAKAA,EAAoB,UAAU,MAAQ,UAAY,CAC9C,KAAK,eAAe,MAAK,CAC7B,EAEAC,GAAiBD,iCC9EJE,GAAkC,wBASlCC,GAA8C,CACzD,KAAMD,GACN,YAAa,UACb,YAAa,iOAIb,SAAU,EAEV,SAAU,CAAA,CACZ,EAOaE,GAAiE,CAACC,EAAgBC,EAAiBC,KAChE,CAC5C,eAAeC,EAAoD,CACjE,KAAM,CAAE,MAAA5K,EAAO,OAAAC,EAAQ,UAAAiB,EAAW,OAAAO,GAAWmJ,EAc7C,OAXgB,IAAIR,GAClB,CACE,MAAO,CAACpK,EAAOC,CAAM,EACrB,YAAaiB,EACb,MAAO,EAAA,EAETO,CAAA,EAIqB,KAAA,CAEzB,CAAA,GAOJf,EAAuB,SAAS4J,GAAME,GAA8BD,EAAsB,EC5DnF,MAAMM,EAAU,sBACVC,EAAW,UACXC,IAAkB,EAAI,EAAIF,GAAWA,EAG3C,SAASG,GAAIC,EAAM,EAAGC,EAAMC,EAAGC,EAAG,CACrC,IAAIC,EAAGC,EAAMC,EAAIC,EACbC,EAAO,EAAE,CAAC,EACVC,EAAOP,EAAE,CAAC,EACVQ,EAAS,EACTC,EAAS,EACRF,EAAOD,GAAWC,EAAO,CAACD,GAC3BJ,EAAII,EACJA,EAAO,EAAE,EAAEE,CAAM,IAEjBN,EAAIK,EACJA,EAAOP,EAAE,EAAES,CAAM,GAErB,IAAIC,EAAS,EACb,GAAIF,EAASV,GAAQW,EAASV,EAc1B,IAbKQ,EAAOD,GAAWC,EAAO,CAACD,GAC3BH,EAAOG,EAAOJ,EACdE,EAAKF,GAAKC,EAAOG,GACjBA,EAAO,EAAE,EAAEE,CAAM,IAEjBL,EAAOI,EAAOL,EACdE,EAAKF,GAAKC,EAAOI,GACjBA,EAAOP,EAAE,EAAES,CAAM,GAErBP,EAAIC,EACAC,IAAO,IACPH,EAAES,GAAQ,EAAIN,GAEXI,EAASV,GAAQW,EAASV,GACxBQ,EAAOD,GAAWC,EAAO,CAACD,GAC3BH,EAAOD,EAAII,EACXD,EAAQF,EAAOD,EACfE,EAAKF,GAAKC,EAAOE,IAAUC,EAAOD,GAClCC,EAAO,EAAE,EAAEE,CAAM,IAEjBL,EAAOD,EAAIK,EACXF,EAAQF,EAAOD,EACfE,EAAKF,GAAKC,EAAOE,IAAUE,EAAOF,GAClCE,EAAOP,EAAE,EAAES,CAAM,GAErBP,EAAIC,EACAC,IAAO,IACPH,EAAES,GAAQ,EAAIN,GAI1B,KAAOI,EAASV,GACZK,EAAOD,EAAII,EACXD,EAAQF,EAAOD,EACfE,EAAKF,GAAKC,EAAOE,IAAUC,EAAOD,GAClCC,EAAO,EAAE,EAAEE,CAAM,EACjBN,EAAIC,EACAC,IAAO,IACPH,EAAES,GAAQ,EAAIN,GAGtB,KAAOK,EAASV,GACZI,EAAOD,EAAIK,EACXF,EAAQF,EAAOD,EACfE,EAAKF,GAAKC,EAAOE,IAAUE,EAAOF,GAClCE,EAAOP,EAAE,EAAES,CAAM,EACjBP,EAAIC,EACAC,IAAO,IACPH,EAAES,GAAQ,EAAIN,GAGtB,OAAIF,IAAM,GAAKQ,IAAW,KACtBT,EAAES,GAAQ,EAAIR,GAEXQ,CACX,CAsDO,SAASC,GAASb,EAAM,EAAG,CAC9B,IAAII,EAAI,EAAE,CAAC,EACX,QAASvE,EAAI,EAAGA,EAAImE,EAAMnE,IAAKuE,GAAK,EAAEvE,CAAC,EACvC,OAAOuE,CACX,CAEO,SAASU,EAAItE,EAAG,CACnB,OAAO,IAAI,aAAaA,CAAC,CAC7B,CCvIA,MAAMuE,IAAgB,EAAI,GAAKnB,GAAWA,EACpCoB,IAAgB,EAAI,GAAKpB,GAAWA,EACpCqB,IAAgB,EAAI,GAAKrB,GAAWA,EAAUA,EAE9CsB,EAAIJ,EAAI,CAAC,EACTK,GAAKL,EAAI,CAAC,EACVM,GAAKN,EAAI,EAAE,EACXO,GAAIP,EAAI,EAAE,EACVQ,EAAIR,EAAI,CAAC,EAEf,SAASS,GAAcC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAQ,CACnD,IAAIC,EAASC,EAASC,EAASC,EAC3B3B,EAAO4B,EAAGC,EAAKC,EAAKC,EAAKC,EAAKC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAE9D,MAAMC,EAAMxB,EAAKI,EACXqB,EAAMvB,EAAKE,EACXsB,EAAMzB,EAAKI,EACXsB,EAAMxB,EAAKE,EAEjBc,EAAKK,EAAMG,EACXhB,EAAItC,EAAWmD,EACfZ,EAAMD,GAAKA,EAAIa,GACfX,EAAMW,EAAMZ,EACZD,EAAItC,EAAWsD,EACfb,EAAMH,GAAKA,EAAIgB,GACfZ,EAAMY,EAAMb,EACZM,EAAKP,EAAME,GAAOI,EAAKP,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDM,EAAKK,EAAMD,EACXd,EAAItC,EAAWqD,EACfd,EAAMD,GAAKA,EAAIe,GACfb,EAAMa,EAAMd,EACZD,EAAItC,EAAWoD,EACfX,EAAMH,GAAKA,EAAIc,GACfV,EAAMU,EAAMX,EACZQ,EAAKT,EAAME,GAAOM,EAAKT,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDC,EAAKI,EAAKE,EACVvC,EAAQqC,EAAKJ,EACbtB,EAAE,CAAC,EAAI0B,GAAMJ,EAAKjC,IAAUA,EAAQuC,GACpCL,EAAKE,EAAKH,EACVjC,EAAQkC,EAAKE,EACbD,EAAKC,GAAMF,EAAKlC,IAAUiC,EAAKjC,GAC/BiC,EAAKE,EAAKG,EACVtC,EAAQmC,EAAKF,EACbtB,EAAE,CAAC,EAAIwB,GAAMF,EAAKjC,IAAUA,EAAQsC,GACpCE,EAAKN,EAAKD,EACVjC,EAAQwC,EAAKN,EACbvB,EAAE,CAAC,EAAIuB,GAAMM,EAAKxC,IAAUiC,EAAKjC,GACjCW,EAAE,CAAC,EAAI6B,EAEP,IAAIK,EAAMvC,GAAS,EAAGK,CAAC,EACnBmC,EAAWrC,GAAec,EAoB9B,GAnBIsB,GAAOC,GAAY,CAACD,GAAOC,IAI/B9C,EAAQiB,EAAKwB,EACbjB,EAAUP,GAAMwB,EAAMzC,IAAUA,EAAQqB,GACxCrB,EAAQmB,EAAKuB,EACbhB,EAAUP,GAAMuB,EAAM1C,IAAUA,EAAQqB,GACxCrB,EAAQkB,EAAKyB,EACblB,EAAUP,GAAMyB,EAAM3C,IAAUA,EAAQsB,GACxCtB,EAAQoB,EAAKwB,EACbjB,EAAUP,GAAMwB,EAAM5C,IAAUA,EAAQsB,GAEpCE,IAAY,GAAKC,IAAY,GAAKC,IAAY,GAAKC,IAAY,KAInEmB,EAAWpC,GAAea,EAAShC,GAAiB,KAAK,IAAIsD,CAAG,EAChEA,GAAQJ,EAAMd,EAAUiB,EAAMpB,GAAYmB,EAAMjB,EAAUgB,EAAMjB,GAC5DoB,GAAOC,GAAY,CAACD,GAAOC,GAAU,OAAOD,EAEhDT,EAAKZ,EAAUoB,EACfhB,EAAItC,EAAWkC,EACfK,EAAMD,GAAKA,EAAIJ,GACfM,EAAMN,EAAUK,EAChBD,EAAItC,EAAWsD,EACfb,EAAMH,GAAKA,EAAIgB,GACfZ,EAAMY,EAAMb,EACZM,EAAKP,EAAME,GAAOI,EAAKP,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDM,EAAKb,EAAUiB,EACfd,EAAItC,EAAWmC,EACfI,EAAMD,GAAKA,EAAIH,GACfK,EAAML,EAAUI,EAChBD,EAAItC,EAAWoD,EACfX,EAAMH,GAAKA,EAAIc,GACfV,EAAMU,EAAMX,EACZQ,EAAKT,EAAME,GAAOM,EAAKT,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDC,EAAKI,EAAKE,EACVvC,EAAQqC,EAAKJ,EACblB,EAAE,CAAC,EAAIsB,GAAMJ,EAAKjC,IAAUA,EAAQuC,GACpCL,EAAKE,EAAKH,EACVjC,EAAQkC,EAAKE,EACbD,EAAKC,GAAMF,EAAKlC,IAAUiC,EAAKjC,GAC/BiC,EAAKE,EAAKG,EACVtC,EAAQmC,EAAKF,EACblB,EAAE,CAAC,EAAIoB,GAAMF,EAAKjC,IAAUA,EAAQsC,GACpCE,EAAKN,EAAKD,EACVjC,EAAQwC,EAAKN,EACbnB,EAAE,CAAC,EAAImB,GAAMM,EAAKxC,IAAUiC,EAAKjC,GACjCe,EAAE,CAAC,EAAIyB,EACP,MAAMO,EAAQvD,GAAI,EAAGmB,EAAG,EAAGI,EAAGH,EAAE,EAEhCwB,EAAKK,EAAMd,EACXC,EAAItC,EAAWmD,EACfZ,EAAMD,GAAKA,EAAIa,GACfX,EAAMW,EAAMZ,EACZD,EAAItC,EAAWqC,EACfI,EAAMH,GAAKA,EAAID,GACfK,EAAML,EAAUI,EAChBM,EAAKP,EAAME,GAAOI,EAAKP,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDM,EAAKK,EAAMjB,EACXE,EAAItC,EAAWqD,EACfd,EAAMD,GAAKA,EAAIe,GACfb,EAAMa,EAAMd,EACZD,EAAItC,EAAWoC,EACfK,EAAMH,GAAKA,EAAIF,GACfM,EAAMN,EAAUK,EAChBQ,EAAKT,EAAME,GAAOM,EAAKT,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDC,EAAKI,EAAKE,EACVvC,EAAQqC,EAAKJ,EACblB,EAAE,CAAC,EAAIsB,GAAMJ,EAAKjC,IAAUA,EAAQuC,GACpCL,EAAKE,EAAKH,EACVjC,EAAQkC,EAAKE,EACbD,EAAKC,GAAMF,EAAKlC,IAAUiC,EAAKjC,GAC/BiC,EAAKE,EAAKG,EACVtC,EAAQmC,EAAKF,EACblB,EAAE,CAAC,EAAIoB,GAAMF,EAAKjC,IAAUA,EAAQsC,GACpCE,EAAKN,EAAKD,EACVjC,EAAQwC,EAAKN,EACbnB,EAAE,CAAC,EAAImB,GAAMM,EAAKxC,IAAUiC,EAAKjC,GACjCe,EAAE,CAAC,EAAIyB,EACP,MAAMQ,EAAQxD,GAAIuD,EAAOnC,GAAI,EAAGG,EAAGF,EAAE,EAErCuB,EAAKZ,EAAUG,EACfC,EAAItC,EAAWkC,EACfK,EAAMD,GAAKA,EAAIJ,GACfM,EAAMN,EAAUK,EAChBD,EAAItC,EAAWqC,EACfI,EAAMH,GAAKA,EAAID,GACfK,EAAML,EAAUI,EAChBM,EAAKP,EAAME,GAAOI,EAAKP,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDM,EAAKb,EAAUC,EACfE,EAAItC,EAAWmC,EACfI,EAAMD,GAAKA,EAAIH,GACfK,EAAML,EAAUI,EAChBD,EAAItC,EAAWoC,EACfK,EAAMH,GAAKA,EAAIF,GACfM,EAAMN,EAAUK,EAChBQ,EAAKT,EAAME,GAAOM,EAAKT,EAAME,EAAMD,EAAMC,EAAMF,EAAMG,GACrDC,EAAKI,EAAKE,EACVvC,EAAQqC,EAAKJ,EACblB,EAAE,CAAC,EAAIsB,GAAMJ,EAAKjC,IAAUA,EAAQuC,GACpCL,EAAKE,EAAKH,EACVjC,EAAQkC,EAAKE,EACbD,EAAKC,GAAMF,EAAKlC,IAAUiC,EAAKjC,GAC/BiC,EAAKE,EAAKG,EACVtC,EAAQmC,EAAKF,EACblB,EAAE,CAAC,EAAIoB,GAAMF,EAAKjC,IAAUA,EAAQsC,GACpCE,EAAKN,EAAKD,EACVjC,EAAQwC,EAAKN,EACbnB,EAAE,CAAC,EAAImB,GAAMM,EAAKxC,IAAUiC,EAAKjC,GACjCe,EAAE,CAAC,EAAIyB,EACP,MAAMS,EAAOzD,GAAIwD,EAAOnC,GAAI,EAAGE,EAAGD,EAAC,EAEnC,OAAOA,GAAEmC,EAAO,CAAC,CACrB,CAEO,SAASC,EAASjC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CAC7C,MAAM6B,GAAWjC,EAAKI,IAAOH,EAAKE,GAC5B+B,GAAYnC,EAAKI,IAAOD,EAAKE,GAC7BuB,EAAMM,EAAUC,EAEhB7B,EAAS,KAAK,IAAI4B,EAAUC,CAAQ,EAC1C,OAAI,KAAK,IAAIP,CAAG,GAAKrC,GAAee,EAAesB,EAE5C,CAAC7B,GAAcC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAM,CACxD,CClLA,MAAM8B,GAAU,KAAK,IAAI,EAAG,GAAG,EACzBC,EAAa,IAAI,YAAY,GAAG,EAIvB,MAAMC,EAAW,CAE5B,OAAO,KAAKrN,EAAQsN,EAAOC,GAAaC,EAAOC,GAAa,CACxD,MAAM,EAAIzN,EAAO,OACX0N,EAAS,IAAI,aAAa,EAAI,CAAC,EAErC,QAAStI,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMuI,EAAI3N,EAAOoF,CAAC,EAClBsI,EAAO,EAAItI,CAAC,EAAIkI,EAAKK,CAAC,EACtBD,EAAO,EAAItI,EAAI,CAAC,EAAIoI,EAAKG,CAAC,CAC9B,CAEA,OAAO,IAAIN,GAAWK,CAAM,CAChC,CAEA,YAAYA,EAAQ,CAChB,MAAM3H,EAAI2H,EAAO,QAAU,EAC3B,GAAI3H,EAAI,GAAK,OAAO2H,EAAO,CAAC,GAAM,SAAU,MAAM,IAAI,MAAM,qCAAqC,EAEjG,KAAK,OAASA,EAGd,MAAME,EAAe,KAAK,IAAI,EAAI7H,EAAI,EAAG,CAAC,EAC1C,KAAK,WAAa,IAAI,YAAY6H,EAAe,CAAC,EAClD,KAAK,WAAa,IAAI,WAAWA,EAAe,CAAC,EAGjD,KAAK,UAAY,KAAK,KAAK,KAAK,KAAK7H,CAAC,CAAC,EACvC,KAAK,UAAY,IAAI,YAAYA,CAAC,EAClC,KAAK,UAAY,IAAI,YAAYA,CAAC,EAClC,KAAK,SAAW,IAAI,YAAYA,CAAC,EACjC,KAAK,UAAY,IAAI,WAAW,KAAK,SAAS,EAG9C,KAAK,KAAO,IAAI,YAAYA,CAAC,EAC7B,KAAK,OAAS,IAAI,aAAaA,CAAC,EAEhC,KAAK,OAAM,CACf,CAEA,QAAS,CACL,KAAM,CAAC,OAAA2H,EAAQ,UAAWG,EAAU,UAAWC,EAAU,SAAUC,EAAS,UAAWC,CAAQ,EAAK,KAC9FjI,EAAI2H,EAAO,QAAU,EAG3B,IAAIO,EAAO,IACPC,EAAO,IACPC,EAAO,KACPC,EAAO,KAEX,QAAShJ,EAAI,EAAGA,EAAIW,EAAGX,IAAK,CACxB,MAAMvE,EAAI6M,EAAO,EAAItI,CAAC,EAChBtE,EAAI4M,EAAO,EAAItI,EAAI,CAAC,EACtBvE,EAAIoN,IAAMA,EAAOpN,GACjBC,EAAIoN,IAAMA,EAAOpN,GACjBD,EAAIsN,IAAMA,EAAOtN,GACjBC,EAAIsN,IAAMA,EAAOtN,GACrB,KAAK,KAAKsE,CAAC,EAAIA,CACnB,CACA,MAAM+F,GAAM8C,EAAOE,GAAQ,EACrB/C,GAAM8C,EAAOE,GAAQ,EAE3B,IAAIC,EAAIC,EAAIC,EAGZ,QAASnJ,EAAI,EAAGoJ,EAAU,IAAUpJ,EAAIW,EAAGX,IAAK,CAC5C,MAAMR,EAAIoB,GAAKmF,EAAIC,EAAIsC,EAAO,EAAItI,CAAC,EAAGsI,EAAO,EAAItI,EAAI,CAAC,CAAC,EACnDR,EAAI4J,IACJH,EAAKjJ,EACLoJ,EAAU5J,EAElB,CACA,MAAM6J,EAAMf,EAAO,EAAIW,CAAE,EACnBK,EAAMhB,EAAO,EAAIW,EAAK,CAAC,EAG7B,QAASjJ,EAAI,EAAGoJ,EAAU,IAAUpJ,EAAIW,EAAGX,IAAK,CAC5C,GAAIA,IAAMiJ,EAAI,SACd,MAAMzJ,EAAIoB,GAAKyI,EAAKC,EAAKhB,EAAO,EAAItI,CAAC,EAAGsI,EAAO,EAAItI,EAAI,CAAC,CAAC,EACrDR,EAAI4J,GAAW5J,EAAI,IACnB0J,EAAKlJ,EACLoJ,EAAU5J,EAElB,CACA,IAAI+J,EAAMjB,EAAO,EAAIY,CAAE,EACnBM,EAAMlB,EAAO,EAAIY,EAAK,CAAC,EAEvBO,EAAY,IAGhB,QAASzJ,EAAI,EAAGA,EAAIW,EAAGX,IAAK,CACxB,GAAIA,IAAMiJ,GAAMjJ,IAAMkJ,EAAI,SAC1B,MAAMpJ,EAAI4J,GAAaL,EAAKC,EAAKC,EAAKC,EAAKlB,EAAO,EAAItI,CAAC,EAAGsI,EAAO,EAAItI,EAAI,CAAC,CAAC,EACvEF,EAAI2J,IACJN,EAAKnJ,EACLyJ,EAAY3J,EAEpB,CACA,IAAI6J,EAAMrB,EAAO,EAAIa,CAAE,EACnBS,EAAMtB,EAAO,EAAIa,EAAK,CAAC,EAE3B,GAAIM,IAAc,IAAU,CAGxB,QAASzJ,EAAI,EAAGA,EAAIW,EAAGX,IACnB,KAAK,OAAOA,CAAC,EAAKsI,EAAO,EAAItI,CAAC,EAAIsI,EAAO,CAAC,GAAOA,EAAO,EAAItI,EAAI,CAAC,EAAIsI,EAAO,CAAC,EAEjFuB,EAAU,KAAK,KAAM,KAAK,OAAQ,EAAGlJ,EAAI,CAAC,EAC1C,MAAMmJ,EAAO,IAAI,YAAYnJ,CAAC,EAC9B,IAAIoJ,EAAI,EACR,QAAS/J,EAAI,EAAGgK,EAAK,KAAWhK,EAAIW,EAAGX,IAAK,CACxC,MAAMiK,EAAK,KAAK,KAAKjK,CAAC,EAChBR,EAAI,KAAK,OAAOyK,CAAE,EACpBzK,EAAIwK,IACJF,EAAKC,GAAG,EAAIE,EACZD,EAAKxK,EAEb,CACA,KAAK,KAAOsK,EAAK,SAAS,EAAGC,CAAC,EAC9B,KAAK,UAAY,IAAI,YAAY,CAAC,EAClC,KAAK,UAAY,IAAI,YAAY,CAAC,EAClC,MACJ,CAGA,GAAInC,EAASyB,EAAKC,EAAKC,EAAKC,EAAKG,EAAKC,CAAG,EAAI,EAAG,CAC5C,MAAM5J,EAAIkJ,EACJzN,EAAI8N,EACJ7N,EAAI8N,EACVN,EAAKC,EACLI,EAAMI,EACNH,EAAMI,EACNT,EAAKnJ,EACL2J,EAAMlO,EACNmO,EAAMlO,CACV,CAEA,MAAMwO,EAASC,GAAad,EAAKC,EAAKC,EAAKC,EAAKG,EAAKC,CAAG,EACxD,KAAK,IAAMM,EAAO,EAClB,KAAK,IAAMA,EAAO,EAElB,QAASlK,EAAI,EAAGA,EAAIW,EAAGX,IACnB,KAAK,OAAOA,CAAC,EAAIY,GAAK0H,EAAO,EAAItI,CAAC,EAAGsI,EAAO,EAAItI,EAAI,CAAC,EAAGkK,EAAO,EAAGA,EAAO,CAAC,EAI9EL,EAAU,KAAK,KAAM,KAAK,OAAQ,EAAGlJ,EAAI,CAAC,EAG1C,KAAK,WAAasI,EAClB,IAAImB,EAAW,EAEf1B,EAASO,CAAE,EAAIR,EAASU,CAAE,EAAID,EAC9BR,EAASQ,CAAE,EAAIT,EAASQ,CAAE,EAAIE,EAC9BT,EAASS,CAAE,EAAIV,EAASS,CAAE,EAAID,EAE9BN,EAAQM,CAAE,EAAI,EACdN,EAAQO,CAAE,EAAI,EACdP,EAAQQ,CAAE,EAAI,EAEdP,EAAS,KAAK,EAAE,EAChBA,EAAS,KAAK,SAASS,EAAKC,CAAG,CAAC,EAAIL,EACpCL,EAAS,KAAK,SAASW,EAAKC,CAAG,CAAC,EAAIN,EACpCN,EAAS,KAAK,SAASe,EAAKC,CAAG,CAAC,EAAIT,EAEpC,KAAK,aAAe,EACpB,KAAK,aAAaF,EAAIC,EAAIC,EAAI,GAAI,GAAI,EAAE,EAExC,QAASkB,EAAI,EAAGC,EAAIC,EAAIF,EAAI,KAAK,KAAK,OAAQA,IAAK,CAC/C,MAAMrK,EAAI,KAAK,KAAKqK,CAAC,EACf5O,EAAI6M,EAAO,EAAItI,CAAC,EAChBtE,EAAI4M,EAAO,EAAItI,EAAI,CAAC,EAQ1B,GALIqK,EAAI,GAAK,KAAK,IAAI5O,EAAI6O,CAAE,GAAKvC,IAAW,KAAK,IAAIrM,EAAI6O,CAAE,GAAKxC,KAChEuC,EAAK7O,EACL8O,EAAK7O,EAGDsE,IAAMiJ,GAAMjJ,IAAMkJ,GAAMlJ,IAAMmJ,GAAI,SAGtC,IAAIqB,EAAQ,EACZ,QAAST,EAAI,EAAGU,GAAM,KAAK,SAAShP,EAAGC,CAAC,EAAGqO,EAAI,KAAK,YAChDS,EAAQ5B,GAAU6B,GAAMV,GAAK,KAAK,SAAS,EACvC,EAAAS,IAAU,IAAMA,IAAU9B,EAAS8B,CAAK,IAFeT,IAE3D,CAGJS,EAAQ/B,EAAS+B,CAAK,EACtB,IAAI5N,EAAI4N,EAAOE,EACf,KAAOA,EAAIhC,EAAS9L,CAAC,EAAGgL,EAASnM,EAAGC,EAAG4M,EAAO,EAAI1L,CAAC,EAAG0L,EAAO,EAAI1L,EAAI,CAAC,EAAG0L,EAAO,EAAIoC,CAAC,EAAGpC,EAAO,EAAIoC,EAAI,CAAC,CAAC,GAAK,GAE1G,GADA9N,EAAI8N,EACA9N,IAAM4N,EAAO,CACb5N,EAAI,GACJ,KACJ,CAEJ,GAAIA,IAAM,GAAI,SAGd,IAAI3C,EAAI,KAAK,aAAa2C,EAAGoD,EAAG0I,EAAS9L,CAAC,EAAG,GAAI,GAAI+L,EAAQ/L,CAAC,CAAC,EAG/D+L,EAAQ3I,CAAC,EAAI,KAAK,UAAU/F,EAAI,CAAC,EACjC0O,EAAQ/L,CAAC,EAAI3C,EACbmQ,IAGA,IAAIzJ,EAAI+H,EAAS9L,CAAC,EAClB,KAAO8N,EAAIhC,EAAS/H,CAAC,EAAGiH,EAASnM,EAAGC,EAAG4M,EAAO,EAAI3H,CAAC,EAAG2H,EAAO,EAAI3H,EAAI,CAAC,EAAG2H,EAAO,EAAIoC,CAAC,EAAGpC,EAAO,EAAIoC,EAAI,CAAC,CAAC,EAAI,GACzGzQ,EAAI,KAAK,aAAa0G,EAAGX,EAAG0K,EAAG/B,EAAQ3I,CAAC,EAAG,GAAI2I,EAAQhI,CAAC,CAAC,EACzDgI,EAAQ3I,CAAC,EAAI,KAAK,UAAU/F,EAAI,CAAC,EACjCyO,EAAS/H,CAAC,EAAIA,EACdyJ,IACAzJ,EAAI+J,EAIR,GAAI9N,IAAM4N,EACN,KAAOE,EAAIjC,EAAS7L,CAAC,EAAGgL,EAASnM,EAAGC,EAAG4M,EAAO,EAAIoC,CAAC,EAAGpC,EAAO,EAAIoC,EAAI,CAAC,EAAGpC,EAAO,EAAI1L,CAAC,EAAG0L,EAAO,EAAI1L,EAAI,CAAC,CAAC,EAAI,GACzG3C,EAAI,KAAK,aAAayQ,EAAG1K,EAAGpD,EAAG,GAAI+L,EAAQ/L,CAAC,EAAG+L,EAAQ+B,CAAC,CAAC,EACzD,KAAK,UAAUzQ,EAAI,CAAC,EACpB0O,EAAQ+B,CAAC,EAAIzQ,EACbyO,EAAS9L,CAAC,EAAIA,EACdwN,IACAxN,EAAI8N,EAKZ,KAAK,WAAajC,EAASzI,CAAC,EAAIpD,EAChC8L,EAAS9L,CAAC,EAAI6L,EAAS9H,CAAC,EAAIX,EAC5B0I,EAAS1I,CAAC,EAAIW,EAGdiI,EAAS,KAAK,SAASnN,EAAGC,CAAC,CAAC,EAAIsE,EAChC4I,EAAS,KAAK,SAASN,EAAO,EAAI1L,CAAC,EAAG0L,EAAO,EAAI1L,EAAI,CAAC,CAAC,CAAC,EAAIA,CAChE,CAEA,KAAK,KAAO,IAAI,YAAYwN,CAAQ,EACpC,QAASpK,EAAI,EAAGpD,EAAI,KAAK,WAAYoD,EAAIoK,EAAUpK,IAC/C,KAAK,KAAKA,CAAC,EAAIpD,EACfA,EAAI8L,EAAS9L,CAAC,EAIlB,KAAK,UAAY,KAAK,WAAW,SAAS,EAAG,KAAK,YAAY,EAC9D,KAAK,UAAY,KAAK,WAAW,SAAS,EAAG,KAAK,YAAY,CAClE,CAEA,SAASnB,EAAGC,EAAG,CACX,OAAO,KAAK,MAAMiP,GAAYlP,EAAI,KAAK,IAAKC,EAAI,KAAK,GAAG,EAAI,KAAK,SAAS,EAAI,KAAK,SACvF,CAEA,UAAUpC,EAAG,CACT,KAAM,CAAC,WAAYsR,EAAW,WAAYC,EAAW,OAAAvC,CAAM,EAAI,KAE/D,IAAItI,EAAI,EACJ8K,EAAK,EAGT,OAAa,CACT,MAAMvR,EAAIsR,EAAUvR,CAAC,EAiBfyR,EAAKzR,EAAIA,EAAI,EAGnB,GAFAwR,EAAKC,GAAMzR,EAAI,GAAK,EAEhBC,IAAM,GAAI,CACV,GAAIyG,IAAM,EAAG,MACb1G,EAAI0O,EAAW,EAAEhI,CAAC,EAClB,QACJ,CAEA,MAAMgL,EAAKzR,EAAIA,EAAI,EACb0R,EAAKF,GAAMzR,EAAI,GAAK,EACpB4R,EAAKF,GAAMzR,EAAI,GAAK,EAEpB4R,EAAKP,EAAUE,CAAE,EACjBM,EAAKR,EAAUtR,CAAC,EAChB+R,EAAKT,EAAUK,CAAE,EACjBK,EAAKV,EAAUM,CAAE,EAQvB,GANgBK,GACZjD,EAAO,EAAI6C,CAAE,EAAG7C,EAAO,EAAI6C,EAAK,CAAC,EACjC7C,EAAO,EAAI8C,CAAE,EAAG9C,EAAO,EAAI8C,EAAK,CAAC,EACjC9C,EAAO,EAAI+C,CAAE,EAAG/C,EAAO,EAAI+C,EAAK,CAAC,EACjC/C,EAAO,EAAIgD,CAAE,EAAGhD,EAAO,EAAIgD,EAAK,CAAC,CAAC,EAEzB,CACTV,EAAUtR,CAAC,EAAIgS,EACfV,EAAUrR,CAAC,EAAI4R,EAEf,MAAMK,EAAMX,EAAUK,CAAE,EAGxB,GAAIM,IAAQ,GAAI,CACZ,IAAI5O,EAAI,KAAK,WACb,EAAG,CACC,GAAI,KAAK,SAASA,CAAC,IAAMsO,EAAI,CACzB,KAAK,SAAStO,CAAC,EAAItD,EACnB,KACJ,CACAsD,EAAI,KAAK,UAAUA,CAAC,CACxB,OAASA,IAAM,KAAK,WACxB,CACA,KAAK,MAAMtD,EAAGkS,CAAG,EACjB,KAAK,MAAMjS,EAAGsR,EAAUC,CAAE,CAAC,EAC3B,KAAK,MAAMA,EAAII,CAAE,EAEjB,MAAMO,EAAKT,GAAMzR,EAAI,GAAK,EAGtByG,EAAIgI,EAAW,SACfA,EAAWhI,GAAG,EAAIyL,EAE1B,KAAO,CACH,GAAIzL,IAAM,EAAG,MACb1G,EAAI0O,EAAW,EAAEhI,CAAC,CACtB,CACJ,CAEA,OAAO8K,CACX,CAEA,MAAMxR,EAAGC,EAAG,CACR,KAAK,WAAWD,CAAC,EAAIC,EACjBA,IAAM,KAAI,KAAK,WAAWA,CAAC,EAAID,EACvC,CAGA,aAAa2P,EAAIC,EAAIC,EAAI7P,EAAGC,EAAG+M,EAAG,CAC9B,MAAMrM,EAAI,KAAK,aAEf,YAAK,WAAWA,CAAC,EAAIgP,EACrB,KAAK,WAAWhP,EAAI,CAAC,EAAIiP,EACzB,KAAK,WAAWjP,EAAI,CAAC,EAAIkP,EAEzB,KAAK,MAAMlP,EAAGX,CAAC,EACf,KAAK,MAAMW,EAAI,EAAGV,CAAC,EACnB,KAAK,MAAMU,EAAI,EAAGqM,CAAC,EAEnB,KAAK,cAAgB,EAEdrM,CACX,CACJ,CAGA,SAAS0Q,GAAYe,EAAIC,EAAI,CACzB,MAAMpD,EAAImD,GAAM,KAAK,IAAIA,CAAE,EAAI,KAAK,IAAIC,CAAE,GAC1C,OAAQA,EAAK,EAAI,EAAIpD,EAAI,EAAIA,GAAK,CACtC,CAEA,SAAS3H,GAAK+E,EAAIC,EAAIC,EAAIC,EAAI,CAC1B,MAAM4F,EAAK/F,EAAKE,EACV8F,EAAK/F,EAAKE,EAChB,OAAO4F,EAAKA,EAAKC,EAAKA,CAC1B,CAEA,SAASJ,GAAS5F,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI4F,EAAIC,EAAI,CAC9C,MAAMH,EAAK/F,EAAKiG,EACVD,EAAK/F,EAAKiG,EACVC,EAAKjG,EAAK+F,EACVG,EAAKjG,EAAK+F,EACVG,EAAKjG,EAAK6F,EACVK,EAAKjG,EAAK6F,EAEVK,EAAKR,EAAKA,EAAKC,EAAKA,EACpBQ,EAAKL,EAAKA,EAAKC,EAAKA,EACpBK,EAAKJ,EAAKA,EAAKC,EAAKA,EAE1B,OAAOP,GAAMK,EAAKK,EAAKD,EAAKF,GACrBN,GAAMG,EAAKM,EAAKD,EAAKH,GACrBE,GAAMJ,EAAKG,EAAKF,EAAKC,GAAM,CACtC,CAEA,SAAStC,GAAa/D,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CAC1C,MAAM0F,EAAK7F,EAAKF,EACVgG,EAAK7F,EAAKF,EACVkG,EAAK/F,EAAKJ,EACVoG,EAAK/F,EAAKJ,EAEVsF,EAAKQ,EAAKA,EAAKC,EAAKA,EACpBU,EAAKP,EAAKA,EAAKC,EAAKA,EACpB,EAAI,IAAOL,EAAKK,EAAKJ,EAAKG,GAE1BrQ,GAAKsQ,EAAKb,EAAKS,EAAKU,GAAM,EAC1B3Q,GAAKgQ,EAAKW,EAAKP,EAAKZ,GAAM,EAEhC,OAAOzP,EAAIA,EAAIC,EAAIA,CACvB,CAEA,SAASyO,GAAaxE,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CAC1C,MAAM0F,EAAK7F,EAAKF,EACVgG,EAAK7F,EAAKF,EACVkG,EAAK/F,EAAKJ,EACVoG,EAAK/F,EAAKJ,EAEVsF,EAAKQ,EAAKA,EAAKC,EAAKA,EACpBU,EAAKP,EAAKA,EAAKC,EAAKA,EACpB,EAAI,IAAOL,EAAKK,EAAKJ,EAAKG,GAE1BrQ,EAAIkK,GAAMoG,EAAKb,EAAKS,EAAKU,GAAM,EAC/B3Q,EAAIkK,GAAM8F,EAAKW,EAAKP,EAAKZ,GAAM,EAErC,MAAO,CAAC,EAAAzP,EAAG,EAAAC,CAAC,CAChB,CAEA,SAASmO,EAAUyC,EAAKC,EAAOC,EAAMC,EAAO,CACxC,GAAIA,EAAQD,GAAQ,GAChB,QAASxM,EAAIwM,EAAO,EAAGxM,GAAKyM,EAAOzM,IAAK,CACpC,MAAM0M,EAAOJ,EAAItM,CAAC,EACZ2M,EAAWJ,EAAMG,CAAI,EAC3B,IAAI3C,EAAI/J,EAAI,EACZ,KAAO+J,GAAKyC,GAAQD,EAAMD,EAAIvC,CAAC,CAAC,EAAI4C,GAAUL,EAAIvC,EAAI,CAAC,EAAIuC,EAAIvC,GAAG,EAClEuC,EAAIvC,EAAI,CAAC,EAAI2C,CACjB,KACG,CACH,MAAME,EAAUJ,EAAOC,GAAU,EACjC,IAAIzM,EAAIwM,EAAO,EACXzC,EAAI0C,EACRI,EAAKP,EAAKM,EAAQ5M,CAAC,EACfuM,EAAMD,EAAIE,CAAI,CAAC,EAAID,EAAMD,EAAIG,CAAK,CAAC,GAAGI,EAAKP,EAAKE,EAAMC,CAAK,EAC3DF,EAAMD,EAAItM,CAAC,CAAC,EAAIuM,EAAMD,EAAIG,CAAK,CAAC,GAAGI,EAAKP,EAAKtM,EAAGyM,CAAK,EACrDF,EAAMD,EAAIE,CAAI,CAAC,EAAID,EAAMD,EAAItM,CAAC,CAAC,GAAG6M,EAAKP,EAAKE,EAAMxM,CAAC,EAEvD,MAAM0M,EAAOJ,EAAItM,CAAC,EACZ2M,EAAWJ,EAAMG,CAAI,EAC3B,OAAa,CACT,GAAG1M,UAAYuM,EAAMD,EAAItM,CAAC,CAAC,EAAI2M,GAC/B,GAAG5C,UAAYwC,EAAMD,EAAIvC,CAAC,CAAC,EAAI4C,GAC/B,GAAI5C,EAAI/J,EAAG,MACX6M,EAAKP,EAAKtM,EAAG+J,CAAC,CAClB,CACAuC,EAAIE,EAAO,CAAC,EAAIF,EAAIvC,CAAC,EACrBuC,EAAIvC,CAAC,EAAI2C,EAELD,EAAQzM,EAAI,GAAK+J,EAAIyC,GACrB3C,EAAUyC,EAAKC,EAAOvM,EAAGyM,CAAK,EAC9B5C,EAAUyC,EAAKC,EAAOC,EAAMzC,EAAI,CAAC,IAEjCF,EAAUyC,EAAKC,EAAOC,EAAMzC,EAAI,CAAC,EACjCF,EAAUyC,EAAKC,EAAOvM,EAAGyM,CAAK,EAEtC,CACJ,CAEA,SAASI,EAAKC,EAAK9M,EAAG+J,EAAG,CACrB,MAAMgD,EAAMD,EAAI9M,CAAC,EACjB8M,EAAI9M,CAAC,EAAI8M,EAAI/C,CAAC,EACd+C,EAAI/C,CAAC,EAAIgD,CACb,CAEA,SAAS5E,GAAYI,EAAG,CACpB,OAAOA,EAAE,CAAC,CACd,CACA,SAASF,GAAYE,EAAG,CACpB,OAAOA,EAAE,CAAC,CACd,CC/dA,MAAMxE,GAAU,KAED,MAAMiJ,CAAK,CACxB,aAAc,CACZ,KAAK,IAAM,KAAK,IAChB,KAAK,IAAM,KAAK,IAAM,KACtB,KAAK,EAAI,EACX,CACA,OAAOvR,EAAGC,EAAG,CACX,KAAK,GAAK,IAAI,KAAK,IAAM,KAAK,IAAM,CAACD,CAAC,IAAI,KAAK,IAAM,KAAK,IAAM,CAACC,CAAC,EACpE,CACA,WAAY,CACN,KAAK,MAAQ,OACf,KAAK,IAAM,KAAK,IAAK,KAAK,IAAM,KAAK,IACrC,KAAK,GAAK,IAEd,CACA,OAAOD,EAAGC,EAAG,CACX,KAAK,GAAK,IAAI,KAAK,IAAM,CAACD,CAAC,IAAI,KAAK,IAAM,CAACC,CAAC,EAC9C,CACA,IAAID,EAAGC,EAAG,EAAG,CACXD,EAAI,CAACA,EAAGC,EAAI,CAACA,EAAG,EAAI,CAAC,EACrB,MAAMuR,EAAKxR,EAAI,EACTyR,EAAKxR,EACX,GAAI,EAAI,EAAG,MAAM,IAAI,MAAM,iBAAiB,EACxC,KAAK,MAAQ,KAAM,KAAK,GAAK,IAAIuR,CAAE,IAAIC,CAAE,IACpC,KAAK,IAAI,KAAK,IAAMD,CAAE,EAAIlJ,IAAW,KAAK,IAAI,KAAK,IAAMmJ,CAAE,EAAInJ,MAAS,KAAK,GAAK,IAAMkJ,EAAK,IAAMC,GACvG,IACL,KAAK,GAAK,IAAI,CAAC,IAAI,CAAC,UAAUzR,EAAI,CAAC,IAAIC,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,KAAK,IAAMuR,CAAE,IAAI,KAAK,IAAMC,CAAE,GAC5F,CACA,KAAKzR,EAAGC,EAAGyR,EAAG7I,EAAG,CACf,KAAK,GAAK,IAAI,KAAK,IAAM,KAAK,IAAM,CAAC7I,CAAC,IAAI,KAAK,IAAM,KAAK,IAAM,CAACC,CAAC,IAAI,CAACyR,CAAC,IAAI,CAAC7I,CAAC,IAAI,CAAC6I,CAAC,GACtF,CACA,OAAQ,CACN,OAAO,KAAK,GAAK,IACnB,CACF,CCpCe,MAAMC,EAAQ,CAC3B,aAAc,CACZ,KAAK,EAAI,CAAA,CACX,CACA,OAAO3R,EAAGC,EAAG,CACX,KAAK,EAAE,KAAK,CAACD,EAAGC,CAAC,CAAC,CACpB,CACA,WAAY,CACV,KAAK,EAAE,KAAK,KAAK,EAAE,CAAC,EAAE,OAAO,CAC/B,CACA,OAAOD,EAAGC,EAAG,CACX,KAAK,EAAE,KAAK,CAACD,EAAGC,CAAC,CAAC,CACpB,CACA,OAAQ,CACN,OAAO,KAAK,EAAE,OAAS,KAAK,EAAI,IAClC,CACF,CCbe,MAAM2R,EAAQ,CAC3B,YAAYC,EAAU,CAACC,EAAMC,EAAMC,EAAMC,CAAI,EAAI,CAAC,EAAG,EAAG,IAAK,GAAG,EAAG,CACjE,GAAI,GAAGD,EAAO,CAACA,KAAUF,EAAO,CAACA,KAAU,GAAGG,EAAO,CAACA,KAAUF,EAAO,CAACA,IAAQ,MAAM,IAAI,MAAM,gBAAgB,EAChH,KAAK,SAAWF,EAChB,KAAK,eAAiB,IAAI,aAAaA,EAAS,OAAO,OAAS,CAAC,EACjE,KAAK,QAAU,IAAI,aAAaA,EAAS,OAAO,OAAS,CAAC,EAC1D,KAAK,KAAOG,EAAM,KAAK,KAAOF,EAC9B,KAAK,KAAOG,EAAM,KAAK,KAAOF,EAC9B,KAAK,MAAK,CACZ,CACA,QAAS,CACP,YAAK,SAAS,OAAM,EACpB,KAAK,MAAK,EACH,IACT,CACA,OAAQ,CACN,KAAM,CAAC,SAAU,CAAC,OAAA5S,EAAQ,KAAAkP,EAAM,UAAAc,CAAS,EAAG,QAAA+C,CAAO,EAAI,KACvD,IAAI9H,EAAIC,EAGR,MAAM8H,EAAgB,KAAK,cAAgB,KAAK,eAAe,SAAS,EAAGhD,EAAU,OAAS,EAAI,CAAC,EACnG,QAAS5K,EAAI,EAAG+J,EAAI,EAAGpJ,EAAIiK,EAAU,OAAQnP,EAAGC,EAAGsE,EAAIW,EAAGX,GAAK,EAAG+J,GAAK,EAAG,CACxE,MAAM/C,EAAK4D,EAAU5K,CAAC,EAAI,EACpB6N,EAAKjD,EAAU5K,EAAI,CAAC,EAAI,EACxB8N,EAAKlD,EAAU5K,EAAI,CAAC,EAAI,EACxB+N,EAAKnT,EAAOoM,CAAE,EACdgH,EAAKpT,EAAOoM,EAAK,CAAC,EAClBiH,EAAKrT,EAAOiT,CAAE,EACdK,EAAKtT,EAAOiT,EAAK,CAAC,EAClBM,EAAKvT,EAAOkT,CAAE,EACdM,EAAKxT,EAAOkT,EAAK,CAAC,EAElBpC,EAAKuC,EAAKF,EACVpC,EAAKuC,EAAKF,EACVlC,EAAKqC,EAAKJ,EACVhC,EAAKqC,EAAKJ,EACVK,GAAM3C,EAAKK,EAAKJ,EAAKG,GAAM,EAEjC,GAAI,KAAK,IAAIuC,CAAE,EAAI,KAAM,CAIvB,GAAIxI,IAAO,OAAW,CACpBA,EAAKC,EAAK,EACV,UAAW9F,KAAK8J,EAAMjE,GAAMjL,EAAOoF,EAAI,CAAC,EAAG8F,GAAMlL,EAAOoF,EAAI,EAAI,CAAC,EACjE6F,GAAMiE,EAAK,OAAQhE,GAAMgE,EAAK,MAChC,CACA,MAAMxQ,EAAI,IAAM,KAAK,MAAMuM,EAAKkI,GAAMhC,GAAMjG,EAAKkI,GAAMlC,CAAE,EACzDrQ,GAAKsS,EAAKI,GAAM,EAAI7U,EAAIyS,EACxBrQ,GAAKsS,EAAKI,GAAM,EAAI9U,EAAIwS,CAC1B,KAAO,CACL,MAAMtM,EAAI,EAAI6O,EACRnD,EAAKQ,EAAKA,EAAKC,EAAKA,EACpBU,EAAKP,EAAKA,EAAKC,EAAKA,EAC1BtQ,EAAIsS,GAAMhC,EAAKb,EAAKS,EAAKU,GAAM7M,EAC/B9D,EAAIsS,GAAMtC,EAAKW,EAAKP,EAAKZ,GAAM1L,CACjC,CACAoO,EAAc7D,CAAC,EAAItO,EACnBmS,EAAc7D,EAAI,CAAC,EAAIrO,CACzB,CAGA,IAAI4I,EAAIwF,EAAKA,EAAK,OAAS,CAAC,EACxBqB,EAAIG,EAAKhH,EAAI,EACb2I,EAAIc,EAAKnT,EAAO,EAAI0J,CAAC,EACrB4I,EAAIc,EAAKpT,EAAO,EAAI0J,EAAI,CAAC,EAC7BqJ,EAAQ,KAAK,CAAC,EACd,QAAS3N,EAAI,EAAGA,EAAI8J,EAAK,OAAQ,EAAE9J,EACjCsE,EAAIwF,EAAK9J,CAAC,EACVmL,EAAKG,EAAI2B,EAAKc,EAAIb,EAAKc,EACvB1C,EAAKhH,EAAI,EAAGyJ,EAAKnT,EAAO,EAAI0J,CAAC,EAAG0J,EAAKpT,EAAO,EAAI0J,EAAI,CAAC,EACrDqJ,EAAQxC,EAAK,CAAC,EAAIwC,EAAQrC,CAAE,EAAI4B,EAAKc,EACrCL,EAAQxC,EAAK,CAAC,EAAIwC,EAAQrC,EAAK,CAAC,EAAIyC,EAAKd,CAE7C,CACA,OAAOqB,EAAS,CACd,MAAMC,EAASD,GAAW,KAAOA,EAAU,IAAItB,EAAO,OAChD,CAAC,SAAU,CAAC,UAAAnC,EAAW,QAAA2D,EAAS,KAAA1E,CAAI,EAAG,cAAA8D,EAAe,QAAAD,CAAO,EAAI,KACvE,GAAI7D,EAAK,QAAU,EAAG,OAAO,KAC7B,QAAS9J,EAAI,EAAGW,EAAIkK,EAAU,OAAQ7K,EAAIW,EAAG,EAAEX,EAAG,CAChD,MAAM+J,EAAIc,EAAU7K,CAAC,EACrB,GAAI+J,EAAI/J,EAAG,SACX,MAAMyO,EAAK,KAAK,MAAMzO,EAAI,CAAC,EAAI,EACzB0O,EAAK,KAAK,MAAM3E,EAAI,CAAC,EAAI,EACzB4E,EAAKf,EAAca,CAAE,EACrBG,EAAKhB,EAAca,EAAK,CAAC,EACzBI,EAAKjB,EAAcc,CAAE,EACrBI,EAAKlB,EAAcc,EAAK,CAAC,EAC/B,KAAK,eAAeC,EAAIC,EAAIC,EAAIC,EAAIR,CAAO,CAC7C,CACA,IAAIS,EAAIC,EAAKlF,EAAKA,EAAK,OAAS,CAAC,EACjC,QAAS9J,EAAI,EAAGA,EAAI8J,EAAK,OAAQ,EAAE9J,EAAG,CACpC+O,EAAKC,EAAIA,EAAKlF,EAAK9J,CAAC,EACpB,MAAM/F,EAAI,KAAK,MAAMuU,EAAQQ,CAAE,EAAI,CAAC,EAAI,EAClCvT,EAAImS,EAAc3T,CAAC,EACnByB,EAAIkS,EAAc3T,EAAI,CAAC,EACvByF,EAAIqP,EAAK,EACT,EAAI,KAAK,SAAStT,EAAGC,EAAGiS,EAAQjO,EAAI,CAAC,EAAGiO,EAAQjO,EAAI,CAAC,CAAC,EACxD,GAAG,KAAK,eAAejE,EAAGC,EAAG,EAAE,CAAC,EAAG,EAAE,CAAC,EAAG4S,CAAO,CACtD,CACA,OAAOC,GAAUA,EAAO,MAAK,CAC/B,CACA,aAAaD,EAAS,CACpB,MAAMC,EAASD,GAAW,KAAOA,EAAU,IAAItB,EAAO,OACtD,OAAAsB,EAAQ,KAAK,KAAK,KAAM,KAAK,KAAM,KAAK,KAAO,KAAK,KAAM,KAAK,KAAO,KAAK,IAAI,EACxEC,GAAUA,EAAO,MAAK,CAC/B,CACA,WAAWvO,EAAGsO,EAAS,CACrB,MAAMC,EAASD,GAAW,KAAOA,EAAU,IAAItB,EAAO,OAChDpS,EAAS,KAAK,MAAMoF,CAAC,EAC3B,GAAIpF,IAAW,MAAQ,CAACA,EAAO,OAAQ,OACvC0T,EAAQ,OAAO1T,EAAO,CAAC,EAAGA,EAAO,CAAC,CAAC,EACnC,IAAI+F,EAAI/F,EAAO,OACf,KAAOA,EAAO,CAAC,IAAMA,EAAO+F,EAAE,CAAC,GAAK/F,EAAO,CAAC,IAAMA,EAAO+F,EAAE,CAAC,GAAKA,EAAI,GAAGA,GAAK,EAC7E,QAASX,EAAI,EAAGA,EAAIW,EAAGX,GAAK,GACtBpF,EAAOoF,CAAC,IAAMpF,EAAOoF,EAAE,CAAC,GAAKpF,EAAOoF,EAAE,CAAC,IAAMpF,EAAOoF,EAAE,CAAC,IACzDsO,EAAQ,OAAO1T,EAAOoF,CAAC,EAAGpF,EAAOoF,EAAI,CAAC,CAAC,EAE3C,OAAAsO,EAAQ,UAAS,EACVC,GAAUA,EAAO,MAAK,CAC/B,CACA,CAAC,cAAe,CACd,KAAM,CAAC,SAAU,CAAC,OAAA3T,CAAM,CAAC,EAAI,KAC7B,QAAS,EAAI,EAAG+F,EAAI/F,EAAO,OAAS,EAAG,EAAI+F,EAAG,EAAE,EAAG,CACjD,MAAMsO,EAAO,KAAK,YAAY,CAAC,EAC3BA,IAAMA,EAAK,MAAQ,EAAG,MAAMA,EAClC,CACF,CACA,YAAYjP,EAAG,CACb,MAAMkP,EAAU,IAAI9B,GACpB,YAAK,WAAWpN,EAAGkP,CAAO,EACnBA,EAAQ,MAAK,CACtB,CACA,eAAejC,EAAIC,EAAIa,EAAIC,EAAIM,EAAS,CACtC,IAAIa,EACJ,MAAMC,EAAK,KAAK,YAAYnC,EAAIC,CAAE,EAC5BmC,EAAK,KAAK,YAAYtB,EAAIC,CAAE,EAC9BoB,IAAO,GAAKC,IAAO,GACrBf,EAAQ,OAAOrB,EAAIC,CAAE,EACrBoB,EAAQ,OAAOP,EAAIC,CAAE,IACZmB,EAAI,KAAK,aAAalC,EAAIC,EAAIa,EAAIC,EAAIoB,EAAIC,CAAE,KACrDf,EAAQ,OAAOa,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EACzBb,EAAQ,OAAOa,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAE7B,CACA,SAASnP,EAAGvE,EAAGC,EAAG,CAChB,OAAKD,EAAI,CAACA,EAAGA,IAAMA,IAAOC,EAAI,CAACA,EAAGA,IAAMA,GAAW,GAC5C,KAAK,SAAS,MAAMsE,EAAGvE,EAAGC,CAAC,IAAMsE,CAC1C,CACA,CAAC,UAAUA,EAAG,CACZ,MAAMsP,EAAK,KAAK,MAAMtP,CAAC,EACvB,GAAIsP,EAAI,UAAWvF,KAAK,KAAK,SAAS,UAAU/J,CAAC,EAAG,CAClD,MAAMuP,EAAK,KAAK,MAAMxF,CAAC,EAEvB,GAAIwF,GAAIC,EAAM,QAASC,EAAK,EAAGC,EAAKJ,EAAG,OAAQG,EAAKC,EAAID,GAAM,EAC5D,QAASE,EAAK,EAAGC,EAAKL,EAAG,OAAQI,EAAKC,EAAID,GAAM,EAC9C,GAAIL,EAAGG,CAAE,IAAMF,EAAGI,CAAE,GACbL,EAAGG,EAAK,CAAC,IAAMF,EAAGI,EAAK,CAAC,GACxBL,GAAIG,EAAK,GAAKC,CAAE,IAAMH,GAAII,EAAKC,EAAK,GAAKA,CAAE,GAC3CN,GAAIG,EAAK,GAAKC,CAAE,IAAMH,GAAII,EAAKC,EAAK,GAAKA,CAAE,EAAG,CACnD,MAAM7F,EACN,MAAMyF,CACR,EAGN,CACF,CACA,MAAMxP,EAAG,CACP,KAAM,CAAC,cAAA4N,EAAe,SAAU,CAAC,QAAAY,EAAS,UAAA3D,EAAW,UAAAD,CAAS,CAAC,EAAI,KAC7DiF,EAAKrB,EAAQxO,CAAC,EACpB,GAAI6P,IAAO,GAAI,OAAO,KACtB,MAAMjV,EAAS,CAAA,EACf,IAAIgC,EAAIiT,EACR,EAAG,CACD,MAAM5V,EAAI,KAAK,MAAM2C,EAAI,CAAC,EAG1B,GAFAhC,EAAO,KAAKgT,EAAc3T,EAAI,CAAC,EAAG2T,EAAc3T,EAAI,EAAI,CAAC,CAAC,EAC1D2C,EAAIA,EAAI,IAAM,EAAIA,EAAI,EAAIA,EAAI,EAC1BgO,EAAUhO,CAAC,IAAMoD,EAAG,MACxBpD,EAAIiO,EAAUjO,CAAC,CACjB,OAASA,IAAMiT,GAAMjT,IAAM,IAC3B,OAAOhC,CACT,CACA,MAAMoF,EAAG,CAEP,GAAIA,IAAM,GAAK,KAAK,SAAS,KAAK,SAAW,EAC3C,MAAO,CAAC,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,IAAI,EAEhG,MAAMpF,EAAS,KAAK,MAAMoF,CAAC,EAC3B,GAAIpF,IAAW,KAAM,OAAO,KAC5B,KAAM,CAAC,QAASkV,CAAC,EAAI,KACfpQ,EAAIM,EAAI,EACd,OAAO,KAAK,UAAU8P,EAAEpQ,CAAC,GAAKoQ,EAAEpQ,EAAI,CAAC,EAC/B,KAAK,cAAcM,EAAGpF,EAAQkV,EAAEpQ,CAAC,EAAGoQ,EAAEpQ,EAAI,CAAC,EAAGoQ,EAAEpQ,EAAI,CAAC,EAAGoQ,EAAEpQ,EAAI,CAAC,CAAC,EAChE,KAAK,YAAYM,EAAGpF,CAAM,CAAC,CACnC,CACA,YAAYoF,EAAGpF,EAAQ,CACrB,MAAM+F,EAAI/F,EAAO,OACjB,IAAImV,EAAI,KACJ9C,EAAIC,EAAIa,EAAKnT,EAAO+F,EAAI,CAAC,EAAGqN,EAAKpT,EAAO+F,EAAI,CAAC,EAC7CyO,EAAIC,EAAK,KAAK,YAAYtB,EAAIC,CAAE,EAChC6B,EAAIG,EAAK,EACb,QAASjG,EAAI,EAAGA,EAAIpJ,EAAGoJ,GAAK,EAG1B,GAFAkD,EAAKc,EAAIb,EAAKc,EAAID,EAAKnT,EAAOmP,CAAC,EAAGiE,EAAKpT,EAAOmP,EAAI,CAAC,EACnDqF,EAAKC,EAAIA,EAAK,KAAK,YAAYtB,EAAIC,CAAE,EACjCoB,IAAO,GAAKC,IAAO,EACrBQ,EAAKG,EAAIA,EAAK,EACVD,EAAGA,EAAE,KAAKhC,EAAIC,CAAE,EACf+B,EAAI,CAAChC,EAAIC,CAAE,MACX,CACL,IAAImB,EAAGc,EAAKC,EAAKC,EAAKC,EACtB,GAAIhB,IAAO,EAAG,CACZ,IAAKD,EAAI,KAAK,aAAalC,EAAIC,EAAIa,EAAIC,EAAIoB,EAAIC,CAAE,KAAO,KAAM,SAC9D,CAACY,EAAKC,EAAKC,EAAKC,CAAG,EAAIjB,CACzB,KAAO,CACL,IAAKA,EAAI,KAAK,aAAapB,EAAIC,EAAIf,EAAIC,EAAImC,EAAID,CAAE,KAAO,KAAM,SAC9D,CAACe,EAAKC,EAAKH,EAAKC,CAAG,EAAIf,EACvBU,EAAKG,EAAIA,EAAK,KAAK,UAAUC,EAAKC,CAAG,EACjCL,GAAMG,GAAI,KAAK,MAAMhQ,EAAG6P,EAAIG,EAAID,EAAGA,EAAE,MAAM,EAC3CA,EAAGA,EAAE,KAAKE,EAAKC,CAAG,EACjBH,EAAI,CAACE,EAAKC,CAAG,CACpB,CACAL,EAAKG,EAAIA,EAAK,KAAK,UAAUG,EAAKC,CAAG,EACjCP,GAAMG,GAAI,KAAK,MAAMhQ,EAAG6P,EAAIG,EAAID,EAAGA,EAAE,MAAM,EAC3CA,EAAGA,EAAE,KAAKI,EAAKC,CAAG,EACjBL,EAAI,CAACI,EAAKC,CAAG,CACpB,CAEF,GAAIL,EACFF,EAAKG,EAAIA,EAAK,KAAK,UAAUD,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EACnCF,GAAMG,GAAI,KAAK,MAAMhQ,EAAG6P,EAAIG,EAAID,EAAGA,EAAE,MAAM,UACtC,KAAK,SAAS/P,GAAI,KAAK,KAAO,KAAK,MAAQ,GAAI,KAAK,KAAO,KAAK,MAAQ,CAAC,EAClF,MAAO,CAAC,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,IAAI,EAEhG,OAAO+P,CACT,CACA,aAAa9C,EAAIC,EAAIa,EAAIC,EAAIoB,EAAIC,EAAI,CAEnC,MAAMgB,EAAOjB,EAAKC,EAElB,IADIgB,IAAM,CAACpD,EAAIC,EAAIa,EAAIC,EAAIoB,EAAIC,CAAE,EAAI,CAACtB,EAAIC,EAAIf,EAAIC,EAAImC,EAAID,CAAE,KAC/C,CACX,GAAIA,IAAO,GAAKC,IAAO,EAAG,OAAOgB,EAAO,CAACtC,EAAIC,EAAIf,EAAIC,CAAE,EAAI,CAACD,EAAIC,EAAIa,EAAIC,CAAE,EAC1E,GAAIoB,EAAKC,EAAI,OAAO,KACpB,IAAI5T,EAAGC,EAAG4K,EAAI8I,GAAMC,EAChB/I,EAAI,GAAQ7K,EAAIwR,GAAMc,EAAKd,IAAO,KAAK,KAAOC,IAAOc,EAAKd,GAAKxR,EAAI,KAAK,MACnE4K,EAAI,GAAQ7K,EAAIwR,GAAMc,EAAKd,IAAO,KAAK,KAAOC,IAAOc,EAAKd,GAAKxR,EAAI,KAAK,MACxE4K,EAAI,GAAQ5K,EAAIwR,GAAMc,EAAKd,IAAO,KAAK,KAAOD,IAAOc,EAAKd,GAAKxR,EAAI,KAAK,OAC5EC,EAAIwR,GAAMc,EAAKd,IAAO,KAAK,KAAOD,IAAOc,EAAKd,GAAKxR,EAAI,KAAK,MAC7D2T,GAAInC,EAAKxR,EAAGyR,EAAKxR,EAAG0T,EAAK,KAAK,YAAYnC,EAAIC,CAAE,IAC/Ca,EAAKtS,EAAGuS,EAAKtS,EAAG2T,EAAK,KAAK,YAAYtB,EAAIC,CAAE,EACnD,CACF,CACA,cAAchO,EAAGpF,EAAQ0V,EAAKC,EAAKC,EAAKC,EAAK,CAC3C,IAAIV,EAAI,MAAM,KAAKnV,CAAM,EAAG2N,EAG5B,IAFIA,EAAI,KAAK,SAASwH,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGO,EAAKC,CAAG,IAAGR,EAAE,QAAQxH,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,GAC7DA,EAAI,KAAK,SAASwH,EAAEA,EAAE,OAAS,CAAC,EAAGA,EAAEA,EAAE,OAAS,CAAC,EAAGS,EAAKC,CAAG,IAAGV,EAAE,KAAKxH,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAChFwH,EAAI,KAAK,YAAY/P,EAAG+P,CAAC,EAC3B,QAAShG,EAAI,EAAGpJ,EAAIoP,EAAE,OAAQX,EAAIC,EAAK,KAAK,UAAUU,EAAEpP,EAAI,CAAC,EAAGoP,EAAEpP,EAAI,CAAC,CAAC,EAAGoJ,EAAIpJ,EAAGoJ,GAAK,EACrFqF,EAAKC,EAAIA,EAAK,KAAK,UAAUU,EAAEhG,CAAC,EAAGgG,EAAEhG,EAAI,CAAC,CAAC,EACvCqF,GAAMC,IAAItF,EAAI,KAAK,MAAM/J,EAAGoP,EAAIC,EAAIU,EAAGhG,CAAC,EAAGpJ,EAAIoP,EAAE,aAE9C,KAAK,SAAS/P,GAAI,KAAK,KAAO,KAAK,MAAQ,GAAI,KAAK,KAAO,KAAK,MAAQ,CAAC,IAClF+P,EAAI,CAAC,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,IAAI,GAE7F,OAAOA,CACT,CACA,MAAM/P,EAAG6P,EAAIG,EAAID,EAAGhG,EAAG,CACrB,KAAO8F,IAAOG,GAAI,CAChB,IAAIvU,EAAGC,EACP,OAAQmU,EAAE,CACR,IAAK,GAAQA,EAAK,EAAQ,SAC1B,IAAK,GAAQA,EAAK,EAAQpU,EAAI,KAAK,KAAMC,EAAI,KAAK,KAAM,MACxD,IAAK,GAAQmU,EAAK,EAAQ,SAC1B,IAAK,GAAQA,EAAK,GAAQpU,EAAI,KAAK,KAAMC,EAAI,KAAK,KAAM,MACxD,IAAK,IAAQmU,EAAK,EAAQ,SAC1B,IAAK,GAAQA,EAAK,EAAQpU,EAAI,KAAK,KAAMC,EAAI,KAAK,KAAM,MACxD,IAAK,GAAQmU,EAAK,EAAQ,SAC1B,IAAK,GAAQA,EAAK,EAAQpU,EAAI,KAAK,KAAMC,EAAI,KAAK,KAAM,KAChE,EAGWqU,EAAEhG,CAAC,IAAMtO,GAAKsU,EAAEhG,EAAI,CAAC,IAAMrO,IAAM,KAAK,SAASsE,EAAGvE,EAAGC,CAAC,IACzDqU,EAAE,OAAOhG,EAAG,EAAGtO,EAAGC,CAAC,EAAGqO,GAAK,EAE/B,CACA,OAAOA,CACT,CACA,SAASkD,EAAIC,EAAIwD,EAAIC,EAAI,CACvB,IAAI,EAAI,IAAUrK,EAAG7K,EAAGC,EACxB,GAAIiV,EAAK,EAAG,CACV,GAAIzD,GAAM,KAAK,KAAM,OAAO,MACvB5G,GAAK,KAAK,KAAO4G,GAAMyD,GAAM,IAAGjV,EAAI,KAAK,KAAMD,EAAIwR,GAAM,EAAI3G,GAAKoK,EACzE,SAAWC,EAAK,EAAG,CACjB,GAAIzD,GAAM,KAAK,KAAM,OAAO,MACvB5G,GAAK,KAAK,KAAO4G,GAAMyD,GAAM,IAAGjV,EAAI,KAAK,KAAMD,EAAIwR,GAAM,EAAI3G,GAAKoK,EACzE,CACA,GAAIA,EAAK,EAAG,CACV,GAAIzD,GAAM,KAAK,KAAM,OAAO,MACvB3G,GAAK,KAAK,KAAO2G,GAAMyD,GAAM,IAAGjV,EAAI,KAAK,KAAMC,EAAIwR,GAAM,EAAI5G,GAAKqK,EACzE,SAAWD,EAAK,EAAG,CACjB,GAAIzD,GAAM,KAAK,KAAM,OAAO,MACvB3G,GAAK,KAAK,KAAO2G,GAAMyD,GAAM,IAAGjV,EAAI,KAAK,KAAMC,EAAIwR,GAAM,EAAI5G,GAAKqK,EACzE,CACA,MAAO,CAAClV,EAAGC,CAAC,CACd,CACA,UAAUD,EAAGC,EAAG,CACd,OAAQD,IAAM,KAAK,KAAO,EACpBA,IAAM,KAAK,KAAO,EAAS,IAC1BC,IAAM,KAAK,KAAO,EACnBA,IAAM,KAAK,KAAO,EAAS,EACnC,CACA,YAAYD,EAAGC,EAAG,CAChB,OAAQD,EAAI,KAAK,KAAO,EAClBA,EAAI,KAAK,KAAO,EAAS,IACxBC,EAAI,KAAK,KAAO,EACjBA,EAAI,KAAK,KAAO,EAAS,EACjC,CACA,UAAUqU,EAAG,CACX,GAAIA,GAAKA,EAAE,OAAS,EAAG,CACrB,QAAS,EAAI,EAAG,EAAIA,EAAE,OAAQ,GAAI,EAAG,CACnC,MAAMhG,GAAK,EAAI,GAAKgG,EAAE,OAAQ1F,GAAK,EAAI,GAAK0F,EAAE,QAC1CA,EAAE,CAAC,IAAMA,EAAEhG,CAAC,GAAKgG,EAAEhG,CAAC,IAAMgG,EAAE1F,CAAC,GAAK0F,EAAE,EAAI,CAAC,IAAMA,EAAEhG,EAAI,CAAC,GAAKgG,EAAEhG,EAAI,CAAC,IAAMgG,EAAE1F,EAAI,CAAC,KACjF0F,EAAE,OAAOhG,EAAG,CAAC,EAAG,GAAK,EAEzB,CACKgG,EAAE,SAAQA,EAAI,KACrB,CACA,OAAOA,CACT,CACF,CCtUA,MAAMa,GAAM,EAAI,KAAK,GAAIC,EAAM,KAAK,IAEpC,SAASC,GAAOvI,EAAG,CACjB,OAAOA,EAAE,CAAC,CACZ,CAEA,SAASwI,GAAOxI,EAAG,CACjB,OAAOA,EAAE,CAAC,CACZ,CAGA,SAASyI,GAAUxR,EAAG,CACpB,KAAM,CAAC,UAAAoL,EAAW,OAAAtC,CAAM,EAAI9I,EAC5B,QAASQ,EAAI,EAAGA,EAAI4K,EAAU,OAAQ5K,GAAK,EAAG,CAC5C,MAAM1G,EAAI,EAAIsR,EAAU5K,CAAC,EACnBzG,EAAI,EAAIqR,EAAU5K,EAAI,CAAC,EACvBsG,EAAI,EAAIsE,EAAU5K,EAAI,CAAC,EAG7B,IAFesI,EAAOhC,CAAC,EAAIgC,EAAOhP,CAAC,IAAMgP,EAAO/O,EAAI,CAAC,EAAI+O,EAAOhP,EAAI,CAAC,IACtDgP,EAAO/O,CAAC,EAAI+O,EAAOhP,CAAC,IAAMgP,EAAOhC,EAAI,CAAC,EAAIgC,EAAOhP,EAAI,CAAC,GACzD,MAAO,MAAO,EAC5B,CACA,MAAO,EACT,CAEA,SAAS2X,GAAOxV,EAAGC,EAAGoE,EAAG,CACvB,MAAO,CAACrE,EAAI,KAAK,IAAIA,EAAIC,CAAC,EAAIoE,EAAGpE,EAAI,KAAK,IAAID,EAAIC,CAAC,EAAIoE,CAAC,CAC1D,CAEe,MAAMoR,EAAS,CAC5B,OAAO,KAAKtW,EAAQoR,EAAK8E,GAAQ7E,EAAK8E,GAAQI,EAAM,CAClD,OAAO,IAAID,GAAS,WAAYtW,EAC1BwW,GAAUxW,EAAQoR,EAAIC,EAAIkF,CAAI,EAC9B,aAAa,KAAKE,GAAazW,EAAQoR,EAAIC,EAAIkF,CAAI,CAAC,CAAC,CAC7D,CACA,YAAYvW,EAAQ,CAClB,KAAK,YAAc,IAAIqN,GAAWrN,CAAM,EACxC,KAAK,QAAU,IAAI,WAAWA,EAAO,OAAS,CAAC,EAC/C,KAAK,WAAa,IAAI,WAAWA,EAAO,OAAS,CAAC,EAClD,KAAK,OAAS,KAAK,YAAY,OAC/B,KAAK,MAAK,CACZ,CACA,QAAS,CACP,YAAK,YAAY,OAAM,EACvB,KAAK,MAAK,EACH,IACT,CACA,OAAQ,CACN,MAAM4E,EAAI,KAAK,YAAa5E,EAAS,KAAK,OAG1C,GAAI4E,EAAE,MAAQA,EAAE,KAAK,OAAS,GAAKwR,GAAUxR,CAAC,EAAG,CAC/C,KAAK,UAAY,WAAW,KAAK,CAAC,OAAQ5E,EAAO,OAAO,CAAC,EAAG,CAAC0W,EAAEtR,IAAMA,CAAC,EACnE,KAAK,CAACA,EAAG+J,IAAMnP,EAAO,EAAIoF,CAAC,EAAIpF,EAAO,EAAImP,CAAC,GAAKnP,EAAO,EAAIoF,EAAI,CAAC,EAAIpF,EAAO,EAAImP,EAAI,CAAC,CAAC,EACxF,MAAMnN,EAAI,KAAK,UAAU,CAAC,EAAGyH,EAAI,KAAK,UAAU,KAAK,UAAU,OAAS,CAAC,EACvEkN,EAAS,CAAE3W,EAAO,EAAIgC,CAAC,EAAGhC,EAAO,EAAIgC,EAAI,CAAC,EAAGhC,EAAO,EAAIyJ,CAAC,EAAGzJ,EAAO,EAAIyJ,EAAI,CAAC,CAAC,EAC7EvE,EAAI,KAAO,KAAK,MAAMyR,EAAO,CAAC,EAAIA,EAAO,CAAC,EAAGA,EAAO,CAAC,EAAIA,EAAO,CAAC,CAAC,EACpE,QAASvR,EAAI,EAAGW,EAAI/F,EAAO,OAAS,EAAGoF,EAAIW,EAAG,EAAEX,EAAG,CACjD,MAAMuI,EAAI0I,GAAOrW,EAAO,EAAIoF,CAAC,EAAGpF,EAAO,EAAIoF,EAAI,CAAC,EAAGF,CAAC,EACpDlF,EAAO,EAAIoF,CAAC,EAAIuI,EAAE,CAAC,EACnB3N,EAAO,EAAIoF,EAAI,CAAC,EAAIuI,EAAE,CAAC,CACzB,CACA,KAAK,YAAc,IAAIN,GAAWrN,CAAM,CAC1C,MACE,OAAO,KAAK,UAGd,MAAMiQ,EAAY,KAAK,UAAY,KAAK,YAAY,UAC9Cf,EAAO,KAAK,KAAO,KAAK,YAAY,KACpCc,EAAY,KAAK,UAAY,KAAK,YAAY,UAC9C4D,EAAU,KAAK,QAAQ,KAAK,EAAE,EAC9BgD,EAAY,KAAK,WAAW,KAAK,EAAE,EAKzC,QAAS5U,EAAI,EAAG+D,EAAIkK,EAAU,OAAQjO,EAAI+D,EAAG,EAAE/D,EAAG,CAChD,MAAM2L,EAAIqC,EAAUhO,EAAI,IAAM,EAAIA,EAAI,EAAIA,EAAI,CAAC,GAC3CiO,EAAUjO,CAAC,IAAM,IAAM4R,EAAQjG,CAAC,IAAM,MAAIiG,EAAQjG,CAAC,EAAI3L,EAC7D,CACA,QAASoD,EAAI,EAAGW,EAAImJ,EAAK,OAAQ9J,EAAIW,EAAG,EAAEX,EACxCwR,EAAU1H,EAAK9J,CAAC,CAAC,EAAIA,EAInB8J,EAAK,QAAU,GAAKA,EAAK,OAAS,IACpC,KAAK,UAAY,IAAI,WAAW,CAAC,EAAE,KAAK,EAAE,EAC1C,KAAK,UAAY,IAAI,WAAW,CAAC,EAAE,KAAK,EAAE,EAC1C,KAAK,UAAU,CAAC,EAAIA,EAAK,CAAC,EAC1B0E,EAAQ1E,EAAK,CAAC,CAAC,EAAI,EACfA,EAAK,SAAW,IAClB0E,EAAQ1E,EAAK,CAAC,CAAC,EAAI,EACnB,KAAK,UAAU,CAAC,EAAIA,EAAK,CAAC,EAC1B,KAAK,UAAU,CAAC,EAAIA,EAAK,CAAC,GAGhC,CACA,QAAQyH,EAAQ,CACd,OAAO,IAAIlE,GAAQ,KAAMkE,CAAM,CACjC,CACA,CAAC,UAAUvR,EAAG,CACZ,KAAM,CAAC,QAAAwO,EAAS,KAAA1E,EAAM,WAAA2H,EAAY,UAAA5G,EAAW,UAAAD,EAAW,UAAAoG,CAAS,EAAI,KAGrE,GAAIA,EAAW,CACb,MAAMU,EAAIV,EAAU,QAAQhR,CAAC,EACzB0R,EAAI,IAAG,MAAMV,EAAUU,EAAI,CAAC,GAC5BA,EAAIV,EAAU,OAAS,IAAG,MAAMA,EAAUU,EAAI,CAAC,GACnD,MACF,CAEA,MAAM7B,EAAKrB,EAAQxO,CAAC,EACpB,GAAI6P,IAAO,GAAI,OACf,IAAIjT,EAAIiT,EAAI1E,EAAK,GACjB,EAAG,CAGD,GAFA,MAAMA,EAAKP,EAAUhO,CAAC,EACtBA,EAAIA,EAAI,IAAM,EAAIA,EAAI,EAAIA,EAAI,EAC1BgO,EAAUhO,CAAC,IAAMoD,EAAG,OAExB,GADApD,EAAIiO,EAAUjO,CAAC,EACXA,IAAM,GAAI,CACZ,MAAM2L,EAAIuB,GAAM2H,EAAWzR,CAAC,EAAI,GAAK8J,EAAK,MAAM,EAC5CvB,IAAM4C,IAAI,MAAM5C,GACpB,MACF,CACF,OAAS3L,IAAMiT,EACjB,CACA,KAAKpU,EAAGC,EAAGsE,EAAI,EAAG,CAChB,GAAKvE,EAAI,CAACA,EAAGA,IAAMA,IAAOC,EAAI,CAACA,EAAGA,IAAMA,GAAI,MAAO,GACnD,MAAMuN,EAAKjJ,EACX,IAAIsG,EACJ,MAAQA,EAAI,KAAK,MAAMtG,EAAGvE,EAAGC,CAAC,IAAM,GAAK4K,IAAMtG,GAAKsG,IAAM2C,GAAIjJ,EAAIsG,EAClE,OAAOA,CACT,CACA,MAAMtG,EAAGvE,EAAGC,EAAG,CACb,KAAM,CAAC,QAAA8S,EAAS,KAAA1E,EAAM,WAAA2H,EAAY,UAAA5G,EAAW,UAAAD,EAAW,OAAAhQ,CAAM,EAAI,KAClE,GAAI4T,EAAQxO,CAAC,IAAM,IAAM,CAACpF,EAAO,OAAQ,OAAQoF,EAAI,IAAMpF,EAAO,QAAU,GAC5E,IAAI0L,EAAItG,EACJ2R,EAAKd,EAAIpV,EAAIb,EAAOoF,EAAI,CAAC,EAAG,CAAC,EAAI6Q,EAAInV,EAAId,EAAOoF,EAAI,EAAI,CAAC,EAAG,CAAC,EACjE,MAAM6P,EAAKrB,EAAQxO,CAAC,EACpB,IAAIpD,EAAIiT,EACR,EAAG,CACD,IAAI5V,EAAI2Q,EAAUhO,CAAC,EACnB,MAAMgV,EAAKf,EAAIpV,EAAIb,EAAOX,EAAI,CAAC,EAAG,CAAC,EAAI4W,EAAInV,EAAId,EAAOX,EAAI,EAAI,CAAC,EAAG,CAAC,EAGnE,GAFI2X,EAAKD,IAAIA,EAAKC,EAAItL,EAAIrM,GAC1B2C,EAAIA,EAAI,IAAM,EAAIA,EAAI,EAAIA,EAAI,EAC1BgO,EAAUhO,CAAC,IAAMoD,EAAG,MAExB,GADApD,EAAIiO,EAAUjO,CAAC,EACXA,IAAM,GAAI,CAEZ,GADAA,EAAIkN,GAAM2H,EAAWzR,CAAC,EAAI,GAAK8J,EAAK,MAAM,EACtClN,IAAM3C,GACJ4W,EAAIpV,EAAIb,EAAOgC,EAAI,CAAC,EAAG,CAAC,EAAIiU,EAAInV,EAAId,EAAOgC,EAAI,EAAI,CAAC,EAAG,CAAC,EAAI+U,EAAI,OAAO/U,EAE7E,KACF,CACF,OAASA,IAAMiT,GACf,OAAOvJ,CACT,CACA,OAAOgI,EAAS,CACd,MAAMC,EAASD,GAAW,KAAOA,EAAU,IAAItB,EAAO,OAChD,CAAC,OAAApS,EAAQ,UAAAiQ,EAAW,UAAAD,CAAS,EAAI,KACvC,QAAS5K,EAAI,EAAGW,EAAIkK,EAAU,OAAQ7K,EAAIW,EAAG,EAAEX,EAAG,CAChD,MAAM+J,EAAIc,EAAU7K,CAAC,EACrB,GAAI+J,EAAI/J,EAAG,SACX,MAAMyO,EAAK7D,EAAU5K,CAAC,EAAI,EACpB0O,EAAK9D,EAAUb,CAAC,EAAI,EAC1BuE,EAAQ,OAAO1T,EAAO6T,CAAE,EAAG7T,EAAO6T,EAAK,CAAC,CAAC,EACzCH,EAAQ,OAAO1T,EAAO8T,CAAE,EAAG9T,EAAO8T,EAAK,CAAC,CAAC,CAC3C,CACA,YAAK,WAAWJ,CAAO,EAChBC,GAAUA,EAAO,MAAK,CAC/B,CACA,aAAaD,EAASxO,EAAG,CACnBA,IAAM,SAAc,CAACwO,GAAW,OAAOA,EAAQ,QAAW,cAAaxO,EAAIwO,EAASA,EAAU,MAClGxO,EAAIA,GAAK,KAAY,EAAI,CAACA,EAC1B,MAAMyO,EAASD,GAAW,KAAOA,EAAU,IAAItB,EAAO,OAChD,CAAC,OAAApS,CAAM,EAAI,KACjB,QAASoF,EAAI,EAAGW,EAAI/F,EAAO,OAAQoF,EAAIW,EAAGX,GAAK,EAAG,CAChD,MAAMvE,EAAIb,EAAOoF,CAAC,EAAGtE,EAAId,EAAOoF,EAAI,CAAC,EACrCsO,EAAQ,OAAO7S,EAAIqE,EAAGpE,CAAC,EACvB4S,EAAQ,IAAI7S,EAAGC,EAAGoE,EAAG,EAAG8Q,EAAG,CAC7B,CACA,OAAOrC,GAAUA,EAAO,MAAK,CAC/B,CACA,WAAWD,EAAS,CAClB,MAAMC,EAASD,GAAW,KAAOA,EAAU,IAAItB,EAAO,OAChD,CAAC,KAAAlD,EAAM,OAAAlP,CAAM,EAAI,KACjB0J,EAAIwF,EAAK,CAAC,EAAI,EAAGnJ,EAAImJ,EAAK,OAChCwE,EAAQ,OAAO1T,EAAO0J,CAAC,EAAG1J,EAAO0J,EAAI,CAAC,CAAC,EACvC,QAAStE,EAAI,EAAGA,EAAIW,EAAG,EAAEX,EAAG,CAC1B,MAAMsE,EAAI,EAAIwF,EAAK9J,CAAC,EACpBsO,EAAQ,OAAO1T,EAAO0J,CAAC,EAAG1J,EAAO0J,EAAI,CAAC,CAAC,CACzC,CACA,OAAAgK,EAAQ,UAAS,EACVC,GAAUA,EAAO,MAAK,CAC/B,CACA,aAAc,CACZ,MAAMW,EAAU,IAAI9B,GACpB,YAAK,WAAW8B,CAAO,EAChBA,EAAQ,MAAK,CACtB,CACA,eAAelP,EAAGsO,EAAS,CACzB,MAAMC,EAASD,GAAW,KAAOA,EAAU,IAAItB,EAAO,OAChD,CAAC,OAAApS,EAAQ,UAAAgQ,CAAS,EAAI,KACtB3D,EAAK2D,EAAU5K,GAAK,CAAC,EAAI,EACzBgH,EAAK4D,EAAU5K,EAAI,CAAC,EAAI,EACxB6N,EAAKjD,EAAU5K,EAAI,CAAC,EAAI,EAC9B,OAAAsO,EAAQ,OAAO1T,EAAOqM,CAAE,EAAGrM,EAAOqM,EAAK,CAAC,CAAC,EACzCqH,EAAQ,OAAO1T,EAAOoM,CAAE,EAAGpM,EAAOoM,EAAK,CAAC,CAAC,EACzCsH,EAAQ,OAAO1T,EAAOiT,CAAE,EAAGjT,EAAOiT,EAAK,CAAC,CAAC,EACzCS,EAAQ,UAAS,EACVC,GAAUA,EAAO,MAAK,CAC/B,CACA,CAAC,kBAAmB,CAClB,KAAM,CAAC,UAAA3D,CAAS,EAAI,KACpB,QAAS,EAAI,EAAGjK,EAAIiK,EAAU,OAAS,EAAG,EAAIjK,EAAG,EAAE,EACjD,MAAM,KAAK,gBAAgB,CAAC,CAEhC,CACA,gBAAgBX,EAAG,CACjB,MAAMkP,EAAU,IAAI9B,GACpB,YAAK,eAAepN,EAAGkP,CAAO,EACvBA,EAAQ,MAAK,CACtB,CACF,CAEA,SAASkC,GAAUxW,EAAQoR,EAAIC,EAAIkF,EAAM,CACvC,MAAM,EAAIvW,EAAO,OACXiX,EAAQ,IAAI,aAAa,EAAI,CAAC,EACpC,QAAS7R,EAAI,EAAGA,EAAI,EAAG,EAAEA,EAAG,CAC1B,MAAMuI,EAAI3N,EAAOoF,CAAC,EAClB6R,EAAM7R,EAAI,CAAC,EAAIgM,EAAG,KAAKmF,EAAM5I,EAAGvI,EAAGpF,CAAM,EACzCiX,EAAM7R,EAAI,EAAI,CAAC,EAAIiM,EAAG,KAAKkF,EAAM5I,EAAGvI,EAAGpF,CAAM,CAC/C,CACA,OAAOiX,CACT,CAEA,SAAUR,GAAazW,EAAQoR,EAAIC,EAAIkF,EAAM,CAC3C,IAAInR,EAAI,EACR,UAAWuI,KAAK3N,EACd,MAAMoR,EAAG,KAAKmF,EAAM5I,EAAGvI,EAAGpF,CAAM,EAChC,MAAMqR,EAAG,KAAKkF,EAAM5I,EAAGvI,EAAGpF,CAAM,EAChC,EAAEoF,CAEN,CCpPA,IAAIiK,GAAK,EACF,SAAS6H,GAAwB,CACtC,OAAO7H,IACT,CCeO,MAAMzG,GAAkC,wBASlCuO,GAAuD,CAClE,KAAMvO,GACN,YAAa,UACb,YAAa,qOAIb,SAAU,EAEV,SAAU,CAAA,CACZ,EAQA,SAASwO,GAAqB9C,EAAuB,CACnD,GAAIA,EAAQ,SAAW,EACrB,MAAO,CAAC,EAAG,EAAG,EAAG,CAAC,EAGpB,IAAIrG,EAAOqG,EAAQ,CAAC,EAAE,CAAC,EACnBpG,EAAOoG,EAAQ,CAAC,EAAE,CAAC,EACnBnG,EAAOF,EACPG,EAAOF,EAEX,QAAS9I,EAAI,EAAGA,EAAIkP,EAAQ,OAAQlP,IAAK,CACvC,MAAMuI,EAAI2G,EAAQlP,CAAC,EACnB6I,EAAO,KAAK,IAAIA,EAAMN,EAAE,CAAC,CAAC,EAC1BO,EAAO,KAAK,IAAIA,EAAMP,EAAE,CAAC,CAAC,EAC1BQ,EAAO,KAAK,IAAIA,EAAMR,EAAE,CAAC,CAAC,EAC1BS,EAAO,KAAK,IAAIA,EAAMT,EAAE,CAAC,CAAC,CAC5B,CAEA,MAAO,CAACM,EAAMC,EAAMC,EAAMC,CAAI,CAChC,CAOA,SAASiJ,GAAmB3F,EAAmB4F,EAAsC,CACnF,MAAMC,EAAM7F,EAAI,OAChB,QAAStM,EAAI,EAAGA,EAAImS,EAAKnS,IAAK,CAC5B,MAAM3E,EAAK6W,EAAI,IAAI5F,EAAItM,CAAC,CAAC,EACzB3E,EAAG,KAAOiR,GAAKtM,EAAI,GAAKmS,CAAG,EAC3B9W,EAAG,KAAOiR,GAAKtM,EAAI,EAAImS,GAAOA,CAAG,CACnC,CACF,CAOA,SAASC,EAAW7J,EAAiB,CACnC,MAAO,GAAGA,EAAE,CAAC,EAAE,YAAY,CAAC,CAAC,IAAIA,EAAE,CAAC,EAAE,YAAY,CAAC,CAAC,EACtD,CAQA,SAAS8J,GAAe/G,EAAUgH,EAAmB,CACnD,OAAO,KAAK,IAAIhH,EAAG,CAAC,EAAIgH,EAAG,CAAC,CAAC,EAAI,MAAQ,KAAK,IAAIhH,EAAG,CAAC,EAAIgH,EAAG,CAAC,CAAC,EAAI,IACrE,CAOO,MAAMC,GAAiE,CAACrZ,EAAeC,EAAgB0K,KAC9D,CAO5C,eAAejJ,EAAgB4X,EAA4D,CAOzF,QAAQ,IAAI,0CAA0CtZ,CAAK,IAAIC,CAAM,EAAE,EAGvE,MAAMsZ,EADWvB,GAAS,KAAKtW,CAAM,EACZ,QAAQ,CAAC,EAAG,EAAG1B,EAAOC,CAAM,CAAC,EAGhD0B,EAA2B,CAC/B,SAAU,CAAA,EACV,WAAY,IACZ,UAAW,IACX,cAAe,IACf,SAAU,CAAA,CAAC,EAIP6X,MAA0B,IAIhC,QAAS1S,EAAI,EAAGA,EAAIpF,EAAO,OAAQoF,IAAK,CACtC,MAAM2S,EAAO/X,EAAOoF,CAAC,EACfkP,EAAUuD,EAAQ,YAAYzS,CAAC,EAErC,GAAI,CAACkP,EAAS,SAEd,MAAMvT,EAAe,CACnB,GAAIqE,EACJ,KAAA2S,EACA,SAAU,GACV,KAAMX,GAAqB9C,CAAO,CAAA,EAG9B0D,EAAiC,CAAA,EAGvC,QAAS7I,EAAI,EAAGA,EAAImF,EAAQ,OAAS,EAAGnF,IAAK,CAC3C,MAAMuB,EAAK4D,EAAQnF,CAAC,EACduI,EAAKpD,EAAQnF,EAAI,CAAC,EAGxB,GAAIsI,GAAe/G,EAAIgH,CAAE,EAAG,SAE5B,MAAMjX,EAAe,CACnB,GAAIyW,EAAA,EACJ,OAAQxG,EACR,KAAM,GACN,KAAM,GACN,KAAM,GACN,MAAOtL,CAAA,EAGTnF,EAAS,UAAU,IAAIQ,EAAG,GAAIA,CAAE,EAChCuX,EAAiB,KAAKvX,EAAG,EAAE,EAI3B,MAAMoP,EAAM,GAAG2H,EAAW9G,CAAE,CAAC,IAAI8G,EAAWE,CAAE,CAAC,GAC/CI,EAAoB,IAAIjI,EAAKpP,EAAG,EAAE,CACpC,CAEIuX,EAAiB,SAAW,IAGhCX,GAAmBW,EAAkB/X,EAAS,SAAS,EAGvDc,EAAM,SAAWiX,EAAiB,CAAC,EACnC/X,EAAS,OAAO,IAAImF,EAAGrE,CAAK,EAC9B,CAGA,UAAWkX,KAAOhY,EAAS,UAAU,OAAA,EAAU,CAE7C,GAAIgY,EAAI,OAAS,GAAI,SAErB,MAAMC,EAAWjY,EAAS,UAAU,IAAIgY,EAAI,IAAI,EAC1CvH,EAAKuH,EAAI,OACTP,EAAKQ,EAAS,OAEdC,EAAa,GAAGX,EAAWE,CAAE,CAAC,IAAIF,EAAW9G,CAAE,CAAC,GAChD0H,EAASN,EAAoB,IAAIK,CAAU,EAE3CE,EAASnB,EAAA,EACf,IAAIhX,EAEJ,GAAIkY,IAAW,OAAW,CAExB,MAAME,EAAMrY,EAAS,UAAU,IAAImY,CAAM,EACzCH,EAAI,KAAOK,EAAI,GACfA,EAAI,KAAOL,EAAI,GAGf/X,EAAO,CACL,GAAImY,EACJ,OAAQJ,EAAI,GACZ,QAASK,EAAI,EAAA,CAEjB,MAEEpY,EAAO,CACL,GAAImY,EACJ,OAAQJ,EAAI,GACZ,QAAS,EAAA,EAEXhY,EAAS,SAAS,KAAKoY,CAAM,EAG/BpY,EAAS,MAAM,IAAIoY,EAAQnY,CAAI,CACjC,CAGA,MAAMqY,MAAgB,IACtB,UAAW9X,KAAMR,EAAS,UAAU,OAAA,EAAU,CAC5C,MAAM4P,EAAM2H,EAAW/W,EAAG,MAAM,EAC3B8X,EAAU,IAAI1I,CAAG,GACpB0I,EAAU,IAAI1I,EAAKpP,EAAG,MAAM,CAEhC,CACA,OAAAR,EAAS,SAAW,MAAM,KAAKsY,EAAU,QAAQ,EAE1CtY,CACT,CAAA,GAOJhB,EAAuB,SAAS2J,GAAM+O,GAA8BR,EAA+B,EClP5F,MAAMvO,GAAoC,0BAgBpC4P,GAAgD,CAC3D,KAAM5P,GACN,YAAa,cACb,YAAa,oEACb,SAAU,EAEV,SAAU,CACR,CACE,KAAM,QACN,KAAM,OACN,MAAO,WACP,aAAc,GACd,IAAK,EACL,IAAK,IACL,KAAM,EACN,SAAU,2DAAA,EAEZ,CACE,KAAM,QACN,KAAM,SACN,MAAO,aACP,aAAc,EACd,IAAK,EACL,IAAK,IACL,KAAM,EACN,SAAU,mEAAA,EAEZ,CACE,KAAM,SACN,KAAM,aACN,MAAO,mBACP,aAAc,GACd,SAAU,GACV,SAAU,sEAAA,EAEZ,CACE,KAAM,SACN,KAAM,aACN,MAAO,oBACP,SAAU,GACV,SAAU,0EAAA,CACZ,CAEJ,EAqBA,SAAS6P,GACP/Z,EACAC,EACA+Z,EACAC,EACA5Y,EACA6Y,EAAS,GACTC,EACe,CAGf,MAAMC,EAAKna,EAAE,CAAC,EAAID,EAAE,CAAC,EACfqa,EAAKpa,EAAE,CAAC,EAAID,EAAE,CAAC,EACf6Y,EAAM,KAAK,MAAMuB,EAAIC,CAAE,EAC7B,GAAIxB,IAAQ,EAAG,MAAM,IAAI,MAAM,sBAAsB,EAGrD,MAAM,EAAU,CAACuB,EAAKvB,EAAKwB,EAAKxB,CAAG,EAC7BzS,EAAU,CAAC,CAAC,EAAE,CAAC,EAAG,EAAE,CAAC,CAAC,EAGtBqQ,EAAI,CAAC6D,EAAWzG,IAAoB,CACxC7T,EAAE,CAAC,GAAK,EAAE,CAAC,EAAIsa,EAAIlU,EAAE,CAAC,EAAIyN,GAAKgF,EAC/B7Y,EAAE,CAAC,GAAK,EAAE,CAAC,EAAIsa,EAAIlU,EAAE,CAAC,EAAIyN,GAAKgF,CAAA,EAK3BpI,EAAIwJ,EAAY,IAChB9T,EAAM,KAAO9E,EAAA,EAAW,EAAI,GAAKoP,EAEjC8J,EAAIpU,EAAA,EACJ4F,EAAI5F,EAAA,EACJqU,EAAIrU,EAAA,EACJ+F,EAAI/F,EAAA,EACJsU,EAAItU,EAAA,EAIV,IAAIxF,EAAIqZ,EAAU,IAEdG,GACuB,EAAIxZ,EAAIkY,EACVsB,IAErBxZ,EAAIwZ,GAAc,EAAItB,IAI1B,MAAM6B,EAAMR,EAAS,GAAK,EAmBpB5Y,EAfmB,CACvB,CAAC,EAA8B,CAAC,EAChC,CAAC,GAA8BiZ,CAAC,EAChC,CAAC,GAAMxO,EAAIG,EAAUwO,GAAO,CAAC/Z,EAAI6Z,EAAE,EACnC,CAAC,GAAM7Z,EAAIoL,EAAU2O,GAAQ/Z,EAAI6Z,EAAE,EACnC,CAAC,GAAM,EAAE7Z,EAAIoL,EAAIG,EAAIwO,GAAO,EAAE/Z,EAAI6Z,EAAE,EACpC,CAAC,GAAM,EAAE7Z,EAAIoL,EAAIG,EAAIwO,GAAO,EAAE/Z,EAAI6Z,EAAE,EACpC,CAAC,GAAM7Z,EAAIoL,EAAU2O,GAAQ/Z,EAAI6Z,EAAE,EACnC,CAAC,GAAMzO,EAAIG,EAAUwO,GAAO,CAAC/Z,EAAI6Z,EAAE,EACnC,CAAC,GAA8BC,CAAC,EAChC,CAAC,EAA8B,CAAC,CAAA,EAKF,IAAI,CAAC,CAACH,EAAGzG,CAAC,IAAM4C,EAAE6D,EAAGzG,CAAC,CAAC,EAEjD8G,EAAgB,CAAE,KAAM,SAAU,GAAIrZ,EAAO,CAAC,EAAG,GAAIA,EAAO,CAAC,EAAG,GAAIA,EAAO,CAAC,CAAA,EAC5EsZ,EAAgB,CAAE,KAAM,SAAU,GAAItZ,EAAO,CAAC,EAAG,GAAIA,EAAO,CAAC,EAAG,GAAIA,EAAO,CAAC,CAAA,EAC5EuZ,EAAgB,CAAE,KAAM,SAAU,GAAIvZ,EAAO,CAAC,EAAG,GAAIA,EAAO,CAAC,EAAG,GAAIA,EAAO,CAAC,CAAA,EAElF,MAAO,CAACqZ,EAAMC,EAAMC,CAAI,CAC1B,CAMA,SAASC,GAAY9Y,EAAkB+Y,EAA4B,CACjE,MAAO,CACL,KAAM,SACN,GAAI/Y,EAAQ,GACZ,GAAIA,EAAQ,GACZ,GAAI+Y,CAAA,CAER,CASO,MAAMC,GAAiE,CAAC3Q,EAAgBC,EAAiBxK,IAAwD,CACtK,KAAM,CAAE,KAAA8G,EAAO,GAAI,OAAA+Q,EAAS,EAAG,WAAAsD,EAAY,WAAAd,GAAera,EAwC1D,MAtC8C,CAC5C,OAAO0B,EAAYgJ,EAAyC,CAC1D,KAAM,CAAE,SAAAjJ,EAAU,OAAAF,CAAA,EAAWmJ,EACvB+O,EAAMhY,EAAS,UAAU,IAAIC,EAAK,MAAM,EACxCoY,EAAMrY,EAAS,UAAU,IAAIC,EAAK,OAAO,EAE/C,GAAI,CAAC+X,GAAO,CAACK,EAAK,OAElB,MAAM5Z,EAAIuZ,EAAI,OACRtZ,EAAI2Z,EAAI,OAEd,GAAIqB,GACU,KAAK,MAAMhb,EAAE,CAAC,EAAID,EAAE,CAAC,EAAGC,EAAE,CAAC,EAAID,EAAE,CAAC,CAAC,EACrCib,EACR,OAIJ,MAAMC,EAAc7Z,IAAW,GAEzB8Z,EAAcpB,GAAqB/Z,EAAGC,EAAG2G,EAAM+Q,EAAQtW,EAAQ6Z,EAAaf,CAAU,EAC5F,GAAIgB,EAAY,SAAW,EAAG,OAK9B,MAAMC,EAA6B,CAAA,EACnC,QAAS1U,EAAIyU,EAAY,OAAS,EAAGzU,GAAK,EAAGA,IAAK,CAChD,MAAM2U,EAAiBF,EAAYzU,CAAC,EAE9B4U,EAAoB5U,EAAI,EAAMyU,EAAYzU,EAAE,CAAC,EAAc,GAAK1G,EACtEob,EAAY,KAAKN,GAAYO,EAAgBC,CAAgB,CAAC,CAChE,CAEA/B,EAAI,SAAW4B,EACfvB,EAAI,SAAWwB,CACjB,CAAA,CAGJ,EAKA5a,EAAqB,SAAS0J,GAAM8Q,GAAgClB,EAAwB,EC9MrF,SAASyB,GAAkBha,EAAsD,CACtF,MAAO,CACL,SAAUA,EAAS,SACnB,OAAQ,MAAM,KAAKA,EAAS,OAAO,SAAS,EAC5C,MAAO,MAAM,KAAKA,EAAS,MAAM,SAAS,EAC1C,UAAW,MAAM,KAAKA,EAAS,UAAU,SAAS,EAClD,SAAUA,EAAS,QAAA,CAEvB,6GC4UO,SAASia,GACd9Z,EACA+Z,EACiB,CACjB,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,MAAMC,EAAS,IAAIC,GAGnBD,EAAO,UAAaE,GAAmD,CACrE,MAAMjW,EAAOiW,EAAM,KAEnB,OAAQjW,EAAK,KAAA,CACb,IAAK,WACH4V,IAAa5V,EAAK,UAAWA,EAAK,KAAK,EACvC,MACF,IAAK,OACH6V,EAAQ7V,EAAK,OAAO,EACpB+V,EAAO,UAAA,EACP,MACF,IAAK,QACHD,EAAO,IAAI,MAAM9V,EAAK,OAAO,CAAC,EAC9B+V,EAAO,UAAA,EACP,KAAA,CAEJ,EAGAA,EAAO,QAAWG,GAAsB,CACtCJ,EAAO,IAAI,MAAMI,EAAM,OAAO,CAAC,EAC/BH,EAAO,UAAA,CACT,EAGA,MAAMI,EAAoC,CACxC,SAAUT,GAAkB7Z,CAAM,CAAA,EAEpCka,EAAO,YAAYI,CAAO,CAC5B,CAAC,CACH,CC5YO,MAAM9R,GAAqC,2BAUrC+R,GAAiD,CAC5D,KAAM/R,GACN,YAAa,OACb,YAAa,qIAEb,SAAU,EAEV,SAAU,CACR,CACE,KAAM,QACN,KAAM,SACN,MAAO,aACP,IAAK,EACL,IAAK,IACL,KAAM,EACN,aAAc,GACd,SAAU,0DAAA,CACZ,CAEJ,EAOagS,GAAoE,CAACtc,EAAeC,EAAgBC,IAA2C,CAC1J,KAAM,CAAE,OAAA6X,EAAS,EAAA,EAAO7X,EAuBxB,MArBiD,CAC/C,eAAe0K,EAAoD,CACjE,KAAM,CAAE,MAAA5K,EAAO,OAAAC,EAAQ,UAAAiB,EAAW,OAAAO,GAAWmJ,EAEvClJ,EAAiB,CAAA,EAEvB,QAASa,EAAI,EAAGA,EAAIvC,EAAOuC,GAAKrB,EAC9B,QAASsB,EAAI,EAAGA,EAAIvC,EAAQuC,GAAKtB,EAAW,CAE1C,MAAM0H,EAAc,CAACrG,EAAIrB,EAAY,EAAGsB,EAAItB,EAAY,CAAC,EAErD6W,EAAS,IACXnP,EAAM,CAAC,IAAMnH,EAAA,EAAW,KAAQsW,EAAS,KAAO7W,EAChD0H,EAAM,CAAC,IAAMnH,EAAA,EAAW,KAAQsW,EAAS,KAAQ7W,GAEnDQ,EAAO,KAAKkH,CAAK,CACnB,CAEF,OAAOlH,CACT,CAAA,CAGJ,EAIAhB,EAAuB,SAAS4J,GAAMgS,GAAiCD,EAAyB,ECrDzF,MAAM/R,GAAsC,4BAStCiS,GAA2D,CACtE,KAAMjS,GACN,YAAa,cACb,YAAa,2HAEb,SAAU,EAEV,SAAU,CAAA,CACZ,EAOakS,GAAqE,CAACxc,EAAeC,EAAgB0K,KAE9D,CAOhD,eAAe8R,EAAiB7R,EAA2D,CACzF,KAAM,CAAE,UAAA1J,GAAc0J,EAEhBjJ,EAA2B,CAC/B,SAAU,CAAA,EACV,WAAY,IACZ,UAAW,IACX,cAAe,IACf,SAAU,CAAA,CAAC,EAKP+a,EAAO,KAAK,KAAK1c,EAAQkB,CAAS,EAClCyb,EAAO,KAAK,KAAK1c,EAASiB,CAAS,EAGnC0b,EAAY,KAAK,MAAM5c,EAAQ0c,CAAI,EACnCG,EAAa,KAAK,MAAM5c,EAAS0c,CAAI,EAIrCG,EAAyB,CAAA,EAC/B,QAASlW,EAAI,EAAGA,GAAK+V,EAAM/V,IAAK,CAC9B,MAAMmW,EAAsB,CAAA,EAC5B,QAAS3P,EAAI,EAAGA,GAAKsP,EAAMtP,IAAK,CAC9B,MAAM7K,EAAI6K,EAAIwP,EACRpa,EAAIoE,EAAIiW,EACdE,EAAY,KAAK,CAACxa,EAAGC,CAAC,CAAC,CACzB,CACAsa,EAAa,KAAKC,CAAW,CAC/B,CAEApb,EAAS,SAAWmb,EAAa,KAAA,EAKjC,MAAME,MAAsB,IAU5B,QAASpW,EAAI,EAAGA,EAAI+V,EAAM/V,IACxB,QAASwG,EAAI,EAAGA,EAAIsP,EAAMtP,IAAK,CAC7B,MAAM6P,EAAUrW,EAAI8V,EAAOtP,EAGrB8P,EAAUJ,EAAalW,CAAC,EAAEwG,CAAC,EAC3B+P,EAAWL,EAAalW,CAAC,EAAEwG,EAAI,CAAC,EAChCgQ,EAAaN,EAAalW,EAAI,CAAC,EAAEwG,CAAC,EAClCiQ,EAAcP,EAAalW,EAAI,CAAC,EAAEwG,EAAI,CAAC,EAGvCkQ,EAAsB,CAAE,GAAI1E,EAAA,EAAe,OAAQsE,EAAa,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,MAAOD,CAAA,EACrGM,EAAsB,CAAE,GAAI3E,EAAA,EAAe,OAAQuE,EAAa,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,MAAOF,CAAA,EACrGO,EAAsB,CAAE,GAAI5E,EAAA,EAAe,OAAQyE,EAAa,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,MAAOJ,CAAA,EACrGQ,EAAsB,CAAE,GAAI7E,EAAA,EAAe,OAAQwE,EAAa,KAAM,GAAI,KAAM,GAAI,KAAM,GAAI,MAAOH,CAAA,EAG3GK,EAAO,KAAOC,EAAS,GACvBA,EAAS,KAAOC,EAAU,GAC1BA,EAAU,KAAOC,EAAQ,GACzBA,EAAQ,KAAOH,EAAO,GAEtBA,EAAO,KAAOG,EAAQ,GACtBA,EAAQ,KAAOD,EAAU,GACzBA,EAAU,KAAOD,EAAS,GAC1BA,EAAS,KAAOD,EAAO,GAGvB3b,EAAS,UAAU,IAAI2b,EAAO,GAAIA,CAAM,EACxC3b,EAAS,UAAU,IAAI4b,EAAS,GAAIA,CAAQ,EAC5C5b,EAAS,UAAU,IAAI6b,EAAU,GAAIA,CAAS,EAC9C7b,EAAS,UAAU,IAAI8b,EAAQ,GAAIA,CAAO,EAG1C,MAAMhb,EAAe,CACnB,GAAIwa,EACJ,KAAM,EAAGC,EAAQ,CAAC,EAAIG,EAAY,CAAC,GAAK,GAAIH,EAAQ,CAAC,EAAIG,EAAY,CAAC,GAAK,CAAE,EAC7E,SAAUC,EAAO,GACjB,KAAM,CAACJ,EAAQ,CAAC,EAAGA,EAAQ,CAAC,EAAGG,EAAY,CAAC,EAAGA,EAAY,CAAC,CAAC,CAAA,EAE/D1b,EAAS,OAAO,IAAIsb,EAASxa,CAAK,EAKlC,MAAM8O,EAAM,CAACa,EAAUgH,IAAa,GAAGhH,EAAG,CAAC,CAAC,IAAIA,EAAG,CAAC,CAAC,IAAIgH,EAAG,CAAC,CAAC,IAAIA,EAAG,CAAC,CAAC,GAEjEsE,EAAiB,CACrB,CAAE,GAAIJ,EAAW,GAAIJ,EAAa,GAAIC,EAAa,WAAYvW,IAAM,CAAA,EACrE,CAAE,GAAI2W,EAAW,GAAIJ,EAAa,GAAIE,EAAa,WAAYjQ,IAAMsP,EAAO,CAAA,EAC5E,CAAE,GAAIc,EAAW,GAAIH,EAAa,GAAID,EAAa,WAAYxW,IAAM+V,EAAO,CAAA,EAC5E,CAAE,GAAIc,EAAW,GAAIL,EAAa,GAAIF,EAAa,WAAY9P,IAAM,CAAA,CAAE,EAGzE,UAAWuQ,KAAYD,EAAgB,CACrC,MAAME,EAAUrM,EAAIoM,EAAS,GAAIA,EAAS,EAAE,EACtC7D,EAASkD,EAAgB,IAAIY,CAAO,EAEpC7D,EAASnB,EAAA,EACf,IAAIhX,EAEJ,GAAIkY,IAAW,OAAW,CAExB,MAAM+D,EAASlc,EAAS,UAAU,IAAImY,CAAM,EAC5C6D,EAAS,GAAG,KAAOE,EAAO,GAC1BA,EAAO,KAAOF,EAAS,GAAG,GAG1B/b,EAAO,CAAE,GAAImY,EAAQ,OAAQ8D,EAAO,GAAI,QAASF,EAAS,GAAG,EAAA,EAC7DX,EAAgB,OAAOY,CAAO,CAChC,KAAO,CAGL,MAAME,EAAUvM,EAAIoM,EAAS,GAAIA,EAAS,EAAE,EAI5C,GAHAX,EAAgB,IAAIc,EAASH,EAAS,GAAG,EAAE,EAGvCA,EAAS,WACX/b,EAAO,CAAE,GAAImY,EAAQ,OAAQ4D,EAAS,GAAG,GAAI,QAAS,EAAA,EACtDhc,EAAS,SAAS,KAAKoY,CAAM,MAE7B,SAEJ,CACApY,EAAS,MAAM,IAAIoY,EAAQnY,CAAI,CACjC,CACF,CAGF,OAAOD,CACT,CAAA,GAOJhB,EAAuB,SAAS2J,GAAMkS,GAAkCD,EAAmC,EC9LpG,MAAMjS,GAA6B,mBAQ7ByT,GAAyC,CACpD,KAAMzT,GACN,YAAa,OACb,YAAa,wDACb,SAAU,EAEV,SAAU,CAAA,CACZ,EAGa0T,GAA0D,CAACvT,EAAgBC,EAAgBC,KAC/D,CACrC,OAAOsT,EAAa3E,EAA0C,CAE9D,CAAA,GAOJ1Y,EAAqB,SAAS0J,GAAM0T,GAAyBD,EAAiB,EC7BvE,MAAMzT,GAAiC,uBAUjC4T,GAA6C,CACxD,KAAM5T,GACN,YAAa,WACb,YAAa,gEACb,SAAU,EAEV,SAAU,CACR,CACE,KAAM,QACN,KAAM,iBACN,MAAO,aACP,SAAU,GACV,IAAK,EACL,IAAK,IACL,KAAM,EACN,aAAc,GACd,SAAU,kFAAA,CACZ,CAEJ,EAWa6T,GAA8D,CAAC1T,EAAgBC,EAAgBxK,IAAuC,CACjJ,KAAM,CAAE,eAAAke,EAAiB,EAAA,EAAOle,EA6EhC,MA3E2C,CACzC,OAAO0B,EAAYgJ,EAAyC,CAC1D,KAAM,CAAE,SAAAjJ,EAAU,OAAAF,CAAA,EAAWmJ,EAIvB+O,EAAMhY,EAAS,UAAU,IAAIC,EAAK,MAAM,EACxCoY,EAAMrY,EAAS,UAAU,IAAIC,EAAK,OAAO,EAG/C,GAAI,CAAC+X,GAAO,CAACK,EAAK,CAChB,QAAQ,KAAK,uDAAwDpY,EAAK,EAAE,EAC5E,MACF,CAKA,MAAMqQ,EAAK0H,EAAI,OACT0E,EAAKrE,EAAI,OAGTsE,EAAmB,CAACD,EAAG,CAAC,EAAIpM,EAAG,CAAC,EAAGoM,EAAG,CAAC,EAAIpM,EAAG,CAAC,CAAC,EAChDsM,EAAa,KAAK,KAAKD,EAAW,CAAC,GAAK,EAAIA,EAAW,CAAC,GAAK,CAAC,EACpE,GAAIC,EAAa,KAAM,OAIvB,MAAMC,EAAgB,CAACF,EAAW,CAAC,EAAIC,EAAYD,EAAW,CAAC,EAAIC,CAAU,EACvEE,EAAkB,CAAC,CAACD,EAAQ,CAAC,EAAGA,EAAQ,CAAC,CAAC,EAI1CE,EAAiB,CAACzM,EAAG,CAAC,EAAIqM,EAAW,CAAC,EAAI,EAAGrM,EAAG,CAAC,EAAIqM,EAAW,CAAC,EAAI,CAAC,EAGtEK,EAAYld,EAAA,EAAW,GAAM,EAAI,GACjCmd,EAAYL,GAAcH,EAAiB,KAAOO,EAGlDE,EAAiB,CACrBH,EAAS,CAAC,EAAID,EAAU,CAAC,EAAIG,EAC7BF,EAAS,CAAC,EAAID,EAAU,CAAC,EAAIG,CAAA,EAQzBE,EAAgB,CACpB,KAAM,SACN,GAAID,EACJ,GAAIA,EACJ,GAAAR,CAAA,EAKIU,EAAqB,CACzBL,EAAS,CAAC,EAAID,EAAU,CAAC,EAAIG,EAC7BF,EAAS,CAAC,EAAID,EAAU,CAAC,EAAIG,CAAA,EAEzBI,EAAgB,CACpB,KAAM,SACN,GAAID,EACJ,GAAIA,EACJ,GAAI9M,CAAA,EAIN0H,EAAI,SAAW,CAACmF,CAAI,EACpB9E,EAAI,SAAW,CAACgF,CAAI,CACtB,CAAA,CAGJ,EAKApe,EAAqB,SAAS0J,GAAM6T,GAA6BD,EAAqB,EC1FtF,MAAMe,GAAoC,IAAM,CAK9C,MAAMC,EAAwBC,GACxBC,EAAwBC,GACxBC,EAAsBC,GA6CtB5c,EAAmB,CACvB,KAAM,IAAI,OAAO,UAAY,MAC7B,YAAa,IACb,aAAc,IACd,YAAa,IAAe,IAC5B,SAAU,GACV,MAAO,UACP,iBAAkB,CAChB,UAAW,GACX,SAAU,OACV,SAAU,MAAA,EAEZ,MAAO,GACP,WAAY,CAEV,MAAO,CACL,MAAO,cACP,SAAUjC,EACV,KAAMwe,EACN,OAAQxe,EAAuB,iBAAiBwe,EAAuB,IAAc,GAAa,CAAA,EAGpG,MAAO,CACL,MAAO,mBACP,SAAUve,EACV,KAAMye,EACN,OAAQze,EAAuB,iBAAiBye,EAAuB,IAAc,GAAa,CAAA,EAGpG,IAAK,CACH,MAAO,OACP,SAAUxe,EACV,KAAM0e,EACN,OAAQ1e,EAAqB,iBAAiB0e,EAAqB,IAAc,GAAa,CAAA,CAChG,EAEF,OAAQ,OACR,mBAAoB,OACpB,oBAAqB,EAAA,EAIvB,SAASE,GAAsB,CACxB7c,EAAM,SAEXA,EAAM,iBAAiB,SAAW,EAClChD,EAAE,OAAA,EAGFic,GAAsBjZ,EAAM,OAAQ,CAAC8c,EAAWC,IAAU,CACxD/c,EAAM,iBAAiB,SAAY8c,EAAYC,EAAS,IACxD/f,EAAE,OAAA,CACJ,CAAC,EAAE,KAAMggB,GAAa,CACpBhd,EAAM,iBAAiB,SAAWgd,EAAS,OAC3Chd,EAAM,iBAAiB,SAAW,OAC9BA,EAAM,SACRA,EAAM,OAAO,SAAWgd,GAE1BhgB,EAAE,OAAA,CACJ,CAAC,EAAE,MAAO0E,GAAQ,CAChB1B,EAAM,iBAAiB,SAAW,OAClC,QAAQ,MAAM0B,CAAG,EACjB1E,EAAE,OAAA,CACJ,CAAC,EACH,CAGA,MAAO,CAEL,SAAU,IAAM,CACdqB,GAAY,CACV,MAAO2B,EAAM,YACb,OAAQA,EAAM,aACd,UAAWA,EAAM,SACjB,YAAaA,EAAM,WAAW,MAAM,OACpC,YAAaA,EAAM,WAAW,MAAM,OACpC,UAAWA,EAAM,WAAW,IAAI,OAChC,KAAMA,EAAM,IAAA,CACb,EAAE,KAAMb,GAAW,CAClBa,EAAM,OAASb,EACfnC,EAAE,OAAA,EACEgD,EAAM,iBAAiB,WACzB6c,EAAA,CAEJ,CAAC,EAAE,MAAOnb,GAAQ,CAChB,QAAQ,MAAMA,CAAG,CACnB,CAAC,CACH,EAEA,SAAU,IAAM,CACV1B,EAAM,QACRA,EAAM,MAAQ,GAEd3B,GAAY,CACV,MAAO2B,EAAM,YACb,OAAQA,EAAM,aACd,UAAWA,EAAM,SACjB,YAAaA,EAAM,WAAW,MAAM,OACpC,YAAaA,EAAM,WAAW,MAAM,OACpC,UAAWA,EAAM,WAAW,IAAI,OAChC,KAAMA,EAAM,IAAA,CACb,EAAE,KAAMb,GAAW,CAClBa,EAAM,iBAAiB,SAAW,OAClCA,EAAM,iBAAiB,SAAW,OAClCA,EAAM,OAASb,EACfnC,EAAE,OAAA,EACEgD,EAAM,iBAAiB,WACzB6c,EAAA,CAEJ,CAAC,EAAE,MAAOnb,GAAQ,CAChB,QAAQ,MAAMA,CAAG,CACnB,CAAC,EAEL,EAEA,SAAU,IAAM,CACV1B,EAAM,qBAER,IAAI,gBAAgBA,EAAM,kBAAkB,EAC5CA,EAAM,mBAAqB,OAE/B,EAGA,KAAM,IAEGhD,EAAE,QAAS,CAChBA,EAAEF,GAAc,CACd,KAAM,kDAAA,CACP,EACDE,EAAE,KAAM,kBAAkB,EAC1BA,EAAE,aAAc,CAEdgD,EAAM,QAAUhD,EAAE,gBAAiB,CAGjCA,EAAE+C,GAAQ,CACR,MAAOC,EAAM,YACb,OAAQA,EAAM,aACd,MAAOA,EAAM,MACb,SAAUA,EAAM,mBAChB,OAAQA,EAAM,OACd,QAASA,EAAM,KAAA,CAChB,EAEDhD,EAAE,WAAY,CAGZA,EAAE0D,GAAsB,CACtB,OAAQV,EAAM,OACd,MAAOA,EAAM,YACb,OAAQA,EAAM,aACd,MAAOA,EAAM,KAAA,CACd,EAGDhD,EAAE2D,GAAwB,CACxB,UAAWX,EAAM,iBAAiB,UAClC,SAAUA,EAAM,iBAAiB,SACjC,gBAAiBA,EAAM,iBAAiB,SACxC,iBAAkB,IAAM,CACjBA,EAAM,OACT6c,EAAA,EAEF7f,EAAE,OAAA,CACJ,EACA,mBAAqBigB,GAAc,CAC7BA,IAAcjd,EAAM,iBAAiB,YACvCA,EAAM,iBAAiB,UAAYid,EACnCjgB,EAAE,OAAA,EAEN,CAAA,CACD,CAAA,CAEF,CAAA,CACF,EAGDA,EAAE,YAAa,CAGbA,EAAE,oBAAqB,CACrBA,EAAEsE,GAAmB,CACnB,MAAO,mBACP,SAAU,CAAC4b,EAAU3c,EAAUlD,EAAOC,IAAW,CAE3C0C,EAAM,oBACR,IAAI,gBAAgBA,EAAM,kBAAkB,EAE9CA,EAAM,YAAc3C,EACpB2C,EAAM,aAAe1C,EACrB0C,EAAM,YAAc3C,EAAQC,EAC5B0C,EAAM,mBAAqBkd,EAC3Bld,EAAM,oBAAsBO,EAC5BP,EAAM,MAAQ,GACdhD,EAAE,OAAA,CACJ,CAAA,CACD,EACDA,EAAE,8BAA+BgD,EAAM,mBAAmB,CAAA,CAC3D,EAGDhD,EAAEuF,GAAmB,CACnB,MAAOvC,EAAM,YACb,SAAUA,EAAM,qBAAuB,OACvC,SAAWmd,GAAU,CACnBnd,EAAM,YAAcmd,EACpBnd,EAAM,YAAcA,EAAM,aAAemd,EACzCnd,EAAM,MAAQ,GACdhD,EAAE,OAAA,CACJ,CAAA,CACD,EAGDA,EAAE6E,GAAoB,CACpB,OAAQ,CACN,KAAM,OACN,MAAO,OACP,KAAM,QAAA,EAER,MAAO7B,EAAM,KACb,SAAWqC,GAAU,CACnBrC,EAAM,KAAOqC,GAAS,EACtBrC,EAAM,MAAQ,GACdhD,EAAE,OAAA,CACJ,CAAA,CACD,EAGDA,EAAE6E,GAAoB,CACpB,OAAQ,CACN,KAAM,YACN,MAAO,aACP,KAAM,QAAA,EAER,MAAO7B,EAAM,SACb,SAAWqC,GAAU,CACnBrC,EAAM,SAAWqC,GAAS,EAC1BrC,EAAM,MAAQ,GACdhD,EAAE,OAAA,CACJ,CAAA,CACD,EAGDA,EAAE6F,GAAa,CACb,MAAO,cACP,MAAO7C,EAAM,MACb,KAAM,QACN,SAAWod,GAAa,CACtBpd,EAAM,MAAQod,EACdpgB,EAAE,OAAA,CACJ,CAAA,CACD,EAGD,GAAG,OAAO,QAAQgD,EAAM,UAAU,EAAE,IAAI,CAAC,CAACqd,EAAM7f,CAAS,IAChDR,EAAE,QAAS,CAChBQ,EAAU,MAAQ,IAClBR,EAAEgF,GAAiB,CACjB,UAAWxE,EAAU,KACrB,SAAUA,EAAU,SACpB,OAAQA,EAAU,OAClB,kBAAoB8f,GAAkB,CAChCA,GAAiB9f,EAAU,OAC7B,QAAQ,IAAI,GAAG6f,CAAI,yBAAyBC,CAAa,EAAE,EAC3D9f,EAAU,KAAO8f,EAEjBtd,EAAM,WAAWqd,CAAI,EAAE,OAAS7f,EAAU,SAAS,iBAAiB8f,EAAetd,EAAM,YAAaA,EAAM,YAAY,EACxHA,EAAM,MAAQ,GACdhD,EAAE,OAAA,EAEN,EACA,eAAgB,CAAC4R,EAAKvM,IAAU,CAC9B,QAAQ,IAAI,GAAGgb,CAAI,sBAAsBzO,CAAG,gBAAgB,OAAOvM,CAAK,CAAC,EAAE,EAC3E7E,EAAU,OAAOoR,CAAG,EAAIvM,EACxBrC,EAAM,MAAQ,GACdhD,EAAE,OAAA,CACJ,CAAA,CACD,CAAA,CACF,CACF,CAAA,CAEF,CAAA,CAEF,CAAA,CAEF,CACH,CAEJ,EAGAugB,GAAoB,WAAY,CAC9B,SAAWrgB,GAAS,CAClB,MAAMsgB,EAAQtgB,EAAK,MAAM,4BAA4B,EACrD,OAAIsgB,EACK,iEAAiEA,EAAM,CAAC,GAAK,UAAU,IAAIA,EAAM,CAAC,CAAC,OAErG,EACT,CACF,CAAC,EAKDxgB,EAAE,MAAM,SAAS,KAAMsf,EAAI","x_google_ignoreList":[16,17,18,19,20,21,22,24,25,26,27,28,29,30]}