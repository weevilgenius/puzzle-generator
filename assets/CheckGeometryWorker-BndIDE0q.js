(function(){"use strict";function W(o,n){const e=o[0]-n[0],i=o[1]-n[1];return e*e+i*i}function tt(o){return{vertices:o.vertices,pieces:new Map(o.pieces),edges:new Map(o.edges),halfEdges:new Map(o.halfEdges),boundary:o.boundary}}function nt(o,n){return!(o[2]<n[0]||o[0]>n[2]||o[3]<n[1]||o[1]>n[3])}function Y(o,n){let[e,i]=o,[r,c]=o;const s=u=>{e=Math.min(e,u[0]),i=Math.min(i,u[1]),r=Math.max(r,u[0]),c=Math.max(c,u[1])};for(const u of n)u.type==="line"?s(u.p):(s(u.p1),s(u.p2),s(u.p3));return[e,i,r,c]}const{abs:F,cos:I,sin:D,acos:et,atan2:R,sqrt:T,pow:S}=Math;function U(o){return o<0?-S(-o,1/3):S(o,1/3)}const Z=Math.PI,V=2*Z,N=Z/2,it=1e-6,X=Number.MAX_SAFE_INTEGER||9007199254740991,H=Number.MIN_SAFE_INTEGER||-9007199254740991,st={x:0,y:0,z:0},y={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(o,n){const e=n(o);let i=e.x*e.x+e.y*e.y;return typeof e.z<"u"&&(i+=e.z*e.z),T(i)},compute:function(o,n,e){if(o===0)return n[0].t=0,n[0];const i=n.length-1;if(o===1)return n[i].t=1,n[i];const r=1-o;let c=n;if(i===0)return n[0].t=o,n[0];if(i===1){const u={x:r*c[0].x+o*c[1].x,y:r*c[0].y+o*c[1].y,t:o};return e&&(u.z=r*c[0].z+o*c[1].z),u}if(i<4){let u=r*r,f=o*o,a,h,l,x=0;i===2?(c=[c[0],c[1],c[2],st],a=u,h=r*o*2,l=f):i===3&&(a=u*r,h=u*o*3,l=r*f*3,x=o*f);const p={x:a*c[0].x+h*c[1].x+l*c[2].x+x*c[3].x,y:a*c[0].y+h*c[1].y+l*c[2].y+x*c[3].y,t:o};return e&&(p.z=a*c[0].z+h*c[1].z+l*c[2].z+x*c[3].z),p}const s=JSON.parse(JSON.stringify(n));for(;s.length>1;){for(let u=0;u<s.length-1;u++)s[u]={x:s[u].x+(s[u+1].x-s[u].x)*o,y:s[u].y+(s[u+1].y-s[u].y)*o},typeof s[u].z<"u"&&(s[u].z=s[u].z+(s[u+1].z-s[u].z)*o);s.splice(s.length-1,1)}return s[0].t=o,s[0]},computeWithRatios:function(o,n,e,i){const r=1-o,c=e,s=n;let u=c[0],f=c[1],a=c[2],h=c[3],l;if(u*=r,f*=o,s.length===2)return l=u+f,{x:(u*s[0].x+f*s[1].x)/l,y:(u*s[0].y+f*s[1].y)/l,z:i?(u*s[0].z+f*s[1].z)/l:!1,t:o};if(u*=r,f*=2*r,a*=o*o,s.length===3)return l=u+f+a,{x:(u*s[0].x+f*s[1].x+a*s[2].x)/l,y:(u*s[0].y+f*s[1].y+a*s[2].y)/l,z:i?(u*s[0].z+f*s[1].z+a*s[2].z)/l:!1,t:o};if(u*=r,f*=1.5*r,a*=3*r,h*=o*o*o,s.length===4)return l=u+f+a+h,{x:(u*s[0].x+f*s[1].x+a*s[2].x+h*s[3].x)/l,y:(u*s[0].y+f*s[1].y+a*s[2].y+h*s[3].y)/l,z:i?(u*s[0].z+f*s[1].z+a*s[2].z+h*s[3].z)/l:!1,t:o}},derive:function(o,n){const e=[];for(let i=o,r=i.length,c=r-1;r>1;r--,c--){const s=[];for(let u=0,f;u<c;u++)f={x:c*(i[u+1].x-i[u].x),y:c*(i[u+1].y-i[u].y)},n&&(f.z=c*(i[u+1].z-i[u].z)),s.push(f);e.push(s),i=s}return e},between:function(o,n,e){return n<=o&&o<=e||y.approximately(o,n)||y.approximately(o,e)},approximately:function(o,n,e){return F(o-n)<=(e||it)},length:function(o){const e=y.Tvalues.length;let i=0;for(let r=0,c;r<e;r++)c=.5*y.Tvalues[r]+.5,i+=y.Cvalues[r]*y.arcfn(c,o);return .5*i},map:function(o,n,e,i,r){const c=e-n,s=r-i,u=o-n,f=u/c;return i+s*f},lerp:function(o,n,e){const i={x:n.x+o*(e.x-n.x),y:n.y+o*(e.y-n.y)};return n.z!==void 0&&e.z!==void 0&&(i.z=n.z+o*(e.z-n.z)),i},pointToString:function(o){let n=o.x+"/"+o.y;return typeof o.z<"u"&&(n+="/"+o.z),n},pointsToString:function(o){return"["+o.map(y.pointToString).join(", ")+"]"},copy:function(o){return JSON.parse(JSON.stringify(o))},angle:function(o,n,e){const i=n.x-o.x,r=n.y-o.y,c=e.x-o.x,s=e.y-o.y,u=i*s-r*c,f=i*c+r*s;return R(u,f)},round:function(o,n){const e=""+o,i=e.indexOf(".");return parseFloat(e.substring(0,i+1+n))},dist:function(o,n){const e=o.x-n.x,i=o.y-n.y;return T(e*e+i*i)},closest:function(o,n){let e=S(2,63),i,r;return o.forEach(function(c,s){r=y.dist(n,c),r<e&&(e=r,i=s)}),{mdist:e,mpos:i}},abcratio:function(o,n){if(n!==2&&n!==3)return!1;if(typeof o>"u")o=.5;else if(o===0||o===1)return o;const e=S(o,n)+S(1-o,n),i=e-1;return F(i/e)},projectionratio:function(o,n){if(n!==2&&n!==3)return!1;if(typeof o>"u")o=.5;else if(o===0||o===1)return o;const e=S(1-o,n),i=S(o,n)+e;return e/i},lli8:function(o,n,e,i,r,c,s,u){const f=(o*i-n*e)*(r-s)-(o-e)*(r*u-c*s),a=(o*i-n*e)*(c-u)-(n-i)*(r*u-c*s),h=(o-e)*(c-u)-(n-i)*(r-s);return h==0?!1:{x:f/h,y:a/h}},lli4:function(o,n,e,i){const r=o.x,c=o.y,s=n.x,u=n.y,f=e.x,a=e.y,h=i.x,l=i.y;return y.lli8(r,c,s,u,f,a,h,l)},lli:function(o,n){return y.lli4(o,o.c,n,n.c)},makeline:function(o,n){return new _(o.x,o.y,(o.x+n.x)/2,(o.y+n.y)/2,n.x,n.y)},findbbox:function(o){let n=X,e=X,i=H,r=H;return o.forEach(function(c){const s=c.bbox();n>s.x.min&&(n=s.x.min),e>s.y.min&&(e=s.y.min),i<s.x.max&&(i=s.x.max),r<s.y.max&&(r=s.y.max)}),{x:{min:n,mid:(n+i)/2,max:i,size:i-n},y:{min:e,mid:(e+r)/2,max:r,size:r-e}}},shapeintersections:function(o,n,e,i,r){if(!y.bboxoverlap(n,i))return[];const c=[],s=[o.startcap,o.forward,o.back,o.endcap],u=[e.startcap,e.forward,e.back,e.endcap];return s.forEach(function(f){f.virtual||u.forEach(function(a){if(a.virtual)return;const h=f.intersects(a,r);h.length>0&&(h.c1=f,h.c2=a,h.s1=o,h.s2=e,c.push(h))})}),c},makeshape:function(o,n,e){const i=n.points.length,r=o.points.length,c=y.makeline(n.points[i-1],o.points[0]),s=y.makeline(o.points[r-1],n.points[0]),u={startcap:c,forward:o,back:n,endcap:s,bbox:y.findbbox([c,o,n,s])};return u.intersections=function(f){return y.shapeintersections(u,u.bbox,f,f.bbox,e)},u},getminmax:function(o,n,e){if(!e)return{min:0,max:0};let i=X,r=H,c,s;e.indexOf(0)===-1&&(e=[0].concat(e)),e.indexOf(1)===-1&&e.push(1);for(let u=0,f=e.length;u<f;u++)c=e[u],s=o.get(c),s[n]<i&&(i=s[n]),s[n]>r&&(r=s[n]);return{min:i,mid:(i+r)/2,max:r,size:r-i}},align:function(o,n){const e=n.p1.x,i=n.p1.y,r=-R(n.p2.y-i,n.p2.x-e),c=function(s){return{x:(s.x-e)*I(r)-(s.y-i)*D(r),y:(s.x-e)*D(r)+(s.y-i)*I(r)}};return o.map(c)},roots:function(o,n){n=n||{p1:{x:0,y:0},p2:{x:1,y:0}};const e=o.length-1,i=y.align(o,n),r=function(g){return 0<=g&&g<=1};if(e===2){const g=i[0].y,v=i[1].y,A=i[2].y,P=g-2*v+A;if(P!==0){const O=-T(v*v-g*A),q=-g+v,$=-(O+q)/P,j=-(-O+q)/P;return[$,j].filter(r)}else if(v!==A&&P===0)return[(2*v-A)/(2*v-2*A)].filter(r);return[]}const c=i[0].y,s=i[1].y,u=i[2].y,f=i[3].y;let a=-c+3*s-3*u+f,h=3*c-6*s+3*u,l=-3*c+3*s,x=c;if(y.approximately(a,0)){if(y.approximately(h,0))return y.approximately(l,0)?[]:[-x/l].filter(r);const g=T(l*l-4*h*x),v=2*h;return[(g-l)/v,(-l-g)/v].filter(r)}h/=a,l/=a,x/=a;const p=(3*l-h*h)/3,d=p/3,z=(2*h*h*h-9*h*l+27*x)/27,E=z/2,w=E*E+d*d*d;let b,k,C,m,M;if(w<0){const g=-p/3,v=g*g*g,A=T(v),P=-z/(2*A),O=P<-1?-1:P>1?1:P,q=et(O),$=U(A),j=2*$;return C=j*I(q/3)-h/3,m=j*I((q+V)/3)-h/3,M=j*I((q+2*V)/3)-h/3,[C,m,M].filter(r)}else{if(w===0)return b=E<0?U(-E):-U(E),C=2*b-h/3,m=-b-h/3,[C,m].filter(r);{const g=T(w);return b=U(-E+g),k=U(E+g),[b-k-h/3].filter(r)}}},droots:function(o){if(o.length===3){const n=o[0],e=o[1],i=o[2],r=n-2*e+i;if(r!==0){const c=-T(e*e-n*i),s=-n+e,u=-(c+s)/r,f=-(-c+s)/r;return[u,f]}else if(e!==i&&r===0)return[(2*e-i)/(2*(e-i))];return[]}if(o.length===2){const n=o[0],e=o[1];return n!==e?[n/(n-e)]:[]}return[]},curvature:function(o,n,e,i,r){let c,s,u,f,a=0,h=0;const l=y.compute(o,n),x=y.compute(o,e),p=l.x*l.x+l.y*l.y;if(i?(c=T(S(l.y*x.z-x.y*l.z,2)+S(l.z*x.x-x.z*l.x,2)+S(l.x*x.y-x.x*l.y,2)),s=S(p+l.z*l.z,3/2)):(c=l.x*x.y-l.y*x.x,s=S(p,3/2)),c===0||s===0)return{k:0,r:0};if(a=c/s,h=s/c,!r){const d=y.curvature(o-.001,n,e,i,!0).k,z=y.curvature(o+.001,n,e,i,!0).k;f=(z-a+(a-d))/2,u=(F(z-a)+F(a-d))/2}return{k:a,r:h,dk:f,adk:u}},inflections:function(o){if(o.length<4)return[];const n=y.align(o,{p1:o[0],p2:o.slice(-1)[0]}),e=n[2].x*n[1].y,i=n[3].x*n[1].y,r=n[1].x*n[2].y,c=n[3].x*n[2].y,s=18*(-3*e+2*i+3*r-c),u=18*(3*e-i-3*r),f=18*(r-e);if(y.approximately(s,0)){if(!y.approximately(u,0)){let x=-f/u;if(0<=x&&x<=1)return[x]}return[]}const a=2*s;if(y.approximately(a,0))return[];const h=u*u-4*s*f;if(h<0)return[];const l=Math.sqrt(h);return[(l-u)/a,-(u+l)/a].filter(function(x){return 0<=x&&x<=1})},bboxoverlap:function(o,n){const e=["x","y"],i=e.length;for(let r=0,c,s,u,f;r<i;r++)if(c=e[r],s=o[c].mid,u=n[c].mid,f=(o[c].size+n[c].size)/2,F(s-u)>=f)return!1;return!0},expandbox:function(o,n){n.x.min<o.x.min&&(o.x.min=n.x.min),n.y.min<o.y.min&&(o.y.min=n.y.min),n.z&&n.z.min<o.z.min&&(o.z.min=n.z.min),n.x.max>o.x.max&&(o.x.max=n.x.max),n.y.max>o.y.max&&(o.y.max=n.y.max),n.z&&n.z.max>o.z.max&&(o.z.max=n.z.max),o.x.mid=(o.x.min+o.x.max)/2,o.y.mid=(o.y.min+o.y.max)/2,o.z&&(o.z.mid=(o.z.min+o.z.max)/2),o.x.size=o.x.max-o.x.min,o.y.size=o.y.max-o.y.min,o.z&&(o.z.size=o.z.max-o.z.min)},pairiteration:function(o,n,e){const i=o.bbox(),r=n.bbox(),c=1e5,s=e||.5;if(i.x.size+i.y.size<s&&r.x.size+r.y.size<s)return[(c*(o._t1+o._t2)/2|0)/c+"/"+(c*(n._t1+n._t2)/2|0)/c];let u=o.split(.5),f=n.split(.5),a=[{left:u.left,right:f.left},{left:u.left,right:f.right},{left:u.right,right:f.right},{left:u.right,right:f.left}];a=a.filter(function(l){return y.bboxoverlap(l.left.bbox(),l.right.bbox())});let h=[];return a.length===0||(a.forEach(function(l){h=h.concat(y.pairiteration(l.left,l.right,s))}),h=h.filter(function(l,x){return h.indexOf(l)===x})),h},getccenter:function(o,n,e){const i=n.x-o.x,r=n.y-o.y,c=e.x-n.x,s=e.y-n.y,u=i*I(N)-r*D(N),f=i*D(N)+r*I(N),a=c*I(N)-s*D(N),h=c*D(N)+s*I(N),l=(o.x+n.x)/2,x=(o.y+n.y)/2,p=(n.x+e.x)/2,d=(n.y+e.y)/2,z=l+u,E=x+f,w=p+a,b=d+h,k=y.lli8(l,x,z,E,p,d,w,b),C=y.dist(k,o);let m=R(o.y-k.y,o.x-k.x),M=R(n.y-k.y,n.x-k.x),g=R(e.y-k.y,e.x-k.x),v;return m<g?((m>M||M>g)&&(m+=V),m>g&&(v=g,g=m,m=v)):g<M&&M<m?(v=g,g=m,m=v):g+=V,k.s=m,k.e=g,k.r=C,k},numberSort:function(o,n){return o-n}};class L{constructor(n){this.curves=[],this._3d=!1,n&&(this.curves=n,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(n){return y.pointsToString(n.points)}).join(", ")+"]"}addCurve(n){this.curves.push(n),this._3d=this._3d||n._3d}length(){return this.curves.map(function(n){return n.length()}).reduce(function(n,e){return n+e})}curve(n){return this.curves[n]}bbox(){const n=this.curves;for(var e=n[0].bbox(),i=1;i<n.length;i++)y.expandbox(e,n[i].bbox());return e}offset(n){const e=[];return this.curves.forEach(function(i){e.push(...i.offset(n))}),new L(e)}}const{abs:G,min:K,max:B,cos:rt,sin:ot,acos:ct,sqrt:J}=Math,ut=Math.PI;class _{constructor(n){let e=n&&n.forEach?n:Array.from(arguments).slice(),i=!1;if(typeof e[0]=="object"){i=e.length;const p=[];e.forEach(function(d){["x","y","z"].forEach(function(z){typeof d[z]<"u"&&p.push(d[z])})}),e=p}let r=!1;const c=e.length;if(i){if(i>4){if(arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");r=!0}}else if(c!==6&&c!==8&&c!==9&&c!==12&&arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const s=this._3d=!r&&(c===9||c===12)||n&&n[0]&&typeof n[0].z<"u",u=this.points=[];for(let p=0,d=s?3:2;p<c;p+=d){var f={x:e[p],y:e[p+1]};s&&(f.z=e[p+2]),u.push(f)}const a=this.order=u.length-1,h=this.dims=["x","y"];s&&h.push("z"),this.dimlen=h.length;const l=y.align(u,{p1:u[0],p2:u[a]}),x=y.dist(u[0],u[a]);this._linear=l.reduce((p,d)=>p+G(d.y),0)<x/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(n,e,i,r){if(typeof r>"u"&&(r=.5),r===0)return new _(e,e,i);if(r===1)return new _(n,e,e);const c=_.getABC(2,n,e,i,r);return new _(n,c.A,i)}static cubicFromPoints(n,e,i,r,c){typeof r>"u"&&(r=.5);const s=_.getABC(3,n,e,i,r);typeof c>"u"&&(c=y.dist(e,s.C));const u=c*(1-r)/r,f=y.dist(n,i),a=(i.x-n.x)/f,h=(i.y-n.y)/f,l=c*a,x=c*h,p=u*a,d=u*h,z={x:e.x-l,y:e.y-x},E={x:e.x+p,y:e.y+d},w=s.A,b={x:w.x+(z.x-w.x)/(1-r),y:w.y+(z.y-w.y)/(1-r)},k={x:w.x+(E.x-w.x)/r,y:w.y+(E.y-w.y)/r},C={x:n.x+(b.x-n.x)/r,y:n.y+(b.y-n.y)/r},m={x:i.x+(k.x-i.x)/(1-r),y:i.y+(k.y-i.y)/(1-r)};return new _(n,C,m,i)}static getUtils(){return y}getUtils(){return _.getUtils()}static get PolyBezier(){return L}valueOf(){return this.toString()}toString(){return y.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const n=this.points,e=n[0].x,i=n[0].y,r=["M",e,i,this.order===2?"Q":"C"];for(let c=1,s=n.length;c<s;c++)r.push(n[c].x),r.push(n[c].y);return r.join(" ")}setRatios(n){if(n.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=n,this._lut=[]}verify(){const n=this.coordDigest();n!==this._print&&(this._print=n,this.update())}coordDigest(){return this.points.map(function(n,e){return""+e+n.x+n.y+(n.z?n.z:0)}).join("")}update(){this._lut=[],this.dpoints=y.derive(this.points,this._3d),this.computedirection()}computedirection(){const n=this.points,e=y.angle(n[0],n[this.order],n[1]);this.clockwise=e>0}length(){return y.length(this.derivative.bind(this))}static getABC(n=2,e,i,r,c=.5){const s=y.projectionratio(c,n),u=1-s,f={x:s*e.x+u*r.x,y:s*e.y+u*r.y},a=y.abcratio(c,n);return{A:{x:i.x+(i.x-f.x)/a,y:i.y+(i.y-f.y)/a},B:i,C:f,S:e,E:r}}getABC(n,e){e=e||this.get(n);let i=this.points[0],r=this.points[this.order];return _.getABC(this.order,i,e,r,n)}getLUT(n){if(this.verify(),n=n||100,this._lut.length===n+1)return this._lut;this._lut=[],n++,this._lut=[];for(let e=0,i,r;e<n;e++)r=e/(n-1),i=this.compute(r),i.t=r,this._lut.push(i);return this._lut}on(n,e){e=e||5;const i=this.getLUT(),r=[];for(let c=0,s,u=0;c<i.length;c++)s=i[c],y.dist(s,n)<e&&(r.push(s),u+=c/i.length);return r.length?t/=r.length:!1}project(n){const e=this.getLUT(),i=e.length-1,r=y.closest(e,n),c=r.mpos,s=(c-1)/i,u=(c+1)/i,f=.1/i;let a=r.mdist,h=s,l=h,x;a+=1;for(let p;h<u+f;h+=f)x=this.compute(h),p=y.dist(n,x),p<a&&(a=p,l=h);return l=l<0?0:l>1?1:l,x=this.compute(l),x.t=l,x.d=a,x}get(n){return this.compute(n)}point(n){return this.points[n]}compute(n){return this.ratios?y.computeWithRatios(n,this.points,this.ratios,this._3d):y.compute(n,this.points,this._3d,this.ratios)}raise(){const n=this.points,e=[n[0]],i=n.length;for(let r=1,c,s;r<i;r++)c=n[r],s=n[r-1],e[r]={x:(i-r)/i*c.x+r/i*s.x,y:(i-r)/i*c.y+r/i*s.y};return e[i]=n[i-1],new _(e)}derivative(n){return y.compute(n,this.dpoints[0],this._3d)}dderivative(n){return y.compute(n,this.dpoints[1],this._3d)}align(){let n=this.points;return new _(y.align(n,{p1:n[0],p2:n[n.length-1]}))}curvature(n){return y.curvature(n,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return y.inflections(this.points)}normal(n){return this._3d?this.__normal3(n):this.__normal2(n)}__normal2(n){const e=this.derivative(n),i=J(e.x*e.x+e.y*e.y);return{t:n,x:-e.y/i,y:e.x/i}}__normal3(n){const e=this.derivative(n),i=this.derivative(n+.01),r=J(e.x*e.x+e.y*e.y+e.z*e.z),c=J(i.x*i.x+i.y*i.y+i.z*i.z);e.x/=r,e.y/=r,e.z/=r,i.x/=c,i.y/=c,i.z/=c;const s={x:i.y*e.z-i.z*e.y,y:i.z*e.x-i.x*e.z,z:i.x*e.y-i.y*e.x},u=J(s.x*s.x+s.y*s.y+s.z*s.z);s.x/=u,s.y/=u,s.z/=u;const f=[s.x*s.x,s.x*s.y-s.z,s.x*s.z+s.y,s.x*s.y+s.z,s.y*s.y,s.y*s.z-s.x,s.x*s.z-s.y,s.y*s.z+s.x,s.z*s.z];return{t:n,x:f[0]*e.x+f[1]*e.y+f[2]*e.z,y:f[3]*e.x+f[4]*e.y+f[5]*e.z,z:f[6]*e.x+f[7]*e.y+f[8]*e.z}}hull(n){let e=this.points,i=[],r=[],c=0;for(r[c++]=e[0],r[c++]=e[1],r[c++]=e[2],this.order===3&&(r[c++]=e[3]);e.length>1;){i=[];for(let s=0,u,f=e.length-1;s<f;s++)u=y.lerp(n,e[s],e[s+1]),r[c++]=u,i.push(u);e=i}return r}split(n,e){if(n===0&&e)return this.split(e).left;if(e===1)return this.split(n).right;const i=this.hull(n),r={left:this.order===2?new _([i[0],i[3],i[5]]):new _([i[0],i[4],i[7],i[9]]),right:this.order===2?new _([i[5],i[4],i[2]]):new _([i[9],i[8],i[6],i[3]]),span:i};return r.left._t1=y.map(0,0,1,this._t1,this._t2),r.left._t2=y.map(n,0,1,this._t1,this._t2),r.right._t1=y.map(n,0,1,this._t1,this._t2),r.right._t2=y.map(1,0,1,this._t1,this._t2),e?(e=y.map(e,n,1,0,1),r.right.split(e).left):r}extrema(){const n={};let e=[];return this.dims.forEach((function(i){let r=function(s){return s[i]},c=this.dpoints[0].map(r);n[i]=y.droots(c),this.order===3&&(c=this.dpoints[1].map(r),n[i]=n[i].concat(y.droots(c))),n[i]=n[i].filter(function(s){return s>=0&&s<=1}),e=e.concat(n[i].sort(y.numberSort))}).bind(this)),n.values=e.sort(y.numberSort).filter(function(i,r){return e.indexOf(i)===r}),n}bbox(){const n=this.extrema(),e={};return this.dims.forEach((function(i){e[i]=y.getminmax(this,i,n[i])}).bind(this)),e}overlaps(n){const e=this.bbox(),i=n.bbox();return y.bboxoverlap(e,i)}offset(n,e){if(typeof e<"u"){const i=this.get(n),r=this.normal(n),c={c:i,n:r,x:i.x+r.x*e,y:i.y+r.y*e};return this._3d&&(c.z=i.z+r.z*e),c}if(this._linear){const i=this.normal(0),r=this.points.map(function(c){const s={x:c.x+n*i.x,y:c.y+n*i.y};return c.z&&i.z&&(s.z=c.z+n*i.z),s});return[new _(r)]}return this.reduce().map(function(i){return i._linear?i.offset(n)[0]:i.scale(n)})}simple(){if(this.order===3){const r=y.angle(this.points[0],this.points[3],this.points[1]),c=y.angle(this.points[0],this.points[3],this.points[2]);if(r>0&&c<0||r<0&&c>0)return!1}const n=this.normal(0),e=this.normal(1);let i=n.x*e.x+n.y*e.y;return this._3d&&(i+=n.z*e.z),G(ct(i))<ut/3}reduce(){let n,e=0,i=0,r=.01,c,s=[],u=[],f=this.extrema().values;for(f.indexOf(0)===-1&&(f=[0].concat(f)),f.indexOf(1)===-1&&f.push(1),e=f[0],n=1;n<f.length;n++)i=f[n],c=this.split(e,i),c._t1=e,c._t2=i,s.push(c),e=i;return s.forEach(function(a){for(e=0,i=0;i<=1;)for(i=e+r;i<=1+r;i+=r)if(c=a.split(e,i),!c.simple()){if(i-=r,G(e-i)<r)return[];c=a.split(e,i),c._t1=y.map(e,0,1,a._t1,a._t2),c._t2=y.map(i,0,1,a._t1,a._t2),u.push(c),e=i;break}e<1&&(c=a.split(e,1),c._t1=y.map(e,0,1,a._t1,a._t2),c._t2=a._t2,u.push(c))}),u}translate(n,e,i){i=typeof i=="number"?i:e;const r=this.order;let c=this.points.map((s,u)=>(1-u/r)*e+u/r*i);return new _(this.points.map((s,u)=>({x:s.x+n.x*c[u],y:s.y+n.y*c[u]})))}scale(n){const e=this.order;let i=!1;if(typeof n=="function"&&(i=n),i&&e===2)return this.raise().scale(i);const r=this.clockwise,c=this.points;if(this._linear)return this.translate(this.normal(0),i?i(0):n,i?i(1):n);const s=i?i(0):n,u=i?i(1):n,f=[this.offset(0,10),this.offset(1,10)],a=[],h=y.lli4(f[0],f[0].c,f[1],f[1].c);if(!h)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach(function(l){const x=a[l*e]=y.copy(c[l*e]);x.x+=(l?u:s)*f[l].n.x,x.y+=(l?u:s)*f[l].n.y}),i?([0,1].forEach(function(l){if(!(e===2&&l)){var x=c[l+1],p={x:x.x-h.x,y:x.y-h.y},d=i?i((l+1)/e):n;i&&!r&&(d=-d);var z=J(p.x*p.x+p.y*p.y);p.x/=z,p.y/=z,a[l+1]={x:x.x+d*p.x,y:x.y+d*p.y}}}),new _(a)):([0,1].forEach(l=>{if(e===2&&l)return;const x=a[l*e],p=this.derivative(l),d={x:x.x+p.x,y:x.y+p.y};a[l+1]=y.lli4(x,d,h,c[l+1])}),new _(a))}outline(n,e,i,r){if(e=e===void 0?n:e,this._linear){const m=this.normal(0),M=this.points[0],g=this.points[this.points.length-1];let v,A,P;i===void 0&&(i=n,r=e),v={x:M.x+m.x*n,y:M.y+m.y*n},P={x:g.x+m.x*i,y:g.y+m.y*i},A={x:(v.x+P.x)/2,y:(v.y+P.y)/2};const O=[v,A,P];v={x:M.x-m.x*e,y:M.y-m.y*e},P={x:g.x-m.x*r,y:g.y-m.y*r},A={x:(v.x+P.x)/2,y:(v.y+P.y)/2};const q=[P,A,v],$=y.makeline(q[2],O[0]),j=y.makeline(O[2],q[0]),xt=[$,new _(O),j,new _(q)];return new L(xt)}const c=this.reduce(),s=c.length,u=[];let f=[],a,h=0,l=this.length();const x=typeof i<"u"&&typeof r<"u";function p(m,M,g,v,A){return function(P){const O=v/g,q=(v+A)/g,$=M-m;return y.map(P,0,1,m+O*$,m+q*$)}}c.forEach(function(m){const M=m.length();x?(u.push(m.scale(p(n,i,l,h,M))),f.push(m.scale(p(-e,-r,l,h,M)))):(u.push(m.scale(n)),f.push(m.scale(-e))),h+=M}),f=f.map(function(m){return a=m.points,a[3]?m.points=[a[3],a[2],a[1],a[0]]:m.points=[a[2],a[1],a[0]],m}).reverse();const d=u[0].points[0],z=u[s-1].points[u[s-1].points.length-1],E=f[s-1].points[f[s-1].points.length-1],w=f[0].points[0],b=y.makeline(E,d),k=y.makeline(z,w),C=[b].concat(u).concat([k]).concat(f);return new L(C)}outlineshapes(n,e,i){e=e||n;const r=this.outline(n,e).curves,c=[];for(let s=1,u=r.length;s<u/2;s++){const f=y.makeshape(r[s],r[u-s],i);f.startcap.virtual=s>1,f.endcap.virtual=s<u/2-1,c.push(f)}return c}intersects(n,e){return n?n.p1&&n.p2?this.lineIntersects(n):(n instanceof _&&(n=n.reduce()),this.curveintersects(this.reduce(),n,e)):this.selfintersects(e)}lineIntersects(n){const e=K(n.p1.x,n.p2.x),i=K(n.p1.y,n.p2.y),r=B(n.p1.x,n.p2.x),c=B(n.p1.y,n.p2.y);return y.roots(this.points,n).filter(s=>{var u=this.get(s);return y.between(u.x,e,r)&&y.between(u.y,i,c)})}selfintersects(n){const e=this.reduce(),i=e.length-2,r=[];for(let c=0,s,u,f;c<i;c++)u=e.slice(c,c+1),f=e.slice(c+2),s=this.curveintersects(u,f,n),r.push(...s);return r}curveintersects(n,e,i){const r=[];n.forEach(function(s){e.forEach(function(u){s.overlaps(u)&&r.push({left:s,right:u})})});let c=[];return r.forEach(function(s){const u=y.pairiteration(s.left,s.right,i);u.length>0&&(c=c.concat(u))}),c}arcs(n){return n=n||.5,this._iterate(n,[])}_error(n,e,i,r){const c=(r-i)/4,s=this.get(i+c),u=this.get(r-c),f=y.dist(n,e),a=y.dist(n,s),h=y.dist(n,u);return G(a-f)+G(h-f)}_iterate(n,e){let i=0,r=1,c;do{c=0,r=1;let s=this.get(i),u,f,a,h,l=!1,x=!1,p,d=r,z=1;do if(x=l,h=a,d=(i+r)/2,u=this.get(d),f=this.get(r),a=y.getccenter(s,u,f),a.interval={start:i,end:r},l=this._error(a,s,i,r)<=n,p=x&&!l,p||(z=r),l){if(r>=1){if(a.interval.end=z=1,h=a,r>1){let w={x:a.x+a.r*rt(a.e),y:a.y+a.r*ot(a.e)};a.e+=y.angle({x:a.x,y:a.y},w,this.get(1))}break}r=r+(r-i)/2}else r=d;while(!p&&c++<100);if(c>=100)break;h=h||a,e.push(h),i=z}while(r<1);return e}}function ft(o){return o.type==="line"?o.p:o.p3}function Q(o){if(o.segment.type!=="bezier")throw new Error("Boundary segment is not a Bezier curve");const{startPoint:n}=o,{p1:e,p2:i,p3:r}=o.segment;return new _({x:n[0],y:n[1]},{x:e[0],y:e[1]},{x:i[0],y:i[1]},{x:r[0],y:r[1]})}function at(o,n){const e=[],i=o.halfEdge;let r=i;do{const c=n.halfEdges.get(r);if(!c){console.error(`Could not find half-edge with ID: ${r}`);break}let s=c.origin;if(c.segments&&c.segments.length>0)for(const u of c.segments)e.push({segment:u,startPoint:s,bbox:Y(s,[u])}),s=u.type==="line"?u.p:u.p3;else{const u=n.halfEdges.get(c.next);if(!u){console.error(`Could not find next half-edge for ID: ${c.next}`);continue}const f={type:"line",p:u.origin};e.push({segment:f,startPoint:s,bbox:Y(s,[f])})}r=c.next}while(r!==i);return e}function lt(o,n,e){return new Promise(i=>{const r=[],c=o.segment.type,s=n.segment.type,u=.01;if(c==="bezier"&&s==="bezier"){const f=Q(o),a=Q(n);f.intersects(a).forEach(l=>{const x=l.split("/"),p=parseFloat(x[0]),d=parseFloat(x[1]);if(e&&(p>1-u&&d<u||p<u&&d>1-u))return;const z=f.get(p);r.push([z.x,z.y])})}else if(c==="bezier"||s==="bezier"){const f=c==="bezier"?o:n,a=c==="line"?o:n,h=Q(f),l={p1:{x:a.startPoint[0],y:a.startPoint[1]},p2:{x:a.segment.p[0],y:a.segment.p[1]}};h.intersects(l).forEach(p=>{if(e&&(p>1-u||p<u))return;const d=h.get(p);r.push([d.x,d.y])})}else{if(!e)return i(r);const f=o.startPoint,a=o.segment.p,h=n.startPoint,l=n.segment.p,[x,p]=f,[d,z]=a,[E,w]=h,[b,k]=l,C=(x-d)*(w-k)-(p-z)*(E-b);if(C!==0){const m=((x-E)*(w-k)-(p-w)*(E-b))/C,M=-((x-d)*(p-w)-(p-z)*(x-E))/C;if(m>=0&&m<=1&&M>=0&&M<=1){const g=x+m*(d-x),v=p+m*(z-p);r.push([g,v])}}}i(r)})}async function ht(o,n){const e=[],c=Array.from(o.pieces.values()).length;let s=0;for(const u of o.pieces.values()){n?.(s,c);const f=at(u,o),a=f.length;if(a<2){s++;continue}for(let h=0;h<a;h++)for(let l=h+1;l<a;l++){const x=f[h],p=f[l];if(!nt(x.bbox,p.bbox))continue;const d=l===h+1||h===0&&l===a-1,z=await lt(x,p,d);if(z.length!==0)if(d){const E=h===0&&l===a-1?x.startPoint:ft(x.segment);for(const w of z)W(w,E)>1e-8&&e.push(w)}else e.push(...z)}s++}return n?.(c,c),console.log(`detected ${e.length} intersections in ${o.pieces.size} pieces`),e}async function yt(o,n){const e=await ht(o,n);if(e.length<2)return e;const i=1,r=[e[0]];for(let c=1;c<e.length;c++){const s=e[c],u=r[r.length-1];W(s,u)>i*i&&r.push(s)}return r}self.onmessage=async o=>{try{const{topology:n}=o.data,e=tt(n),c={type:"done",results:await yt(e,(s,u)=>{const f={type:"progress",processed:s,total:u};self.postMessage(f)})};self.postMessage(c)}catch(n){const e={type:"error",message:n instanceof Error?n.message:`An error occurred in the CheckGeometryWorker: ${String(n)}.`};self.postMessage(e)}finally{self.close()}}})();
//# sourceMappingURL=CheckGeometryWorker-BndIDE0q.js.map
