import{m as v,g as Ne}from"./mithril-DD6GaBKN.js";import"./shoelace-CTvh2FiC.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))r(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function t(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(n){if(n.ep)return;n.ep=!0;const s=t(n);fetch(n.href,s)}})();const Fe={view:({attrs:l})=>v("a.github-corner",{href:l.link,"aria-label":"View source on GitHub",title:"View source on GitHub",target:"_blank"},v("svg",{width:80,height:80,viewBox:"0 0 250 250","aria-hidden":"true"},[v("path",{d:"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"}),v("path.octo-arm",{fill:"currentColor",style:"transform-origin: 130px 106px;",d:"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"}),v("path.octo-body",{fill:"currentColor",d:"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"})]))};class ge{generators=new Map;register(e,t,r){this.generators.has(e)&&console.warn(`Generator "${e}" is already registered, overwriting`),this.generators.set(e,{factory:t,uiMetadata:r})}create(e){const t=this.generators.get(e.name);if(!t)throw new Error(`Unknown generator "${e.name}". Is it registered?`);return t.factory(e)}getAvailableGenerators(){return Array.from(this.generators.values()).sort((e,t)=>e.uiMetadata.sortHint-t.uiMetadata.sortHint).map(e=>({name:e.uiMetadata.name,displayName:e.uiMetadata.displayName}))}getUIMetadata(e){return this.generators.get(e)?.uiMetadata}getDefaultConfig(e,t,r){const n={name:e,width:t,height:r},s=this.getUIMetadata(e);if(s)for(const i of s.controls)n[i.name]=i.defaultValue;return n}}const te=new ge,fe=new ge,B=new ge;function Re(l){return function(){let e=l+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}async function me(l){const{width:e,height:t,pieceSize:r}=l,{pointConfig:n,pieceConfig:s,tabConfig:i}=l,a=te.create(n),o=fe.create(s),h=B.create(i),u=l.seed??new Date().getTime(),c=Re(u),d=a.generatePoints({width:e,height:t,pieceSize:r,random:c});console.log(`Generated ${d.length} points`);const g=o.generatePieces(d,{random:c});console.log(`Generated ${g.pieces.size} pieces`);for(const f of g.edges.values())f.heRight!==-1&&h.addTab(f,{topology:g,random:c});const p={created:new Date().toISOString(),seed:u,vertices:g.vertices,boundary:g.boundary,pieces:g.pieces,edges:g.edges,halfEdges:g.halfEdges};return Promise.resolve(p)}function be(l,e,t,r=!1){const n=e.getContext("2d");if(!n){console.error("Could not get 2D context from canvas");return}n.clearRect(0,0,e.width,e.height),n.strokeStyle=t,n.lineWidth=1,n.beginPath();for(const s of l.edges.values()){const i=l.halfEdges.get(s.heLeft);if(i)if(n.moveTo(i.origin[0],i.origin[1]),i.segments)for(const a of i.segments)switch(a.type){case"bezier":n.bezierCurveTo(a.p1[0],a.p1[1],a.p2[0],a.p2[1],a.p3[0],a.p3[1]);break;case"line":n.lineTo(a.p[0],a.p[1]);break}else{let a;i.twin!==-1?a=l.halfEdges.get(i.twin).origin:a=l.halfEdges.get(i.next).origin,n.lineTo(a[0],a[1])}}if(n.stroke(),r){n.fillStyle="red";for(const s of l.pieces.values()){const[i,a]=s.site;n.beginPath(),n.arc(i,a,3,0,2*Math.PI),n.fill()}}}const He=()=>{const l={canvas:null};return{oncreate:({dom:e,attrs:t})=>{if(l.canvas=e.querySelector("canvas.puzzle"),!l.canvas){console.log("couldn't get canvas element");return}be(t.puzzle,l.canvas,t.color)},onupdate:({attrs:e})=>{if(!l.canvas){console.log("couldn't get canvas element");return}be(e.puzzle,l.canvas,e.color)},view:({attrs:e})=>v(".puzzle-stack",[v("img.background",{width:e.width,height:e.height,src:e.imageUrl}),v("canvas.puzzle",{width:e.width,height:e.height})])}};function qe(l,e,t,r="black"){const s=[];for(const o of l.edges.values()){const h=l.halfEdges.get(o.heLeft);if(h)if(s.push(`M ${h.origin[0].toFixed(3)} ${h.origin[1].toFixed(3)}`),h.segments)for(const u of h.segments)switch(u.type){case"bezier":s.push(`C ${u.p1[0].toFixed(3)} ${u.p1[1].toFixed(3)}, ${u.p2[0].toFixed(3)} ${u.p2[1].toFixed(3)}, ${u.p3[0].toFixed(3)} ${u.p3[1].toFixed(3)}`);break;case"line":s.push(`L ${u.p[0].toFixed(3)} ${u.p[1].toFixed(3)}`);break}else{let u;h.twin!==-1?u=l.halfEdges.get(h.twin).origin:u=l.halfEdges.get(h.next).origin,s.push(`L ${u[0].toFixed(3)} ${u[1].toFixed(3)}`)}}const i=s.join(" ");return`
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg
  width="${e}"
  height="${t}"
  viewBox="0 0 ${e} ${t}"
  xmlns="http://www.w3.org/2000/svg"
  version="1.1"
>
  <path
    d="${i}"
    fill="none"
    stroke="${r}"
    stroke-width="1"
    vector-effect="non-scaling-stroke"
  />
</svg>`.trim().replace(/\r\n/g,`
`)}function Ve(l,e="puzzle.svg"){const t=new Blob([l],{type:"image/svg+xml"}),r=URL.createObjectURL(t),n=document.createElement("a");n.href=r,n.download=e,n.hidden=!0,document.body.appendChild(n),n.click(),document.body.removeChild(n),setTimeout(()=>URL.revokeObjectURL(r),100)}const je={view:({attrs:l})=>v("sl-button.download-svg",{onclick:()=>{const e=qe(l.puzzle,l.width,l.height,l.color);Ve(e,l.filename??"puzzle.svg")}},"Download SVG")},We=()=>{const l={inputElement:void 0};return{view:({attrs:e})=>[v("sl-button.upload-button",{disabled:e.disabled===!0,onclick:()=>{l.inputElement&&l.inputElement.click()}},e.label??"Upload Image"),v("input[type=file]",{style:{display:"none"},accept:"image/*",oncreate:({dom:t})=>{l.inputElement=t},onchange:t=>{if(t.redraw=!1,l.inputElement){const r=l.inputElement.files?.[0];if(r?.type.startsWith("image/")){const n=URL.createObjectURL(r);e.onUpload(n,r.name)}}}})]}},Oe=()=>({view:({attrs:l})=>v("sl-checkbox.boolean-input",{"help-text":l.config.helpText,disabled:l.disabled,checked:l.value,"onsl-change":e=>{const r=e.target.checked;l.onChange(r)}},l.config.label)}),ue=()=>({view:({attrs:l})=>v("sl-input.number-input",{label:l.config.label,"help-text":l.config.helpText,type:"number",inputmode:"numeric",size:"small",disabled:l.disabled,value:l.value,min:l.config.min,max:l.config.max,"onsl-change":e=>{const r=e.target.valueAsNumber;l.onChange(isNaN(r)?void 0:r)}})}),Be=()=>({view:({attrs:l})=>v("sl-range.range-input",{label:l.config.label,"help-text":l.config.helpText,disabled:l.disabled,value:l.value,min:l.config.min,max:l.config.max,step:l.config.step,"onsl-change":e=>{const r=e.target.value;l.onChange(isNaN(r)?void 0:r)}})}),Ke=()=>({view:({attrs:l})=>v("sl-input.string-input",{label:l.config.label,"help-text":l.config.helpText,type:"text",inputmode:"text",size:"small",disabled:l.disabled,value:l.value,"onsl-change":e=>{const r=e.target.value;l.onChange(r.length>0?r:void 0)}})}),Ye=()=>({oncreate:({dom:l,attrs:e})=>{l.querySelector("sl-tab-group").show(e.generator)},onupdate:({dom:l,attrs:e})=>{l.querySelector("sl-tab-group").show(e.generator)},view:({attrs:l})=>{const e=l.registry.getAvailableGenerators();return v(".generator-picker",v("sl-tab-group",{"onsl-tab-show":t=>{const r=t.detail.name;l.generator!==r&&l.onGeneratorChange(r)}},[...e.map(t=>{const r=l.registry.getUIMetadata(t.name),n=v("sl-tab",{slot:"nav",panel:t.name},t.displayName),s=v("sl-tab-panel",{name:t.name},v(".controls",[r?.description?v("p",r.description):null,...r?.controls.map(i=>{switch(i.type){case"range":return v(Be,{config:i,value:l.config?.[i.name]??i.defaultValue,onChange:a=>{l.onConfigChange(i.name,a)}});case"boolean":return v(Oe,{config:i,value:(l.config?.[i.name]??i.defaultValue)===!0,onChange:a=>{l.onConfigChange(i.name,a)}});case"number":return v(ue,{config:i,value:l.config?.[i.name]??i.defaultValue,onChange:a=>{l.onConfigChange(i.name,a)}});case"string":return v(Ke,{config:i,value:l.config?.[i.name]??i.defaultValue,onChange:a=>{l.onConfigChange(i.name,a)}})}})??[],!r?.description&&r?.controls.length==0?v("p","No controls for this strategy."):null]));return[n,s]})]))}}),Xe={view:({attrs:l})=>v(".color-picker",[v(".label",l.label),v("sl-color-picker",{label:"Select a color",value:l.color,size:l.size??"medium",format:"rgb","onsl-change":e=>{e.redraw=!1;const t=e.target;l.onUpdate(t.value)}})])};var ne,ye;function Ie(){if(ye)return ne;ye=1;function l(t){var r=t.length,n=1,s=new Array(r),i;for(i=r;i>0;i--)s[i-1]=n,n=n*t[i-1];return{stride:s,data:new Uint32Array(n)}}function e(t){var r=t.length,n=1,s=new Array(r),i=[],a,o;for(a=r;a>0;a--)s[a-1]=n,n=n*t[a-1];for(o=0;o<n;o++)i.push([]);return{stride:s,data:i}}return ne={integer:l,array:e},ne}var ie,we;function Ae(){if(we)return ie;we=1,ie=l;function l(e,t){var r=new Array(e),n=Math.floor(e/2)<<1,s=0,i,a,o,h,u;for(u=0;u<n;u+=2)i=-2*Math.log(t()),a=Math.sqrt(i),o=2*Math.PI*t(),s+=i,r[u]=a*Math.cos(o),r[u+1]=a*Math.sin(o);if(e%2){var c=Math.sqrt(-2*Math.log(t()))*Math.cos(2*Math.PI*t());r[e-1]=c,s+=Math.pow(c,2)}for(h=1/Math.sqrt(s),u=0;u<e;++u)r[u]*=h;return r}return ie}var se,ve;function Je(){return ve||(ve=1,se=function(e,t){e=e||1,t=t||2;for(var r=e*2+1,n=Math.pow(r,t)-1,s=new Array(n),i=0;i<n;i++)for(var a=s[i]=new Array(t),o=i<n/2?i:i+1,h=1;h<=t;h++){var u=o%Math.pow(r,h);a[h-1]=u/Math.pow(r,h-1)-e,o-=u}return s}),se}var oe,_e;function Ge(){if(_e)return oe;_e=1;var l=Je();function e(n){var s=l(2,n),i=[],a;for(s=s.filter(function(o){for(var h=0,u=0;u<n;u++)h+=Math.pow(Math.max(0,Math.abs(o[u])-1),2);return h<n}),a=0;a<n;a++)i.push(0);return s.push(i),s.sort(function(o,h){var u=0,c=0,d;for(d=0;d<n;d++)u+=Math.pow(o[d],2),c+=Math.pow(h[d],2);return u<c?-1:u>c?1:0}),s}var t={};function r(n){return t[n]||(t[n]=e(n)),t[n]}return oe=r,oe}var re,xe;function Ze(){if(xe)return re;xe=1;var l=Ie().integer,e=Ae(),t=Ge();function r(s,i){for(var a=0,o=0;o<s.length;o++)a+=Math.pow(s[o]-i[o],2);return a}function n(s,i){if(typeof s.distanceFunction=="function")throw new Error("PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction");this.shape=s.shape,this.minDistance=s.minDistance,this.maxDistance=s.maxDistance||s.minDistance*2,this.maxTries=Math.ceil(Math.max(1,s.tries||30)),this.rng=i||Math.random;for(var a=0,o=0;o<this.shape.length;o++)a=Math.max(a,this.shape[o]);var h=Math.max(1,a/128|0),u=1e-14*h;this.dimension=this.shape.length,this.squaredMinDistance=this.minDistance*this.minDistance,this.minDistancePlusEpsilon=this.minDistance+u,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.minDistance/Math.sqrt(this.dimension),this.neighbourhood=t(this.dimension),this.currentPoint=null,this.processList=[],this.samplePoints=[],this.gridShape=[];for(var o=0;o<this.dimension;o++)this.gridShape.push(Math.ceil(this.shape[o]/this.cellSize));this.grid=l(this.gridShape)}return n.prototype.shape=null,n.prototype.dimension=null,n.prototype.minDistance=null,n.prototype.maxDistance=null,n.prototype.minDistancePlusEpsilon=null,n.prototype.squaredMinDistance=null,n.prototype.deltaDistance=null,n.prototype.cellSize=null,n.prototype.maxTries=null,n.prototype.rng=null,n.prototype.neighbourhood=null,n.prototype.currentPoint=null,n.prototype.processList=null,n.prototype.samplePoints=null,n.prototype.gridShape=null,n.prototype.grid=null,n.prototype.addRandomPoint=function(){for(var s=new Array(this.dimension),i=0;i<this.dimension;i++)s[i]=this.rng()*this.shape[i];return this.directAddPoint(s)},n.prototype.addPoint=function(s){var i,a=!0;if(s.length===this.dimension)for(i=0;i<this.dimension&&a;i++)a=s[i]>=0&&s[i]<this.shape[i];else a=!1;return a?this.directAddPoint(s):null},n.prototype.directAddPoint=function(s){var i=0,a=this.grid.stride,o;for(this.processList.push(s),this.samplePoints.push(s),o=0;o<this.dimension;o++)i+=(s[o]/this.cellSize|0)*a[o];return this.grid.data[i]=this.samplePoints.length,s},n.prototype.inNeighbourhood=function(s){var i=this.dimension,a=this.grid.stride,o,h,u,c,d;for(o=0;o<this.neighbourhood.length;o++){for(h=0,u=0;u<i;u++){if(c=(s[u]/this.cellSize|0)+this.neighbourhood[o][u],c<0||c>=this.gridShape[u]){h=-1;break}h+=c*a[u]}if(h!==-1&&this.grid.data[h]!==0&&(d=this.samplePoints[this.grid.data[h]-1],r(s,d)<this.squaredMinDistance))return!0}return!1},n.prototype.next=function(){for(var s,i,a,o,h,u,c;this.processList.length>0;){for(this.currentPoint===null&&(this.currentPoint=this.processList.shift()),o=this.currentPoint,s=0;s<this.maxTries;s++){for(u=!0,a=this.minDistancePlusEpsilon+this.deltaDistance*this.rng(),this.dimension===2?(i=this.rng()*Math.PI*2,h=[Math.cos(i),Math.sin(i)]):h=e(this.dimension,this.rng),c=0;u&&c<this.dimension;c++)h[c]=o[c]+h[c]*a,u=h[c]>=0&&h[c]<this.shape[c];if(u&&!this.inNeighbourhood(h))return this.directAddPoint(h)}s===this.maxTries&&(this.currentPoint=null)}return null},n.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},n.prototype.getAllPoints=function(){return this.samplePoints},n.prototype.getAllPointsWithDistance=function(){throw new Error("PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation")},n.prototype.reset=function(){var s=this.grid.data,i=0;for(i=0;i<s.length;i++)s[i]=0;this.samplePoints=[],this.currentPoint=null,this.processList.length=0},re=n,re}var ae,Pe;function Qe(){if(Pe)return ae;Pe=1;var l=Ie().array,e=Ae(),t=Ge();function r(s,i){for(var a=0,o=0;o<s.length;o++)a+=Math.pow(s[o]-i[o],2);return Math.sqrt(a)}function n(s,i){if(typeof s.distanceFunction!="function")throw new Error("PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction");this.shape=s.shape,this.minDistance=s.minDistance,this.maxDistance=s.maxDistance||s.minDistance*2,this.maxTries=Math.ceil(Math.max(1,s.tries||30)),this.distanceFunction=s.distanceFunction,this.bias=Math.max(0,Math.min(1,s.bias||0)),this.rng=i||Math.random;for(var a=0,o=0;o<this.shape.length;o++)a=Math.max(a,this.shape[o]);var h=Math.max(1,a/128|0),u=1e-14*h;this.dimension=this.shape.length,this.minDistancePlusEpsilon=this.minDistance+u,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.maxDistance/Math.sqrt(this.dimension),this.neighbourhood=t(this.dimension),this.currentPoint=null,this.currentDistance=0,this.processList=[],this.samplePoints=[],this.sampleDistance=[],this.gridShape=[];for(var o=0;o<this.dimension;o++)this.gridShape.push(Math.ceil(this.shape[o]/this.cellSize));this.grid=l(this.gridShape)}return n.prototype.shape=null,n.prototype.dimension=null,n.prototype.minDistance=null,n.prototype.maxDistance=null,n.prototype.minDistancePlusEpsilon=null,n.prototype.deltaDistance=null,n.prototype.cellSize=null,n.prototype.maxTries=null,n.prototype.distanceFunction=null,n.prototype.bias=null,n.prototype.rng=null,n.prototype.neighbourhood=null,n.prototype.currentPoint=null,n.prototype.currentDistance=null,n.prototype.processList=null,n.prototype.samplePoints=null,n.prototype.sampleDistance=null,n.prototype.gridShape=null,n.prototype.grid=null,n.prototype.addRandomPoint=function(){for(var s=new Array(this.dimension),i=0;i<this.dimension;i++)s[i]=this.rng()*this.shape[i];return this.directAddPoint(s)},n.prototype.addPoint=function(s){var i,a=!0;if(s.length===this.dimension)for(i=0;i<this.dimension&&a;i++)a=s[i]>=0&&s[i]<this.shape[i];else a=!1;return a?this.directAddPoint(s):null},n.prototype.directAddPoint=function(s){var i=0,a=this.grid.stride,o=this.samplePoints.length,h;for(this.processList.push(o),this.samplePoints.push(s),this.sampleDistance.push(this.distanceFunction(s)),h=0;h<this.dimension;h++)i+=(s[h]/this.cellSize|0)*a[h];return this.grid.data[i].push(o),s},n.prototype.inNeighbourhood=function(s){var i=this.dimension,a=this.grid.stride,o,h,u,c,d,g,p=this.distanceFunction(s);for(o=0;o<this.neighbourhood.length;o++){for(h=0,u=0;u<i;u++){if(c=(s[u]/this.cellSize|0)+this.neighbourhood[o][u],c<0||c>=this.gridShape[u]){h=-1;break}h+=c*a[u]}if(h!==-1&&this.grid.data[h].length>0)for(var f=0;f<this.grid.data[h].length;f++){d=this.samplePoints[this.grid.data[h][f]],g=this.sampleDistance[this.grid.data[h][f]];var b=Math.min(g,p),m=Math.max(g,p),y=b+(m-b)*this.bias;if(r(s,d)<this.minDistance+this.deltaDistance*y)return!0}}return!1},n.prototype.next=function(){for(var s,i,a,o,h,u,c,d;this.processList.length>0;){if(this.currentPoint===null){var g=this.processList.shift();this.currentPoint=this.samplePoints[g],this.currentDistance=this.sampleDistance[g]}for(o=this.currentPoint,h=this.currentDistance,s=0;s<this.maxTries;s++){for(c=!0,a=this.minDistancePlusEpsilon+this.deltaDistance*(h+(1-h)*this.bias),this.dimension===2?(i=this.rng()*Math.PI*2,u=[Math.cos(i),Math.sin(i)]):u=e(this.dimension,this.rng),d=0;c&&d<this.dimension;d++)u[d]=o[d]+u[d]*a,c=u[d]>=0&&u[d]<this.shape[d];if(c&&!this.inNeighbourhood(u))return this.directAddPoint(u)}s===this.maxTries&&(this.currentPoint=null)}return null},n.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},n.prototype.getAllPoints=function(){return this.samplePoints},n.prototype.getAllPointsWithDistance=function(){var s=new Array(this.samplePoints.length),i=0,a=0,o;for(i=0;i<this.samplePoints.length;i++){for(o=new Array(this.dimension+1),a=0;a<this.dimension;a++)o[a]=this.samplePoints[i][a];o[this.dimension]=this.sampleDistance[i],s[i]=o}return s},n.prototype.reset=function(){var s=this.grid.data,i=0;for(i=0;i<s.length;i++)s[i]=[];this.samplePoints=[],this.currentPoint=null,this.processList.length=0},ae=n,ae}var le,De;function et(){if(De)return le;De=1;var l=Ze(),e=Qe();function t(r,n){this.shape=r.shape,typeof r.distanceFunction=="function"?this.implementation=new e(r,n):this.implementation=new l(r,n)}return t.prototype.implementation=null,t.prototype.addRandomPoint=function(){return this.implementation.addRandomPoint()},t.prototype.addPoint=function(r){return this.implementation.addPoint(r)},t.prototype.next=function(){return this.implementation.next()},t.prototype.fill=function(){return this.implementation.fill()},t.prototype.getAllPoints=function(){return this.implementation.getAllPoints()},t.prototype.getAllPointsWithDistance=function(){return this.implementation.getAllPointsWithDistance()},t.prototype.reset=function(){this.implementation.reset()},le=t,le}var tt=et();const nt=Ne(tt),J="PoissonPointGenerator",it={name:J,displayName:"Poisson",description:"Generate seed points using Poisson disk sampling. The algorithm produces points that are tightly-packed, but no closer to each other than a specified minimum distance (the piece size), resulting in a more natural, organic look.",sortHint:1,controls:[]},st=l=>({generatePoints(t){const{width:r,height:n,pieceSize:s,random:i}=t;return new nt({shape:[r,n],minDistance:s,tries:20},i).fill()}});te.register(J,st,it);const F=11102230246251565e-32,L=134217729,ot=(3+8*F)*F;function he(l,e,t,r,n){let s,i,a,o,h=e[0],u=r[0],c=0,d=0;u>h==u>-h?(s=h,h=e[++c]):(s=u,u=r[++d]);let g=0;if(c<l&&d<t)for(u>h==u>-h?(i=h+s,a=s-(i-h),h=e[++c]):(i=u+s,a=s-(i-u),u=r[++d]),s=i,a!==0&&(n[g++]=a);c<l&&d<t;)u>h==u>-h?(i=s+h,o=i-s,a=s-(i-o)+(h-o),h=e[++c]):(i=s+u,o=i-s,a=s-(i-o)+(u-o),u=r[++d]),s=i,a!==0&&(n[g++]=a);for(;c<l;)i=s+h,o=i-s,a=s-(i-o)+(h-o),h=e[++c],s=i,a!==0&&(n[g++]=a);for(;d<t;)i=s+u,o=i-s,a=s-(i-o)+(u-o),u=r[++d],s=i,a!==0&&(n[g++]=a);return(s!==0||g===0)&&(n[g++]=s),g}function rt(l,e){let t=e[0];for(let r=1;r<l;r++)t+=e[r];return t}function K(l){return new Float64Array(l)}const at=(3+16*F)*F,lt=(2+12*F)*F,ht=(9+64*F)*F*F,q=K(4),Me=K(8),Te=K(12),ze=K(16),U=K(4);function ct(l,e,t,r,n,s,i){let a,o,h,u,c,d,g,p,f,b,m,y,_,P,z,k,S,C;const w=l-n,D=t-n,x=e-s,M=r-s;P=w*M,d=L*w,g=d-(d-w),p=w-g,d=L*M,f=d-(d-M),b=M-f,z=p*b-(P-g*f-p*f-g*b),k=x*D,d=L*x,g=d-(d-x),p=x-g,d=L*D,f=d-(d-D),b=D-f,S=p*b-(k-g*f-p*f-g*b),m=z-S,c=z-m,q[0]=z-(m+c)+(c-S),y=P+m,c=y-P,_=P-(y-c)+(m-c),m=_-k,c=_-m,q[1]=_-(m+c)+(c-k),C=y+m,c=C-y,q[2]=y-(C-c)+(m-c),q[3]=C;let I=rt(4,q),A=lt*i;if(I>=A||-I>=A||(c=l-w,a=l-(w+c)+(c-n),c=t-D,h=t-(D+c)+(c-n),c=e-x,o=e-(x+c)+(c-s),c=r-M,u=r-(M+c)+(c-s),a===0&&o===0&&h===0&&u===0)||(A=ht*i+ot*Math.abs(I),I+=w*u+M*a-(x*h+D*o),I>=A||-I>=A))return I;P=a*M,d=L*a,g=d-(d-a),p=a-g,d=L*M,f=d-(d-M),b=M-f,z=p*b-(P-g*f-p*f-g*b),k=o*D,d=L*o,g=d-(d-o),p=o-g,d=L*D,f=d-(d-D),b=D-f,S=p*b-(k-g*f-p*f-g*b),m=z-S,c=z-m,U[0]=z-(m+c)+(c-S),y=P+m,c=y-P,_=P-(y-c)+(m-c),m=_-k,c=_-m,U[1]=_-(m+c)+(c-k),C=y+m,c=C-y,U[2]=y-(C-c)+(m-c),U[3]=C;const E=he(4,q,4,U,Me);P=w*u,d=L*w,g=d-(d-w),p=w-g,d=L*u,f=d-(d-u),b=u-f,z=p*b-(P-g*f-p*f-g*b),k=x*h,d=L*x,g=d-(d-x),p=x-g,d=L*h,f=d-(d-h),b=h-f,S=p*b-(k-g*f-p*f-g*b),m=z-S,c=z-m,U[0]=z-(m+c)+(c-S),y=P+m,c=y-P,_=P-(y-c)+(m-c),m=_-k,c=_-m,U[1]=_-(m+c)+(c-k),C=y+m,c=C-y,U[2]=y-(C-c)+(m-c),U[3]=C;const T=he(E,Me,4,U,Te);P=a*u,d=L*a,g=d-(d-a),p=a-g,d=L*u,f=d-(d-u),b=u-f,z=p*b-(P-g*f-p*f-g*b),k=o*h,d=L*o,g=d-(d-o),p=o-g,d=L*h,f=d-(d-h),b=h-f,S=p*b-(k-g*f-p*f-g*b),m=z-S,c=z-m,U[0]=z-(m+c)+(c-S),y=P+m,c=y-P,_=P-(y-c)+(m-c),m=_-k,c=_-m,U[1]=_-(m+c)+(c-k),C=y+m,c=C-y,U[2]=y-(C-c)+(m-c),U[3]=C;const G=he(T,Te,4,U,ze);return ze[G-1]}function Y(l,e,t,r,n,s){const i=(e-s)*(t-n),a=(l-n)*(r-s),o=i-a,h=Math.abs(i+a);return Math.abs(o)>=at*h?o:-ct(l,e,t,r,n,s,h)}const Se=Math.pow(2,-52),X=new Uint32Array(512);class Z{static from(e,t=pt,r=mt){const n=e.length,s=new Float64Array(n*2);for(let i=0;i<n;i++){const a=e[i];s[2*i]=t(a),s[2*i+1]=r(a)}return new Z(s)}constructor(e){const t=e.length>>1;if(t>0&&typeof e[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=e;const r=Math.max(2*t-5,0);this._triangles=new Uint32Array(r*3),this._halfedges=new Int32Array(r*3),this._hashSize=Math.ceil(Math.sqrt(t)),this._hullPrev=new Uint32Array(t),this._hullNext=new Uint32Array(t),this._hullTri=new Uint32Array(t),this._hullHash=new Int32Array(this._hashSize),this._ids=new Uint32Array(t),this._dists=new Float64Array(t),this.update()}update(){const{coords:e,_hullPrev:t,_hullNext:r,_hullTri:n,_hullHash:s}=this,i=e.length>>1;let a=1/0,o=1/0,h=-1/0,u=-1/0;for(let w=0;w<i;w++){const D=e[2*w],x=e[2*w+1];D<a&&(a=D),x<o&&(o=x),D>h&&(h=D),x>u&&(u=x),this._ids[w]=w}const c=(a+h)/2,d=(o+u)/2;let g,p,f;for(let w=0,D=1/0;w<i;w++){const x=ce(c,d,e[2*w],e[2*w+1]);x<D&&(g=w,D=x)}const b=e[2*g],m=e[2*g+1];for(let w=0,D=1/0;w<i;w++){if(w===g)continue;const x=ce(b,m,e[2*w],e[2*w+1]);x<D&&x>0&&(p=w,D=x)}let y=e[2*p],_=e[2*p+1],P=1/0;for(let w=0;w<i;w++){if(w===g||w===p)continue;const D=gt(b,m,y,_,e[2*w],e[2*w+1]);D<P&&(f=w,P=D)}let z=e[2*f],k=e[2*f+1];if(P===1/0){for(let x=0;x<i;x++)this._dists[x]=e[2*x]-e[0]||e[2*x+1]-e[1];j(this._ids,this._dists,0,i-1);const w=new Uint32Array(i);let D=0;for(let x=0,M=-1/0;x<i;x++){const I=this._ids[x],A=this._dists[I];A>M&&(w[D++]=I,M=A)}this.hull=w.subarray(0,D),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(Y(b,m,y,_,z,k)<0){const w=p,D=y,x=_;p=f,y=z,_=k,f=w,z=D,k=x}const S=ft(b,m,y,_,z,k);this._cx=S.x,this._cy=S.y;for(let w=0;w<i;w++)this._dists[w]=ce(e[2*w],e[2*w+1],S.x,S.y);j(this._ids,this._dists,0,i-1),this._hullStart=g;let C=3;r[g]=t[f]=p,r[p]=t[g]=f,r[f]=t[p]=g,n[g]=0,n[p]=1,n[f]=2,s.fill(-1),s[this._hashKey(b,m)]=g,s[this._hashKey(y,_)]=p,s[this._hashKey(z,k)]=f,this.trianglesLen=0,this._addTriangle(g,p,f,-1,-1,-1);for(let w=0,D,x;w<this._ids.length;w++){const M=this._ids[w],I=e[2*M],A=e[2*M+1];if(w>0&&Math.abs(I-D)<=Se&&Math.abs(A-x)<=Se||(D=I,x=A,M===g||M===p||M===f))continue;let E=0;for(let H=0,Ue=this._hashKey(I,A);H<this._hashSize&&(E=s[(Ue+H)%this._hashSize],!(E!==-1&&E!==r[E]));H++);E=t[E];let T=E,G;for(;G=r[T],Y(I,A,e[2*T],e[2*T+1],e[2*G],e[2*G+1])>=0;)if(T=G,T===E){T=-1;break}if(T===-1)continue;let N=this._addTriangle(T,M,r[T],-1,-1,n[T]);n[M]=this._legalize(N+2),n[T]=N,C++;let $=r[T];for(;G=r[$],Y(I,A,e[2*$],e[2*$+1],e[2*G],e[2*G+1])<0;)N=this._addTriangle($,M,G,n[M],-1,n[$]),n[M]=this._legalize(N+2),r[$]=$,C--,$=G;if(T===E)for(;G=t[T],Y(I,A,e[2*G],e[2*G+1],e[2*T],e[2*T+1])<0;)N=this._addTriangle(G,M,T,-1,n[T],n[G]),this._legalize(N+2),n[G]=N,r[T]=T,C--,T=G;this._hullStart=t[M]=T,r[T]=t[$]=M,r[M]=$,s[this._hashKey(I,A)]=M,s[this._hashKey(e[2*T],e[2*T+1])]=T}this.hull=new Uint32Array(C);for(let w=0,D=this._hullStart;w<C;w++)this.hull[w]=D,D=r[D];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(e,t){return Math.floor(ut(e-this._cx,t-this._cy)*this._hashSize)%this._hashSize}_legalize(e){const{_triangles:t,_halfedges:r,coords:n}=this;let s=0,i=0;for(;;){const a=r[e],o=e-e%3;if(i=o+(e+2)%3,a===-1){if(s===0)break;e=X[--s];continue}const h=a-a%3,u=o+(e+1)%3,c=h+(a+2)%3,d=t[i],g=t[e],p=t[u],f=t[c];if(dt(n[2*d],n[2*d+1],n[2*g],n[2*g+1],n[2*p],n[2*p+1],n[2*f],n[2*f+1])){t[e]=f,t[a]=d;const m=r[c];if(m===-1){let _=this._hullStart;do{if(this._hullTri[_]===c){this._hullTri[_]=e;break}_=this._hullPrev[_]}while(_!==this._hullStart)}this._link(e,m),this._link(a,r[i]),this._link(i,c);const y=h+(a+1)%3;s<X.length&&(X[s++]=y)}else{if(s===0)break;e=X[--s]}}return i}_link(e,t){this._halfedges[e]=t,t!==-1&&(this._halfedges[t]=e)}_addTriangle(e,t,r,n,s,i){const a=this.trianglesLen;return this._triangles[a]=e,this._triangles[a+1]=t,this._triangles[a+2]=r,this._link(a,n),this._link(a+1,s),this._link(a+2,i),this.trianglesLen+=3,a}}function ut(l,e){const t=l/(Math.abs(l)+Math.abs(e));return(e>0?3-t:1+t)/4}function ce(l,e,t,r){const n=l-t,s=e-r;return n*n+s*s}function dt(l,e,t,r,n,s,i,a){const o=l-i,h=e-a,u=t-i,c=r-a,d=n-i,g=s-a,p=o*o+h*h,f=u*u+c*c,b=d*d+g*g;return o*(c*b-f*g)-h*(u*b-f*d)+p*(u*g-c*d)<0}function gt(l,e,t,r,n,s){const i=t-l,a=r-e,o=n-l,h=s-e,u=i*i+a*a,c=o*o+h*h,d=.5/(i*h-a*o),g=(h*u-a*c)*d,p=(i*c-o*u)*d;return g*g+p*p}function ft(l,e,t,r,n,s){const i=t-l,a=r-e,o=n-l,h=s-e,u=i*i+a*a,c=o*o+h*h,d=.5/(i*h-a*o),g=l+(h*u-a*c)*d,p=e+(i*c-o*u)*d;return{x:g,y:p}}function j(l,e,t,r){if(r-t<=20)for(let n=t+1;n<=r;n++){const s=l[n],i=e[s];let a=n-1;for(;a>=t&&e[l[a]]>i;)l[a+1]=l[a--];l[a+1]=s}else{const n=t+r>>1;let s=t+1,i=r;W(l,n,s),e[l[t]]>e[l[r]]&&W(l,t,r),e[l[s]]>e[l[r]]&&W(l,s,r),e[l[t]]>e[l[s]]&&W(l,t,s);const a=l[s],o=e[a];for(;;){do s++;while(e[l[s]]<o);do i--;while(e[l[i]]>o);if(i<s)break;W(l,s,i)}l[t+1]=l[i],l[i]=a,r-s+1>=i-t?(j(l,e,s,r),j(l,e,t,i-1)):(j(l,e,t,i-1),j(l,e,s,r))}}function W(l,e,t){const r=l[e];l[e]=l[t],l[t]=r}function pt(l){return l[0]}function mt(l){return l[1]}const Ce=1e-6;class R{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(e,t){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+t}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(e,t){this._+=`L${this._x1=+e},${this._y1=+t}`}arc(e,t,r){e=+e,t=+t,r=+r;const n=e+r,s=t;if(r<0)throw new Error("negative radius");this._x1===null?this._+=`M${n},${s}`:(Math.abs(this._x1-n)>Ce||Math.abs(this._y1-s)>Ce)&&(this._+="L"+n+","+s),r&&(this._+=`A${r},${r},0,1,1,${e-r},${t}A${r},${r},0,1,1,${this._x1=n},${this._y1=s}`)}rect(e,t,r,n){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+t}h${+r}v${+n}h${-r}Z`}value(){return this._||null}}class de{constructor(){this._=[]}moveTo(e,t){this._.push([e,t])}closePath(){this._.push(this._[0].slice())}lineTo(e,t){this._.push([e,t])}value(){return this._.length?this._:null}}class bt{constructor(e,[t,r,n,s]=[0,0,960,500]){if(!((n=+n)>=(t=+t))||!((s=+s)>=(r=+r)))throw new Error("invalid bounds");this.delaunay=e,this._circumcenters=new Float64Array(e.points.length*2),this.vectors=new Float64Array(e.points.length*2),this.xmax=n,this.xmin=t,this.ymax=s,this.ymin=r,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:e,hull:t,triangles:r},vectors:n}=this;let s,i;const a=this.circumcenters=this._circumcenters.subarray(0,r.length/3*2);for(let f=0,b=0,m=r.length,y,_;f<m;f+=3,b+=2){const P=r[f]*2,z=r[f+1]*2,k=r[f+2]*2,S=e[P],C=e[P+1],w=e[z],D=e[z+1],x=e[k],M=e[k+1],I=w-S,A=D-C,E=x-S,T=M-C,G=(I*T-A*E)*2;if(Math.abs(G)<1e-9){if(s===void 0){s=i=0;for(const $ of t)s+=e[$*2],i+=e[$*2+1];s/=t.length,i/=t.length}const N=1e9*Math.sign((s-S)*T-(i-C)*E);y=(S+x)/2-N*T,_=(C+M)/2+N*E}else{const N=1/G,$=I*I+A*A,H=E*E+T*T;y=S+(T*$-A*H)*N,_=C+(I*H-E*$)*N}a[b]=y,a[b+1]=_}let o=t[t.length-1],h,u=o*4,c,d=e[2*o],g,p=e[2*o+1];n.fill(0);for(let f=0;f<t.length;++f)o=t[f],h=u,c=d,g=p,u=o*4,d=e[2*o],p=e[2*o+1],n[h+2]=n[u]=g-p,n[h+3]=n[u+1]=d-c}render(e){const t=e==null?e=new R:void 0,{delaunay:{halfedges:r,inedges:n,hull:s},circumcenters:i,vectors:a}=this;if(s.length<=1)return null;for(let u=0,c=r.length;u<c;++u){const d=r[u];if(d<u)continue;const g=Math.floor(u/3)*2,p=Math.floor(d/3)*2,f=i[g],b=i[g+1],m=i[p],y=i[p+1];this._renderSegment(f,b,m,y,e)}let o,h=s[s.length-1];for(let u=0;u<s.length;++u){o=h,h=s[u];const c=Math.floor(n[h]/3)*2,d=i[c],g=i[c+1],p=o*4,f=this._project(d,g,a[p+2],a[p+3]);f&&this._renderSegment(d,g,f[0],f[1],e)}return t&&t.value()}renderBounds(e){const t=e==null?e=new R:void 0;return e.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),t&&t.value()}renderCell(e,t){const r=t==null?t=new R:void 0,n=this._clip(e);if(n===null||!n.length)return;t.moveTo(n[0],n[1]);let s=n.length;for(;n[0]===n[s-2]&&n[1]===n[s-1]&&s>1;)s-=2;for(let i=2;i<s;i+=2)(n[i]!==n[i-2]||n[i+1]!==n[i-1])&&t.lineTo(n[i],n[i+1]);return t.closePath(),r&&r.value()}*cellPolygons(){const{delaunay:{points:e}}=this;for(let t=0,r=e.length/2;t<r;++t){const n=this.cellPolygon(t);n&&(n.index=t,yield n)}}cellPolygon(e){const t=new de;return this.renderCell(e,t),t.value()}_renderSegment(e,t,r,n,s){let i;const a=this._regioncode(e,t),o=this._regioncode(r,n);a===0&&o===0?(s.moveTo(e,t),s.lineTo(r,n)):(i=this._clipSegment(e,t,r,n,a,o))&&(s.moveTo(i[0],i[1]),s.lineTo(i[2],i[3]))}contains(e,t,r){return t=+t,t!==t||(r=+r,r!==r)?!1:this.delaunay._step(e,t,r)===e}*neighbors(e){const t=this._clip(e);if(t)for(const r of this.delaunay.neighbors(e)){const n=this._clip(r);if(n){e:for(let s=0,i=t.length;s<i;s+=2)for(let a=0,o=n.length;a<o;a+=2)if(t[s]===n[a]&&t[s+1]===n[a+1]&&t[(s+2)%i]===n[(a+o-2)%o]&&t[(s+3)%i]===n[(a+o-1)%o]){yield r;break e}}}}_cell(e){const{circumcenters:t,delaunay:{inedges:r,halfedges:n,triangles:s}}=this,i=r[e];if(i===-1)return null;const a=[];let o=i;do{const h=Math.floor(o/3);if(a.push(t[h*2],t[h*2+1]),o=o%3===2?o-2:o+1,s[o]!==e)break;o=n[o]}while(o!==i&&o!==-1);return a}_clip(e){if(e===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const t=this._cell(e);if(t===null)return null;const{vectors:r}=this,n=e*4;return this._simplify(r[n]||r[n+1]?this._clipInfinite(e,t,r[n],r[n+1],r[n+2],r[n+3]):this._clipFinite(e,t))}_clipFinite(e,t){const r=t.length;let n=null,s,i,a=t[r-2],o=t[r-1],h,u=this._regioncode(a,o),c,d=0;for(let g=0;g<r;g+=2)if(s=a,i=o,a=t[g],o=t[g+1],h=u,u=this._regioncode(a,o),h===0&&u===0)c=d,d=0,n?n.push(a,o):n=[a,o];else{let p,f,b,m,y;if(h===0){if((p=this._clipSegment(s,i,a,o,h,u))===null)continue;[f,b,m,y]=p}else{if((p=this._clipSegment(a,o,s,i,u,h))===null)continue;[m,y,f,b]=p,c=d,d=this._edgecode(f,b),c&&d&&this._edge(e,c,d,n,n.length),n?n.push(f,b):n=[f,b]}c=d,d=this._edgecode(m,y),c&&d&&this._edge(e,c,d,n,n.length),n?n.push(m,y):n=[m,y]}if(n)c=d,d=this._edgecode(n[0],n[1]),c&&d&&this._edge(e,c,d,n,n.length);else if(this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return n}_clipSegment(e,t,r,n,s,i){const a=s<i;for(a&&([e,t,r,n,s,i]=[r,n,e,t,i,s]);;){if(s===0&&i===0)return a?[r,n,e,t]:[e,t,r,n];if(s&i)return null;let o,h,u=s||i;u&8?(o=e+(r-e)*(this.ymax-t)/(n-t),h=this.ymax):u&4?(o=e+(r-e)*(this.ymin-t)/(n-t),h=this.ymin):u&2?(h=t+(n-t)*(this.xmax-e)/(r-e),o=this.xmax):(h=t+(n-t)*(this.xmin-e)/(r-e),o=this.xmin),s?(e=o,t=h,s=this._regioncode(e,t)):(r=o,n=h,i=this._regioncode(r,n))}}_clipInfinite(e,t,r,n,s,i){let a=Array.from(t),o;if((o=this._project(a[0],a[1],r,n))&&a.unshift(o[0],o[1]),(o=this._project(a[a.length-2],a[a.length-1],s,i))&&a.push(o[0],o[1]),a=this._clipFinite(e,a))for(let h=0,u=a.length,c,d=this._edgecode(a[u-2],a[u-1]);h<u;h+=2)c=d,d=this._edgecode(a[h],a[h+1]),c&&d&&(h=this._edge(e,c,d,a,h),u=a.length);else this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(a=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return a}_edge(e,t,r,n,s){for(;t!==r;){let i,a;switch(t){case 5:t=4;continue;case 4:t=6,i=this.xmax,a=this.ymin;break;case 6:t=2;continue;case 2:t=10,i=this.xmax,a=this.ymax;break;case 10:t=8;continue;case 8:t=9,i=this.xmin,a=this.ymax;break;case 9:t=1;continue;case 1:t=5,i=this.xmin,a=this.ymin;break}(n[s]!==i||n[s+1]!==a)&&this.contains(e,i,a)&&(n.splice(s,0,i,a),s+=2)}return s}_project(e,t,r,n){let s=1/0,i,a,o;if(n<0){if(t<=this.ymin)return null;(i=(this.ymin-t)/n)<s&&(o=this.ymin,a=e+(s=i)*r)}else if(n>0){if(t>=this.ymax)return null;(i=(this.ymax-t)/n)<s&&(o=this.ymax,a=e+(s=i)*r)}if(r>0){if(e>=this.xmax)return null;(i=(this.xmax-e)/r)<s&&(a=this.xmax,o=t+(s=i)*n)}else if(r<0){if(e<=this.xmin)return null;(i=(this.xmin-e)/r)<s&&(a=this.xmin,o=t+(s=i)*n)}return[a,o]}_edgecode(e,t){return(e===this.xmin?1:e===this.xmax?2:0)|(t===this.ymin?4:t===this.ymax?8:0)}_regioncode(e,t){return(e<this.xmin?1:e>this.xmax?2:0)|(t<this.ymin?4:t>this.ymax?8:0)}_simplify(e){if(e&&e.length>4){for(let t=0;t<e.length;t+=2){const r=(t+2)%e.length,n=(t+4)%e.length;(e[t]===e[r]&&e[r]===e[n]||e[t+1]===e[r+1]&&e[r+1]===e[n+1])&&(e.splice(r,2),t-=2)}e.length||(e=null)}return e}}const yt=2*Math.PI,V=Math.pow;function wt(l){return l[0]}function vt(l){return l[1]}function _t(l){const{triangles:e,coords:t}=l;for(let r=0;r<e.length;r+=3){const n=2*e[r],s=2*e[r+1],i=2*e[r+2];if((t[i]-t[n])*(t[s+1]-t[n+1])-(t[s]-t[n])*(t[i+1]-t[n+1])>1e-10)return!1}return!0}function xt(l,e,t){return[l+Math.sin(l+e)*t,e+Math.cos(l-e)*t]}class pe{static from(e,t=wt,r=vt,n){return new pe("length"in e?Pt(e,t,r,n):Float64Array.from(Dt(e,t,r,n)))}constructor(e){this._delaunator=new Z(e),this.inedges=new Int32Array(e.length/2),this._hullIndex=new Int32Array(e.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const e=this._delaunator,t=this.points;if(e.hull&&e.hull.length>2&&_t(e)){this.collinear=Int32Array.from({length:t.length/2},(d,g)=>g).sort((d,g)=>t[2*d]-t[2*g]||t[2*d+1]-t[2*g+1]);const o=this.collinear[0],h=this.collinear[this.collinear.length-1],u=[t[2*o],t[2*o+1],t[2*h],t[2*h+1]],c=1e-8*Math.hypot(u[3]-u[1],u[2]-u[0]);for(let d=0,g=t.length/2;d<g;++d){const p=xt(t[2*d],t[2*d+1],c);t[2*d]=p[0],t[2*d+1]=p[1]}this._delaunator=new Z(t)}else delete this.collinear;const r=this.halfedges=this._delaunator.halfedges,n=this.hull=this._delaunator.hull,s=this.triangles=this._delaunator.triangles,i=this.inedges.fill(-1),a=this._hullIndex.fill(-1);for(let o=0,h=r.length;o<h;++o){const u=s[o%3===2?o-2:o+1];(r[o]===-1||i[u]===-1)&&(i[u]=o)}for(let o=0,h=n.length;o<h;++o)a[n[o]]=o;n.length<=2&&n.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=n[0],i[n[0]]=1,n.length===2&&(i[n[1]]=0,this.triangles[1]=n[1],this.triangles[2]=n[1]))}voronoi(e){return new bt(this,e)}*neighbors(e){const{inedges:t,hull:r,_hullIndex:n,halfedges:s,triangles:i,collinear:a}=this;if(a){const c=a.indexOf(e);c>0&&(yield a[c-1]),c<a.length-1&&(yield a[c+1]);return}const o=t[e];if(o===-1)return;let h=o,u=-1;do{if(yield u=i[h],h=h%3===2?h-2:h+1,i[h]!==e)return;if(h=s[h],h===-1){const c=r[(n[e]+1)%r.length];c!==u&&(yield c);return}}while(h!==o)}find(e,t,r=0){if(e=+e,e!==e||(t=+t,t!==t))return-1;const n=r;let s;for(;(s=this._step(r,e,t))>=0&&s!==r&&s!==n;)r=s;return s}_step(e,t,r){const{inedges:n,hull:s,_hullIndex:i,halfedges:a,triangles:o,points:h}=this;if(n[e]===-1||!h.length)return(e+1)%(h.length>>1);let u=e,c=V(t-h[e*2],2)+V(r-h[e*2+1],2);const d=n[e];let g=d;do{let p=o[g];const f=V(t-h[p*2],2)+V(r-h[p*2+1],2);if(f<c&&(c=f,u=p),g=g%3===2?g-2:g+1,o[g]!==e)break;if(g=a[g],g===-1){if(g=s[(i[e]+1)%s.length],g!==p&&V(t-h[g*2],2)+V(r-h[g*2+1],2)<c)return g;break}}while(g!==d);return u}render(e){const t=e==null?e=new R:void 0,{points:r,halfedges:n,triangles:s}=this;for(let i=0,a=n.length;i<a;++i){const o=n[i];if(o<i)continue;const h=s[i]*2,u=s[o]*2;e.moveTo(r[h],r[h+1]),e.lineTo(r[u],r[u+1])}return this.renderHull(e),t&&t.value()}renderPoints(e,t){t===void 0&&(!e||typeof e.moveTo!="function")&&(t=e,e=null),t=t==null?2:+t;const r=e==null?e=new R:void 0,{points:n}=this;for(let s=0,i=n.length;s<i;s+=2){const a=n[s],o=n[s+1];e.moveTo(a+t,o),e.arc(a,o,t,0,yt)}return r&&r.value()}renderHull(e){const t=e==null?e=new R:void 0,{hull:r,points:n}=this,s=r[0]*2,i=r.length;e.moveTo(n[s],n[s+1]);for(let a=1;a<i;++a){const o=2*r[a];e.lineTo(n[o],n[o+1])}return e.closePath(),t&&t.value()}hullPolygon(){const e=new de;return this.renderHull(e),e.value()}renderTriangle(e,t){const r=t==null?t=new R:void 0,{points:n,triangles:s}=this,i=s[e*=3]*2,a=s[e+1]*2,o=s[e+2]*2;return t.moveTo(n[i],n[i+1]),t.lineTo(n[a],n[a+1]),t.lineTo(n[o],n[o+1]),t.closePath(),r&&r.value()}*trianglePolygons(){const{triangles:e}=this;for(let t=0,r=e.length/3;t<r;++t)yield this.trianglePolygon(t)}trianglePolygon(e){const t=new de;return this.renderTriangle(e,t),t.value()}}function Pt(l,e,t,r){const n=l.length,s=new Float64Array(n*2);for(let i=0;i<n;++i){const a=l[i];s[i*2]=e.call(r,a,i,l),s[i*2+1]=t.call(r,a,i,l)}return s}function*Dt(l,e,t,r){let n=0;for(const s of l)yield e.call(r,s,n,l),yield t.call(r,s,n,l),++n}let Mt=0;function ke(){return Mt++}const Q="VoronoiPieceGenerator",Tt={name:Q,displayName:"Voronoi",description:"Construct pieces by building a Voronoi diagram from the seed points. Each piece consists of all points of the plane closer to that seed point than any other seed point. In practice, this creates polygons with 3-8 sides.",sortHint:1,controls:[]};function zt(l){if(l.length===0)return[0,0,0,0];let e=l[0][0],t=l[0][1],r=e,n=t;for(let s=1;s<l.length;s++){const i=l[s];e=Math.min(e,i[0]),t=Math.min(t,i[1]),r=Math.max(r,i[0]),n=Math.max(n,i[1])}return[e,t,r,n]}function St(l,e){const t=l.length;for(let r=0;r<t;r++){const n=e.get(l[r]);n.next=l[(r+1)%t],n.prev=l[(r-1+t)%t]}}function O(l){return`${l[0].toPrecision(7)},${l[1].toPrecision(7)}`}function Ct(l,e){return Math.abs(l[0]-e[0])<1e-6&&Math.abs(l[1]-e[1])<1e-6}const kt=l=>{const{width:e,height:t}=l;return{generatePieces(n,s){const a=pe.from(n).voronoi([0,0,e,t]),o={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},h=new Map;for(let c=0;c<n.length;c++){const d=n[c],g=a.cellPolygon(c);if(!g)continue;const p={id:c,site:d,halfEdge:-1,bbox:zt(g)},f=[];for(let b=0;b<g.length-1;b++){const m=g[b],y=g[b+1];if(Ct(m,y))continue;const _={id:ke(),origin:m,twin:-1,next:-1,prev:-1,piece:c};o.halfEdges.set(_.id,_),f.push(_.id);const P=`${O(m)}-${O(y)}`;h.set(P,_.id)}f.length!==0&&(St(f,o.halfEdges),p.halfEdge=f[0],o.pieces.set(c,p))}for(const c of o.halfEdges.values()){if(c.twin!==-1)continue;const d=o.halfEdges.get(c.next),g=c.origin,p=d.origin,f=`${O(p)}-${O(g)}`,b=h.get(f),m=ke();let y;if(b!==void 0){const _=o.halfEdges.get(b);c.twin=_.id,_.twin=c.id,y={id:m,heLeft:c.id,heRight:_.id}}else y={id:m,heLeft:c.id,heRight:-1},o.boundary.push(m);o.edges.set(m,y)}const u=new Map;for(const c of o.halfEdges.values()){const d=O(c.origin);u.has(d)||u.set(d,c.origin)}return o.vertices=Array.from(u.values()),o}}};fe.register(Q,kt,Tt);const ee="TraditionalTabGenerator",It={name:ee,displayName:"Traditional",description:"Creates a traditional rounded tab for each (internal) piece edge.",sortHint:1,controls:[{type:"range",name:"size",label:"Tab Size",defaultValue:20,min:1,max:100,step:1,helpText:"Size of each tab as a percent relative to its edge length"},{type:"range",name:"jitter",label:"Randomness",defaultValue:8,min:0,max:100,step:1,helpText:"Adds randomness to the tab shape. 0 means completely uniform tabs"},{type:"number",name:"minTabSize",label:"Minimum Tab Size",optional:!0,helpText:"If provided, tabs will not generate on edges shorter than this value"},{type:"number",name:"maxTabSize",label:"Maximum Tab Width",optional:!0,helpText:"If provided, the width of a tab's features will be clamped to this value"}]};function At(l,e,t,r,n,s=!1,i){const a=e[0]-l[0],o=e[1]-l[1],h=Math.hypot(a,o);if(h===0)throw new Error("Edge has zero length");const u=[a/h,o/h],c=[-u[1],u[0]],d=(x,M)=>[l[0]+(u[0]*x+c[0]*M)*h,l[1]+(u[1]*x+c[1]*M)*h],g=r/100,p=()=>(n()*2-1)*g,f=p(),b=p(),m=p(),y=p(),_=p();let P=t/200;i&&4*P*h>i&&(P=i/(4*h));const z=s?-1:1,S=[[0,0],[.2,f],[.5+b+y,z*(-P+m)],[.5-P+b,z*(P+m)],[.5-2*P+b-y,z*(3*P+m)],[.5+2*P+b-y,z*(3*P+m)],[.5+P+b,z*(P+m)],[.5+b+y,z*(-P+m)],[.8,_],[1,0]].map(([x,M])=>d(x,M)),C={type:"bezier",p1:S[1],p2:S[2],p3:S[3]},w={type:"bezier",p1:S[4],p2:S[5],p3:S[6]},D={type:"bezier",p1:S[7],p2:S[8],p3:S[9]};return[C,w,D]}function Gt(l,e){return{type:"bezier",p1:l.p2,p2:l.p1,p3:e}}const Et=l=>{const{size:e=20,jitter:t=8,minTabSize:r,maxTabSize:n}=l;return{addTab(i,a){const{topology:o,random:h}=a,u=o.halfEdges.get(i.heLeft),c=o.halfEdges.get(i.heRight);if(!u||!c)return;const d=u.origin,g=c.origin;if(r&&Math.hypot(g[0]-d[0],g[1]-d[1])<r)return;const p=h()>.5,f=At(d,g,e,t,h,p,n);if(f.length===0)return;const b=[];for(let m=f.length-1;m>=0;m--){const y=f[m],_=m>0?f[m-1].p3:d;b.push(Gt(y,_))}u.segments=f,c.segments=b}}};B.register(ee,Et,It);const Ee="GridJitterPointGenerator",$t={name:Ee,displayName:"Grid",description:"Generate seed points using a grid with optional random jitter. Has a more uniform, regular look, especially with low randomness values.",sortHint:2,controls:[{type:"range",name:"jitter",label:"Randomness",min:0,max:100,step:5,defaultValue:50,helpText:"Amount of jitter to apply to each grid point (0 to 100%)"}]},Lt=l=>{const{jitter:e=50}=l;return{generatePoints(r){const{width:n,height:s,pieceSize:i,random:a}=r,o=[];for(let h=0;h<n;h+=i)for(let u=0;u<s;u+=i){const c=[h+i/2,u+i/2];e>0&&(c[0]+=(a()-.5)*(e/100)*i,c[1]+=(a()-.5)*(e/100)*i),o.push(c)}return o}}};te.register(Ee,Lt,$t);const $e="NullTabGenerator",Ut={name:$e,displayName:"None",description:"Do not generate tabs. All pieces have straight edges.",sortHint:3,controls:[]},Nt=l=>({addTab(t,r){}});B.register($e,Nt,Ut);const Le="TriangleTabGenerator",Ft={name:Le,displayName:"Triangle",description:"Creates a simple triangle between each (internal) piece edge.",sortHint:2,controls:[{type:"range",name:"tabHeightRatio",label:"Tab Height",optional:!0,min:0,max:100,step:1,defaultValue:20,helpText:'Determines how "tall" the tab is relative to the length of the edge as a percent'}]},Rt=l=>{const{tabHeightRatio:e=20}=l;return{addTab(r,n){const{topology:s,random:i}=n,a=s.halfEdges.get(r.heLeft),o=s.halfEdges.get(r.heRight);if(!a||!o){console.warn("Could not find half-edges for a given internal edge:",r.id);return}const h=a.origin,u=o.origin,c=[u[0]-h[0],u[1]-h[1]],d=Math.sqrt(c[0]**2+c[1]**2);if(d<1e-6)return;const g=[c[0]/d,c[1]/d],p=[-g[1],g[0]],f=[h[0]+c[0]/2,h[1]+c[1]/2],b=i()>.5?1:-1,m=d*(e/100)*b,y=[f[0]+p[0]*m,f[1]+p[1]*m],_={type:"bezier",p1:y,p2:y,p3:u},P=[f[0]-p[0]*m,f[1]-p[1]*m],z={type:"bezier",p1:P,p2:P,p3:h};a.segments=[_],o.segments=[z]}}};B.register(Le,Rt,Ft);const Ht=()=>{const t=J,r={name:J,width:800,height:600},n=Q,s={name:Q,width:800,height:600},i=ee,a={name:ee,width:800,height:600},o={seed:new Date().getTime()%10240,canvasWidth:800,canvasHeight:600,distance:40,color:"#333333",dirty:!0,generators:{point:{label:"Seed Point Generator",registry:te,name:t,config:r},piece:{label:"Piece Generator",registry:fe,name:n,config:s},tab:{label:"Tab Generator",registry:B,name:i,config:a}},puzzle:void 0,backgroundImageUrl:void 0,backgroundImageName:""};return{oncreate:()=>{me({width:o.canvasWidth,height:o.canvasHeight,pieceSize:o.distance,pointConfig:o.generators.point.config,pieceConfig:o.generators.piece.config,tabConfig:o.generators.tab.config,seed:o.seed}).then(h=>{o.puzzle=h,v.redraw()}).catch(h=>{console.error(h)})},onupdate:()=>{o.dirty&&(o.dirty=!1,me({width:o.canvasWidth,height:o.canvasHeight,pieceSize:o.distance,pointConfig:o.generators.point.config,pieceConfig:o.generators.piece.config,tabConfig:o.generators.tab.config,seed:o.seed}).then(h=>{o.puzzle=h,v.redraw()}).catch(h=>{console.error(h)}))},onremove:()=>{o.backgroundImageUrl&&(URL.revokeObjectURL(o.backgroundImageUrl),o.backgroundImageUrl=void 0)},view:()=>v(".page",[v(Fe,{link:"https://github.com/weevilgenius/puzzle-generator"}),v("h1","Puzzle Generator"),v(".container",[o.puzzle&&v(".puzzle-stack",[v(He,{width:o.canvasWidth,height:o.canvasHeight,color:o.color,imageUrl:o.backgroundImageUrl,puzzle:o.puzzle}),v(je,{puzzle:o.puzzle,width:o.canvasWidth,height:o.canvasHeight,color:o.color})]),v(".controls",[v(".background-image",[v(We,{label:"Background Image",onUpload:(h,u)=>{o.backgroundImageUrl&&URL.revokeObjectURL(o.backgroundImageUrl),o.backgroundImageUrl=h,o.backgroundImageName=u,v.redraw()}}),v("span.background-image-label",o.backgroundImageName)]),v(ue,{config:{name:"seed",label:"Seed",type:"number"},value:o.seed,onChange:h=>{o.seed=h??0,o.dirty=!0,v.redraw()}}),v(ue,{config:{name:"pieceSize",label:"Piece size",type:"number"},value:o.distance,onChange:h=>{o.distance=h??0,o.dirty=!0,v.redraw()}}),v(Xe,{label:"Piece color",color:o.color,size:"small",onUpdate:h=>{o.color=h,v.redraw()}}),...Object.entries(o.generators).map(([h,u])=>v("label",[u.label+":",v(Ye,{generator:u.name,registry:u.registry,config:u.config,onGeneratorChange:c=>{c!=u.name&&(console.log(`${h} generator changed to ${c}`),u.name=c,o.generators[h].config=u.registry.getDefaultConfig(c,o.canvasWidth,o.canvasHeight),o.dirty=!0,v.redraw())},onConfigChange:(c,d)=>{console.log(`${h} generator config "${c}" changed to ${String(d)}`),u.config[c]=d,o.dirty=!0,v.redraw()}})]))])])])}};v.mount(document.body,Ht);
//# sourceMappingURL=index-T1WhpPAP.js.map
