import{m as D,g as ce}from"./mithril-DD6GaBKN.js";import{r as he}from"./shoelace-BEtx4ju6.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=n(s);fetch(s.href,i)}})();const ue={view:({attrs:l})=>D("a.github-corner",{href:l.link,"aria-label":"View source on GitHub",title:"View source on GitHub",target:"_blank"},D("svg",{width:80,height:80,viewBox:"0 0 250 250","aria-hidden":"true"},[D("path",{d:"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"}),D("path.octo-arm",{fill:"currentColor",style:"transform-origin: 130px 106px;",d:"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"}),D("path.octo-body",{fill:"currentColor",d:"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"})]))};class St{generators=new Map;register(e,n,r){this.generators.has(e)&&console.warn(`Generator "${e}" is already registered, overwriting`),this.generators.set(e,{factory:n,uiMetadata:r})}create(e,n,r){const s=this.generators.get(r.name);if(!s)throw new Error(`Unknown generator "${r.name}". Is it registered?`);return s.factory(e,n,r)}getAvailableGenerators(){return Array.from(this.generators.values()).sort((e,n)=>e.uiMetadata.sortHint-n.uiMetadata.sortHint).map(e=>({name:e.uiMetadata.name,displayName:e.uiMetadata.displayName}))}getUIMetadata(e){return this.generators.get(e)?.uiMetadata}getDefaultConfig(e,n,r){const s={name:e,width:n,height:r},i=this.getUIMetadata(e);if(i)for(const o of i.controls)s[o.name]=o.defaultValue;return s}}const ct=new St,ht=new St,tt=new St;function fe(l){return function(){let e=l+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}}async function Gt(l){const{width:e,height:n,pieceSize:r}=l,{pointConfig:s,pieceConfig:i,tabConfig:o}=l;console.log(`rebuilding puzzle with dimensions ${e}x${n}, piece size ${r}`);const a=ct.create(e,n,s),c=ht.create(e,n,i),h=tt.create(e,n,o),f=l.seed??new Date().getTime(),u=fe(f),d=a.generatePoints({width:e,height:n,pieceSize:r,random:u});console.log(`Generated ${d.length} points`);const g=c.generatePieces(d,{random:u,pieceSize:r});console.log(`Generated ${g.pieces.size} pieces`);for(const m of g.edges.values())m.heRight!==-1&&h.addTab(m,{topology:g,random:u});return{created:new Date().toISOString(),seed:f,width:e,height:n,vertices:g.vertices,boundary:g.boundary,pieces:g.pieces,edges:g.edges,halfEdges:g.halfEdges}}function Rt(l,e,n,r=!1){const s=e.getContext("2d");if(!s){console.error("Could not get 2D context from canvas");return}s.clearRect(0,0,e.width,e.height);{s.strokeStyle=n,s.lineWidth=1,s.beginPath();for(const i of l.edges.values()){const o=l.halfEdges.get(i.heLeft);if(o)if(s.moveTo(o.origin[0],o.origin[1]),o.segments)for(const a of o.segments)switch(a.type){case"bezier":s.bezierCurveTo(a.p1[0],a.p1[1],a.p2[0],a.p2[1],a.p3[0],a.p3[1]);break;case"line":s.lineTo(a.p[0],a.p[1]);break}else{let a;o.twin!==-1?a=l.halfEdges.get(o.twin).origin:a=l.halfEdges.get(o.next).origin,s.lineTo(a[0],a[1])}}s.stroke()}if(l.problems&&l.problems.length>0){s.lineWidth=2,s.strokeStyle="red";for(const i of l.problems){const[o,a]=i;s.beginPath(),s.arc(o,a,8,0,2*Math.PI),s.stroke()}}if(r){s.fillStyle="blue";for(const i of l.pieces.values()){const[o,a]=i.site;s.beginPath(),s.arc(o,a,3,0,2*Math.PI),s.fill()}}}const de=()=>{const l={canvas:null};return{oncreate:({dom:e,attrs:n})=>{if(l.canvas=e.querySelector("canvas.puzzle"),!l.canvas){console.log("couldn't get canvas element");return}n.isDirty||Rt(n.puzzle,l.canvas,n.color)},onupdate:({attrs:e})=>{if(!l.canvas){console.log("couldn't get canvas element");return}e.isDirty||Rt(e.puzzle,l.canvas,e.color)},view:({attrs:e})=>D(".puzzle-stack",[D("img.background",{width:e.width,height:e.height,src:e.imageUrl}),D("canvas.puzzle",{width:e.width,height:e.height,style:{width:`${e.width}px`,height:`${e.height}px`}})])}};function ge(l,e,n,r="black"){const i=[];for(const c of l.edges.values()){const h=l.halfEdges.get(c.heLeft);if(h)if(i.push(`M ${h.origin[0].toFixed(3)} ${h.origin[1].toFixed(3)}`),h.segments)for(const f of h.segments)switch(f.type){case"bezier":i.push(`C ${f.p1[0].toFixed(3)} ${f.p1[1].toFixed(3)}, ${f.p2[0].toFixed(3)} ${f.p2[1].toFixed(3)}, ${f.p3[0].toFixed(3)} ${f.p3[1].toFixed(3)}`);break;case"line":i.push(`L ${f.p[0].toFixed(3)} ${f.p[1].toFixed(3)}`);break}else{let f;h.twin!==-1?f=l.halfEdges.get(h.twin).origin:f=l.halfEdges.get(h.next).origin,i.push(`L ${f[0].toFixed(3)} ${f[1].toFixed(3)}`)}}const o=i.join(" ");return`
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg
  width="${e}"
  height="${n}"
  viewBox="0 0 ${e} ${n}"
  xmlns="http://www.w3.org/2000/svg"
  version="1.1"
>
  <path
    d="${o}"
    fill="none"
    stroke="${r}"
    stroke-width="1"
    vector-effect="non-scaling-stroke"
  />
</svg>`.trim().replace(/\r\n/g,`
`)}function pe(l,e="puzzle.svg"){const n=new Blob([l],{type:"image/svg+xml"}),r=URL.createObjectURL(n),s=document.createElement("a");s.href=r,s.download=e,s.hidden=!0,document.body.appendChild(s),s.click(),document.body.removeChild(s),setTimeout(()=>URL.revokeObjectURL(r),100)}const me={view:({attrs:l})=>D("sl-button.download-svg",{onclick:()=>{const e=ge(l.puzzle,l.width,l.height,l.color);pe(e,l.filename??"puzzle.svg")}},"Download SVG")},ye={view:({attrs:l})=>{const e=l.progressPercent!==void 0&&l.progressPercent<100,n=!e&&l.problems!==void 0&&l.problems==0,r=!e&&l.problems!==void 0&&l.problems>0;return console.log(`showProgress is ${e}, showOKBadge is ${n}, showProblemBadge is ${r}`),D(".geometry-check-indicator",[D(".label","Geometry Check:"),D("sl-tooltip",{content:"Check geometry now"},D("sl-icon-button.check-now",{library:"material",name:"refresh",label:"Check geometry now",disabled:e,onclick:s=>{s.redraw=!1,l.onCheckRequested?.()}})),D("sl-tooltip",{content:"Check geometry after every change"},D("sl-checkbox",{checked:l.autoCheck,disabled:e,size:"small","onsl-change":s=>{s.redraw=!1;const i=s.target;l.onAutocheckChanged?.(i.checked)}},"auto check")),e&&D("sl-progress-bar",{label:"Geometry check progress",value:l.progressPercent??0}),n&&D("sl-badge",{variant:"success",pill:!0},"OK"),r&&D("sl-badge",{variant:"danger",pill:!0},`${l.problems} issues`)])}};function xe(l,e,n=800){if(l<=n)return{width:l,height:e};const r=e/l;return{width:n,height:Math.round(n*r)}}const be=()=>{const l={inputElement:void 0};return{view:({attrs:e})=>[D("sl-button.upload-button",{disabled:e.disabled===!0,onclick:()=>{l.inputElement&&l.inputElement.click()}},e.label??"Upload Image"),D("input[type=file]",{style:{display:"none"},accept:"image/*",oncreate:({dom:n})=>{l.inputElement=n},onchange:n=>{if(n.redraw=!1,l.inputElement){const r=l.inputElement.files?.[0];r?.type.startsWith("image/")&&createImageBitmap(r).then(s=>{const{width:i,height:o}=xe(s.width,s.height),a=URL.createObjectURL(r);s.close(),e.onUpload(a,r.name,i,o)}).catch(s=>{console.error("could not create a bitmap image: ",s)})}}})]}},ve=()=>({view:({attrs:l})=>D("sl-checkbox.boolean-input",{"help-text":l.config.helpText,disabled:l.disabled,checked:l.value,"onsl-change":e=>{const r=e.target.checked;l.onChange(r)}},l.config.label)}),Ct=()=>({view:({attrs:l})=>D("sl-input.number-input",{label:l.config.label,"help-text":l.config.helpText,type:"number",inputmode:"numeric",size:"small",disabled:l.disabled,value:l.value,min:l.config.min,max:l.config.max,"onsl-change":e=>{const r=e.target.valueAsNumber;l.onChange(isNaN(r)?void 0:r)}})}),we=()=>({view:({attrs:l})=>D("sl-range.range-input",{label:l.config.label,"help-text":l.config.helpText,disabled:l.disabled,value:l.value,min:l.config.min,max:l.config.max,step:l.config.step,"onsl-change":e=>{const r=e.target.value;l.onChange(isNaN(r)?void 0:r)}})}),_e=()=>({view:({attrs:l})=>D("sl-input.string-input",{label:l.config.label,"help-text":l.config.helpText,type:"text",inputmode:"text",size:"small",disabled:l.disabled,value:l.value,"onsl-change":e=>{const r=e.target.value;l.onChange(r.length>0?r:void 0)}})}),Pe=()=>({oncreate:({dom:l,attrs:e})=>{l.querySelector("sl-tab-group").show(e.generator)},onupdate:({dom:l,attrs:e})=>{l.querySelector("sl-tab-group").show(e.generator)},view:({attrs:l})=>{const e=l.registry.getAvailableGenerators();return D(".generator-picker",D("sl-tab-group",{"onsl-tab-show":n=>{const r=n.detail.name;l.generator!==r&&l.onGeneratorChange(r)}},[...e.map(n=>{const r=l.registry.getUIMetadata(n.name),s=D("sl-tab",{slot:"nav",panel:n.name},n.displayName),i=D("sl-tab-panel",{name:n.name},D(".controls",[r?.description?D("p",r.description):null,...r?.controls.map(o=>{switch(o.type){case"range":return D(we,{config:o,value:l.config?.[o.name]??o.defaultValue,onChange:a=>{l.onConfigChange(o.name,a)}});case"boolean":return D(ve,{config:o,value:(l.config?.[o.name]??o.defaultValue)===!0,onChange:a=>{l.onConfigChange(o.name,a)}});case"number":return D(Ct,{config:o,value:l.config?.[o.name]??o.defaultValue,onChange:a=>{l.onConfigChange(o.name,a)}});case"string":return D(_e,{config:o,value:l.config?.[o.name]??o.defaultValue,onChange:a=>{l.onConfigChange(o.name,a)}})}})??[],!r?.description&&r?.controls.length==0?D("p","No controls for this strategy."):null]));return[s,i]})]))}}),Lt=[["Square","1:1",1],["Classic Photo","5:4",5/4],["Standard Photo","4:3",4/3],["35mm/DSLR","3:2",3/2],["Widescreen","16:9",16/9],["UltraWide","21:9",21/9],["Panorama","2:1",2/1],["Instagram Portrait","4:5",4/5],["Classic Portrait","3:4",3/4],["DSLR Portrait","2:3",2/3],["Phone Portrait","9:16",9/16],["Tall Poster","9:21",9/21],["Tall Panorama","1:2",1/2]],ze={view:({attrs:l})=>{const e=!Lt.some(([,,r])=>r===l.ratio),n=Lt.map(([r,s,i])=>D("sl-option",{value:String(i)},`${r} [${s}]`));return e&&n.unshift(D("sl-option",{value:"custom"},"Custom")),D(".aspect-ratio-picker",[D("sl-select",{label:"Aspect Ratio",size:"small",disabled:l.disabled,value:e?"custom":String(l.ratio),"onsl-change":r=>{r.redraw=!1;const i=r.target.value;i&&i!=="custom"&&l.onChange(Number(i))}},n),D("sl-range",{min:.25,max:4,step:.01,disabled:l.disabled,value:l.ratio,"onsl-change":r=>{r.redraw=!1;const s=r.target;l.onChange(s.value)}})])}},De={view:({attrs:l})=>D(".color-picker",[D(".label",l.label),D("sl-color-picker",{label:"Select a color",value:l.color,size:l.size??"medium",format:"rgb","onsl-change":e=>{e.redraw=!1;const n=e.target;l.onUpdate(n.value)}})])};var mt,Nt;function Zt(){if(Nt)return mt;Nt=1;function l(n){var r=n.length,s=1,i=new Array(r),o;for(o=r;o>0;o--)i[o-1]=s,s=s*n[o-1];return{stride:i,data:new Uint32Array(s)}}function e(n){var r=n.length,s=1,i=new Array(r),o=[],a,c;for(a=r;a>0;a--)i[a-1]=s,s=s*n[a-1];for(c=0;c<s;c++)o.push([]);return{stride:i,data:o}}return mt={integer:l,array:e},mt}var yt,Ut;function te(){if(Ut)return yt;Ut=1,yt=l;function l(e,n){var r=new Array(e),s=Math.floor(e/2)<<1,i=0,o,a,c,h,f;for(f=0;f<s;f+=2)o=-2*Math.log(n()),a=Math.sqrt(o),c=2*Math.PI*n(),i+=o,r[f]=a*Math.cos(c),r[f+1]=a*Math.sin(c);if(e%2){var u=Math.sqrt(-2*Math.log(n()))*Math.cos(2*Math.PI*n());r[e-1]=u,i+=Math.pow(u,2)}for(h=1/Math.sqrt(i),f=0;f<e;++f)r[f]*=h;return r}return yt}var xt,qt;function Me(){return qt||(qt=1,xt=function(e,n){e=e||1,n=n||2;for(var r=e*2+1,s=Math.pow(r,n)-1,i=new Array(s),o=0;o<s;o++)for(var a=i[o]=new Array(n),c=o<s/2?o:o+1,h=1;h<=n;h++){var f=c%Math.pow(r,h);a[h-1]=f/Math.pow(r,h-1)-e,c-=f}return i}),xt}var bt,Ft;function ee(){if(Ft)return bt;Ft=1;var l=Me();function e(s){var i=l(2,s),o=[],a;for(i=i.filter(function(c){for(var h=0,f=0;f<s;f++)h+=Math.pow(Math.max(0,Math.abs(c[f])-1),2);return h<s}),a=0;a<s;a++)o.push(0);return i.push(o),i.sort(function(c,h){var f=0,u=0,d;for(d=0;d<s;d++)f+=Math.pow(c[d],2),u+=Math.pow(h[d],2);return f<u?-1:f>u?1:0}),i}var n={};function r(s){return n[s]||(n[s]=e(s)),n[s]}return bt=r,bt}var vt,Ht;function ke(){if(Ht)return vt;Ht=1;var l=Zt().integer,e=te(),n=ee();function r(i,o){for(var a=0,c=0;c<i.length;c++)a+=Math.pow(i[c]-o[c],2);return a}function s(i,o){if(typeof i.distanceFunction=="function")throw new Error("PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction");this.shape=i.shape,this.minDistance=i.minDistance,this.maxDistance=i.maxDistance||i.minDistance*2,this.maxTries=Math.ceil(Math.max(1,i.tries||30)),this.rng=o||Math.random;for(var a=0,c=0;c<this.shape.length;c++)a=Math.max(a,this.shape[c]);var h=Math.max(1,a/128|0),f=1e-14*h;this.dimension=this.shape.length,this.squaredMinDistance=this.minDistance*this.minDistance,this.minDistancePlusEpsilon=this.minDistance+f,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.minDistance/Math.sqrt(this.dimension),this.neighbourhood=n(this.dimension),this.currentPoint=null,this.processList=[],this.samplePoints=[],this.gridShape=[];for(var c=0;c<this.dimension;c++)this.gridShape.push(Math.ceil(this.shape[c]/this.cellSize));this.grid=l(this.gridShape)}return s.prototype.shape=null,s.prototype.dimension=null,s.prototype.minDistance=null,s.prototype.maxDistance=null,s.prototype.minDistancePlusEpsilon=null,s.prototype.squaredMinDistance=null,s.prototype.deltaDistance=null,s.prototype.cellSize=null,s.prototype.maxTries=null,s.prototype.rng=null,s.prototype.neighbourhood=null,s.prototype.currentPoint=null,s.prototype.processList=null,s.prototype.samplePoints=null,s.prototype.gridShape=null,s.prototype.grid=null,s.prototype.addRandomPoint=function(){for(var i=new Array(this.dimension),o=0;o<this.dimension;o++)i[o]=this.rng()*this.shape[o];return this.directAddPoint(i)},s.prototype.addPoint=function(i){var o,a=!0;if(i.length===this.dimension)for(o=0;o<this.dimension&&a;o++)a=i[o]>=0&&i[o]<this.shape[o];else a=!1;return a?this.directAddPoint(i):null},s.prototype.directAddPoint=function(i){var o=0,a=this.grid.stride,c;for(this.processList.push(i),this.samplePoints.push(i),c=0;c<this.dimension;c++)o+=(i[c]/this.cellSize|0)*a[c];return this.grid.data[o]=this.samplePoints.length,i},s.prototype.inNeighbourhood=function(i){var o=this.dimension,a=this.grid.stride,c,h,f,u,d;for(c=0;c<this.neighbourhood.length;c++){for(h=0,f=0;f<o;f++){if(u=(i[f]/this.cellSize|0)+this.neighbourhood[c][f],u<0||u>=this.gridShape[f]){h=-1;break}h+=u*a[f]}if(h!==-1&&this.grid.data[h]!==0&&(d=this.samplePoints[this.grid.data[h]-1],r(i,d)<this.squaredMinDistance))return!0}return!1},s.prototype.next=function(){for(var i,o,a,c,h,f,u;this.processList.length>0;){for(this.currentPoint===null&&(this.currentPoint=this.processList.shift()),c=this.currentPoint,i=0;i<this.maxTries;i++){for(f=!0,a=this.minDistancePlusEpsilon+this.deltaDistance*this.rng(),this.dimension===2?(o=this.rng()*Math.PI*2,h=[Math.cos(o),Math.sin(o)]):h=e(this.dimension,this.rng),u=0;f&&u<this.dimension;u++)h[u]=c[u]+h[u]*a,f=h[u]>=0&&h[u]<this.shape[u];if(f&&!this.inNeighbourhood(h))return this.directAddPoint(h)}i===this.maxTries&&(this.currentPoint=null)}return null},s.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},s.prototype.getAllPoints=function(){return this.samplePoints},s.prototype.getAllPointsWithDistance=function(){throw new Error("PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation")},s.prototype.reset=function(){var i=this.grid.data,o=0;for(o=0;o<i.length;o++)i[o]=0;this.samplePoints=[],this.currentPoint=null,this.processList.length=0},vt=s,vt}var wt,jt;function Ce(){if(jt)return wt;jt=1;var l=Zt().array,e=te(),n=ee();function r(i,o){for(var a=0,c=0;c<i.length;c++)a+=Math.pow(i[c]-o[c],2);return Math.sqrt(a)}function s(i,o){if(typeof i.distanceFunction!="function")throw new Error("PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction");this.shape=i.shape,this.minDistance=i.minDistance,this.maxDistance=i.maxDistance||i.minDistance*2,this.maxTries=Math.ceil(Math.max(1,i.tries||30)),this.distanceFunction=i.distanceFunction,this.bias=Math.max(0,Math.min(1,i.bias||0)),this.rng=o||Math.random;for(var a=0,c=0;c<this.shape.length;c++)a=Math.max(a,this.shape[c]);var h=Math.max(1,a/128|0),f=1e-14*h;this.dimension=this.shape.length,this.minDistancePlusEpsilon=this.minDistance+f,this.deltaDistance=Math.max(0,this.maxDistance-this.minDistancePlusEpsilon),this.cellSize=this.maxDistance/Math.sqrt(this.dimension),this.neighbourhood=n(this.dimension),this.currentPoint=null,this.currentDistance=0,this.processList=[],this.samplePoints=[],this.sampleDistance=[],this.gridShape=[];for(var c=0;c<this.dimension;c++)this.gridShape.push(Math.ceil(this.shape[c]/this.cellSize));this.grid=l(this.gridShape)}return s.prototype.shape=null,s.prototype.dimension=null,s.prototype.minDistance=null,s.prototype.maxDistance=null,s.prototype.minDistancePlusEpsilon=null,s.prototype.deltaDistance=null,s.prototype.cellSize=null,s.prototype.maxTries=null,s.prototype.distanceFunction=null,s.prototype.bias=null,s.prototype.rng=null,s.prototype.neighbourhood=null,s.prototype.currentPoint=null,s.prototype.currentDistance=null,s.prototype.processList=null,s.prototype.samplePoints=null,s.prototype.sampleDistance=null,s.prototype.gridShape=null,s.prototype.grid=null,s.prototype.addRandomPoint=function(){for(var i=new Array(this.dimension),o=0;o<this.dimension;o++)i[o]=this.rng()*this.shape[o];return this.directAddPoint(i)},s.prototype.addPoint=function(i){var o,a=!0;if(i.length===this.dimension)for(o=0;o<this.dimension&&a;o++)a=i[o]>=0&&i[o]<this.shape[o];else a=!1;return a?this.directAddPoint(i):null},s.prototype.directAddPoint=function(i){var o=0,a=this.grid.stride,c=this.samplePoints.length,h;for(this.processList.push(c),this.samplePoints.push(i),this.sampleDistance.push(this.distanceFunction(i)),h=0;h<this.dimension;h++)o+=(i[h]/this.cellSize|0)*a[h];return this.grid.data[o].push(c),i},s.prototype.inNeighbourhood=function(i){var o=this.dimension,a=this.grid.stride,c,h,f,u,d,g,p=this.distanceFunction(i);for(c=0;c<this.neighbourhood.length;c++){for(h=0,f=0;f<o;f++){if(u=(i[f]/this.cellSize|0)+this.neighbourhood[c][f],u<0||u>=this.gridShape[f]){h=-1;break}h+=u*a[f]}if(h!==-1&&this.grid.data[h].length>0)for(var m=0;m<this.grid.data[h].length;m++){d=this.samplePoints[this.grid.data[h][m]],g=this.sampleDistance[this.grid.data[h][m]];var x=Math.min(g,p),y=Math.max(g,p),w=x+(y-x)*this.bias;if(r(i,d)<this.minDistance+this.deltaDistance*w)return!0}}return!1},s.prototype.next=function(){for(var i,o,a,c,h,f,u,d;this.processList.length>0;){if(this.currentPoint===null){var g=this.processList.shift();this.currentPoint=this.samplePoints[g],this.currentDistance=this.sampleDistance[g]}for(c=this.currentPoint,h=this.currentDistance,i=0;i<this.maxTries;i++){for(u=!0,a=this.minDistancePlusEpsilon+this.deltaDistance*(h+(1-h)*this.bias),this.dimension===2?(o=this.rng()*Math.PI*2,f=[Math.cos(o),Math.sin(o)]):f=e(this.dimension,this.rng),d=0;u&&d<this.dimension;d++)f[d]=c[d]+f[d]*a,u=f[d]>=0&&f[d]<this.shape[d];if(u&&!this.inNeighbourhood(f))return this.directAddPoint(f)}i===this.maxTries&&(this.currentPoint=null)}return null},s.prototype.fill=function(){for(this.samplePoints.length===0&&this.addRandomPoint();this.next(););return this.samplePoints},s.prototype.getAllPoints=function(){return this.samplePoints},s.prototype.getAllPointsWithDistance=function(){var i=new Array(this.samplePoints.length),o=0,a=0,c;for(o=0;o<this.samplePoints.length;o++){for(c=new Array(this.dimension+1),a=0;a<this.dimension;a++)c[a]=this.samplePoints[o][a];c[this.dimension]=this.sampleDistance[o],i[o]=c}return i},s.prototype.reset=function(){var i=this.grid.data,o=0;for(o=0;o<i.length;o++)i[o]=[];this.samplePoints=[],this.currentPoint=null,this.processList.length=0},wt=s,wt}var _t,Ot;function Te(){if(Ot)return _t;Ot=1;var l=ke(),e=Ce();function n(r,s){this.shape=r.shape,typeof r.distanceFunction=="function"?this.implementation=new e(r,s):this.implementation=new l(r,s)}return n.prototype.implementation=null,n.prototype.addRandomPoint=function(){return this.implementation.addRandomPoint()},n.prototype.addPoint=function(r){return this.implementation.addPoint(r)},n.prototype.next=function(){return this.implementation.next()},n.prototype.fill=function(){return this.implementation.fill()},n.prototype.getAllPoints=function(){return this.implementation.getAllPoints()},n.prototype.getAllPointsWithDistance=function(){return this.implementation.getAllPointsWithDistance()},n.prototype.reset=function(){this.implementation.reset()},_t=n,_t}var Se=Te();const Ie=ce(Se),It="PoissonPointGenerator",Ae={name:It,displayName:"Poisson",description:"Generate seed points using Poisson disk sampling. The algorithm produces points that are tightly-packed, but no closer to each other than a specified minimum distance (the piece size), resulting in a natural, organic look.",sortHint:1,controls:[]},Ee=(l,e,n)=>({generatePoints(s){const{width:i,height:o,pieceSize:a,random:c}=s;return new Ie({shape:[i,o],minDistance:a,tries:20},c).fill()}});ct.register(It,Ee,Ae);const O=11102230246251565e-32,U=134217729,$e=(3+8*O)*O;function Pt(l,e,n,r,s){let i,o,a,c,h=e[0],f=r[0],u=0,d=0;f>h==f>-h?(i=h,h=e[++u]):(i=f,f=r[++d]);let g=0;if(u<l&&d<n)for(f>h==f>-h?(o=h+i,a=i-(o-h),h=e[++u]):(o=f+i,a=i-(o-f),f=r[++d]),i=o,a!==0&&(s[g++]=a);u<l&&d<n;)f>h==f>-h?(o=i+h,c=o-i,a=i-(o-c)+(h-c),h=e[++u]):(o=i+f,c=o-i,a=i-(o-c)+(f-c),f=r[++d]),i=o,a!==0&&(s[g++]=a);for(;u<l;)o=i+h,c=o-i,a=i-(o-c)+(h-c),h=e[++u],i=o,a!==0&&(s[g++]=a);for(;d<n;)o=i+f,c=o-i,a=i-(o-c)+(f-c),f=r[++d],i=o,a!==0&&(s[g++]=a);return(i!==0||g===0)&&(s[g++]=i),g}function Ge(l,e){let n=e[0];for(let r=1;r<l;r++)n+=e[r];return n}function ut(l){return new Float64Array(l)}const Re=(3+16*O)*O,Le=(2+12*O)*O,Ne=(9+64*O)*O*O,Y=ut(4),Vt=ut(8),Wt=ut(12),Kt=ut(16),q=ut(4);function Ue(l,e,n,r,s,i,o){let a,c,h,f,u,d,g,p,m,x,y,w,_,M,b,I,P,k;const z=l-s,T=n-s,S=e-i,C=r-i;M=z*C,d=U*z,g=d-(d-z),p=z-g,d=U*C,m=d-(d-C),x=C-m,b=p*x-(M-g*m-p*m-g*x),I=S*T,d=U*S,g=d-(d-S),p=S-g,d=U*T,m=d-(d-T),x=T-m,P=p*x-(I-g*m-p*m-g*x),y=b-P,u=b-y,Y[0]=b-(y+u)+(u-P),w=M+y,u=w-M,_=M-(w-u)+(y-u),y=_-I,u=_-y,Y[1]=_-(y+u)+(u-I),k=w+y,u=k-w,Y[2]=w-(k-u)+(y-u),Y[3]=k;let A=Ge(4,Y),$=Le*o;if(A>=$||-A>=$||(u=l-z,a=l-(z+u)+(u-s),u=n-T,h=n-(T+u)+(u-s),u=e-S,c=e-(S+u)+(u-i),u=r-C,f=r-(C+u)+(u-i),a===0&&c===0&&h===0&&f===0)||($=Ne*o+$e*Math.abs(A),A+=z*f+C*a-(S*h+T*c),A>=$||-A>=$))return A;M=a*C,d=U*a,g=d-(d-a),p=a-g,d=U*C,m=d-(d-C),x=C-m,b=p*x-(M-g*m-p*m-g*x),I=c*T,d=U*c,g=d-(d-c),p=c-g,d=U*T,m=d-(d-T),x=T-m,P=p*x-(I-g*m-p*m-g*x),y=b-P,u=b-y,q[0]=b-(y+u)+(u-P),w=M+y,u=w-M,_=M-(w-u)+(y-u),y=_-I,u=_-y,q[1]=_-(y+u)+(u-I),k=w+y,u=k-w,q[2]=w-(k-u)+(y-u),q[3]=k;const R=Pt(4,Y,4,q,Vt);M=z*f,d=U*z,g=d-(d-z),p=z-g,d=U*f,m=d-(d-f),x=f-m,b=p*x-(M-g*m-p*m-g*x),I=S*h,d=U*S,g=d-(d-S),p=S-g,d=U*h,m=d-(d-h),x=h-m,P=p*x-(I-g*m-p*m-g*x),y=b-P,u=b-y,q[0]=b-(y+u)+(u-P),w=M+y,u=w-M,_=M-(w-u)+(y-u),y=_-I,u=_-y,q[1]=_-(y+u)+(u-I),k=w+y,u=k-w,q[2]=w-(k-u)+(y-u),q[3]=k;const E=Pt(R,Vt,4,q,Wt);M=a*f,d=U*a,g=d-(d-a),p=a-g,d=U*f,m=d-(d-f),x=f-m,b=p*x-(M-g*m-p*m-g*x),I=c*h,d=U*c,g=d-(d-c),p=c-g,d=U*h,m=d-(d-h),x=h-m,P=p*x-(I-g*m-p*m-g*x),y=b-P,u=b-y,q[0]=b-(y+u)+(u-P),w=M+y,u=w-M,_=M-(w-u)+(y-u),y=_-I,u=_-y,q[1]=_-(y+u)+(u-I),k=w+y,u=k-w,q[2]=w-(k-u)+(y-u),q[3]=k;const G=Pt(E,Wt,4,q,Kt);return Kt[G-1]}function ft(l,e,n,r,s,i){const o=(e-i)*(n-s),a=(l-s)*(r-i),c=o-a,h=Math.abs(o+a);return Math.abs(c)>=Re*h?c:-Ue(l,e,n,r,s,i,h)}const Bt=Math.pow(2,-52),dt=new Uint32Array(512);class pt{static from(e,n=Oe,r=Ve){const s=e.length,i=new Float64Array(s*2);for(let o=0;o<s;o++){const a=e[o];i[2*o]=n(a),i[2*o+1]=r(a)}return new pt(i)}constructor(e){const n=e.length>>1;if(n>0&&typeof e[0]!="number")throw new Error("Expected coords to contain numbers.");this.coords=e;const r=Math.max(2*n-5,0);this._triangles=new Uint32Array(r*3),this._halfedges=new Int32Array(r*3),this._hashSize=Math.ceil(Math.sqrt(n)),this._hullPrev=new Uint32Array(n),this._hullNext=new Uint32Array(n),this._hullTri=new Uint32Array(n),this._hullHash=new Int32Array(this._hashSize),this._ids=new Uint32Array(n),this._dists=new Float64Array(n),this.update()}update(){const{coords:e,_hullPrev:n,_hullNext:r,_hullTri:s,_hullHash:i}=this,o=e.length>>1;let a=1/0,c=1/0,h=-1/0,f=-1/0;for(let z=0;z<o;z++){const T=e[2*z],S=e[2*z+1];T<a&&(a=T),S<c&&(c=S),T>h&&(h=T),S>f&&(f=S),this._ids[z]=z}const u=(a+h)/2,d=(c+f)/2;let g,p,m;for(let z=0,T=1/0;z<o;z++){const S=zt(u,d,e[2*z],e[2*z+1]);S<T&&(g=z,T=S)}const x=e[2*g],y=e[2*g+1];for(let z=0,T=1/0;z<o;z++){if(z===g)continue;const S=zt(x,y,e[2*z],e[2*z+1]);S<T&&S>0&&(p=z,T=S)}let w=e[2*p],_=e[2*p+1],M=1/0;for(let z=0;z<o;z++){if(z===g||z===p)continue;const T=He(x,y,w,_,e[2*z],e[2*z+1]);T<M&&(m=z,M=T)}let b=e[2*m],I=e[2*m+1];if(M===1/0){for(let S=0;S<o;S++)this._dists[S]=e[2*S]-e[0]||e[2*S+1]-e[1];Z(this._ids,this._dists,0,o-1);const z=new Uint32Array(o);let T=0;for(let S=0,C=-1/0;S<o;S++){const A=this._ids[S],$=this._dists[A];$>C&&(z[T++]=A,C=$)}this.hull=z.subarray(0,T),this.triangles=new Uint32Array(0),this.halfedges=new Uint32Array(0);return}if(ft(x,y,w,_,b,I)<0){const z=p,T=w,S=_;p=m,w=b,_=I,m=z,b=T,I=S}const P=je(x,y,w,_,b,I);this._cx=P.x,this._cy=P.y;for(let z=0;z<o;z++)this._dists[z]=zt(e[2*z],e[2*z+1],P.x,P.y);Z(this._ids,this._dists,0,o-1),this._hullStart=g;let k=3;r[g]=n[m]=p,r[p]=n[g]=m,r[m]=n[p]=g,s[g]=0,s[p]=1,s[m]=2,i.fill(-1),i[this._hashKey(x,y)]=g,i[this._hashKey(w,_)]=p,i[this._hashKey(b,I)]=m,this.trianglesLen=0,this._addTriangle(g,p,m,-1,-1,-1);for(let z=0,T,S;z<this._ids.length;z++){const C=this._ids[z],A=e[2*C],$=e[2*C+1];if(z>0&&Math.abs(A-T)<=Bt&&Math.abs($-S)<=Bt||(T=A,S=$,C===g||C===p||C===m))continue;let R=0;for(let X=0,le=this._hashKey(A,$);X<this._hashSize&&(R=i[(le+X)%this._hashSize],!(R!==-1&&R!==r[R]));X++);R=n[R];let E=R,G;for(;G=r[E],ft(A,$,e[2*E],e[2*E+1],e[2*G],e[2*G+1])>=0;)if(E=G,E===R){E=-1;break}if(E===-1)continue;let F=this._addTriangle(E,C,r[E],-1,-1,s[E]);s[C]=this._legalize(F+2),s[E]=F,k++;let N=r[E];for(;G=r[N],ft(A,$,e[2*N],e[2*N+1],e[2*G],e[2*G+1])<0;)F=this._addTriangle(N,C,G,s[C],-1,s[N]),s[C]=this._legalize(F+2),r[N]=N,k--,N=G;if(E===R)for(;G=n[E],ft(A,$,e[2*G],e[2*G+1],e[2*E],e[2*E+1])<0;)F=this._addTriangle(G,C,E,-1,s[E],s[G]),this._legalize(F+2),s[G]=F,r[E]=E,k--,E=G;this._hullStart=n[C]=E,r[E]=n[N]=C,r[C]=N,i[this._hashKey(A,$)]=C,i[this._hashKey(e[2*E],e[2*E+1])]=E}this.hull=new Uint32Array(k);for(let z=0,T=this._hullStart;z<k;z++)this.hull[z]=T,T=r[T];this.triangles=this._triangles.subarray(0,this.trianglesLen),this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(e,n){return Math.floor(qe(e-this._cx,n-this._cy)*this._hashSize)%this._hashSize}_legalize(e){const{_triangles:n,_halfedges:r,coords:s}=this;let i=0,o=0;for(;;){const a=r[e],c=e-e%3;if(o=c+(e+2)%3,a===-1){if(i===0)break;e=dt[--i];continue}const h=a-a%3,f=c+(e+1)%3,u=h+(a+2)%3,d=n[o],g=n[e],p=n[f],m=n[u];if(Fe(s[2*d],s[2*d+1],s[2*g],s[2*g+1],s[2*p],s[2*p+1],s[2*m],s[2*m+1])){n[e]=m,n[a]=d;const y=r[u];if(y===-1){let _=this._hullStart;do{if(this._hullTri[_]===u){this._hullTri[_]=e;break}_=this._hullPrev[_]}while(_!==this._hullStart)}this._link(e,y),this._link(a,r[o]),this._link(o,u);const w=h+(a+1)%3;i<dt.length&&(dt[i++]=w)}else{if(i===0)break;e=dt[--i]}}return o}_link(e,n){this._halfedges[e]=n,n!==-1&&(this._halfedges[n]=e)}_addTriangle(e,n,r,s,i,o){const a=this.trianglesLen;return this._triangles[a]=e,this._triangles[a+1]=n,this._triangles[a+2]=r,this._link(a,s),this._link(a+1,i),this._link(a+2,o),this.trianglesLen+=3,a}}function qe(l,e){const n=l/(Math.abs(l)+Math.abs(e));return(e>0?3-n:1+n)/4}function zt(l,e,n,r){const s=l-n,i=e-r;return s*s+i*i}function Fe(l,e,n,r,s,i,o,a){const c=l-o,h=e-a,f=n-o,u=r-a,d=s-o,g=i-a,p=c*c+h*h,m=f*f+u*u,x=d*d+g*g;return c*(u*x-m*g)-h*(f*x-m*d)+p*(f*g-u*d)<0}function He(l,e,n,r,s,i){const o=n-l,a=r-e,c=s-l,h=i-e,f=o*o+a*a,u=c*c+h*h,d=.5/(o*h-a*c),g=(h*f-a*u)*d,p=(o*u-c*f)*d;return g*g+p*p}function je(l,e,n,r,s,i){const o=n-l,a=r-e,c=s-l,h=i-e,f=o*o+a*a,u=c*c+h*h,d=.5/(o*h-a*c),g=l+(h*f-a*u)*d,p=e+(o*u-c*f)*d;return{x:g,y:p}}function Z(l,e,n,r){if(r-n<=20)for(let s=n+1;s<=r;s++){const i=l[s],o=e[i];let a=s-1;for(;a>=n&&e[l[a]]>o;)l[a+1]=l[a--];l[a+1]=i}else{const s=n+r>>1;let i=n+1,o=r;et(l,s,i),e[l[n]]>e[l[r]]&&et(l,n,r),e[l[i]]>e[l[r]]&&et(l,i,r),e[l[n]]>e[l[i]]&&et(l,n,i);const a=l[i],c=e[a];for(;;){do i++;while(e[l[i]]<c);do o--;while(e[l[o]]>c);if(o<i)break;et(l,i,o)}l[n+1]=l[o],l[o]=a,r-i+1>=o-n?(Z(l,e,i,r),Z(l,e,n,o-1)):(Z(l,e,n,o-1),Z(l,e,i,r))}}function et(l,e,n){const r=l[e];l[e]=l[n],l[n]=r}function Oe(l){return l[0]}function Ve(l){return l[1]}const Xt=1e-6;class B{constructor(){this._x0=this._y0=this._x1=this._y1=null,this._=""}moveTo(e,n){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+n}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(e,n){this._+=`L${this._x1=+e},${this._y1=+n}`}arc(e,n,r){e=+e,n=+n,r=+r;const s=e+r,i=n;if(r<0)throw new Error("negative radius");this._x1===null?this._+=`M${s},${i}`:(Math.abs(this._x1-s)>Xt||Math.abs(this._y1-i)>Xt)&&(this._+="L"+s+","+i),r&&(this._+=`A${r},${r},0,1,1,${e-r},${n}A${r},${r},0,1,1,${this._x1=s},${this._y1=i}`)}rect(e,n,r,s){this._+=`M${this._x0=this._x1=+e},${this._y0=this._y1=+n}h${+r}v${+s}h${-r}Z`}value(){return this._||null}}class Tt{constructor(){this._=[]}moveTo(e,n){this._.push([e,n])}closePath(){this._.push(this._[0].slice())}lineTo(e,n){this._.push([e,n])}value(){return this._.length?this._:null}}class We{constructor(e,[n,r,s,i]=[0,0,960,500]){if(!((s=+s)>=(n=+n))||!((i=+i)>=(r=+r)))throw new Error("invalid bounds");this.delaunay=e,this._circumcenters=new Float64Array(e.points.length*2),this.vectors=new Float64Array(e.points.length*2),this.xmax=s,this.xmin=n,this.ymax=i,this.ymin=r,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:e,hull:n,triangles:r},vectors:s}=this;let i,o;const a=this.circumcenters=this._circumcenters.subarray(0,r.length/3*2);for(let m=0,x=0,y=r.length,w,_;m<y;m+=3,x+=2){const M=r[m]*2,b=r[m+1]*2,I=r[m+2]*2,P=e[M],k=e[M+1],z=e[b],T=e[b+1],S=e[I],C=e[I+1],A=z-P,$=T-k,R=S-P,E=C-k,G=(A*E-$*R)*2;if(Math.abs(G)<1e-9){if(i===void 0){i=o=0;for(const N of n)i+=e[N*2],o+=e[N*2+1];i/=n.length,o/=n.length}const F=1e9*Math.sign((i-P)*E-(o-k)*R);w=(P+S)/2-F*E,_=(k+C)/2+F*R}else{const F=1/G,N=A*A+$*$,X=R*R+E*E;w=P+(E*N-$*X)*F,_=k+(A*X-R*N)*F}a[x]=w,a[x+1]=_}let c=n[n.length-1],h,f=c*4,u,d=e[2*c],g,p=e[2*c+1];s.fill(0);for(let m=0;m<n.length;++m)c=n[m],h=f,u=d,g=p,f=c*4,d=e[2*c],p=e[2*c+1],s[h+2]=s[f]=g-p,s[h+3]=s[f+1]=d-u}render(e){const n=e==null?e=new B:void 0,{delaunay:{halfedges:r,inedges:s,hull:i},circumcenters:o,vectors:a}=this;if(i.length<=1)return null;for(let f=0,u=r.length;f<u;++f){const d=r[f];if(d<f)continue;const g=Math.floor(f/3)*2,p=Math.floor(d/3)*2,m=o[g],x=o[g+1],y=o[p],w=o[p+1];this._renderSegment(m,x,y,w,e)}let c,h=i[i.length-1];for(let f=0;f<i.length;++f){c=h,h=i[f];const u=Math.floor(s[h]/3)*2,d=o[u],g=o[u+1],p=c*4,m=this._project(d,g,a[p+2],a[p+3]);m&&this._renderSegment(d,g,m[0],m[1],e)}return n&&n.value()}renderBounds(e){const n=e==null?e=new B:void 0;return e.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),n&&n.value()}renderCell(e,n){const r=n==null?n=new B:void 0,s=this._clip(e);if(s===null||!s.length)return;n.moveTo(s[0],s[1]);let i=s.length;for(;s[0]===s[i-2]&&s[1]===s[i-1]&&i>1;)i-=2;for(let o=2;o<i;o+=2)(s[o]!==s[o-2]||s[o+1]!==s[o-1])&&n.lineTo(s[o],s[o+1]);return n.closePath(),r&&r.value()}*cellPolygons(){const{delaunay:{points:e}}=this;for(let n=0,r=e.length/2;n<r;++n){const s=this.cellPolygon(n);s&&(s.index=n,yield s)}}cellPolygon(e){const n=new Tt;return this.renderCell(e,n),n.value()}_renderSegment(e,n,r,s,i){let o;const a=this._regioncode(e,n),c=this._regioncode(r,s);a===0&&c===0?(i.moveTo(e,n),i.lineTo(r,s)):(o=this._clipSegment(e,n,r,s,a,c))&&(i.moveTo(o[0],o[1]),i.lineTo(o[2],o[3]))}contains(e,n,r){return n=+n,n!==n||(r=+r,r!==r)?!1:this.delaunay._step(e,n,r)===e}*neighbors(e){const n=this._clip(e);if(n)for(const r of this.delaunay.neighbors(e)){const s=this._clip(r);if(s){t:for(let i=0,o=n.length;i<o;i+=2)for(let a=0,c=s.length;a<c;a+=2)if(n[i]===s[a]&&n[i+1]===s[a+1]&&n[(i+2)%o]===s[(a+c-2)%c]&&n[(i+3)%o]===s[(a+c-1)%c]){yield r;break t}}}}_cell(e){const{circumcenters:n,delaunay:{inedges:r,halfedges:s,triangles:i}}=this,o=r[e];if(o===-1)return null;const a=[];let c=o;do{const h=Math.floor(c/3);if(a.push(n[h*2],n[h*2+1]),c=c%3===2?c-2:c+1,i[c]!==e)break;c=s[c]}while(c!==o&&c!==-1);return a}_clip(e){if(e===0&&this.delaunay.hull.length===1)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const n=this._cell(e);if(n===null)return null;const{vectors:r}=this,s=e*4;return this._simplify(r[s]||r[s+1]?this._clipInfinite(e,n,r[s],r[s+1],r[s+2],r[s+3]):this._clipFinite(e,n))}_clipFinite(e,n){const r=n.length;let s=null,i,o,a=n[r-2],c=n[r-1],h,f=this._regioncode(a,c),u,d=0;for(let g=0;g<r;g+=2)if(i=a,o=c,a=n[g],c=n[g+1],h=f,f=this._regioncode(a,c),h===0&&f===0)u=d,d=0,s?s.push(a,c):s=[a,c];else{let p,m,x,y,w;if(h===0){if((p=this._clipSegment(i,o,a,c,h,f))===null)continue;[m,x,y,w]=p}else{if((p=this._clipSegment(a,c,i,o,f,h))===null)continue;[y,w,m,x]=p,u=d,d=this._edgecode(m,x),u&&d&&this._edge(e,u,d,s,s.length),s?s.push(m,x):s=[m,x]}u=d,d=this._edgecode(y,w),u&&d&&this._edge(e,u,d,s,s.length),s?s.push(y,w):s=[y,w]}if(s)u=d,d=this._edgecode(s[0],s[1]),u&&d&&this._edge(e,u,d,s,s.length);else if(this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return s}_clipSegment(e,n,r,s,i,o){const a=i<o;for(a&&([e,n,r,s,i,o]=[r,s,e,n,o,i]);;){if(i===0&&o===0)return a?[r,s,e,n]:[e,n,r,s];if(i&o)return null;let c,h,f=i||o;f&8?(c=e+(r-e)*(this.ymax-n)/(s-n),h=this.ymax):f&4?(c=e+(r-e)*(this.ymin-n)/(s-n),h=this.ymin):f&2?(h=n+(s-n)*(this.xmax-e)/(r-e),c=this.xmax):(h=n+(s-n)*(this.xmin-e)/(r-e),c=this.xmin),i?(e=c,n=h,i=this._regioncode(e,n)):(r=c,s=h,o=this._regioncode(r,s))}}_clipInfinite(e,n,r,s,i,o){let a=Array.from(n),c;if((c=this._project(a[0],a[1],r,s))&&a.unshift(c[0],c[1]),(c=this._project(a[a.length-2],a[a.length-1],i,o))&&a.push(c[0],c[1]),a=this._clipFinite(e,a))for(let h=0,f=a.length,u,d=this._edgecode(a[f-2],a[f-1]);h<f;h+=2)u=d,d=this._edgecode(a[h],a[h+1]),u&&d&&(h=this._edge(e,u,d,a,h),f=a.length);else this.contains(e,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(a=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return a}_edge(e,n,r,s,i){for(;n!==r;){let o,a;switch(n){case 5:n=4;continue;case 4:n=6,o=this.xmax,a=this.ymin;break;case 6:n=2;continue;case 2:n=10,o=this.xmax,a=this.ymax;break;case 10:n=8;continue;case 8:n=9,o=this.xmin,a=this.ymax;break;case 9:n=1;continue;case 1:n=5,o=this.xmin,a=this.ymin;break}(s[i]!==o||s[i+1]!==a)&&this.contains(e,o,a)&&(s.splice(i,0,o,a),i+=2)}return i}_project(e,n,r,s){let i=1/0,o,a,c;if(s<0){if(n<=this.ymin)return null;(o=(this.ymin-n)/s)<i&&(c=this.ymin,a=e+(i=o)*r)}else if(s>0){if(n>=this.ymax)return null;(o=(this.ymax-n)/s)<i&&(c=this.ymax,a=e+(i=o)*r)}if(r>0){if(e>=this.xmax)return null;(o=(this.xmax-e)/r)<i&&(a=this.xmax,c=n+(i=o)*s)}else if(r<0){if(e<=this.xmin)return null;(o=(this.xmin-e)/r)<i&&(a=this.xmin,c=n+(i=o)*s)}return[a,c]}_edgecode(e,n){return(e===this.xmin?1:e===this.xmax?2:0)|(n===this.ymin?4:n===this.ymax?8:0)}_regioncode(e,n){return(e<this.xmin?1:e>this.xmax?2:0)|(n<this.ymin?4:n>this.ymax?8:0)}_simplify(e){if(e&&e.length>4){for(let n=0;n<e.length;n+=2){const r=(n+2)%e.length,s=(n+4)%e.length;(e[n]===e[r]&&e[r]===e[s]||e[n+1]===e[r+1]&&e[r+1]===e[s+1])&&(e.splice(r,2),n-=2)}e.length||(e=null)}return e}}const Ke=2*Math.PI,J=Math.pow;function Be(l){return l[0]}function Xe(l){return l[1]}function Ye(l){const{triangles:e,coords:n}=l;for(let r=0;r<e.length;r+=3){const s=2*e[r],i=2*e[r+1],o=2*e[r+2];if((n[o]-n[s])*(n[i+1]-n[s+1])-(n[i]-n[s])*(n[o+1]-n[s+1])>1e-10)return!1}return!0}function Je(l,e,n){return[l+Math.sin(l+e)*n,e+Math.cos(l-e)*n]}class At{static from(e,n=Be,r=Xe,s){return new At("length"in e?Qe(e,n,r,s):Float64Array.from(Ze(e,n,r,s)))}constructor(e){this._delaunator=new pt(e),this.inedges=new Int32Array(e.length/2),this._hullIndex=new Int32Array(e.length/2),this.points=this._delaunator.coords,this._init()}update(){return this._delaunator.update(),this._init(),this}_init(){const e=this._delaunator,n=this.points;if(e.hull&&e.hull.length>2&&Ye(e)){this.collinear=Int32Array.from({length:n.length/2},(d,g)=>g).sort((d,g)=>n[2*d]-n[2*g]||n[2*d+1]-n[2*g+1]);const c=this.collinear[0],h=this.collinear[this.collinear.length-1],f=[n[2*c],n[2*c+1],n[2*h],n[2*h+1]],u=1e-8*Math.hypot(f[3]-f[1],f[2]-f[0]);for(let d=0,g=n.length/2;d<g;++d){const p=Je(n[2*d],n[2*d+1],u);n[2*d]=p[0],n[2*d+1]=p[1]}this._delaunator=new pt(n)}else delete this.collinear;const r=this.halfedges=this._delaunator.halfedges,s=this.hull=this._delaunator.hull,i=this.triangles=this._delaunator.triangles,o=this.inedges.fill(-1),a=this._hullIndex.fill(-1);for(let c=0,h=r.length;c<h;++c){const f=i[c%3===2?c-2:c+1];(r[c]===-1||o[f]===-1)&&(o[f]=c)}for(let c=0,h=s.length;c<h;++c)a[s[c]]=c;s.length<=2&&s.length>0&&(this.triangles=new Int32Array(3).fill(-1),this.halfedges=new Int32Array(3).fill(-1),this.triangles[0]=s[0],o[s[0]]=1,s.length===2&&(o[s[1]]=0,this.triangles[1]=s[1],this.triangles[2]=s[1]))}voronoi(e){return new We(this,e)}*neighbors(e){const{inedges:n,hull:r,_hullIndex:s,halfedges:i,triangles:o,collinear:a}=this;if(a){const u=a.indexOf(e);u>0&&(yield a[u-1]),u<a.length-1&&(yield a[u+1]);return}const c=n[e];if(c===-1)return;let h=c,f=-1;do{if(yield f=o[h],h=h%3===2?h-2:h+1,o[h]!==e)return;if(h=i[h],h===-1){const u=r[(s[e]+1)%r.length];u!==f&&(yield u);return}}while(h!==c)}find(e,n,r=0){if(e=+e,e!==e||(n=+n,n!==n))return-1;const s=r;let i;for(;(i=this._step(r,e,n))>=0&&i!==r&&i!==s;)r=i;return i}_step(e,n,r){const{inedges:s,hull:i,_hullIndex:o,halfedges:a,triangles:c,points:h}=this;if(s[e]===-1||!h.length)return(e+1)%(h.length>>1);let f=e,u=J(n-h[e*2],2)+J(r-h[e*2+1],2);const d=s[e];let g=d;do{let p=c[g];const m=J(n-h[p*2],2)+J(r-h[p*2+1],2);if(m<u&&(u=m,f=p),g=g%3===2?g-2:g+1,c[g]!==e)break;if(g=a[g],g===-1){if(g=i[(o[e]+1)%i.length],g!==p&&J(n-h[g*2],2)+J(r-h[g*2+1],2)<u)return g;break}}while(g!==d);return f}render(e){const n=e==null?e=new B:void 0,{points:r,halfedges:s,triangles:i}=this;for(let o=0,a=s.length;o<a;++o){const c=s[o];if(c<o)continue;const h=i[o]*2,f=i[c]*2;e.moveTo(r[h],r[h+1]),e.lineTo(r[f],r[f+1])}return this.renderHull(e),n&&n.value()}renderPoints(e,n){n===void 0&&(!e||typeof e.moveTo!="function")&&(n=e,e=null),n=n==null?2:+n;const r=e==null?e=new B:void 0,{points:s}=this;for(let i=0,o=s.length;i<o;i+=2){const a=s[i],c=s[i+1];e.moveTo(a+n,c),e.arc(a,c,n,0,Ke)}return r&&r.value()}renderHull(e){const n=e==null?e=new B:void 0,{hull:r,points:s}=this,i=r[0]*2,o=r.length;e.moveTo(s[i],s[i+1]);for(let a=1;a<o;++a){const c=2*r[a];e.lineTo(s[c],s[c+1])}return e.closePath(),n&&n.value()}hullPolygon(){const e=new Tt;return this.renderHull(e),e.value()}renderTriangle(e,n){const r=n==null?n=new B:void 0,{points:s,triangles:i}=this,o=i[e*=3]*2,a=i[e+1]*2,c=i[e+2]*2;return n.moveTo(s[o],s[o+1]),n.lineTo(s[a],s[a+1]),n.lineTo(s[c],s[c+1]),n.closePath(),r&&r.value()}*trianglePolygons(){const{triangles:e}=this;for(let n=0,r=e.length/3;n<r;++n)yield this.trianglePolygon(n)}trianglePolygon(e){const n=new Tt;return this.renderTriangle(e,n),n.value()}}function Qe(l,e,n,r){const s=l.length,i=new Float64Array(s*2);for(let o=0;o<s;++o){const a=l[o];i[o*2]=e.call(r,a,o,l),i[o*2+1]=n.call(r,a,o,l)}return i}function*Ze(l,e,n,r){let s=0;for(const i of l)yield e.call(r,i,s,l),yield n.call(r,i,s,l),++s}let tn=0;function K(){return tn++}const Et="VoronoiPieceGenerator",en={name:Et,displayName:"Voronoi",description:"Construct pieces by building a Voronoi diagram from the seed points. Each piece consists of all area of the plane closer to its seed point than any other seed point. In practice, this creates irregular polygons with 3-8 sides.",sortHint:1,controls:[]};function nn(l){if(l.length===0)return[0,0,0,0];let e=l[0][0],n=l[0][1],r=e,s=n;for(let i=1;i<l.length;i++){const o=l[i];e=Math.min(e,o[0]),n=Math.min(n,o[1]),r=Math.max(r,o[0]),s=Math.max(s,o[1])}return[e,n,r,s]}function sn(l,e){const n=l.length;for(let r=0;r<n;r++){const s=e.get(l[r]);s.next=l[(r+1)%n],s.prev=l[(r-1+n)%n]}}function nt(l){return`${l[0].toPrecision(7)},${l[1].toPrecision(7)}`}function rn(l,e){return Math.abs(l[0]-e[0])<1e-6&&Math.abs(l[1]-e[1])<1e-6}const on=(l,e,n)=>({generatePieces(s,i){console.log(`VoronoiPieceGenerator using dimensions ${l}x${e}`);const a=At.from(s).voronoi([0,0,l,e]),c={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},h=new Map;for(let u=0;u<s.length;u++){const d=s[u],g=a.cellPolygon(u);if(!g)continue;const p={id:u,site:d,halfEdge:-1,bbox:nn(g)},m=[];for(let x=0;x<g.length-1;x++){const y=g[x],w=g[x+1];if(rn(y,w))continue;const _={id:K(),origin:y,twin:-1,next:-1,prev:-1,piece:u};c.halfEdges.set(_.id,_),m.push(_.id);const M=`${nt(y)}-${nt(w)}`;h.set(M,_.id)}m.length!==0&&(sn(m,c.halfEdges),p.halfEdge=m[0],c.pieces.set(u,p))}for(const u of c.halfEdges.values()){if(u.twin!==-1)continue;const d=c.halfEdges.get(u.next),g=u.origin,p=d.origin,m=`${nt(p)}-${nt(g)}`,x=h.get(m),y=K();let w;if(x!==void 0){const _=c.halfEdges.get(x);u.twin=_.id,_.twin=u.id,w={id:y,heLeft:u.id,heRight:_.id}}else w={id:y,heLeft:u.id,heRight:-1},c.boundary.push(y);c.edges.set(y,w)}const f=new Map;for(const u of c.halfEdges.values()){const d=nt(u.origin);f.has(d)||f.set(d,u.origin)}return c.vertices=Array.from(f.values()),c}});ht.register(Et,on,en);const $t="TraditionalTabGenerator",an={name:$t,displayName:"Traditional",description:"Creates a traditional rounded tab for each (internal) piece edge.",sortHint:1,controls:[{type:"range",name:"size",label:"Tab Size",defaultValue:20,min:1,max:100,step:1,helpText:"Size of each tab as a percent relative to its edge length"},{type:"range",name:"jitter",label:"Randomness",defaultValue:8,min:0,max:100,step:1,helpText:"Adds randomness to the tab shape. 0 means completely uniform tabs"},{type:"number",name:"minTabSize",label:"Minimum Tab Size",defaultValue:20,optional:!0,helpText:"If provided, tabs will not generate on edges shorter than this value"},{type:"number",name:"maxTabSize",label:"Maximum Tab Width",optional:!0,helpText:"If provided, the width of a tab's features will be clamped to this value"}]};function ln(l,e,n,r,s,i=!1,o){const a=e[0]-l[0],c=e[1]-l[1],h=Math.hypot(a,c);if(h===0)throw new Error("Edge has zero length");const f=[a/h,c/h],u=[-f[1],f[0]],d=(S,C)=>[l[0]+(f[0]*S+u[0]*C)*h,l[1]+(f[1]*S+u[1]*C)*h],g=r/100,p=()=>(s()*2-1)*g,m=p(),x=p(),y=p(),w=p(),_=p();let M=n/200;o&&4*M*h>o&&(M=o/(4*h));const b=i?-1:1,P=[[0,0],[.2,m],[.5+x+w,b*(-M+y)],[.5-M+x,b*(M+y)],[.5-2*M+x-w,b*(3*M+y)],[.5+2*M+x-w,b*(3*M+y)],[.5+M+x,b*(M+y)],[.5+x+w,b*(-M+y)],[.8,_],[1,0]].map(([S,C])=>d(S,C)),k={type:"bezier",p1:P[1],p2:P[2],p3:P[3]},z={type:"bezier",p1:P[4],p2:P[5],p3:P[6]},T={type:"bezier",p1:P[7],p2:P[8],p3:P[9]};return[k,z,T]}function cn(l,e){return{type:"bezier",p1:l.p2,p2:l.p1,p3:e}}const hn=(l,e,n)=>{const{size:r=20,jitter:s=8,minTabSize:i,maxTabSize:o}=n;return{addTab(c,h){const{topology:f,random:u}=h,d=f.halfEdges.get(c.heLeft),g=f.halfEdges.get(c.heRight);if(!d||!g)return;const p=d.origin,m=g.origin;if(i&&Math.hypot(m[0]-p[0],m[1]-p[1])<i)return;const x=u()>.5,y=ln(p,m,r,s,u,x,o);if(y.length===0)return;const w=[];for(let _=y.length-1;_>=0;_--){const M=y[_],b=_>0?y[_-1].p3:p;w.push(cn(M,b))}d.segments=y,g.segments=w}}};tt.register($t,hn,an);const{abs:it,cos:j,sin:Q,acos:un,atan2:st,sqrt:V,pow:H}=Math;function rt(l){return l<0?-H(-l,1/3):H(l,1/3)}const ne=Math.PI,gt=2*ne,W=ne/2,fn=1e-6,Dt=Number.MAX_SAFE_INTEGER||9007199254740991,Mt=Number.MIN_SAFE_INTEGER||-9007199254740991,dn={x:0,y:0,z:0},v={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(l,e){const n=e(l);let r=n.x*n.x+n.y*n.y;return typeof n.z<"u"&&(r+=n.z*n.z),V(r)},compute:function(l,e,n){if(l===0)return e[0].t=0,e[0];const r=e.length-1;if(l===1)return e[r].t=1,e[r];const s=1-l;let i=e;if(r===0)return e[0].t=l,e[0];if(r===1){const a={x:s*i[0].x+l*i[1].x,y:s*i[0].y+l*i[1].y,t:l};return n&&(a.z=s*i[0].z+l*i[1].z),a}if(r<4){let a=s*s,c=l*l,h,f,u,d=0;r===2?(i=[i[0],i[1],i[2],dn],h=a,f=s*l*2,u=c):r===3&&(h=a*s,f=a*l*3,u=s*c*3,d=l*c);const g={x:h*i[0].x+f*i[1].x+u*i[2].x+d*i[3].x,y:h*i[0].y+f*i[1].y+u*i[2].y+d*i[3].y,t:l};return n&&(g.z=h*i[0].z+f*i[1].z+u*i[2].z+d*i[3].z),g}const o=JSON.parse(JSON.stringify(e));for(;o.length>1;){for(let a=0;a<o.length-1;a++)o[a]={x:o[a].x+(o[a+1].x-o[a].x)*l,y:o[a].y+(o[a+1].y-o[a].y)*l},typeof o[a].z<"u"&&(o[a].z=o[a].z+(o[a+1].z-o[a].z)*l);o.splice(o.length-1,1)}return o[0].t=l,o[0]},computeWithRatios:function(l,e,n,r){const s=1-l,i=n,o=e;let a=i[0],c=i[1],h=i[2],f=i[3],u;if(a*=s,c*=l,o.length===2)return u=a+c,{x:(a*o[0].x+c*o[1].x)/u,y:(a*o[0].y+c*o[1].y)/u,z:r?(a*o[0].z+c*o[1].z)/u:!1,t:l};if(a*=s,c*=2*s,h*=l*l,o.length===3)return u=a+c+h,{x:(a*o[0].x+c*o[1].x+h*o[2].x)/u,y:(a*o[0].y+c*o[1].y+h*o[2].y)/u,z:r?(a*o[0].z+c*o[1].z+h*o[2].z)/u:!1,t:l};if(a*=s,c*=1.5*s,h*=3*s,f*=l*l*l,o.length===4)return u=a+c+h+f,{x:(a*o[0].x+c*o[1].x+h*o[2].x+f*o[3].x)/u,y:(a*o[0].y+c*o[1].y+h*o[2].y+f*o[3].y)/u,z:r?(a*o[0].z+c*o[1].z+h*o[2].z+f*o[3].z)/u:!1,t:l}},derive:function(l,e){const n=[];for(let r=l,s=r.length,i=s-1;s>1;s--,i--){const o=[];for(let a=0,c;a<i;a++)c={x:i*(r[a+1].x-r[a].x),y:i*(r[a+1].y-r[a].y)},e&&(c.z=i*(r[a+1].z-r[a].z)),o.push(c);n.push(o),r=o}return n},between:function(l,e,n){return e<=l&&l<=n||v.approximately(l,e)||v.approximately(l,n)},approximately:function(l,e,n){return it(l-e)<=(n||fn)},length:function(l){const n=v.Tvalues.length;let r=0;for(let s=0,i;s<n;s++)i=.5*v.Tvalues[s]+.5,r+=v.Cvalues[s]*v.arcfn(i,l);return .5*r},map:function(l,e,n,r,s){const i=n-e,o=s-r,a=l-e,c=a/i;return r+o*c},lerp:function(l,e,n){const r={x:e.x+l*(n.x-e.x),y:e.y+l*(n.y-e.y)};return e.z!==void 0&&n.z!==void 0&&(r.z=e.z+l*(n.z-e.z)),r},pointToString:function(l){let e=l.x+"/"+l.y;return typeof l.z<"u"&&(e+="/"+l.z),e},pointsToString:function(l){return"["+l.map(v.pointToString).join(", ")+"]"},copy:function(l){return JSON.parse(JSON.stringify(l))},angle:function(l,e,n){const r=e.x-l.x,s=e.y-l.y,i=n.x-l.x,o=n.y-l.y,a=r*o-s*i,c=r*i+s*o;return st(a,c)},round:function(l,e){const n=""+l,r=n.indexOf(".");return parseFloat(n.substring(0,r+1+e))},dist:function(l,e){const n=l.x-e.x,r=l.y-e.y;return V(n*n+r*r)},closest:function(l,e){let n=H(2,63),r,s;return l.forEach(function(i,o){s=v.dist(e,i),s<n&&(n=s,r=o)}),{mdist:n,mpos:r}},abcratio:function(l,e){if(e!==2&&e!==3)return!1;if(typeof l>"u")l=.5;else if(l===0||l===1)return l;const n=H(l,e)+H(1-l,e),r=n-1;return it(r/n)},projectionratio:function(l,e){if(e!==2&&e!==3)return!1;if(typeof l>"u")l=.5;else if(l===0||l===1)return l;const n=H(1-l,e),r=H(l,e)+n;return n/r},lli8:function(l,e,n,r,s,i,o,a){const c=(l*r-e*n)*(s-o)-(l-n)*(s*a-i*o),h=(l*r-e*n)*(i-a)-(e-r)*(s*a-i*o),f=(l-n)*(i-a)-(e-r)*(s-o);return f==0?!1:{x:c/f,y:h/f}},lli4:function(l,e,n,r){const s=l.x,i=l.y,o=e.x,a=e.y,c=n.x,h=n.y,f=r.x,u=r.y;return v.lli8(s,i,o,a,c,h,f,u)},lli:function(l,e){return v.lli4(l,l.c,e,e.c)},makeline:function(l,e){return new L(l.x,l.y,(l.x+e.x)/2,(l.y+e.y)/2,e.x,e.y)},findbbox:function(l){let e=Dt,n=Dt,r=Mt,s=Mt;return l.forEach(function(i){const o=i.bbox();e>o.x.min&&(e=o.x.min),n>o.y.min&&(n=o.y.min),r<o.x.max&&(r=o.x.max),s<o.y.max&&(s=o.y.max)}),{x:{min:e,mid:(e+r)/2,max:r,size:r-e},y:{min:n,mid:(n+s)/2,max:s,size:s-n}}},shapeintersections:function(l,e,n,r,s){if(!v.bboxoverlap(e,r))return[];const i=[],o=[l.startcap,l.forward,l.back,l.endcap],a=[n.startcap,n.forward,n.back,n.endcap];return o.forEach(function(c){c.virtual||a.forEach(function(h){if(h.virtual)return;const f=c.intersects(h,s);f.length>0&&(f.c1=c,f.c2=h,f.s1=l,f.s2=n,i.push(f))})}),i},makeshape:function(l,e,n){const r=e.points.length,s=l.points.length,i=v.makeline(e.points[r-1],l.points[0]),o=v.makeline(l.points[s-1],e.points[0]),a={startcap:i,forward:l,back:e,endcap:o,bbox:v.findbbox([i,l,e,o])};return a.intersections=function(c){return v.shapeintersections(a,a.bbox,c,c.bbox,n)},a},getminmax:function(l,e,n){if(!n)return{min:0,max:0};let r=Dt,s=Mt,i,o;n.indexOf(0)===-1&&(n=[0].concat(n)),n.indexOf(1)===-1&&n.push(1);for(let a=0,c=n.length;a<c;a++)i=n[a],o=l.get(i),o[e]<r&&(r=o[e]),o[e]>s&&(s=o[e]);return{min:r,mid:(r+s)/2,max:s,size:s-r}},align:function(l,e){const n=e.p1.x,r=e.p1.y,s=-st(e.p2.y-r,e.p2.x-n),i=function(o){return{x:(o.x-n)*j(s)-(o.y-r)*Q(s),y:(o.x-n)*Q(s)+(o.y-r)*j(s)}};return l.map(i)},roots:function(l,e){e=e||{p1:{x:0,y:0},p2:{x:1,y:0}};const n=l.length-1,r=v.align(l,e),s=function(P){return 0<=P&&P<=1};if(n===2){const P=r[0].y,k=r[1].y,z=r[2].y,T=P-2*k+z;if(T!==0){const S=-V(k*k-P*z),C=-P+k,A=-(S+C)/T,$=-(-S+C)/T;return[A,$].filter(s)}else if(k!==z&&T===0)return[(2*k-z)/(2*k-2*z)].filter(s);return[]}const i=r[0].y,o=r[1].y,a=r[2].y,c=r[3].y;let h=-i+3*o-3*a+c,f=3*i-6*o+3*a,u=-3*i+3*o,d=i;if(v.approximately(h,0)){if(v.approximately(f,0))return v.approximately(u,0)?[]:[-d/u].filter(s);const P=V(u*u-4*f*d),k=2*f;return[(P-u)/k,(-u-P)/k].filter(s)}f/=h,u/=h,d/=h;const g=(3*u-f*f)/3,p=g/3,m=(2*f*f*f-9*f*u+27*d)/27,x=m/2,y=x*x+p*p*p;let w,_,M,b,I;if(y<0){const P=-g/3,k=P*P*P,z=V(k),T=-m/(2*z),S=T<-1?-1:T>1?1:T,C=un(S),A=rt(z),$=2*A;return M=$*j(C/3)-f/3,b=$*j((C+gt)/3)-f/3,I=$*j((C+2*gt)/3)-f/3,[M,b,I].filter(s)}else{if(y===0)return w=x<0?rt(-x):-rt(x),M=2*w-f/3,b=-w-f/3,[M,b].filter(s);{const P=V(y);return w=rt(-x+P),_=rt(x+P),[w-_-f/3].filter(s)}}},droots:function(l){if(l.length===3){const e=l[0],n=l[1],r=l[2],s=e-2*n+r;if(s!==0){const i=-V(n*n-e*r),o=-e+n,a=-(i+o)/s,c=-(-i+o)/s;return[a,c]}else if(n!==r&&s===0)return[(2*n-r)/(2*(n-r))];return[]}if(l.length===2){const e=l[0],n=l[1];return e!==n?[e/(e-n)]:[]}return[]},curvature:function(l,e,n,r,s){let i,o,a,c,h=0,f=0;const u=v.compute(l,e),d=v.compute(l,n),g=u.x*u.x+u.y*u.y;if(r?(i=V(H(u.y*d.z-d.y*u.z,2)+H(u.z*d.x-d.z*u.x,2)+H(u.x*d.y-d.x*u.y,2)),o=H(g+u.z*u.z,3/2)):(i=u.x*d.y-u.y*d.x,o=H(g,3/2)),i===0||o===0)return{k:0,r:0};if(h=i/o,f=o/i,!s){const p=v.curvature(l-.001,e,n,r,!0).k,m=v.curvature(l+.001,e,n,r,!0).k;c=(m-h+(h-p))/2,a=(it(m-h)+it(h-p))/2}return{k:h,r:f,dk:c,adk:a}},inflections:function(l){if(l.length<4)return[];const e=v.align(l,{p1:l[0],p2:l.slice(-1)[0]}),n=e[2].x*e[1].y,r=e[3].x*e[1].y,s=e[1].x*e[2].y,i=e[3].x*e[2].y,o=18*(-3*n+2*r+3*s-i),a=18*(3*n-r-3*s),c=18*(s-n);if(v.approximately(o,0)){if(!v.approximately(a,0)){let d=-c/a;if(0<=d&&d<=1)return[d]}return[]}const h=2*o;if(v.approximately(h,0))return[];const f=a*a-4*o*c;if(f<0)return[];const u=Math.sqrt(f);return[(u-a)/h,-(a+u)/h].filter(function(d){return 0<=d&&d<=1})},bboxoverlap:function(l,e){const n=["x","y"],r=n.length;for(let s=0,i,o,a,c;s<r;s++)if(i=n[s],o=l[i].mid,a=e[i].mid,c=(l[i].size+e[i].size)/2,it(o-a)>=c)return!1;return!0},expandbox:function(l,e){e.x.min<l.x.min&&(l.x.min=e.x.min),e.y.min<l.y.min&&(l.y.min=e.y.min),e.z&&e.z.min<l.z.min&&(l.z.min=e.z.min),e.x.max>l.x.max&&(l.x.max=e.x.max),e.y.max>l.y.max&&(l.y.max=e.y.max),e.z&&e.z.max>l.z.max&&(l.z.max=e.z.max),l.x.mid=(l.x.min+l.x.max)/2,l.y.mid=(l.y.min+l.y.max)/2,l.z&&(l.z.mid=(l.z.min+l.z.max)/2),l.x.size=l.x.max-l.x.min,l.y.size=l.y.max-l.y.min,l.z&&(l.z.size=l.z.max-l.z.min)},pairiteration:function(l,e,n){const r=l.bbox(),s=e.bbox(),i=1e5,o=n||.5;if(r.x.size+r.y.size<o&&s.x.size+s.y.size<o)return[(i*(l._t1+l._t2)/2|0)/i+"/"+(i*(e._t1+e._t2)/2|0)/i];let a=l.split(.5),c=e.split(.5),h=[{left:a.left,right:c.left},{left:a.left,right:c.right},{left:a.right,right:c.right},{left:a.right,right:c.left}];h=h.filter(function(u){return v.bboxoverlap(u.left.bbox(),u.right.bbox())});let f=[];return h.length===0||(h.forEach(function(u){f=f.concat(v.pairiteration(u.left,u.right,o))}),f=f.filter(function(u,d){return f.indexOf(u)===d})),f},getccenter:function(l,e,n){const r=e.x-l.x,s=e.y-l.y,i=n.x-e.x,o=n.y-e.y,a=r*j(W)-s*Q(W),c=r*Q(W)+s*j(W),h=i*j(W)-o*Q(W),f=i*Q(W)+o*j(W),u=(l.x+e.x)/2,d=(l.y+e.y)/2,g=(e.x+n.x)/2,p=(e.y+n.y)/2,m=u+a,x=d+c,y=g+h,w=p+f,_=v.lli8(u,d,m,x,g,p,y,w),M=v.dist(_,l);let b=st(l.y-_.y,l.x-_.x),I=st(e.y-_.y,e.x-_.x),P=st(n.y-_.y,n.x-_.x),k;return b<P?((b>I||I>P)&&(b+=gt),b>P&&(k=P,P=b,b=k)):P<I&&I<b?(k=P,P=b,b=k):P+=gt,_.s=b,_.e=P,_.r=M,_},numberSort:function(l,e){return l-e}};class lt{constructor(e){this.curves=[],this._3d=!1,e&&(this.curves=e,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(e){return v.pointsToString(e.points)}).join(", ")+"]"}addCurve(e){this.curves.push(e),this._3d=this._3d||e._3d}length(){return this.curves.map(function(e){return e.length()}).reduce(function(e,n){return e+n})}curve(e){return this.curves[e]}bbox(){const e=this.curves;for(var n=e[0].bbox(),r=1;r<e.length;r++)v.expandbox(n,e[r].bbox());return n}offset(e){const n=[];return this.curves.forEach(function(r){n.push(...r.offset(e))}),new lt(n)}}const{abs:ot,min:Yt,max:Jt,cos:gn,sin:pn,acos:mn,sqrt:at}=Math,yn=Math.PI;class L{constructor(e){let n=e&&e.forEach?e:Array.from(arguments).slice(),r=!1;if(typeof n[0]=="object"){r=n.length;const g=[];n.forEach(function(p){["x","y","z"].forEach(function(m){typeof p[m]<"u"&&g.push(p[m])})}),n=g}let s=!1;const i=n.length;if(r){if(r>4){if(arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");s=!0}}else if(i!==6&&i!==8&&i!==9&&i!==12&&arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const o=this._3d=!s&&(i===9||i===12)||e&&e[0]&&typeof e[0].z<"u",a=this.points=[];for(let g=0,p=o?3:2;g<i;g+=p){var c={x:n[g],y:n[g+1]};o&&(c.z=n[g+2]),a.push(c)}const h=this.order=a.length-1,f=this.dims=["x","y"];o&&f.push("z"),this.dimlen=f.length;const u=v.align(a,{p1:a[0],p2:a[h]}),d=v.dist(a[0],a[h]);this._linear=u.reduce((g,p)=>g+ot(p.y),0)<d/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(e,n,r,s){if(typeof s>"u"&&(s=.5),s===0)return new L(n,n,r);if(s===1)return new L(e,n,n);const i=L.getABC(2,e,n,r,s);return new L(e,i.A,r)}static cubicFromPoints(e,n,r,s,i){typeof s>"u"&&(s=.5);const o=L.getABC(3,e,n,r,s);typeof i>"u"&&(i=v.dist(n,o.C));const a=i*(1-s)/s,c=v.dist(e,r),h=(r.x-e.x)/c,f=(r.y-e.y)/c,u=i*h,d=i*f,g=a*h,p=a*f,m={x:n.x-u,y:n.y-d},x={x:n.x+g,y:n.y+p},y=o.A,w={x:y.x+(m.x-y.x)/(1-s),y:y.y+(m.y-y.y)/(1-s)},_={x:y.x+(x.x-y.x)/s,y:y.y+(x.y-y.y)/s},M={x:e.x+(w.x-e.x)/s,y:e.y+(w.y-e.y)/s},b={x:r.x+(_.x-r.x)/(1-s),y:r.y+(_.y-r.y)/(1-s)};return new L(e,M,b,r)}static getUtils(){return v}getUtils(){return L.getUtils()}static get PolyBezier(){return lt}valueOf(){return this.toString()}toString(){return v.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const e=this.points,n=e[0].x,r=e[0].y,s=["M",n,r,this.order===2?"Q":"C"];for(let i=1,o=e.length;i<o;i++)s.push(e[i].x),s.push(e[i].y);return s.join(" ")}setRatios(e){if(e.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=e,this._lut=[]}verify(){const e=this.coordDigest();e!==this._print&&(this._print=e,this.update())}coordDigest(){return this.points.map(function(e,n){return""+n+e.x+e.y+(e.z?e.z:0)}).join("")}update(){this._lut=[],this.dpoints=v.derive(this.points,this._3d),this.computedirection()}computedirection(){const e=this.points,n=v.angle(e[0],e[this.order],e[1]);this.clockwise=n>0}length(){return v.length(this.derivative.bind(this))}static getABC(e=2,n,r,s,i=.5){const o=v.projectionratio(i,e),a=1-o,c={x:o*n.x+a*s.x,y:o*n.y+a*s.y},h=v.abcratio(i,e);return{A:{x:r.x+(r.x-c.x)/h,y:r.y+(r.y-c.y)/h},B:r,C:c,S:n,E:s}}getABC(e,n){n=n||this.get(e);let r=this.points[0],s=this.points[this.order];return L.getABC(this.order,r,n,s,e)}getLUT(e){if(this.verify(),e=e||100,this._lut.length===e+1)return this._lut;this._lut=[],e++,this._lut=[];for(let n=0,r,s;n<e;n++)s=n/(e-1),r=this.compute(s),r.t=s,this._lut.push(r);return this._lut}on(e,n){n=n||5;const r=this.getLUT(),s=[];for(let i=0,o,a=0;i<r.length;i++)o=r[i],v.dist(o,e)<n&&(s.push(o),a+=i/r.length);return s.length?t/=s.length:!1}project(e){const n=this.getLUT(),r=n.length-1,s=v.closest(n,e),i=s.mpos,o=(i-1)/r,a=(i+1)/r,c=.1/r;let h=s.mdist,f=o,u=f,d;h+=1;for(let g;f<a+c;f+=c)d=this.compute(f),g=v.dist(e,d),g<h&&(h=g,u=f);return u=u<0?0:u>1?1:u,d=this.compute(u),d.t=u,d.d=h,d}get(e){return this.compute(e)}point(e){return this.points[e]}compute(e){return this.ratios?v.computeWithRatios(e,this.points,this.ratios,this._3d):v.compute(e,this.points,this._3d,this.ratios)}raise(){const e=this.points,n=[e[0]],r=e.length;for(let s=1,i,o;s<r;s++)i=e[s],o=e[s-1],n[s]={x:(r-s)/r*i.x+s/r*o.x,y:(r-s)/r*i.y+s/r*o.y};return n[r]=e[r-1],new L(n)}derivative(e){return v.compute(e,this.dpoints[0],this._3d)}dderivative(e){return v.compute(e,this.dpoints[1],this._3d)}align(){let e=this.points;return new L(v.align(e,{p1:e[0],p2:e[e.length-1]}))}curvature(e){return v.curvature(e,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return v.inflections(this.points)}normal(e){return this._3d?this.__normal3(e):this.__normal2(e)}__normal2(e){const n=this.derivative(e),r=at(n.x*n.x+n.y*n.y);return{t:e,x:-n.y/r,y:n.x/r}}__normal3(e){const n=this.derivative(e),r=this.derivative(e+.01),s=at(n.x*n.x+n.y*n.y+n.z*n.z),i=at(r.x*r.x+r.y*r.y+r.z*r.z);n.x/=s,n.y/=s,n.z/=s,r.x/=i,r.y/=i,r.z/=i;const o={x:r.y*n.z-r.z*n.y,y:r.z*n.x-r.x*n.z,z:r.x*n.y-r.y*n.x},a=at(o.x*o.x+o.y*o.y+o.z*o.z);o.x/=a,o.y/=a,o.z/=a;const c=[o.x*o.x,o.x*o.y-o.z,o.x*o.z+o.y,o.x*o.y+o.z,o.y*o.y,o.y*o.z-o.x,o.x*o.z-o.y,o.y*o.z+o.x,o.z*o.z];return{t:e,x:c[0]*n.x+c[1]*n.y+c[2]*n.z,y:c[3]*n.x+c[4]*n.y+c[5]*n.z,z:c[6]*n.x+c[7]*n.y+c[8]*n.z}}hull(e){let n=this.points,r=[],s=[],i=0;for(s[i++]=n[0],s[i++]=n[1],s[i++]=n[2],this.order===3&&(s[i++]=n[3]);n.length>1;){r=[];for(let o=0,a,c=n.length-1;o<c;o++)a=v.lerp(e,n[o],n[o+1]),s[i++]=a,r.push(a);n=r}return s}split(e,n){if(e===0&&n)return this.split(n).left;if(n===1)return this.split(e).right;const r=this.hull(e),s={left:this.order===2?new L([r[0],r[3],r[5]]):new L([r[0],r[4],r[7],r[9]]),right:this.order===2?new L([r[5],r[4],r[2]]):new L([r[9],r[8],r[6],r[3]]),span:r};return s.left._t1=v.map(0,0,1,this._t1,this._t2),s.left._t2=v.map(e,0,1,this._t1,this._t2),s.right._t1=v.map(e,0,1,this._t1,this._t2),s.right._t2=v.map(1,0,1,this._t1,this._t2),n?(n=v.map(n,e,1,0,1),s.right.split(n).left):s}extrema(){const e={};let n=[];return this.dims.forEach((function(r){let s=function(o){return o[r]},i=this.dpoints[0].map(s);e[r]=v.droots(i),this.order===3&&(i=this.dpoints[1].map(s),e[r]=e[r].concat(v.droots(i))),e[r]=e[r].filter(function(o){return o>=0&&o<=1}),n=n.concat(e[r].sort(v.numberSort))}).bind(this)),e.values=n.sort(v.numberSort).filter(function(r,s){return n.indexOf(r)===s}),e}bbox(){const e=this.extrema(),n={};return this.dims.forEach((function(r){n[r]=v.getminmax(this,r,e[r])}).bind(this)),n}overlaps(e){const n=this.bbox(),r=e.bbox();return v.bboxoverlap(n,r)}offset(e,n){if(typeof n<"u"){const r=this.get(e),s=this.normal(e),i={c:r,n:s,x:r.x+s.x*n,y:r.y+s.y*n};return this._3d&&(i.z=r.z+s.z*n),i}if(this._linear){const r=this.normal(0),s=this.points.map(function(i){const o={x:i.x+e*r.x,y:i.y+e*r.y};return i.z&&r.z&&(o.z=i.z+e*r.z),o});return[new L(s)]}return this.reduce().map(function(r){return r._linear?r.offset(e)[0]:r.scale(e)})}simple(){if(this.order===3){const s=v.angle(this.points[0],this.points[3],this.points[1]),i=v.angle(this.points[0],this.points[3],this.points[2]);if(s>0&&i<0||s<0&&i>0)return!1}const e=this.normal(0),n=this.normal(1);let r=e.x*n.x+e.y*n.y;return this._3d&&(r+=e.z*n.z),ot(mn(r))<yn/3}reduce(){let e,n=0,r=0,s=.01,i,o=[],a=[],c=this.extrema().values;for(c.indexOf(0)===-1&&(c=[0].concat(c)),c.indexOf(1)===-1&&c.push(1),n=c[0],e=1;e<c.length;e++)r=c[e],i=this.split(n,r),i._t1=n,i._t2=r,o.push(i),n=r;return o.forEach(function(h){for(n=0,r=0;r<=1;)for(r=n+s;r<=1+s;r+=s)if(i=h.split(n,r),!i.simple()){if(r-=s,ot(n-r)<s)return[];i=h.split(n,r),i._t1=v.map(n,0,1,h._t1,h._t2),i._t2=v.map(r,0,1,h._t1,h._t2),a.push(i),n=r;break}n<1&&(i=h.split(n,1),i._t1=v.map(n,0,1,h._t1,h._t2),i._t2=h._t2,a.push(i))}),a}translate(e,n,r){r=typeof r=="number"?r:n;const s=this.order;let i=this.points.map((o,a)=>(1-a/s)*n+a/s*r);return new L(this.points.map((o,a)=>({x:o.x+e.x*i[a],y:o.y+e.y*i[a]})))}scale(e){const n=this.order;let r=!1;if(typeof e=="function"&&(r=e),r&&n===2)return this.raise().scale(r);const s=this.clockwise,i=this.points;if(this._linear)return this.translate(this.normal(0),r?r(0):e,r?r(1):e);const o=r?r(0):e,a=r?r(1):e,c=[this.offset(0,10),this.offset(1,10)],h=[],f=v.lli4(c[0],c[0].c,c[1],c[1].c);if(!f)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach(function(u){const d=h[u*n]=v.copy(i[u*n]);d.x+=(u?a:o)*c[u].n.x,d.y+=(u?a:o)*c[u].n.y}),r?([0,1].forEach(function(u){if(!(n===2&&u)){var d=i[u+1],g={x:d.x-f.x,y:d.y-f.y},p=r?r((u+1)/n):e;r&&!s&&(p=-p);var m=at(g.x*g.x+g.y*g.y);g.x/=m,g.y/=m,h[u+1]={x:d.x+p*g.x,y:d.y+p*g.y}}}),new L(h)):([0,1].forEach(u=>{if(n===2&&u)return;const d=h[u*n],g=this.derivative(u),p={x:d.x+g.x,y:d.y+g.y};h[u+1]=v.lli4(d,p,f,i[u+1])}),new L(h))}outline(e,n,r,s){if(n=n===void 0?e:n,this._linear){const b=this.normal(0),I=this.points[0],P=this.points[this.points.length-1];let k,z,T;r===void 0&&(r=e,s=n),k={x:I.x+b.x*e,y:I.y+b.y*e},T={x:P.x+b.x*r,y:P.y+b.y*r},z={x:(k.x+T.x)/2,y:(k.y+T.y)/2};const S=[k,z,T];k={x:I.x-b.x*n,y:I.y-b.y*n},T={x:P.x-b.x*s,y:P.y-b.y*s},z={x:(k.x+T.x)/2,y:(k.y+T.y)/2};const C=[T,z,k],A=v.makeline(C[2],S[0]),$=v.makeline(S[2],C[0]),R=[A,new L(S),$,new L(C)];return new lt(R)}const i=this.reduce(),o=i.length,a=[];let c=[],h,f=0,u=this.length();const d=typeof r<"u"&&typeof s<"u";function g(b,I,P,k,z){return function(T){const S=k/P,C=(k+z)/P,A=I-b;return v.map(T,0,1,b+S*A,b+C*A)}}i.forEach(function(b){const I=b.length();d?(a.push(b.scale(g(e,r,u,f,I))),c.push(b.scale(g(-n,-s,u,f,I)))):(a.push(b.scale(e)),c.push(b.scale(-n))),f+=I}),c=c.map(function(b){return h=b.points,h[3]?b.points=[h[3],h[2],h[1],h[0]]:b.points=[h[2],h[1],h[0]],b}).reverse();const p=a[0].points[0],m=a[o-1].points[a[o-1].points.length-1],x=c[o-1].points[c[o-1].points.length-1],y=c[0].points[0],w=v.makeline(x,p),_=v.makeline(m,y),M=[w].concat(a).concat([_]).concat(c);return new lt(M)}outlineshapes(e,n,r){n=n||e;const s=this.outline(e,n).curves,i=[];for(let o=1,a=s.length;o<a/2;o++){const c=v.makeshape(s[o],s[a-o],r);c.startcap.virtual=o>1,c.endcap.virtual=o<a/2-1,i.push(c)}return i}intersects(e,n){return e?e.p1&&e.p2?this.lineIntersects(e):(e instanceof L&&(e=e.reduce()),this.curveintersects(this.reduce(),e,n)):this.selfintersects(n)}lineIntersects(e){const n=Yt(e.p1.x,e.p2.x),r=Yt(e.p1.y,e.p2.y),s=Jt(e.p1.x,e.p2.x),i=Jt(e.p1.y,e.p2.y);return v.roots(this.points,e).filter(o=>{var a=this.get(o);return v.between(a.x,n,s)&&v.between(a.y,r,i)})}selfintersects(e){const n=this.reduce(),r=n.length-2,s=[];for(let i=0,o,a,c;i<r;i++)a=n.slice(i,i+1),c=n.slice(i+2),o=this.curveintersects(a,c,e),s.push(...o);return s}curveintersects(e,n,r){const s=[];e.forEach(function(o){n.forEach(function(a){o.overlaps(a)&&s.push({left:o,right:a})})});let i=[];return s.forEach(function(o){const a=v.pairiteration(o.left,o.right,r);a.length>0&&(i=i.concat(a))}),i}arcs(e){return e=e||.5,this._iterate(e,[])}_error(e,n,r,s){const i=(s-r)/4,o=this.get(r+i),a=this.get(s-i),c=v.dist(e,n),h=v.dist(e,o),f=v.dist(e,a);return ot(h-c)+ot(f-c)}_iterate(e,n){let r=0,s=1,i;do{i=0,s=1;let o=this.get(r),a,c,h,f,u=!1,d=!1,g,p=s,m=1;do if(d=u,f=h,p=(r+s)/2,a=this.get(p),c=this.get(s),h=v.getccenter(o,a,c),h.interval={start:r,end:s},u=this._error(h,o,r,s)<=e,g=d&&!u,g||(m=s),u){if(s>=1){if(h.interval.end=m=1,f=h,s>1){let y={x:h.x+h.r*gn(h.e),y:h.y+h.r*pn(h.e)};h.e+=v.angle({x:h.x,y:h.y},y,this.get(1))}break}s=s+(s-r)/2}else s=p;while(!g&&i++<100);if(i>=100)break;f=f||h,n.push(f),r=m}while(s<1);return n}}function Qt(l,e){const n=[e];l.type==="line"?n.push(l.p):n.push(l.p1,l.p2,l.p3);const r=n.map(i=>i[0]),s=n.map(i=>i[1]);return[Math.min(...r),Math.min(...s),Math.max(...r),Math.max(...s)]}function ie(l,e){const n=l[0]-e[0],r=l[1]-e[1];return n*n+r*r}function xn(l){return l.segment.type==="line"?l.segment.p:l.segment.p3}function kt(l){if(l.segment.type!=="bezier")throw new Error("Boundary segment is not a Bezier curve");const{startPoint:e}=l,{p1:n,p2:r,p3:s}=l.segment;return new L({x:e[0],y:e[1]},{x:n[0],y:n[1]},{x:r[0],y:r[1]},{x:s[0],y:s[1]})}function bn(l,e){const n=[],r=l.halfEdge;let s=r;do{const i=e.halfEdges.get(s);if(!i){console.error(`Could not find half-edge with ID: ${s}`);break}let o=i.origin;if(i.segments&&i.segments.length>0)for(const a of i.segments)n.push({segment:a,startPoint:o,bbox:Qt(a,o)}),o=a.type==="line"?a.p:a.p3;else{const a=e.halfEdges.get(i.next);if(!a){console.error(`Could not find next half-edge for ID: ${i.next}`);continue}const c={type:"line",p:a.origin};n.push({segment:c,startPoint:o,bbox:Qt(c,o)})}s=i.next}while(s!==r);return n}function vn(l,e){return!(l[2]<e[0]||l[0]>e[2]||l[3]<e[1]||l[1]>e[3])}function wn(l,e,n){return new Promise(r=>{const s=[],i=l.segment.type,o=e.segment.type;if(i==="bezier"&&o==="bezier"){const a=kt(l),c=kt(e);a.intersects(c).forEach(f=>{const u=f.split("/"),d=parseFloat(u[0]),g=parseFloat(u[1]);if(n&&(d>.99&&g<.01||d<.01&&g>.99))return;const p=a.get(d);s.push([p.x,p.y])})}else if(i==="bezier"||o==="bezier"){const a=i==="bezier"?l:e,c=i==="line"?l:e,h=kt(a),f={p1:{x:c.startPoint[0],y:c.startPoint[1]},p2:{x:c.segment.p[0],y:c.segment.p[1]}};h.intersects(f).forEach(d=>{const g=h.get(d);s.push([g.x,g.y])})}else{const a=l.startPoint,c=l.segment.p,h=e.startPoint,f=e.segment.p,[u,d]=a,[g,p]=c,[m,x]=h,[y,w]=f,_=(u-g)*(x-w)-(d-p)*(m-y);if(_!==0){const M=((u-m)*(x-w)-(d-x)*(m-y))/_,b=-((u-g)*(d-x)-(d-p)*(u-m))/_;if(M>=0&&M<=1&&b>=0&&b<=1){const I=u+M*(g-u),P=d+M*(p-d);s.push([I,P])}}}r(s)})}async function _n(l,e){const n=[],i=Array.from(l.pieces.values()).length;let o=0;for(const a of l.pieces.values()){e?.(o,i);const c=bn(a,l),h=c.length;if(h<2){o++;continue}for(let f=0;f<h;f++)for(let u=f+1;u<h;u++){const d=c[f],g=c[u];if(!vn(d.bbox,g.bbox))continue;const p=u===f+1||f===0&&u===h-1,m=await wn(d,g,p);if(m.length!==0)if(p){const x=f===0&&u===h-1?d.startPoint:xn(d);for(const y of m)ie(y,x)>1e-8&&n.push(y)}else n.push(...m)}o++}return e?.(i,i),console.log(`detected ${n.length} intersections in ${l.pieces.size} pieces`),n}async function Pn(l,e){const n=await _n(l,e);if(n.length<2)return n;const r=1,s=[n[0]];for(let i=1;i<n.length;i++){const o=n[i],a=s[s.length-1];ie(o,a)>r*r&&s.push(o)}return s}const se="GridJitterPointGenerator",zn={name:se,displayName:"Grid",description:"Generate seed points using a grid with optional random jitter. Has a uniform, regular look, especially with low randomness values.",sortHint:2,controls:[{type:"range",name:"jitter",label:"Randomness",min:0,max:100,step:5,defaultValue:50,helpText:"Amount of jitter to apply to each grid point (0 to 100%)"}]},Dn=(l,e,n)=>{const{jitter:r=50}=n;return{generatePoints(i){const{width:o,height:a,pieceSize:c,random:h}=i,f=[];for(let u=0;u<o;u+=c)for(let d=0;d<a;d+=c){const g=[u+c/2,d+c/2];r>0&&(g[0]+=(h()-.5)*(r/100)*c,g[1]+=(h()-.5)*(r/100)*c),f.push(g)}return f}}};ct.register(se,Dn,zn);const re="RectangularPieceGenerator",Mn={name:re,displayName:"Rectangular",description:"Construct pieces from a regular grid. All pieces have 4 sides and are the same size. This generator ignores seed points.",sortHint:2,controls:[]},kn=(l,e,n)=>({generatePieces(s,i){const{pieceSize:o}=i,a={vertices:[],pieces:new Map,edges:new Map,halfEdges:new Map,boundary:[]},c=Math.ceil(l/o),h=Math.ceil(e/o),f=Math.round(l/c),u=Math.round(e/h),d=[];for(let p=0;p<=h;p++){const m=[];for(let x=0;x<=c;x++){const y=x*f,w=p*u;m.push([y,w])}d.push(m)}a.vertices=d.flat();const g=new Map;for(let p=0;p<h;p++)for(let m=0;m<c;m++){const x=p*c+m,y=d[p][m],w=d[p][m+1],_=d[p+1][m],M=d[p+1][m+1],b={id:K(),origin:y,twin:-1,next:-1,prev:-1,piece:x},I={id:K(),origin:w,twin:-1,next:-1,prev:-1,piece:x},P={id:K(),origin:M,twin:-1,next:-1,prev:-1,piece:x},k={id:K(),origin:_,twin:-1,next:-1,prev:-1,piece:x};b.next=I.id,I.next=P.id,P.next=k.id,k.next=b.id,b.prev=k.id,k.prev=P.id,P.prev=I.id,I.prev=b.id,a.halfEdges.set(b.id,b),a.halfEdges.set(I.id,I),a.halfEdges.set(P.id,P),a.halfEdges.set(k.id,k);const z={id:x,site:[(y[0]+M[0])/2,(y[1]+M[1])/2],halfEdge:b.id,bbox:[y[0],y[1],M[0],M[1]]};a.pieces.set(x,z);const T=(C,A)=>`${C[0]},${C[1]}-${A[0]},${A[1]}`,S=[{he:b,p1:y,p2:w,isBoundary:p===0},{he:I,p1:w,p2:M,isBoundary:m===c-1},{he:P,p1:M,p2:_,isBoundary:p===h-1},{he:k,p1:_,p2:y,isBoundary:m===0}];for(const C of S){const A=T(C.p2,C.p1),$=g.get(A),R=K();let E;if($!==void 0){const G=a.halfEdges.get($);C.he.twin=G.id,G.twin=C.he.id,E={id:R,heLeft:G.id,heRight:C.he.id},g.delete(A)}else{const G=T(C.p1,C.p2);if(g.set(G,C.he.id),C.isBoundary)E={id:R,heLeft:C.he.id,heRight:-1},a.boundary.push(R);else continue}a.edges.set(R,E)}}return a}});ht.register(re,kn,Mn);const oe="NullTabGenerator",Cn={name:oe,displayName:"None",description:"Do not generate tabs. All pieces have straight edges.",sortHint:3,controls:[]},Tn=(l,e,n)=>({addTab(s,i){}});tt.register(oe,Tn,Cn);const ae="TriangleTabGenerator",Sn={name:ae,displayName:"Triangle",description:"Creates a simple triangle between each (internal) piece edge.",sortHint:2,controls:[{type:"range",name:"tabHeightRatio",label:"Tab Height",optional:!0,min:0,max:100,step:1,defaultValue:20,helpText:'Determines how "tall" the tab is relative to the length of the edge as a percent'}]},In=(l,e,n)=>{const{tabHeightRatio:r=20}=n;return{addTab(i,o){const{topology:a,random:c}=o,h=a.halfEdges.get(i.heLeft),f=a.halfEdges.get(i.heRight);if(!h||!f){console.warn("Could not find half-edges for a given internal edge:",i.id);return}const u=h.origin,d=f.origin,g=[d[0]-u[0],d[1]-u[1]],p=Math.sqrt(g[0]**2+g[1]**2);if(p<1e-6)return;const m=[g[0]/p,g[1]/p],x=[-m[1],m[0]],y=[u[0]+g[0]/2,u[1]+g[1]/2],w=c()>.5?1:-1,_=p*(r/100)*w,M=[y[0]+x[0]*_,y[1]+x[1]*_],b={type:"bezier",p1:M,p2:M,p3:d},I=[y[0]-x[0]*_,y[1]-x[1]*_],P={type:"bezier",p1:I,p2:I,p3:u};h.segments=[b],f.segments=[P]}}};tt.register(ae,In,Sn);const An=()=>{const n=It,r=Et,s=$t,i={seed:new Date().getTime()%10240,canvasWidth:800,canvasHeight:600,aspectRatio:800/600,distance:40,color:"#333333",geometryProblems:{autoCheck:!1,problems:void 0,progress:void 0},dirty:!0,generators:{point:{label:"Seed Points",registry:ct,name:n,config:ct.getDefaultConfig(n,800,600)},piece:{label:"Piece Generation",registry:ht,name:r,config:ht.getDefaultConfig(r,800,600)},tab:{label:"Tabs",registry:tt,name:s,config:tt.getDefaultConfig(s,800,600)}},puzzle:void 0,backgroundImageUrl:void 0,backgroundImageName:""};function o(){i.puzzle&&(i.geometryProblems.progress=0,D.redraw(),setTimeout(()=>{i.puzzle&&Pn(i.puzzle,(a,c)=>{i.geometryProblems.progress=a/c*100,D.redraw()}).then(a=>{i.geometryProblems.problems=a.length,i.geometryProblems.progress=void 0,i.puzzle&&(i.puzzle.problems=a),D.redraw()}).catch(a=>{i.geometryProblems.progress=void 0,console.error(a),D.redraw()})},100))}return{oncreate:()=>{Gt({width:i.canvasWidth,height:i.canvasHeight,pieceSize:i.distance,pointConfig:i.generators.point.config,pieceConfig:i.generators.piece.config,tabConfig:i.generators.tab.config,seed:i.seed}).then(a=>{i.puzzle=a,D.redraw(),i.geometryProblems.autoCheck&&o()}).catch(a=>{console.error(a)})},onupdate:()=>{i.dirty&&(i.dirty=!1,Gt({width:i.canvasWidth,height:i.canvasHeight,pieceSize:i.distance,pointConfig:i.generators.point.config,pieceConfig:i.generators.piece.config,tabConfig:i.generators.tab.config,seed:i.seed}).then(a=>{i.geometryProblems.problems=void 0,i.geometryProblems.progress=void 0,i.puzzle=a,D.redraw(),i.geometryProblems.autoCheck&&o()}).catch(a=>{console.error(a)}))},onremove:()=>{i.backgroundImageUrl&&(URL.revokeObjectURL(i.backgroundImageUrl),i.backgroundImageUrl=void 0)},view:()=>D(".page",[D(ue,{link:"https://github.com/weevilgenius/puzzle-generator"}),D("h1","Puzzle Generator"),D(".container",[i.puzzle&&D(".puzzle-stack",[D(de,{width:i.canvasWidth,height:i.canvasHeight,color:i.color,imageUrl:i.backgroundImageUrl,puzzle:i.puzzle,isDirty:i.dirty}),D(".actions",[D(me,{puzzle:i.puzzle,width:i.canvasWidth,height:i.canvasHeight,color:i.color}),D(ye,{autoCheck:i.geometryProblems.autoCheck,problems:i.geometryProblems.problems,progressPercent:i.geometryProblems.progress,onCheckRequested:()=>{i.dirty||o(),D.redraw()},onAutocheckChanged:a=>{a!==i.geometryProblems.autoCheck&&(i.geometryProblems.autoCheck=a,D.redraw())}})])]),D(".controls",[D(".background-image",[D(be,{label:"Background Image",onUpload:(a,c,h,f)=>{i.backgroundImageUrl&&URL.revokeObjectURL(i.backgroundImageUrl),i.canvasWidth=h,i.canvasHeight=f,i.aspectRatio=h/f,i.backgroundImageUrl=a,i.backgroundImageName=c,i.dirty=!0,D.redraw()}}),D("span.background-image-label",i.backgroundImageName)]),D(ze,{ratio:i.aspectRatio,disabled:i.backgroundImageUrl!==void 0,onChange:a=>{i.aspectRatio=a,i.canvasWidth=i.canvasHeight*a,i.dirty=!0,D.redraw()}}),D(Ct,{config:{name:"seed",label:"Seed",type:"number"},value:i.seed,onChange:a=>{i.seed=a??0,i.dirty=!0,D.redraw()}}),D(Ct,{config:{name:"pieceSize",label:"Piece size",type:"number"},value:i.distance,onChange:a=>{i.distance=a??0,i.dirty=!0,D.redraw()}}),D(De,{label:"Piece color",color:i.color,size:"small",onUpdate:a=>{i.color=a,D.redraw()}}),...Object.entries(i.generators).map(([a,c])=>D("label",[c.label+":",D(Pe,{generator:c.name,registry:c.registry,config:c.config,onGeneratorChange:h=>{h!=c.name&&(console.log(`${a} generator changed to ${h}`),c.name=h,i.generators[a].config=c.registry.getDefaultConfig(h,i.canvasWidth,i.canvasHeight),i.dirty=!0,D.redraw())},onConfigChange:(h,f)=>{console.log(`${a} generator config "${h}" changed to ${String(f)}`),c.config[h]=f,i.dirty=!0,D.redraw()}})]))])])])}};he("material",{resolver:l=>{const e=l.match(/^(.*?)(_(rounded|sharp))?$/);return e?`https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${e[3]??"outlined"}/${e[1]}.svg`:""}});D.mount(document.body,An);
//# sourceMappingURL=index-pzb-tTT8.js.map
