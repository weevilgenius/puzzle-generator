(function(){"use strict";const{abs:j,cos:F,sin:U,acos:at,atan2:N,sqrt:$,pow:S}=Math;function D(o){return o<0?-S(-o,1/3):S(o,1/3)}const B=Math.PI,Y=2*B,R=B/2,ut=1e-6,Q=Number.MAX_SAFE_INTEGER||9007199254740991,H=Number.MIN_SAFE_INTEGER||-9007199254740991,ft={x:0,y:0,z:0},y={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(o,e){const n=e(o);let r=n.x*n.x+n.y*n.y;return typeof n.z<"u"&&(r+=n.z*n.z),$(r)},compute:function(o,e,n){if(o===0)return e[0].t=0,e[0];const r=e.length-1;if(o===1)return e[r].t=1,e[r];const s=1-o;let c=e;if(r===0)return e[0].t=o,e[0];if(r===1){const a={x:s*c[0].x+o*c[1].x,y:s*c[0].y+o*c[1].y,t:o};return n&&(a.z=s*c[0].z+o*c[1].z),a}if(r<4){let a=s*s,u=o*o,f,h,l,x=0;r===2?(c=[c[0],c[1],c[2],ft],f=a,h=s*o*2,l=u):r===3&&(f=a*s,h=a*o*3,l=s*u*3,x=o*u);const p={x:f*c[0].x+h*c[1].x+l*c[2].x+x*c[3].x,y:f*c[0].y+h*c[1].y+l*c[2].y+x*c[3].y,t:o};return n&&(p.z=f*c[0].z+h*c[1].z+l*c[2].z+x*c[3].z),p}const i=JSON.parse(JSON.stringify(e));for(;i.length>1;){for(let a=0;a<i.length-1;a++)i[a]={x:i[a].x+(i[a+1].x-i[a].x)*o,y:i[a].y+(i[a+1].y-i[a].y)*o},typeof i[a].z<"u"&&(i[a].z=i[a].z+(i[a+1].z-i[a].z)*o);i.splice(i.length-1,1)}return i[0].t=o,i[0]},computeWithRatios:function(o,e,n,r){const s=1-o,c=n,i=e;let a=c[0],u=c[1],f=c[2],h=c[3],l;if(a*=s,u*=o,i.length===2)return l=a+u,{x:(a*i[0].x+u*i[1].x)/l,y:(a*i[0].y+u*i[1].y)/l,z:r?(a*i[0].z+u*i[1].z)/l:!1,t:o};if(a*=s,u*=2*s,f*=o*o,i.length===3)return l=a+u+f,{x:(a*i[0].x+u*i[1].x+f*i[2].x)/l,y:(a*i[0].y+u*i[1].y+f*i[2].y)/l,z:r?(a*i[0].z+u*i[1].z+f*i[2].z)/l:!1,t:o};if(a*=s,u*=1.5*s,f*=3*s,h*=o*o*o,i.length===4)return l=a+u+f+h,{x:(a*i[0].x+u*i[1].x+f*i[2].x+h*i[3].x)/l,y:(a*i[0].y+u*i[1].y+f*i[2].y+h*i[3].y)/l,z:r?(a*i[0].z+u*i[1].z+f*i[2].z+h*i[3].z)/l:!1,t:o}},derive:function(o,e){const n=[];for(let r=o,s=r.length,c=s-1;s>1;s--,c--){const i=[];for(let a=0,u;a<c;a++)u={x:c*(r[a+1].x-r[a].x),y:c*(r[a+1].y-r[a].y)},e&&(u.z=c*(r[a+1].z-r[a].z)),i.push(u);n.push(i),r=i}return n},between:function(o,e,n){return e<=o&&o<=n||y.approximately(o,e)||y.approximately(o,n)},approximately:function(o,e,n){return j(o-e)<=(n||ut)},length:function(o){const n=y.Tvalues.length;let r=0;for(let s=0,c;s<n;s++)c=.5*y.Tvalues[s]+.5,r+=y.Cvalues[s]*y.arcfn(c,o);return .5*r},map:function(o,e,n,r,s){const c=n-e,i=s-r,a=o-e,u=a/c;return r+i*u},lerp:function(o,e,n){const r={x:e.x+o*(n.x-e.x),y:e.y+o*(n.y-e.y)};return e.z!==void 0&&n.z!==void 0&&(r.z=e.z+o*(n.z-e.z)),r},pointToString:function(o){let e=o.x+"/"+o.y;return typeof o.z<"u"&&(e+="/"+o.z),e},pointsToString:function(o){return"["+o.map(y.pointToString).join(", ")+"]"},copy:function(o){return JSON.parse(JSON.stringify(o))},angle:function(o,e,n){const r=e.x-o.x,s=e.y-o.y,c=n.x-o.x,i=n.y-o.y,a=r*i-s*c,u=r*c+s*i;return N(a,u)},round:function(o,e){const n=""+o,r=n.indexOf(".");return parseFloat(n.substring(0,r+1+e))},dist:function(o,e){const n=o.x-e.x,r=o.y-e.y;return $(n*n+r*r)},closest:function(o,e){let n=S(2,63),r,s;return o.forEach(function(c,i){s=y.dist(e,c),s<n&&(n=s,r=i)}),{mdist:n,mpos:r}},abcratio:function(o,e){if(e!==2&&e!==3)return!1;if(typeof o>"u")o=.5;else if(o===0||o===1)return o;const n=S(o,e)+S(1-o,e),r=n-1;return j(r/n)},projectionratio:function(o,e){if(e!==2&&e!==3)return!1;if(typeof o>"u")o=.5;else if(o===0||o===1)return o;const n=S(1-o,e),r=S(o,e)+n;return n/r},lli8:function(o,e,n,r,s,c,i,a){const u=(o*r-e*n)*(s-i)-(o-n)*(s*a-c*i),f=(o*r-e*n)*(c-a)-(e-r)*(s*a-c*i),h=(o-n)*(c-a)-(e-r)*(s-i);return h==0?!1:{x:u/h,y:f/h}},lli4:function(o,e,n,r){const s=o.x,c=o.y,i=e.x,a=e.y,u=n.x,f=n.y,h=r.x,l=r.y;return y.lli8(s,c,i,a,u,f,h,l)},lli:function(o,e){return y.lli4(o,o.c,e,e.c)},makeline:function(o,e){return new b(o.x,o.y,(o.x+e.x)/2,(o.y+e.y)/2,e.x,e.y)},findbbox:function(o){let e=Q,n=Q,r=H,s=H;return o.forEach(function(c){const i=c.bbox();e>i.x.min&&(e=i.x.min),n>i.y.min&&(n=i.y.min),r<i.x.max&&(r=i.x.max),s<i.y.max&&(s=i.y.max)}),{x:{min:e,mid:(e+r)/2,max:r,size:r-e},y:{min:n,mid:(n+s)/2,max:s,size:s-n}}},shapeintersections:function(o,e,n,r,s){if(!y.bboxoverlap(e,r))return[];const c=[],i=[o.startcap,o.forward,o.back,o.endcap],a=[n.startcap,n.forward,n.back,n.endcap];return i.forEach(function(u){u.virtual||a.forEach(function(f){if(f.virtual)return;const h=u.intersects(f,s);h.length>0&&(h.c1=u,h.c2=f,h.s1=o,h.s2=n,c.push(h))})}),c},makeshape:function(o,e,n){const r=e.points.length,s=o.points.length,c=y.makeline(e.points[r-1],o.points[0]),i=y.makeline(o.points[s-1],e.points[0]),a={startcap:c,forward:o,back:e,endcap:i,bbox:y.findbbox([c,o,e,i])};return a.intersections=function(u){return y.shapeintersections(a,a.bbox,u,u.bbox,n)},a},getminmax:function(o,e,n){if(!n)return{min:0,max:0};let r=Q,s=H,c,i;n.indexOf(0)===-1&&(n=[0].concat(n)),n.indexOf(1)===-1&&n.push(1);for(let a=0,u=n.length;a<u;a++)c=n[a],i=o.get(c),i[e]<r&&(r=i[e]),i[e]>s&&(s=i[e]);return{min:r,mid:(r+s)/2,max:s,size:s-r}},align:function(o,e){const n=e.p1.x,r=e.p1.y,s=-N(e.p2.y-r,e.p2.x-n),c=function(i){return{x:(i.x-n)*F(s)-(i.y-r)*U(s),y:(i.x-n)*U(s)+(i.y-r)*F(s)}};return o.map(c)},roots:function(o,e){e=e||{p1:{x:0,y:0},p2:{x:1,y:0}};const n=o.length-1,r=y.align(o,e),s=function(v){return 0<=v&&v<=1};if(n===2){const v=r[0].y,w=r[1].y,P=r[2].y,A=v-2*w+P;if(A!==0){const T=-$(w*w-v*P),C=-v+w,I=-(T+C)/A,O=-(-T+C)/A;return[I,O].filter(s)}else if(w!==P&&A===0)return[(2*w-P)/(2*w-2*P)].filter(s);return[]}const c=r[0].y,i=r[1].y,a=r[2].y,u=r[3].y;let f=-c+3*i-3*a+u,h=3*c-6*i+3*a,l=-3*c+3*i,x=c;if(y.approximately(f,0)){if(y.approximately(h,0))return y.approximately(l,0)?[]:[-x/l].filter(s);const v=$(l*l-4*h*x),w=2*h;return[(v-l)/w,(-l-v)/w].filter(s)}h/=f,l/=f,x/=f;const p=(3*l-h*h)/3,d=p/3,g=(2*h*h*h-9*h*l+27*x)/27,_=g/2,z=_*_+d*d*d;let k,M,q,m,E;if(z<0){const v=-p/3,w=v*v*v,P=$(w),A=-g/(2*P),T=A<-1?-1:A>1?1:A,C=at(T),I=D(P),O=2*I;return q=O*F(C/3)-h/3,m=O*F((C+Y)/3)-h/3,E=O*F((C+2*Y)/3)-h/3,[q,m,E].filter(s)}else{if(z===0)return k=_<0?D(-_):-D(_),q=2*k-h/3,m=-k-h/3,[q,m].filter(s);{const v=$(z);return k=D(-_+v),M=D(_+v),[k-M-h/3].filter(s)}}},droots:function(o){if(o.length===3){const e=o[0],n=o[1],r=o[2],s=e-2*n+r;if(s!==0){const c=-$(n*n-e*r),i=-e+n,a=-(c+i)/s,u=-(-c+i)/s;return[a,u]}else if(n!==r&&s===0)return[(2*n-r)/(2*(n-r))];return[]}if(o.length===2){const e=o[0],n=o[1];return e!==n?[e/(e-n)]:[]}return[]},curvature:function(o,e,n,r,s){let c,i,a,u,f=0,h=0;const l=y.compute(o,e),x=y.compute(o,n),p=l.x*l.x+l.y*l.y;if(r?(c=$(S(l.y*x.z-x.y*l.z,2)+S(l.z*x.x-x.z*l.x,2)+S(l.x*x.y-x.x*l.y,2)),i=S(p+l.z*l.z,3/2)):(c=l.x*x.y-l.y*x.x,i=S(p,3/2)),c===0||i===0)return{k:0,r:0};if(f=c/i,h=i/c,!s){const d=y.curvature(o-.001,e,n,r,!0).k,g=y.curvature(o+.001,e,n,r,!0).k;u=(g-f+(f-d))/2,a=(j(g-f)+j(f-d))/2}return{k:f,r:h,dk:u,adk:a}},inflections:function(o){if(o.length<4)return[];const e=y.align(o,{p1:o[0],p2:o.slice(-1)[0]}),n=e[2].x*e[1].y,r=e[3].x*e[1].y,s=e[1].x*e[2].y,c=e[3].x*e[2].y,i=18*(-3*n+2*r+3*s-c),a=18*(3*n-r-3*s),u=18*(s-n);if(y.approximately(i,0)){if(!y.approximately(a,0)){let x=-u/a;if(0<=x&&x<=1)return[x]}return[]}const f=2*i;if(y.approximately(f,0))return[];const h=a*a-4*i*u;if(h<0)return[];const l=Math.sqrt(h);return[(l-a)/f,-(a+l)/f].filter(function(x){return 0<=x&&x<=1})},bboxoverlap:function(o,e){const n=["x","y"],r=n.length;for(let s=0,c,i,a,u;s<r;s++)if(c=n[s],i=o[c].mid,a=e[c].mid,u=(o[c].size+e[c].size)/2,j(i-a)>=u)return!1;return!0},expandbox:function(o,e){e.x.min<o.x.min&&(o.x.min=e.x.min),e.y.min<o.y.min&&(o.y.min=e.y.min),e.z&&e.z.min<o.z.min&&(o.z.min=e.z.min),e.x.max>o.x.max&&(o.x.max=e.x.max),e.y.max>o.y.max&&(o.y.max=e.y.max),e.z&&e.z.max>o.z.max&&(o.z.max=e.z.max),o.x.mid=(o.x.min+o.x.max)/2,o.y.mid=(o.y.min+o.y.max)/2,o.z&&(o.z.mid=(o.z.min+o.z.max)/2),o.x.size=o.x.max-o.x.min,o.y.size=o.y.max-o.y.min,o.z&&(o.z.size=o.z.max-o.z.min)},pairiteration:function(o,e,n){const r=o.bbox(),s=e.bbox(),c=1e5,i=n||.5;if(r.x.size+r.y.size<i&&s.x.size+s.y.size<i)return[(c*(o._t1+o._t2)/2|0)/c+"/"+(c*(e._t1+e._t2)/2|0)/c];let a=o.split(.5),u=e.split(.5),f=[{left:a.left,right:u.left},{left:a.left,right:u.right},{left:a.right,right:u.right},{left:a.right,right:u.left}];f=f.filter(function(l){return y.bboxoverlap(l.left.bbox(),l.right.bbox())});let h=[];return f.length===0||(f.forEach(function(l){h=h.concat(y.pairiteration(l.left,l.right,i))}),h=h.filter(function(l,x){return h.indexOf(l)===x})),h},getccenter:function(o,e,n){const r=e.x-o.x,s=e.y-o.y,c=n.x-e.x,i=n.y-e.y,a=r*F(R)-s*U(R),u=r*U(R)+s*F(R),f=c*F(R)-i*U(R),h=c*U(R)+i*F(R),l=(o.x+e.x)/2,x=(o.y+e.y)/2,p=(e.x+n.x)/2,d=(e.y+n.y)/2,g=l+a,_=x+u,z=p+f,k=d+h,M=y.lli8(l,x,g,_,p,d,z,k),q=y.dist(M,o);let m=N(o.y-M.y,o.x-M.x),E=N(e.y-M.y,e.x-M.x),v=N(n.y-M.y,n.x-M.x),w;return m<v?((m>E||E>v)&&(m+=Y),m>v&&(w=v,v=m,m=w)):v<E&&E<m?(w=v,v=m,m=w):v+=Y,M.s=m,M.e=v,M.r=q,M},numberSort:function(o,e){return o-e}};class L{constructor(e){this.curves=[],this._3d=!1,e&&(this.curves=e,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(e){return y.pointsToString(e.points)}).join(", ")+"]"}addCurve(e){this.curves.push(e),this._3d=this._3d||e._3d}length(){return this.curves.map(function(e){return e.length()}).reduce(function(e,n){return e+n})}curve(e){return this.curves[e]}bbox(){const e=this.curves;for(var n=e[0].bbox(),r=1;r<e.length;r++)y.expandbox(n,e[r].bbox());return n}offset(e){const n=[];return this.curves.forEach(function(r){n.push(...r.offset(e))}),new L(n)}}const{abs:V,min:tt,max:et,cos:lt,sin:ht,acos:yt,sqrt:X}=Math,xt=Math.PI;class b{constructor(e){let n=e&&e.forEach?e:Array.from(arguments).slice(),r=!1;if(typeof n[0]=="object"){r=n.length;const p=[];n.forEach(function(d){["x","y","z"].forEach(function(g){typeof d[g]<"u"&&p.push(d[g])})}),n=p}let s=!1;const c=n.length;if(r){if(r>4){if(arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");s=!0}}else if(c!==6&&c!==8&&c!==9&&c!==12&&arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const i=this._3d=!s&&(c===9||c===12)||e&&e[0]&&typeof e[0].z<"u",a=this.points=[];for(let p=0,d=i?3:2;p<c;p+=d){var u={x:n[p],y:n[p+1]};i&&(u.z=n[p+2]),a.push(u)}const f=this.order=a.length-1,h=this.dims=["x","y"];i&&h.push("z"),this.dimlen=h.length;const l=y.align(a,{p1:a[0],p2:a[f]}),x=y.dist(a[0],a[f]);this._linear=l.reduce((p,d)=>p+V(d.y),0)<x/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(e,n,r,s){if(typeof s>"u"&&(s=.5),s===0)return new b(n,n,r);if(s===1)return new b(e,n,n);const c=b.getABC(2,e,n,r,s);return new b(e,c.A,r)}static cubicFromPoints(e,n,r,s,c){typeof s>"u"&&(s=.5);const i=b.getABC(3,e,n,r,s);typeof c>"u"&&(c=y.dist(n,i.C));const a=c*(1-s)/s,u=y.dist(e,r),f=(r.x-e.x)/u,h=(r.y-e.y)/u,l=c*f,x=c*h,p=a*f,d=a*h,g={x:n.x-l,y:n.y-x},_={x:n.x+p,y:n.y+d},z=i.A,k={x:z.x+(g.x-z.x)/(1-s),y:z.y+(g.y-z.y)/(1-s)},M={x:z.x+(_.x-z.x)/s,y:z.y+(_.y-z.y)/s},q={x:e.x+(k.x-e.x)/s,y:e.y+(k.y-e.y)/s},m={x:r.x+(M.x-r.x)/(1-s),y:r.y+(M.y-r.y)/(1-s)};return new b(e,q,m,r)}static getUtils(){return y}getUtils(){return b.getUtils()}static get PolyBezier(){return L}valueOf(){return this.toString()}toString(){return y.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const e=this.points,n=e[0].x,r=e[0].y,s=["M",n,r,this.order===2?"Q":"C"];for(let c=1,i=e.length;c<i;c++)s.push(e[c].x),s.push(e[c].y);return s.join(" ")}setRatios(e){if(e.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=e,this._lut=[]}verify(){const e=this.coordDigest();e!==this._print&&(this._print=e,this.update())}coordDigest(){return this.points.map(function(e,n){return""+n+e.x+e.y+(e.z?e.z:0)}).join("")}update(){this._lut=[],this.dpoints=y.derive(this.points,this._3d),this.computedirection()}computedirection(){const e=this.points,n=y.angle(e[0],e[this.order],e[1]);this.clockwise=n>0}length(){return y.length(this.derivative.bind(this))}static getABC(e=2,n,r,s,c=.5){const i=y.projectionratio(c,e),a=1-i,u={x:i*n.x+a*s.x,y:i*n.y+a*s.y},f=y.abcratio(c,e);return{A:{x:r.x+(r.x-u.x)/f,y:r.y+(r.y-u.y)/f},B:r,C:u,S:n,E:s}}getABC(e,n){n=n||this.get(e);let r=this.points[0],s=this.points[this.order];return b.getABC(this.order,r,n,s,e)}getLUT(e){if(this.verify(),e=e||100,this._lut.length===e+1)return this._lut;this._lut=[],e++,this._lut=[];for(let n=0,r,s;n<e;n++)s=n/(e-1),r=this.compute(s),r.t=s,this._lut.push(r);return this._lut}on(e,n){n=n||5;const r=this.getLUT(),s=[];for(let c=0,i,a=0;c<r.length;c++)i=r[c],y.dist(i,e)<n&&(s.push(i),a+=c/r.length);return s.length?t/=s.length:!1}project(e){const n=this.getLUT(),r=n.length-1,s=y.closest(n,e),c=s.mpos,i=(c-1)/r,a=(c+1)/r,u=.1/r;let f=s.mdist,h=i,l=h,x;f+=1;for(let p;h<a+u;h+=u)x=this.compute(h),p=y.dist(e,x),p<f&&(f=p,l=h);return l=l<0?0:l>1?1:l,x=this.compute(l),x.t=l,x.d=f,x}get(e){return this.compute(e)}point(e){return this.points[e]}compute(e){return this.ratios?y.computeWithRatios(e,this.points,this.ratios,this._3d):y.compute(e,this.points,this._3d,this.ratios)}raise(){const e=this.points,n=[e[0]],r=e.length;for(let s=1,c,i;s<r;s++)c=e[s],i=e[s-1],n[s]={x:(r-s)/r*c.x+s/r*i.x,y:(r-s)/r*c.y+s/r*i.y};return n[r]=e[r-1],new b(n)}derivative(e){return y.compute(e,this.dpoints[0],this._3d)}dderivative(e){return y.compute(e,this.dpoints[1],this._3d)}align(){let e=this.points;return new b(y.align(e,{p1:e[0],p2:e[e.length-1]}))}curvature(e){return y.curvature(e,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return y.inflections(this.points)}normal(e){return this._3d?this.__normal3(e):this.__normal2(e)}__normal2(e){const n=this.derivative(e),r=X(n.x*n.x+n.y*n.y);return{t:e,x:-n.y/r,y:n.x/r}}__normal3(e){const n=this.derivative(e),r=this.derivative(e+.01),s=X(n.x*n.x+n.y*n.y+n.z*n.z),c=X(r.x*r.x+r.y*r.y+r.z*r.z);n.x/=s,n.y/=s,n.z/=s,r.x/=c,r.y/=c,r.z/=c;const i={x:r.y*n.z-r.z*n.y,y:r.z*n.x-r.x*n.z,z:r.x*n.y-r.y*n.x},a=X(i.x*i.x+i.y*i.y+i.z*i.z);i.x/=a,i.y/=a,i.z/=a;const u=[i.x*i.x,i.x*i.y-i.z,i.x*i.z+i.y,i.x*i.y+i.z,i.y*i.y,i.y*i.z-i.x,i.x*i.z-i.y,i.y*i.z+i.x,i.z*i.z];return{t:e,x:u[0]*n.x+u[1]*n.y+u[2]*n.z,y:u[3]*n.x+u[4]*n.y+u[5]*n.z,z:u[6]*n.x+u[7]*n.y+u[8]*n.z}}hull(e){let n=this.points,r=[],s=[],c=0;for(s[c++]=n[0],s[c++]=n[1],s[c++]=n[2],this.order===3&&(s[c++]=n[3]);n.length>1;){r=[];for(let i=0,a,u=n.length-1;i<u;i++)a=y.lerp(e,n[i],n[i+1]),s[c++]=a,r.push(a);n=r}return s}split(e,n){if(e===0&&n)return this.split(n).left;if(n===1)return this.split(e).right;const r=this.hull(e),s={left:this.order===2?new b([r[0],r[3],r[5]]):new b([r[0],r[4],r[7],r[9]]),right:this.order===2?new b([r[5],r[4],r[2]]):new b([r[9],r[8],r[6],r[3]]),span:r};return s.left._t1=y.map(0,0,1,this._t1,this._t2),s.left._t2=y.map(e,0,1,this._t1,this._t2),s.right._t1=y.map(e,0,1,this._t1,this._t2),s.right._t2=y.map(1,0,1,this._t1,this._t2),n?(n=y.map(n,e,1,0,1),s.right.split(n).left):s}extrema(){const e={};let n=[];return this.dims.forEach((function(r){let s=function(i){return i[r]},c=this.dpoints[0].map(s);e[r]=y.droots(c),this.order===3&&(c=this.dpoints[1].map(s),e[r]=e[r].concat(y.droots(c))),e[r]=e[r].filter(function(i){return i>=0&&i<=1}),n=n.concat(e[r].sort(y.numberSort))}).bind(this)),e.values=n.sort(y.numberSort).filter(function(r,s){return n.indexOf(r)===s}),e}bbox(){const e=this.extrema(),n={};return this.dims.forEach((function(r){n[r]=y.getminmax(this,r,e[r])}).bind(this)),n}overlaps(e){const n=this.bbox(),r=e.bbox();return y.bboxoverlap(n,r)}offset(e,n){if(typeof n<"u"){const r=this.get(e),s=this.normal(e),c={c:r,n:s,x:r.x+s.x*n,y:r.y+s.y*n};return this._3d&&(c.z=r.z+s.z*n),c}if(this._linear){const r=this.normal(0),s=this.points.map(function(c){const i={x:c.x+e*r.x,y:c.y+e*r.y};return c.z&&r.z&&(i.z=c.z+e*r.z),i});return[new b(s)]}return this.reduce().map(function(r){return r._linear?r.offset(e)[0]:r.scale(e)})}simple(){if(this.order===3){const s=y.angle(this.points[0],this.points[3],this.points[1]),c=y.angle(this.points[0],this.points[3],this.points[2]);if(s>0&&c<0||s<0&&c>0)return!1}const e=this.normal(0),n=this.normal(1);let r=e.x*n.x+e.y*n.y;return this._3d&&(r+=e.z*n.z),V(yt(r))<xt/3}reduce(){let e,n=0,r=0,s=.01,c,i=[],a=[],u=this.extrema().values;for(u.indexOf(0)===-1&&(u=[0].concat(u)),u.indexOf(1)===-1&&u.push(1),n=u[0],e=1;e<u.length;e++)r=u[e],c=this.split(n,r),c._t1=n,c._t2=r,i.push(c),n=r;return i.forEach(function(f){for(n=0,r=0;r<=1;)for(r=n+s;r<=1+s;r+=s)if(c=f.split(n,r),!c.simple()){if(r-=s,V(n-r)<s)return[];c=f.split(n,r),c._t1=y.map(n,0,1,f._t1,f._t2),c._t2=y.map(r,0,1,f._t1,f._t2),a.push(c),n=r;break}n<1&&(c=f.split(n,1),c._t1=y.map(n,0,1,f._t1,f._t2),c._t2=f._t2,a.push(c))}),a}translate(e,n,r){r=typeof r=="number"?r:n;const s=this.order;let c=this.points.map((i,a)=>(1-a/s)*n+a/s*r);return new b(this.points.map((i,a)=>({x:i.x+e.x*c[a],y:i.y+e.y*c[a]})))}scale(e){const n=this.order;let r=!1;if(typeof e=="function"&&(r=e),r&&n===2)return this.raise().scale(r);const s=this.clockwise,c=this.points;if(this._linear)return this.translate(this.normal(0),r?r(0):e,r?r(1):e);const i=r?r(0):e,a=r?r(1):e,u=[this.offset(0,10),this.offset(1,10)],f=[],h=y.lli4(u[0],u[0].c,u[1],u[1].c);if(!h)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach(function(l){const x=f[l*n]=y.copy(c[l*n]);x.x+=(l?a:i)*u[l].n.x,x.y+=(l?a:i)*u[l].n.y}),r?([0,1].forEach(function(l){if(!(n===2&&l)){var x=c[l+1],p={x:x.x-h.x,y:x.y-h.y},d=r?r((l+1)/n):e;r&&!s&&(d=-d);var g=X(p.x*p.x+p.y*p.y);p.x/=g,p.y/=g,f[l+1]={x:x.x+d*p.x,y:x.y+d*p.y}}}),new b(f)):([0,1].forEach(l=>{if(n===2&&l)return;const x=f[l*n],p=this.derivative(l),d={x:x.x+p.x,y:x.y+p.y};f[l+1]=y.lli4(x,d,h,c[l+1])}),new b(f))}outline(e,n,r,s){if(n=n===void 0?e:n,this._linear){const m=this.normal(0),E=this.points[0],v=this.points[this.points.length-1];let w,P,A;r===void 0&&(r=e,s=n),w={x:E.x+m.x*e,y:E.y+m.y*e},A={x:v.x+m.x*r,y:v.y+m.y*r},P={x:(w.x+A.x)/2,y:(w.y+A.y)/2};const T=[w,P,A];w={x:E.x-m.x*n,y:E.y-m.y*n},A={x:v.x-m.x*s,y:v.y-m.y*s},P={x:(w.x+A.x)/2,y:(w.y+A.y)/2};const C=[A,P,w],I=y.makeline(C[2],T[0]),O=y.makeline(T[2],C[0]),K=[I,new b(T),O,new b(C)];return new L(K)}const c=this.reduce(),i=c.length,a=[];let u=[],f,h=0,l=this.length();const x=typeof r<"u"&&typeof s<"u";function p(m,E,v,w,P){return function(A){const T=w/v,C=(w+P)/v,I=E-m;return y.map(A,0,1,m+T*I,m+C*I)}}c.forEach(function(m){const E=m.length();x?(a.push(m.scale(p(e,r,l,h,E))),u.push(m.scale(p(-n,-s,l,h,E)))):(a.push(m.scale(e)),u.push(m.scale(-n))),h+=E}),u=u.map(function(m){return f=m.points,f[3]?m.points=[f[3],f[2],f[1],f[0]]:m.points=[f[2],f[1],f[0]],m}).reverse();const d=a[0].points[0],g=a[i-1].points[a[i-1].points.length-1],_=u[i-1].points[u[i-1].points.length-1],z=u[0].points[0],k=y.makeline(_,d),M=y.makeline(g,z),q=[k].concat(a).concat([M]).concat(u);return new L(q)}outlineshapes(e,n,r){n=n||e;const s=this.outline(e,n).curves,c=[];for(let i=1,a=s.length;i<a/2;i++){const u=y.makeshape(s[i],s[a-i],r);u.startcap.virtual=i>1,u.endcap.virtual=i<a/2-1,c.push(u)}return c}intersects(e,n){return e?e.p1&&e.p2?this.lineIntersects(e):(e instanceof b&&(e=e.reduce()),this.curveintersects(this.reduce(),e,n)):this.selfintersects(n)}lineIntersects(e){const n=tt(e.p1.x,e.p2.x),r=tt(e.p1.y,e.p2.y),s=et(e.p1.x,e.p2.x),c=et(e.p1.y,e.p2.y);return y.roots(this.points,e).filter(i=>{var a=this.get(i);return y.between(a.x,n,s)&&y.between(a.y,r,c)})}selfintersects(e){const n=this.reduce(),r=n.length-2,s=[];for(let c=0,i,a,u;c<r;c++)a=n.slice(c,c+1),u=n.slice(c+2),i=this.curveintersects(a,u,e),s.push(...i);return s}curveintersects(e,n,r){const s=[];e.forEach(function(i){n.forEach(function(a){i.overlaps(a)&&s.push({left:i,right:a})})});let c=[];return s.forEach(function(i){const a=y.pairiteration(i.left,i.right,r);a.length>0&&(c=c.concat(a))}),c}arcs(e){return e=e||.5,this._iterate(e,[])}_error(e,n,r,s){const c=(s-r)/4,i=this.get(r+c),a=this.get(s-c),u=y.dist(e,n),f=y.dist(e,i),h=y.dist(e,a);return V(f-u)+V(h-u)}_iterate(e,n){let r=0,s=1,c;do{c=0,s=1;let i=this.get(r),a,u,f,h,l=!1,x=!1,p,d=s,g=1;do if(x=l,h=f,d=(r+s)/2,a=this.get(d),u=this.get(s),f=y.getccenter(i,a,u),f.interval={start:r,end:s},l=this._error(f,i,r,s)<=e,p=x&&!l,p||(g=s),l){if(s>=1){if(f.interval.end=g=1,h=f,s>1){let z={x:f.x+f.r*lt(f.e),y:f.y+f.r*ht(f.e)};f.e+=y.angle({x:f.x,y:f.y},z,this.get(1))}break}s=s+(s-r)/2}else s=d;while(!p&&c++<100);if(c>=100)break;h=h||f,n.push(h),r=g}while(s<1);return n}}var pt=(function(){function o(e,n){var r=[],s=!0,c=!1,i=void 0;try{for(var a=e[Symbol.iterator](),u;!(s=(u=a.next()).done)&&(r.push(u.value),!(n&&r.length===n));s=!0);}catch(f){c=!0,i=f}finally{try{!s&&a.return&&a.return()}finally{if(c)throw i}}return r}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return o(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}})(),G=Math.PI*2,W=function(e,n,r,s,c,i,a){var u=e.x,f=e.y;u*=n,f*=r;var h=s*u-c*f,l=c*u+s*f;return{x:h+i,y:l+a}},mt=function(e,n){var r=n===1.5707963267948966?.551915024494:n===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(n/4),s=Math.cos(e),c=Math.sin(e),i=Math.cos(e+n),a=Math.sin(e+n);return[{x:s-c*r,y:c+s*r},{x:i+a*r,y:a-i*r},{x:i,y:a}]},nt=function(e,n,r,s){var c=e*s-n*r<0?-1:1,i=e*r+n*s;return i>1&&(i=1),i<-1&&(i=-1),c*Math.acos(i)},dt=function(e,n,r,s,c,i,a,u,f,h,l,x){var p=Math.pow(c,2),d=Math.pow(i,2),g=Math.pow(l,2),_=Math.pow(x,2),z=p*d-p*_-d*g;z<0&&(z=0),z/=p*_+d*g,z=Math.sqrt(z)*(a===u?-1:1);var k=z*c/i*x,M=z*-i/c*l,q=h*k-f*M+(e+r)/2,m=f*k+h*M+(n+s)/2,E=(l-k)/c,v=(x-M)/i,w=(-l-k)/c,P=(-x-M)/i,A=nt(1,0,E,v),T=nt(E,v,w,P);return u===0&&T>0&&(T-=G),u===1&&T<0&&(T+=G),[q,m,A,T]},gt=function(e){var n=e.px,r=e.py,s=e.cx,c=e.cy,i=e.rx,a=e.ry,u=e.xAxisRotation,f=u===void 0?0:u,h=e.largeArcFlag,l=h===void 0?0:h,x=e.sweepFlag,p=x===void 0?0:x,d=[];if(i===0||a===0)return[];var g=Math.sin(f*G/360),_=Math.cos(f*G/360),z=_*(n-s)/2+g*(r-c)/2,k=-g*(n-s)/2+_*(r-c)/2;if(z===0&&k===0)return[];i=Math.abs(i),a=Math.abs(a);var M=Math.pow(z,2)/Math.pow(i,2)+Math.pow(k,2)/Math.pow(a,2);M>1&&(i*=Math.sqrt(M),a*=Math.sqrt(M));var q=dt(n,r,s,c,i,a,l,p,g,_,z,k),m=pt(q,4),E=m[0],v=m[1],w=m[2],P=m[3],A=Math.abs(P)/(G/4);Math.abs(1-A)<1e-7&&(A=1);var T=Math.max(Math.ceil(A),1);P/=T;for(var C=0;C<T;C++)d.push(mt(w,P)),w+=P;return d.map(function(I){var O=W(I[0],i,a,_,g,E,v),K=O.x,St=O.y,ot=W(I[1],i,a,_,g,E,v),It=ot.x,Ot=ot.y,ct=W(I[2],i,a,_,g,E,v),Ft=ct.x,$t=ct.y;return{x1:K,y1:St,x2:It,y2:Ot,x:Ft,y:$t}})},J={exports:{}},rt;function vt(){if(rt)return J.exports;rt=1,J.exports=o,J.exports.default=o;function o(n,r){if(!(this instanceof o))return new o(n,r);if(this.data=n||[],this.length=this.data.length,this.compare=r||e,this.length>0)for(var s=(this.length>>1)-1;s>=0;s--)this._down(s)}function e(n,r){return n<r?-1:n>r?1:0}return o.prototype={push:function(n){this.data.push(n),this.length++,this._up(this.length-1)},pop:function(){if(this.length!==0){var n=this.data[0];return this.length--,this.length>0&&(this.data[0]=this.data[this.length],this._down(0)),this.data.pop(),n}},peek:function(){return this.data[0]},_up:function(n){for(var r=this.data,s=this.compare,c=r[n];n>0;){var i=n-1>>1,a=r[i];if(s(c,a)>=0)break;r[n]=a,n=i}r[n]=c},_down:function(n){for(var r=this.data,s=this.compare,c=this.length>>1,i=r[n];n<c;){var a=(n<<1)+1,u=a+1,f=r[a];if(u<this.length&&s(r[u],f)<0&&(a=u,f=r[u]),s(f,i)>=0)break;r[n]=f,n=a}r[n]=i}},J.exports}vt();function it(o,e){const n=o[0]-e[0],r=o[1]-e[1];return n*n+r*r}function zt(o){return{vertices:o.vertices,pieces:new Map(o.pieces),edges:new Map(o.edges),halfEdges:new Map(o.halfEdges),boundary:o.boundary,borderPath:o.borderPath}}function wt(o,e){return!(o[2]<e[0]||o[0]>e[2]||o[3]<e[1]||o[1]>e[3])}function st(o,e){let[n,r]=o,[s,c]=o;const i=a=>{n=Math.min(n,a[0]),r=Math.min(r,a[1]),s=Math.max(s,a[0]),c=Math.max(c,a[1])};for(const a of e)a.type==="line"?i(a.p):(i(a.p1),i(a.p2),i(a.p3));return[n,r,s,c]}function _t(o,e){const{p:n,radii:r,rotation:s,largeArc:c,sweep:i}=e,[a,u]=o,[f,h]=n,[l,x]=r;return gt({px:a,py:u,cx:f,cy:h,rx:l,ry:x,xAxisRotation:s,largeArcFlag:c?1:0,sweepFlag:i?1:0}).map(g=>({type:"bezier",p1:[g.x1,g.y1],p2:[g.x2,g.y2],p3:[g.x,g.y]}))}function Mt(o){const e=[];let n=[];if(o.length===0||o[0].type!=="move")return[];let r=[0,0];for(const s of o)switch(s.type){case"move":n.length>0&&e.push(n),r=s.p,n=[r];break;case"line":n.push(s.p),r=s.p;break;case"bezier":{const{p1:c,p2:i,p3:a}=s,f=new b([...r,...c,...i,...a]).getLUT(100);n.push(...f.slice(1).map(h=>[h.x,h.y])),r=a;break}case"arc":{const c=_t(r,s);let i=r;for(const a of c){const f=new b([...i,...a.p1,...a.p2,...a.p3]).getLUT(100);n.push(...f.slice(1).map(h=>[h.x,h.y])),i=a.p3}r=s.p;break}}return n.length>0&&e.push(n),e}function Et(o,e,n){if(n){for(const c of n)if(o[0]===c[0]&&o[1]===c[1])return!0}if(e.length>0&&e[0].type!=="move")throw new Error("Boundary path must start with a 'move' command.");const r=Mt(e);let s=0;for(const c of r)bt(o,c)&&s++;return s%2===1}function bt(o,e){const[n,r]=o;let s=!1;for(let c=0,i=e.length-1;c<e.length;i=c++){const[a,u]=e[c],[f,h]=e[i];u>r!=h>r&&n<(f-a)*(r-u)/(h-u)+a&&(s=!s)}return s}function At(o){return o.type==="line"?o.p:o.p3}function Z(o){if(o.segment.type!=="bezier")throw new Error("Boundary segment is not a Bezier curve");const{startPoint:e}=o,{p1:n,p2:r,p3:s}=o.segment;return new b({x:e[0],y:e[1]},{x:n[0],y:n[1]},{x:r[0],y:r[1]},{x:s[0],y:s[1]})}function kt(o,e){const n=[],r=o.halfEdge;let s=r;do{const c=e.halfEdges.get(s);if(!c){console.error(`Could not find half-edge with ID: ${s}`);break}let i=c.origin;if(c.segments&&c.segments.length>0)for(const a of c.segments)n.push({segment:a,startPoint:i,bbox:st(i,[a])}),i=a.type==="line"?a.p:a.p3;else{const a=e.halfEdges.get(c.next);if(!a){console.error(`Could not find next half-edge for ID: ${c.next}`);continue}const u={type:"line",p:a.origin};n.push({segment:u,startPoint:i,bbox:st(i,[u])})}s=c.next}while(s!==r);return n}function Pt(o,e,n){return new Promise(r=>{const s=[],c=o.segment.type,i=e.segment.type,a=.01;if(c==="bezier"&&i==="bezier"){const u=Z(o),f=Z(e);u.intersects(f).forEach(l=>{const x=l.split("/"),p=parseFloat(x[0]),d=parseFloat(x[1]);if(n&&(p>1-a&&d<a||p<a&&d>1-a))return;const g=u.get(p);s.push([g.x,g.y])})}else if(c==="bezier"||i==="bezier"){const u=c==="bezier"?o:e,f=c==="line"?o:e,h=Z(u),l={p1:{x:f.startPoint[0],y:f.startPoint[1]},p2:{x:f.segment.p[0],y:f.segment.p[1]}};h.intersects(l).forEach(p=>{if(n&&(p>1-a||p<a))return;const d=h.get(p);s.push([d.x,d.y])})}else{if(!n)return r(s);const u=o.startPoint,f=o.segment.p,h=e.startPoint,l=e.segment.p,[x,p]=u,[d,g]=f,[_,z]=h,[k,M]=l,q=(x-d)*(z-M)-(p-g)*(_-k);if(q!==0){const m=((x-_)*(z-M)-(p-z)*(_-k))/q,E=-((x-d)*(p-z)-(p-g)*(x-_))/q;if(m>=0&&m<=1&&E>=0&&E<=1){const v=x+m*(d-x),w=p+m*(g-p);s.push([v,w])}}}r(s)})}async function Tt(o,e){const n=[],c=Array.from(o.pieces.values()).length;let i=0;for(const a of o.pieces.values()){e?.(i,c);const u=kt(a,o),f=u.length;if(f<2){i++;continue}for(let h=0;h<f;h++)for(let l=h+1;l<f;l++){const x=u[h],p=u[l];if(!wt(x.bbox,p.bbox))continue;const d=l===h+1||h===0&&l===f-1,g=await Pt(x,p,d);if(g.length!==0)if(d){const _=h===0&&l===f-1?x.startPoint:At(x.segment);for(const z of g)it(z,_)>1e-8&&n.push(z)}else n.push(...g)}i++}return e?.(c,c),console.log(`detected ${n.length} intersections in ${o.pieces.size} pieces`),n}function qt(o){const e=[],n=new Set;for(const r of o.halfEdges.values())r.twin===-1&&n.add(r.origin);for(const r of o.vertices)Et(r,o.borderPath,n)||e.push(r);return e.length>0&&console.log(`detected ${e.length} vertices outside the boundary`),e}async function Ct(o,e){const n=await Tt(o,e),r=qt(o),s=[...n,...r];if(s.length<2)return s;const c=1,i=[s[0]];for(let a=1;a<s.length;a++){const u=s[a],f=i[i.length-1];it(u,f)>c*c&&i.push(u)}return i}self.onmessage=async o=>{try{const{topology:e}=o.data,n=zt(e),c={type:"done",results:await Ct(n,(i,a)=>{const u={type:"progress",processed:i,total:a};self.postMessage(u)})};self.postMessage(c)}catch(e){const n={type:"error",message:e instanceof Error?e.message:`An error occurred in the CheckGeometryWorker: ${String(e)}.`};self.postMessage(n)}finally{self.close()}}})();
//# sourceMappingURL=CheckGeometryWorker-B-2izMXZ.js.map
