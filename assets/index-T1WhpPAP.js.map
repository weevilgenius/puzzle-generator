{"version":3,"file":"index-T1WhpPAP.js","sources":["../../src/ui/GitHubCorner.ts","../../src/geometry/generators/Generator.ts","../../src/utils/mulberry.ts","../../src/geometry/PuzzleMaker.ts","../../src/ui/Puzzle.ts","../../src/utils/svg.ts","../../src/ui/DownloadPuzzleButton.ts","../../src/ui/UploadImageButton.ts","../../src/ui/inputs/BooleanInputControl.ts","../../src/ui/inputs/NumberInputControl.ts","../../src/ui/inputs/RangeInputControl.ts","../../src/ui/inputs/StringInputControl.ts","../../src/ui/GeneratorPicker.ts","../../src/ui/ColorPicker.ts","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/tiny-ndarray.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/sphere-random.js","../../node_modules/.pnpm/moore@1.0.0/node_modules/moore/index.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/neighbourhood.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/fixed-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/variable-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js","../../src/geometry/generators/point/PoissonPointGenerator.ts","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/delaunator@5.0.1/node_modules/delaunator/index.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/path.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/polygon.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/voronoi.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/delaunay.js","../../src/utils/UniqueId.ts","../../src/geometry/generators/piece/VoronoiPieceGenerator.ts","../../src/geometry/generators/tab/TraditionalTabGenerator.ts","../../src/geometry/generators/point/GridJitterPointGenerator.ts","../../src/geometry/generators/tab/NullTabGenerator.ts","../../src/geometry/generators/tab/TriangleTabGenerator.ts","../../src/index.ts"],"sourcesContent":["// SVG rendering the GitHub Octocat in a corner with a link\n// adapted from https://github.com/tholman/github-corners/\nimport m from 'mithril';\n\n// include our CSS\nimport './GitHubCorner.css';\n\n// component attributes\nexport interface GitHubCornerAttrs extends m.Attributes {\n  /** Url to use when clicked */\n  link: string;\n}\n\n// Mithril component\nexport const GitHubCorner: m.Component<GitHubCornerAttrs, unknown> = {\n\n  view: ({ attrs }) => {\n\n    return m(\"a.github-corner\", {\n      href: attrs.link,\n      \"aria-label\": \"View source on GitHub\",\n      title: \"View source on GitHub\",\n      target: \"_blank\",\n    }, m(\"svg\", {\n      width: 80,\n      height: 80,\n      viewBox: \"0 0 250 250\",\n      \"aria-hidden\": \"true\",\n    }, [\n      m('path', {\n        d: \"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\",\n      }),\n      m('path.octo-arm', {\n        fill: \"currentColor\",\n        style: \"transform-origin: 130px 106px;\",\n        d: \"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\",\n      }),\n      m('path.octo-body', {\n        fill: \"currentColor\",\n        d: \"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\",\n      }),\n    ]));\n  },\n\n};\nexport default GitHubCorner;\n","import type { GeneratorUIMetadata } from '../ui_types';\n\n/** The name of a particular generator implementation. Must be unique. */\nexport type GeneratorName = string;\n\n/** Base configuration for any generator */\nexport interface GeneratorConfig {\n  /** The name of the generator to which this config belongs */\n  name: GeneratorName;\n  /** The width of the puzzle in pixels */\n  width: number;\n  /** The height of the puzzle in pixels */\n  height: number;\n\n  // additional fields specific to this generator\n  [key: string]: unknown;\n}\n\n/**\n * A generic interface for a function that creates a configured generator instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type GeneratorFactory<T> = (options: any) => T;\n\n\ninterface RegisteredGenerator<T> {\n  factory: GeneratorFactory<T>;\n  uiMetadata: GeneratorUIMetadata;\n}\n\n/**\n * A generic registry for creating instances of generates from configurations.\n * This allows for a pluggable system where generators can be added dynamically.\n *\n * @template T The base interface for this type of generator, e.g. `TabGenerator`\n */\nexport class GeneratorRegistry<T> {\n  private generators = new Map<GeneratorName, RegisteredGenerator<T>>();\n\n  /**\n   * Registers a new generator factory associated with a specific generator type.\n   * Intended to be called from within each generator's implementation file.\n   * @param name The unique string identifier for the generator, e.g. \"TraditionalTabGenerator\"\n   * @param factory A function that takes an options object and returns a generator\n   * @param uiMetadata A description of the UI needed to configure the generator\n   */\n  public register(name: GeneratorName, factory: GeneratorFactory<T>, uiMetadata: GeneratorUIMetadata): void {\n    if (this.generators.has(name)) {\n      console.warn(`Generator \"${name}\" is already registered, overwriting`);\n    }\n    this.generators.set(name, { factory, uiMetadata });\n  }\n\n  /**\n   * Creates an instance of a generator based on the provided configuration object.\n   * It looks up the correct factory using the `name` property from the config.\n   * @param config A configuration object for the generator\n   * @returns A configured instance of the requested generator\n   */\n  public create(config: GeneratorConfig): T {\n    const generator = this.generators.get(config.name);\n    if (!generator) {\n      throw new Error(`Unknown generator \"${config.name}\". Is it registered?`);\n    }\n    return generator.factory(config);\n  }\n\n  /**\n   * Returns a list of all available generators for populating a selector UI.\n   * @returns An array of objects with the name and human-readable display name.\n   */\n  public getAvailableGenerators(): { name: GeneratorName, displayName: string }[] {\n    return Array.from(this.generators.values())\n      .sort((a, b) => a.uiMetadata.sortHint - b.uiMetadata.sortHint)\n      .map((g) => ({\n        name: g.uiMetadata.name,\n        displayName: g.uiMetadata.displayName,\n      }));\n  }\n\n  /**\n   * Retrieves the full UI metadata for a single generator.\n   * @param name The name of the generator.\n   * @returns The UI metadata object, or undefined if not found.\n   */\n  public getUIMetadata(name: GeneratorName): GeneratorUIMetadata | undefined {\n    return this.generators.get(name)?.uiMetadata;\n  }\n\n  /**\n   * Builds a default (empty) config object for a given generator.\n   * @param name The name of the generator.\n   * @param width The width of the puzzle\n   * @param height The height of the puzzle\n   * @returns Default config object for the given generator\n   */\n  public getDefaultConfig(name: GeneratorName, width: number, height: number): GeneratorConfig {\n    const newConfig: GeneratorConfig = {\n      name: name,\n      width: width,\n      height: height,\n    };\n\n    const metadata = this.getUIMetadata(name);\n    if (metadata) {\n      for (const control of metadata.controls) {\n        newConfig[control.name] = control.defaultValue;\n      }\n    }\n\n    return newConfig;\n\n  }\n}\n\n/* ========================================================= *\\\n *  Public registeries                                       *\n\\* ========================================================= */\n\n// Public registry for PointGenerators\nimport { PointGenerator } from \"./point/PointGenerator\";\nexport const PointGeneratorRegistry = new GeneratorRegistry<PointGenerator>();\n\n// Public registry for PieceGenerators\nimport { PieceGenerator } from \"./piece/PieceGenerator\";\nexport const PieceGeneratorRegistry = new GeneratorRegistry<PieceGenerator>();\n\n// Public registry for TabGenerators\nimport { TabGenerator } from \"./tab/TabGenerator\";\nexport const TabGeneratorRegistry = new GeneratorRegistry<TabGenerator>();\n","\n/**\n * Simple seeded PRNG. The state space is 32 bits, so the period (the point at\n * which random numbers repeat for the same seed) is 2^32.\n * See https://github.com/cprosche/mulberry32 for more details.\n * @param seed seed number\n * @returns function which returns a random number each time it is called\n */\nexport function mulberry32(seed: number) {\n  return function() {\n    let t = seed += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nexport default mulberry32;\n","import type { PuzzleGeometry, PuzzleTopology, Vec2 } from \"./types\";\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabGeneratorRegistry, type GeneratorConfig } from \"./generators/Generator\";\nimport mulberry32 from \"../utils/mulberry\";\n\n/**\n * Configuration options for the entire puzzle generation process.\n */\nexport interface PuzzleGenerationOptions {\n  /** Width of the puzzle */\n  width: number;\n  /** Height of the puzzle */\n  height: number;\n  /** A rough guide for piece size */\n  pieceSize: number;\n  /** Random seed to produce repeatable puzzles */\n  seed?: number;\n  /** How shoule the points that control the pieces get generated? */\n  pointConfig: GeneratorConfig;\n  /** How should the pieces get built? */\n  pieceConfig: GeneratorConfig;\n  /** How should tabs get constructed? */\n  tabConfig: GeneratorConfig;\n}\n\n/**\n * Orchestrates the procedural generation of a jigsaw puzzle\n * by coordinating various pluggable generators.\n */\nexport async function buildPuzzle(options: PuzzleGenerationOptions): Promise<PuzzleGeometry> {\n  const { width, height, pieceSize } = options;\n  const { pointConfig, pieceConfig, tabConfig } = options;\n\n\n  // get and configure the necessary generators\n  const pointGenerator = PointGeneratorRegistry.create(pointConfig);\n  const pieceGenerator = PieceGeneratorRegistry.create(pieceConfig);\n  const tabGenerator = TabGeneratorRegistry.create(tabConfig);\n\n  // seeded PRNG used to generate repeatable random numbers\n  const seed = options.seed ?? new Date().getTime();\n  const random = mulberry32(seed);\n\n  // 1. Generate seed points for the pieces\n  const points = pointGenerator.generatePoints({ width, height, pieceSize, random });\n  console.log(`Generated ${points.length} points`);\n\n  // 2. Convert points to a puzzle topology (pieces and edges)\n  const topology = pieceGenerator.generatePieces(points, { random });\n  console.log(`Generated ${topology.pieces.size} pieces`);\n\n  // 3. Decorate internal edges with tabs\n  for (const edge of topology.edges.values()) {\n    // Only add tabs to internal edges (those with a left and right piece)\n    const isInternal = edge.heRight !== -1;\n    if (isInternal) {\n      tabGenerator.addTab(edge, { topology, random });\n    }\n  }\n\n  // 4. Assemble and return the final puzzle data structure\n  const puzzle: PuzzleGeometry = {\n    created: new Date().toISOString(),\n    seed: seed,\n    vertices: topology.vertices,\n    boundary: topology.boundary,\n    pieces: topology.pieces,\n    edges: topology.edges,\n    halfEdges: topology.halfEdges,\n  };\n\n  return Promise.resolve(puzzle);\n}\n\n/** Draws puzzle geometry onto a canvas */\nexport function drawPuzzle(topology: PuzzleTopology, canvas: HTMLCanvasElement, pieceColor: string, showPoints = false) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error(\"Could not get 2D context from canvas\");\n    return;\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Style for piece boundaries\n  ctx.strokeStyle = pieceColor;\n  ctx.lineWidth = 1;\n\n  // it's more efficient to batch all paths together\n  ctx.beginPath();\n\n  // By iterating through all unique edges and drawing the curve for one of\n  // its half-edges, we ensure every cut is defined exactly once.\n  for (const edge of topology.edges.values()) {\n    // We consistently choose heLeft. The tab generator puts the \"outie\"\n    // or \"innie\" on this half-edge, and the twin gets the inverse.\n    const he = topology.halfEdges.get(edge.heLeft);\n    if (!he) continue; // should not happen\n\n    // move to the start of this edge segment\n    ctx.moveTo(he.origin[0], he.origin[1]);\n\n    if (he.segments) {\n      // if a custom tab is defined, draw each segment in order\n      for (const segment of he.segments) {\n        switch (segment.type) {\n        case 'bezier':\n          ctx.bezierCurveTo(\n            segment.p1[0], segment.p1[1],\n            segment.p2[0], segment.p2[1],\n            segment.p3[0], segment.p3[1]\n          );\n          break;\n        case 'line':\n          ctx.lineTo(segment.p[0], segment.p[1]);\n          break;\n        }\n      }\n    } else {\n      // no tab, draw a straight line to the edge's endpoint.\n      // The end point of a half-edge is the origin of its twin.\n      // For boundary edges, the twin is -1, so we find the end point\n      // by looking at the start of the next half-edge around the piece.\n      let destination: Vec2;\n      // For an internal edge, the destination is the origin of the twin half-edge.\n      if (he.twin !== -1) {\n        const twinHe = topology.halfEdges.get(he.twin)!;\n        destination = twinHe.origin;\n      } else {\n        // For a boundary edge, the destination is the origin of the next half-edge in the loop.\n        const nextHe = topology.halfEdges.get(he.next)!;\n        destination = nextHe.origin;\n      }\n      ctx.lineTo(destination[0], destination[1]);\n    }\n  }\n\n  // stroke the entire path containing all the unique puzzle edges\n  ctx.stroke();\n\n  // draw the piece sites (original Voronoi points) for reference\n  if (showPoints) {\n    ctx.fillStyle = 'red';\n    for (const piece of topology.pieces.values()) {\n      const [x, y] = piece.site;\n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n}\n","import m from 'mithril';\nimport { drawPuzzle } from \"../geometry/PuzzleMaker\";\nimport type { PuzzleGeometry } from '../geometry/types';\n\n// include our CSS\nimport './Puzzle.css';\n\n// component attributes\nexport interface PuzzleAttrs extends m.Attributes {\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Generated puzzle geometry */\n  puzzle: PuzzleGeometry,\n  /** User uploaded image */\n  imageUrl?: string;\n}\n\n// Mithril component\nexport const Puzzle: m.ClosureComponent<PuzzleAttrs> = () => {\n\n  // component state\n  const state = {\n    /** Canvas HTML element */\n    canvas: null as HTMLCanvasElement | null,\n  };\n\n  return {\n    // component lifecycle: called after our DOM element is created and attached\n    oncreate: ({ dom, attrs }) => {\n      state.canvas = dom.querySelector<HTMLCanvasElement>(\"canvas.puzzle\");\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      drawPuzzle(attrs.puzzle, state.canvas, attrs.color);\n    },\n\n    onupdate: ({ attrs }) => {\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      drawPuzzle(attrs.puzzle, state.canvas, attrs.color);\n    },\n\n    // component lifecycle: render our output\n    view: ({ attrs }) => {\n\n      return m(\".puzzle-stack\", [\n        // user uploaded image\n        m(\"img.background\", {\n          width: attrs.width,\n          height: attrs.height,\n          src: attrs.imageUrl,\n        }),\n        // canvas for rendering the current puzzle\n        m('canvas.puzzle', {\n          width: attrs.width,\n          height: attrs.height,\n        }),\n      ]);\n    },\n\n  };\n};\nexport default Puzzle;\n\n","import { PuzzleTopology, Vec2 } from \"../geometry/types\";\n\n/**\n * Generates an SVG string representation of the puzzle's cut lines.\n *\n * @param topology - The puzzle topology containing the geometric data.\n * @param width - The width of the SVG viewport.\n * @param height - The height of the SVG viewport.\n * @param pieceColor - Optional color to draw the pieces (default black)\n * @returns A string containing the complete SVG markup.\n */\nexport function createSVG(topology: PuzzleTopology, width: number, height: number, pieceColor = \"black\"): string {\n  // how many digits to preserve when converting decimal numbers to SVG string\n  const precisionDigits = 3;\n\n  // Array to hold the individual path commands (e.g., \"M 10 10\", \"L 100 100\").\n  const pathData: string[] = [];\n\n  // Iterate over each unique edge, ensuring each cut is only defined once.\n  for (const edge of topology.edges.values()) {\n    const he = topology.halfEdges.get(edge.heLeft);\n    if (!he) continue;\n\n    // SVG Path Command: \"M\" - move to the starting point of the half-edge.\n    pathData.push(`M ${he.origin[0].toFixed(precisionDigits)} ${he.origin[1].toFixed(precisionDigits)}`);\n\n    if (he.segments) {\n      // if a custom tab is defined, draw each segment in order\n      for (const segment of he.segments) {\n        switch (segment.type) {\n        case 'bezier':\n          // SVG Path Command: \"C\" - draw a cubic Bézier curve.\n          pathData.push(\n            `C ${segment.p1[0].toFixed(precisionDigits)} ${segment.p1[1].toFixed(precisionDigits)}, ` +\n            `${segment.p2[0].toFixed(precisionDigits)} ${segment.p2[1].toFixed(precisionDigits)}, ` +\n            `${segment.p3[0].toFixed(precisionDigits)} ${segment.p3[1].toFixed(precisionDigits)}`\n          );\n          break;\n        case 'line':\n          // SVG Path Command: \"L\" - draw a straight line to the destination.\n          pathData.push(`L ${segment.p[0].toFixed(precisionDigits)} ${segment.p[1].toFixed(precisionDigits)}`);\n          break;\n        }\n      }\n    } else {\n      // SVG Path Command: \"L\" - draw a straight line to the destination.\n      let destination: Vec2;\n      if (he.twin !== -1) {\n        // Internal edge: destination is the start of the twin half-edge.\n        const twinHe = topology.halfEdges.get(he.twin)!;\n        destination = twinHe.origin;\n      } else {\n        // Boundary edge: destination is the start of the next half-edge.\n        const nextHe = topology.halfEdges.get(he.next)!;\n        destination = nextHe.origin;\n      }\n      pathData.push(`L ${destination[0].toFixed(precisionDigits)} ${destination[1].toFixed(precisionDigits)}`);\n    }\n  }\n\n  // Join all path commands into a single string for the 'd' attribute.\n  const pathD = pathData.join(' ');\n\n  // Construct the final SVG markup.\n  // The <path> element uses vector-effect=\"non-scaling-stroke\" which is a best\n  // practice for laser cutting files, as it ensures the line width remains\n  // constant regardless of scaling.\n  const svgString = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg\n  width=\"${width}\"\n  height=\"${height}\"\n  viewBox=\"0 0 ${width} ${height}\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  version=\"1.1\"\n>\n  <path\n    d=\"${pathD}\"\n    fill=\"none\"\n    stroke=\"${pieceColor}\"\n    stroke-width=\"1\"\n    vector-effect=\"non-scaling-stroke\"\n  />\n</svg>`\n    .trim() // strip leading and trailing whitespace\n    .replace(/\\r\\n/g, '\\n'); // use unix line endings for max compatibility\n\n  return svgString;\n}\n\n\n/**\n * Offers a SVG file for download\n * @param svg SVG string as generated by drawSVG()\n * @param filename Optional name of file for download\n */\nexport function downloadSvg(svg: string, filename = \"puzzle.svg\") {\n  // create a blob from the SVG string\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n\n  // create a temporary object URL for the blob\n  const url = URL.createObjectURL(blob);\n\n  // create a hidden <a> element with the download attribute\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  a.hidden = true;\n\n  // click it\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n\n  // clean up\n  setTimeout(() => URL.revokeObjectURL(url), 100);\n}\n","// UI component that offers a SVG download when clicked\nimport m from 'mithril';\nimport { createSVG, downloadSvg } from '../utils/svg';\nimport type { PuzzleTopology } from '../geometry/types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/button/button.js';\n\nexport interface DownloadPuzzleButtonAttrs extends m.Attributes {\n  /** Generated puzzle geometry */\n  puzzle: PuzzleTopology;\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Optional filename for the download */\n  filename?: string;\n}\n\nexport const DownloadPuzzleButton: m.Component<DownloadPuzzleButtonAttrs> = {\n  view: ({ attrs }) => {\n    return m('sl-button.download-svg', {\n      onclick: () => {\n        // convert the puzzle geometry into a SVG string\n        const svg = createSVG(attrs.puzzle, attrs.width, attrs.height, attrs.color);\n        // offer it as a download\n        downloadSvg(svg, attrs.filename ?? 'puzzle.svg');\n      },\n    }, 'Download SVG');\n  },\n};\nexport default DownloadPuzzleButton;\n","// UI component that allows the user to select an image to upload when clicked\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/button/button.js';\n\n// component attributes\nexport interface UploadImageAttrs extends m.Attributes {\n  /** Optional label for the button, default \"Upload Image\" */\n  label?: string;\n  /** If true, the button will be disabled */\n  disabled?: boolean;\n  /**\n   * Called when the user uploads an image. The caller is responsible for\n   * cleaning up the returned image URL.\n   */\n  onUpload: (imageUrl: string, filename: string) => void;\n};\n\n// component\nexport const UploadImageButton: m.ClosureComponent<UploadImageAttrs> = () => {\n\n  // component state\n  const state = {\n    inputElement: undefined as HTMLInputElement | undefined,\n  };\n\n  return {\n\n    view: ({ attrs }) => {\n      return [\n\n        // button for display\n        m('sl-button.upload-button', {\n          disabled: attrs.disabled === true,\n          onclick: () => {\n            if (state.inputElement) {\n              state.inputElement.click();\n            }\n          },\n        }, attrs.label ?? 'Upload Image'),\n\n        // hidden file input that does the work\n        m('input[type=file]', {\n          style: { display: 'none' },\n          accept: 'image/*',\n          oncreate: ({ dom }) => {\n            state.inputElement = dom as HTMLInputElement;\n          },\n          onchange: (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            if (state.inputElement) {\n              const file = state.inputElement.files?.[0];\n              if (file?.type.startsWith('image/')) {\n                const uploadUrl = URL.createObjectURL(file);\n                attrs.onUpload(uploadUrl, file.name);\n              }\n            }\n          },\n        }),\n      ];\n    },\n  };\n};\nexport default UploadImageButton;\n","// UI component to take boolean input\nimport m from 'mithril';\nimport type { BooleanUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/checkbox/checkbox.js';\nimport type { SlCheckbox } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface BooleanInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: BooleanUIControl;\n  /** Current value */\n  value: boolean;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: boolean) => void;\n}\n\n// component\nexport const BooleanInputControl: m.ClosureComponent<BooleanInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-checkbox.boolean-input', {\n        \"help-text\": attrs.config.helpText,\n        disabled: attrs.disabled,\n        checked: attrs.value,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlCheckbox;\n          const newValue = input.checked;\n          attrs.onChange(newValue);\n        },\n      }, attrs.config.label);\n    },\n  };\n};\nexport default BooleanInputControl;\n","// UI component to take a number input\nimport m from 'mithril';\nimport type { NumberUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/input/input.js';\nimport type { SlInput } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface NumberInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: NumberUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const NumberInputControl: m.ClosureComponent<NumberInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-input.number-input', {\n        label: attrs.config.label,\n        \"help-text\": attrs.config.helpText,\n        type: \"number\",\n        inputmode: \"numeric\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlInput;\n          const newValue = input.valueAsNumber;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default NumberInputControl;\n","// UI component to take number input from a slider\nimport m from 'mithril';\nimport type { RangeUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/range/range.js';\nimport type { SlRange } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface RangeInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: RangeUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const RangeInputControl: m.ClosureComponent<RangeInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-range.range-input', {\n        label: attrs.config.label,\n        \"help-text\": attrs.config.helpText,\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        step: attrs.config.step,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlRange;\n          const newValue = input.value;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default RangeInputControl;\n","// UI component to take string input\nimport m from 'mithril';\nimport type { StringUIControl } from '../../geometry/ui_types';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/input/input.js';\nimport type { SlInput } from '@shoelace-style/shoelace';\n\n// component attributes\nexport interface StringInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: StringUIControl;\n  /** Current value */\n  value?: string;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: string | undefined) => void;\n}\n\n// component\nexport const StringInputControl: m.ClosureComponent<StringInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Shoelace for the heavy lifting\n      return m('sl-input.string-input', {\n        label: attrs.config.label,\n        \"help-text\": attrs.config.helpText,\n        type: \"text\",\n        inputmode: \"text\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        'onsl-change': (e: Event) => {\n          const input = e.target as SlInput;\n          const newValue = input.value;\n          attrs.onChange(newValue.length > 0 ? newValue : undefined);\n        },\n      });\n    },\n  };\n};\nexport default StringInputControl;\n","// UI component that lets the user pick and configure a generator\nimport m from 'mithril';\nimport type { GeneratorRegistry, GeneratorConfig, GeneratorName } from '../geometry/generators/Generator';\nimport BooleanInputControl from './inputs/BooleanInputControl';\nimport NumberInputControl from './inputs/NumberInputControl';\nimport RangeInputControl from './inputs/RangeInputControl';\nimport StringInputControl from './inputs/StringInputControl';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/tab/tab.js';\nimport '@shoelace-style/shoelace/dist/components/tab-group/tab-group.js';\nimport '@shoelace-style/shoelace/dist/components/tab-panel/tab-panel.js';\nimport type { SlTabShowEvent, SlTabGroup } from '@shoelace-style/shoelace';\n\n\n// include our CSS\nimport './GeneratorPicker.css';\n\n// component attributes\nexport interface GeneratorPickerAttrs<C extends GeneratorConfig = GeneratorConfig> extends m.Attributes {\n  /** Currently selected generator for this type */\n  generator: GeneratorName;\n  /** All the registered generators for this type */\n  registry: GeneratorRegistry<unknown>;\n  /** Current configuration for the selected generator */\n  config: C;\n  /** Called when the selected generator changes */\n  onGeneratorChange: (generatorName: string) => void;\n  /** Called when any config value changes */\n  onConfigChange: <K extends keyof C>(key: K, value: C[K]) => void;\n}\n\n// component\nexport const GeneratorPicker: m.ClosureComponent<GeneratorPickerAttrs> = () => {\n\n  // no component state\n\n  // component\n  return {\n    oncreate: ({ dom, attrs }) => {\n      const tabGroup = dom.querySelector('sl-tab-group') as SlTabGroup;\n      tabGroup.show(attrs.generator);\n    },\n\n    onupdate: ({ dom, attrs }) => {\n      const tabGroup = dom.querySelector('sl-tab-group') as SlTabGroup;\n      tabGroup.show(attrs.generator);\n    },\n\n    view: ({ attrs }) => {\n\n      const generators = attrs.registry.getAvailableGenerators();\n\n      return m(\".generator-picker\",\n        m('sl-tab-group', {\n          // custom Shoelace event triggered when a new tab panel is shown\n          'onsl-tab-show': (e: SlTabShowEvent) => {\n            const newSelected = e.detail.name;\n            if (attrs.generator !== newSelected) {\n              attrs.onGeneratorChange(newSelected);\n            }\n          },\n        }, [\n          ...generators.map((generator) => {\n            // get the UI metadata associated with this generator\n            const uiMetadata = attrs.registry.getUIMetadata(generator.name);\n\n            // tab contains name of generator\n            const tab = m('sl-tab', {\n              slot: \"nav\",\n              panel: generator.name,\n            }, generator.displayName);\n\n            // matching panel contains controls specific to that generator\n            const panel = m('sl-tab-panel', {\n              name: generator.name,\n            }, m('.controls',\n              [\n                // detailed description of the generator if available\n                uiMetadata?.description ? m('p', uiMetadata.description) : null,\n\n                // UI controls defined by the generator\n                ...uiMetadata?.controls.map((control) => {\n                  switch(control.type) {\n                  case \"range\":\n                    return m(RangeInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"boolean\":\n                    return m(BooleanInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) === true,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"number\":\n                    return m(NumberInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"string\":\n                    return m(StringInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as string | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  }\n                }) ?? [],\n\n                // no controls message when appropriate\n                (!uiMetadata?.description && uiMetadata?.controls.length == 0) ? m('p', 'No controls for this strategy.') : null,\n              ])\n            );\n            return [tab, panel];\n          }),\n        ])\n      );\n    },\n  };\n};\nexport default GeneratorPicker;\n","// UI component to let the user select a color\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Shoelace components\nimport '@shoelace-style/shoelace/dist/components/color-picker/color-picker.js';\nimport type { SlColorPicker } from '@shoelace-style/shoelace';\n\n// this component's CSS\nimport './ColorPicker.css';\n\n// component attributes\nexport interface ColorPickerAttrs extends m.Attributes {\n  /** Label to display next to the color picker */\n  label: string;\n  /** Current color */\n  color: string;\n  /** Optional size of picker trigger area */\n  size?: \"small\" | \"medium\" | \"large\";\n  /** Called when the user changes the color */\n  onUpdate: (newColor: string) => void;\n};\n\n// component with no state\nexport const ColorPicker: m.Component<ColorPickerAttrs> = {\n  view: ({ attrs }) => {\n    return m('.color-picker', [\n      m('.label', attrs.label),\n      m('sl-color-picker', {\n        label: 'Select a color', // used by assistive devices\n        value: attrs.color,\n        size: attrs.size ?? \"medium\",\n        format: 'rgb',\n        'onsl-change': (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const input = e.target as SlColorPicker;\n          attrs.onUpdate(input.value);\n        },\n      }),\n    ]);\n  },\n};\nexport default ColorPicker;\n","\"use strict\";\n\nfunction tinyNDArrayOfInteger (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        dimension;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    return {\n        stride: stride,\n        data: new Uint32Array(totalLength)\n    };\n}\n\nfunction tinyNDArrayOfArray (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        data = [],\n        dimension, index;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    for (index = 0; index < totalLength; index++) {\n        data.push([]);\n    }\n\n    return {\n        stride: stride,\n        data: data\n    };\n}\n\nmodule.exports = {\n    integer: tinyNDArrayOfInteger,\n    array: tinyNDArrayOfArray\n};","\"use strict\";\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n","module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n","\"use strict\";\n\nvar moore = require('moore');\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    // filter out neighbours who are too far from the center cell\n    // the impact of this, performance wise, is surprisingly small, even in 3d and higher dimensions\n    neighbourhood = neighbourhood.filter(function (n) {\n        var dist = 0;\n\n        for (var d = 0; d < dimensionNumber; d++) {\n            dist += Math.pow(Math.max(0, Math.abs(n[d]) - 1), 2);\n        }\n\n        return dist < dimensionNumber; // cellSize = Math.sqrt(this.dimension)\n    });\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0,\n            dimension;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n}\n\nvar neighbourhoodCache = {};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhoodMemoized (dimensionNumber) {\n    if (!neighbourhoodCache[dimensionNumber]) {\n        neighbourhoodCache[dimensionNumber] = getNeighbourhood(dimensionNumber);\n    }\n\n    return neighbourhoodCache[dimensionNumber];\n}\n\nmodule.exports = getNeighbourhoodMemoized;","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').integer,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nfunction squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n}\n\n/**\n * FixedDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction FixedDensityPDS (options, rng) {\n    if (typeof options.distanceFunction === 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.squaredMinDistance = this.minDistance * this.minDistance;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.minDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints\n}\n\nFixedDensityPDS.prototype.shape = null;\nFixedDensityPDS.prototype.dimension = null;\nFixedDensityPDS.prototype.minDistance = null;\nFixedDensityPDS.prototype.maxDistance = null;\nFixedDensityPDS.prototype.minDistancePlusEpsilon = null;\nFixedDensityPDS.prototype.squaredMinDistance = null;\nFixedDensityPDS.prototype.deltaDistance = null;\nFixedDensityPDS.prototype.cellSize = null;\nFixedDensityPDS.prototype.maxTries = null;\nFixedDensityPDS.prototype.rng = null;\nFixedDensityPDS.prototype.neighbourhood = null;\n\nFixedDensityPDS.prototype.currentPoint = null;\nFixedDensityPDS.prototype.processList = null;\nFixedDensityPDS.prototype.samplePoints = null;\nFixedDensityPDS.prototype.gridShape = null;\nFixedDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nFixedDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nFixedDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nFixedDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nFixedDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nFixedDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will always throw an error.\n */\nFixedDensityPDS.prototype.getAllPointsWithDistance = function () {\n    throw new Error('PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation');\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nFixedDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = FixedDensityPDS;\n","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').array,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Euclidean distance\n */\nfunction euclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return Math.sqrt(result);\n}\n\n/**\n * VariableDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function} options.distanceFunction Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {float} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} rng RNG function, defaults to Math.random\n * @constructor\n */\nfunction VariableDensityPDS (options, rng) {\n    if (typeof options.distanceFunction !== 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n    this.distanceFunction = options.distanceFunction;\n    this.bias = Math.max(0, Math.min(1, options.bias || 0));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.maxDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.currentDistance = 0;\n    this.processList = [];\n    this.samplePoints = [];\n    this.sampleDistance = []; // used to store the distance for a given point\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints and sampleDistance\n}\n\nVariableDensityPDS.prototype.shape = null;\nVariableDensityPDS.prototype.dimension = null;\nVariableDensityPDS.prototype.minDistance = null;\nVariableDensityPDS.prototype.maxDistance = null;\nVariableDensityPDS.prototype.minDistancePlusEpsilon = null;\nVariableDensityPDS.prototype.deltaDistance = null;\nVariableDensityPDS.prototype.cellSize = null;\nVariableDensityPDS.prototype.maxTries = null;\nVariableDensityPDS.prototype.distanceFunction = null;\nVariableDensityPDS.prototype.bias = null;\nVariableDensityPDS.prototype.rng = null;\nVariableDensityPDS.prototype.neighbourhood = null;\n\nVariableDensityPDS.prototype.currentPoint = null;\nVariableDensityPDS.prototype.currentDistance = null;\nVariableDensityPDS.prototype.processList = null;\nVariableDensityPDS.prototype.samplePoints = null;\nVariableDensityPDS.prototype.sampleDistance = null;\nVariableDensityPDS.prototype.gridShape = null;\nVariableDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nVariableDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nVariableDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nVariableDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        pointIndex = this.samplePoints.length,\n        dimension;\n\n    this.processList.push(pointIndex);\n    this.samplePoints.push(point);\n    this.sampleDistance.push(this.distanceFunction(point));\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex].push(pointIndex); // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nVariableDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint,\n        existingPointDistance;\n\n    var pointDistance = this.distanceFunction(point);\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex].length > 0) {\n            for (var i = 0; i < this.grid.data[internalArrayIndex].length; i++) {\n                existingPoint = this.samplePoints[this.grid.data[internalArrayIndex][i]];\n                existingPointDistance = this.sampleDistance[this.grid.data[internalArrayIndex][i]];\n\n                var minDistance = Math.min(existingPointDistance, pointDistance);\n                var maxDistance = Math.max(existingPointDistance, pointDistance);\n                var dist = minDistance + (maxDistance - minDistance) * this.bias;\n\n                if (euclideanDistance(point, existingPoint) < this.minDistance + this.deltaDistance * dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nVariableDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        currentDistance,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            var sampleIndex = this.processList.shift();\n            this.currentPoint = this.samplePoints[sampleIndex];\n            this.currentDistance = this.sampleDistance[sampleIndex];\n        }\n\n        currentPoint = this.currentPoint;\n        currentDistance = this.currentDistance;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * (currentDistance + (1 - currentDistance) * this.bias);\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @returns {Array[]} Sample points with their distance function result\n */\nVariableDensityPDS.prototype.getAllPointsWithDistance = function () {\n    var result = new Array(this.samplePoints.length),\n        i = 0,\n        dimension = 0,\n        point;\n\n    for (i = 0; i < this.samplePoints.length; i++) {\n        point = new Array(this.dimension + 1);\n\n        for (dimension = 0; dimension < this.dimension; dimension++) {\n            point[dimension] = this.samplePoints[i][dimension];\n        }\n\n        point[this.dimension] = this.sampleDistance[i];\n\n        result[i] = point;\n    }\n\n    return result;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nVariableDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = [];\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = VariableDensityPDS;\n","\"use strict\";\n\nvar FixedDensityPDS = require('./implementations/fixed-density');\nvar VariableDensityPDS = require('./implementations/variable-density');\n\n/**\n * PoissonDiskSampling constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [options.distanceFunction] Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {function|null} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction PoissonDiskSampling (options, rng) {\n    this.shape = options.shape;\n\n    if (typeof options.distanceFunction === 'function') {\n        this.implementation = new VariableDensityPDS(options, rng);\n    } else {\n        this.implementation = new FixedDensityPDS(options, rng);\n    }\n}\n\nPoissonDiskSampling.prototype.implementation = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    return this.implementation.addRandomPoint();\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    return this.implementation.addPoint(point);\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    return this.implementation.next();\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    return this.implementation.fill();\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.implementation.getAllPoints();\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will throw an error if a distance function was not provided to the constructor.\n * @returns {Array[]} Sample points with their distance function result\n */\nPoissonDiskSampling.prototype.getAllPointsWithDistance = function () {\n    return this.implementation.getAllPointsWithDistance();\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    this.implementation.reset();\n};\n\nmodule.exports = PoissonDiskSampling;\n","import PoissonDiskSampling from 'poisson-disk-sampling';\nimport type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype PoissonPointGeneratorName = \"PoissonPointGenerator\";\nexport const Name: PoissonPointGeneratorName = \"PoissonPointGenerator\";\n\n/** Required config for this generator */\nexport interface PoissonPointGeneratorConfig extends GeneratorConfig {\n  name: PoissonPointGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const PoissonPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Poisson\",\n  description: \"Generate seed points using Poisson disk sampling. \" +\n    \"The algorithm produces points that are tightly-packed, but no closer to \" +\n    \"each other than a specified minimum distance (the piece size), resulting \" +\n    \"in a more natural, organic look.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A point generator that uses Poisson disk sampling to create a more organic\n * distribution of random points. `pieceSize` is interpreted as the minimum\n * distance between generated points.\n */\nexport const PoissonPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_config: PoissonPointGeneratorConfig) => {\n  const PoissonPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      // generate points randomly in a Poisson disk sampling\n      const poisson = new PoissonDiskSampling(\n        {\n          shape: [width, height], // clamps generated points within bounds\n          minDistance: pieceSize,\n          tries: 20,\n        },\n        random\n      );\n\n      // have to cast because @types/PoissonDiskSampling is not correct for fill()\n      const points = poisson.fill() as unknown as Vec2[];\n      return points;\n    },\n  };\n  return PoissonPointGenerator;\n};\nexport default PoissonPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, PoissonPointGeneratorFactory, PoissonPointUIMetadata);\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const {delaunay: {points, hull, triangles}, vectors} = this;\n    let bx, by; // lazily computed barycenter of the hull\n\n    // Compute circumcenters.\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const ex = x3 - x1;\n      const ey = y3 - y1;\n      const ab = (dx * ey - dy * ex) * 2;\n\n      if (Math.abs(ab) < 1e-9) {\n        // For a degenerate triangle, the circumcenter is at the infinity, in a\n        // direction orthogonal to the halfedge and away from the “center” of\n        // the diagram <bx, by>, defined as the hull’s barycenter.\n        if (bx === undefined) {\n          bx = by = 0;\n          for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];\n          bx /= hull.length, by /= hull.length;\n        }\n        const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);\n        x = (x1 + x3) / 2 - a * ey;\n        y = (y1 + y3) / 2 + a * ex;\n      } else {\n        const d = 1 / ab;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x = x1 + (ey * bl - dy * cl) * d;\n        y = y1 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x;\n      circumcenters[j + 1] = y;\n    }\n\n    // Compute exterior cell rays.\n    let h = hull[hull.length - 1];\n    let p0, p1 = h * 4;\n    let x0, x1 = points[2 * h];\n    let y0, y1 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull.length; ++i) {\n      h = hull[i];\n      p0 = p1, x0 = x1, y0 = y1;\n      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;\n    if (hull.length <= 1) return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull[hull.length - 1];\n    for (let i = 0; i < hull.length; ++i) {\n      h0 = h1, h1 = hull[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = h0 * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null || !points.length) return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;\n    for (let i = 2; i < n; i += 2) {\n      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])\n        context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) cell.index = i, yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci) for (const j of this.delaunay.neighbors(i)) {\n      const cj = this._clip(j);\n      // find the common edge\n      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n          if (ci[ai] === cj[aj]\n              && ci[ai + 1] === cj[aj + 1]\n              && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]\n              && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {\n            yield j;\n            break loop;\n          }\n        }\n      }\n    }\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    // degenerate case (1 valid point: return the box)\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return this._simplify(V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points));\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    // for more robustness, always consider the segment in the same order\n    const flip = c0 < c1;\n    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];\n    while (true) {\n      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n      // undefined, the conditional statement will be executed.\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n  _simplify(P) {\n    if (P && P.length > 4) {\n      for (let i = 0; i < P.length; i+= 2) {\n        const j = (i + 2) % P.length, k = (i + 4) % P.length;\n        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n          P.splice(j, 2), i -= 2;\n        }\n      }\n      if (!P.length) P = null;\n    }\n    return P;\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n","\nexport type UniqueId = number;\n\nlet id = 0;\nexport function getUniqueId(): UniqueId {\n  return id++;\n}\n","import { Delaunay } from 'd3-delaunay';\nimport { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  AABB,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { getUniqueId } from '../../../utils/UniqueId';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\nexport const Name: VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\n\n/** Required config for this generator */\nexport interface VoronoiPieceGeneratorConfig extends GeneratorConfig {\n  name: VoronoiPieceGeneratorName;\n  // no special config\n}\n\n/** UI metadata needed for this generator */\nexport const VoronoiPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Voronoi\",\n  description: \"Construct pieces by building a Voronoi diagram from the seed points. \" +\n    \"Each piece consists of all points of the plane closer to that seed point than \" +\n    \"any other seed point. In practice, this creates polygons with 3-8 sides.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a given polygon.\n * @param polygon - An array of vertices representing the polygon.\n * @returns The AABB as `[xmin, ymin, xmax, ymax]`. Returns a zero-area\n * box at the origin if the polygon is empty.\n */\nfunction calculateBoundingBox(polygon: Vec2[]): AABB {\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = polygon[0][0];\n  let minY = polygon[0][1];\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 1; i < polygon.length; i++) {\n    const p = polygon[i];\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n\n/**\n * Links the `next` and `prev` properties of a circular list of half-edges for a single piece.\n * @param ids The array of half-edge IDs belonging to a piece.\n * @param map The map containing all half-edge objects.\n */\nfunction linkPieceHalfEdges(ids: HalfEdgeID[], map: Map<HalfEdgeID, HalfEdge>): void {\n  const len = ids.length;\n  for (let i = 0; i < len; i++) {\n    const he = map.get(ids[i])!;\n    he.next = ids[(i + 1) % len];\n    he.prev = ids[(i - 1 + len) % len];\n  }\n}\n\n/**\n * Creates a consistent string key for a point, handling floating point inaccuracies.\n * @param p The point.\n * @returns A string key.\n */\nfunction pointToKey(p: Vec2): string {\n  return `${p[0].toPrecision(7)},${p[1].toPrecision(7)}`;\n}\n\n/**\n * Checks if two points are effectively at the same location.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns `true` if points are equal.\n */\nfunction arePointsEqual(p1: Vec2, p2: Vec2): boolean {\n  return Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6;\n}\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const VoronoiPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (config: VoronoiPieceGeneratorConfig) => {\n  const { width, height } = config;\n  const VoronoiPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param points The seed points for the centers of the puzzle pieces.\n     * @param _runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(points: Vec2[], _runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n\n      // Note: Lloyd's relaxation could be performed here to create more uniform\n      // piece shapes. This would involve creating the Voronoi diagram, calculating\n      // the centroid of each cell, moving the input point to that centroid, and\n      // repeating for a number of iterations before proceeding.\n\n      // 1. Generate Voronoi diagram from points, clipped to the puzzle bounds.\n      const delaunay = Delaunay.from(points);\n      const voronoi = delaunay.voronoi([0, 0, width, height]);\n\n      // 2. Initialize data structures for the topology.\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n      };\n\n      // A map to find a half-edge's twin, keyed by its start and end vertex coordinates.\n      const halfEdgeEndpointMap = new Map<string, HalfEdgeID>();\n\n      // 3. First pass: Create Piece and HalfEdge objects for each cell.\n      // At this stage, the half-edges are not yet linked (next, prev, twin).\n      for (let i = 0; i < points.length; i++) {\n        const site = points[i];\n        const polygon = voronoi.cellPolygon(i);\n\n        if (!polygon) continue;\n\n        const piece: Piece = {\n          id: i,\n          site,\n          halfEdge: -1, // Placeholder, will be set after creating half-edges.\n          bbox: calculateBoundingBox(polygon),\n        };\n\n        const pieceHalfEdgeIds: HalfEdgeID[] = [];\n\n        // Create a half-edge for each segment of the piece's polygon boundary.\n        for (let j = 0; j < polygon.length - 1; j++) {\n          const p1 = polygon[j];\n          const p2 = polygon[j + 1];\n\n          // Skip zero-length edges that can sometimes occur at the boundary.\n          if (arePointsEqual(p1, p2)) continue;\n\n          const he: HalfEdge = {\n            id: getUniqueId(),\n            origin: p1,\n            twin: -1, // To be linked in the second pass.\n            next: -1, // To be linked next.\n            prev: -1, // To be linked next.\n            piece: i,\n          };\n\n          topology.halfEdges.set(he.id, he);\n          pieceHalfEdgeIds.push(he.id);\n\n          // Store the half-edge in a map to easily find its twin later.\n          // The key is a string representation of its start and end points.\n          const key = `${pointToKey(p1)}-${pointToKey(p2)}`;\n          halfEdgeEndpointMap.set(key, he.id);\n        }\n\n        if (pieceHalfEdgeIds.length === 0) continue;\n\n        // Link the `next` and `prev` pointers for the half-edges of the current piece.\n        linkPieceHalfEdges(pieceHalfEdgeIds, topology.halfEdges);\n\n        // Set a starting half-edge for the piece and save it.\n        piece.halfEdge = pieceHalfEdgeIds[0];\n        topology.pieces.set(i, piece);\n      }\n\n      // 4. Second pass: Link twins and create the undirected Edge objects.\n      for (const he1 of topology.halfEdges.values()) {\n        // If twin is already set, it was handled when we processed its pair.\n        if (he1.twin !== -1) continue;\n\n        const he1_next = topology.halfEdges.get(he1.next)!;\n        const p1 = he1.origin;\n        const p2 = he1_next.origin;\n\n        const keyForTwin = `${pointToKey(p2)}-${pointToKey(p1)}`;\n        const twinId = halfEdgeEndpointMap.get(keyForTwin);\n\n        const edgeId = getUniqueId();\n        let edge: Edge;\n\n        if (twinId !== undefined) {\n          // This is an internal edge with a twin.\n          const he2 = topology.halfEdges.get(twinId)!;\n          he1.twin = he2.id;\n          he2.twin = he1.id;\n\n          // he1 is the \"left\" half-edge when looking from p1 to p2.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id,\n            heRight: he2.id,\n          };\n        } else {\n          // This is a boundary edge with no twin.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id, // The one existing half-edge.\n            heRight: -1,     // Sentinel for no half-edge.\n          };\n          topology.boundary.push(edgeId);\n        }\n\n        topology.edges.set(edgeId, edge);\n      }\n\n      // 5. Final step: Collect all unique vertices.\n      const vertexSet = new Map<string, Vec2>();\n      for (const he of topology.halfEdges.values()) {\n        const key = pointToKey(he.origin);\n        if (!vertexSet.has(key)) {\n          vertexSet.set(key, he.origin);\n        }\n      }\n      topology.vertices = Array.from(vertexSet.values());\n\n      return topology;\n    },\n  };\n  return VoronoiPieceGenerator;\n};\nexport default VoronoiPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, VoronoiPieceGeneratorFactory, VoronoiPieceGeneratorUIMetadata);\n","import type { TabGenerator, TabGeneratorRuntimeOptions } from \"./TabGenerator\";\nimport type { CurveTo, Edge, EdgeSegment, RandomFn, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\nexport const Name: TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TraditionalTabGeneratorConfig extends GeneratorConfig {\n  name: TraditionalTabGeneratorName;\n  /** Size of the tab relative to its edge as a percent (1-100) */\n  size?: number;\n  /** Amount of randomness to apply to each tab (0-100) */\n  jitter?: number;\n  /** If provided, tabs will not generate on edges shorter than this value */\n  minTabSize?: number;\n  /** If provided, the width of a tab's features will be clamped to this value */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TraditionalTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Traditional\",\n  description: \"Creates a traditional rounded tab for each (internal) piece edge.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'size',\n      label: 'Tab Size',\n      defaultValue: 20,\n      min: 1,\n      max: 100,\n      step: 1,\n      helpText: 'Size of each tab as a percent relative to its edge length',\n    },\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      defaultValue: 8,\n      min: 0,\n      max: 100,\n      step: 1,\n      helpText: 'Adds randomness to the tab shape. 0 means completely uniform tabs',\n    },\n    {\n      type: 'number',\n      name: 'minTabSize',\n      label: 'Minimum Tab Size',\n      optional: true,\n      helpText: 'If provided, tabs will not generate on edges shorter than this value',\n    },\n    {\n      type: 'number',\n      name: 'maxTabSize',\n      label: 'Maximum Tab Width',\n      optional: true,\n      helpText: 'If provided, the width of a tab\\'s features will be clamped to this value',\n    },\n  ],\n};\n\n\n/**\n * Build a puzzle nub using three cubic Bézier segments that replace a straight\n * edge AB. Curve 1 is a gentle S-curve up to the nub edge, Curve 2 is the arch\n * across the top of the nub, Curve 3 is the mirror of curve 1 back to the baseline.\n *   - the edge is parameterised from 0.0 → 1.0 along its length;\n *   - the nub is centred roughly at s = 0.5 and spans ≈ 4 · t of the edge;\n *   - the peak of the nub reaches ± 3 · t away from the baseline.\n *\n * @param a         Edge start point.\n * @param b         Edge end point.\n * @param sizePct   “Tab size” slider value (0–100 %).\n * @param jitterPct “Jitter” slider value (0–100 %).\n * @param random    Seeded RNG so callers can reproduce shapes.\n * @param inward    If true the nub is an **indent**; otherwise a **bump**.\n * @param maxTabSize Optional maximum absolute width for the tab.\n *\n * @returns Three cubic Bézier segments, ordered from a→b.\n */\nfunction createTraditionalTab(\n  a: Vec2,\n  b: Vec2,\n  sizePct: number,\n  jitterPct: number,\n  random: RandomFn,\n  inward = false,\n  maxTabSize?: number\n): EdgeSegment[] {\n  /* --- 1.  Work in a local (u,v) coordinate frame ---------------------- */\n\n  const ux = b[0] - a[0];\n  const uy = b[1] - a[1];\n  const len = Math.hypot(ux, uy);\n  if (len === 0) throw new Error(\"Edge has zero length\");\n\n  // Basis vectors:  u along the edge, v = +90° (right-hand rule).\n  const u: Vec2 = [ux / len, uy / len];\n  const v: Vec2 = [-u[1], u[0]]; // perpendicular\n\n  /** Convert (s,w) → world coordinates.  Both s and w are normalised by len. */\n  const P = (s: number, w: number): Vec2 => [\n    a[0] + (u[0] * s + v[0] * w) * len,\n    a[1] + (u[1] * s + v[1] * w) * len,\n  ];\n\n  /* --- 2.  Derive the five random perturbations a…e -------------------- */\n\n  const j = jitterPct / 100;\n  const rng = () => (random() * 2 - 1) * j; // uniform(-j, +j)\n\n  const A = rng(); // entry handle offset\n  const B = rng(); // l-shift of whole nub\n  const C = rng(); // vertical wobble of apex\n  const D = rng(); // anti-sym tweak\n  const E = rng(); // exit handle offset\n\n  /* --- 3.  Fixed shape constants -------------------------------------- */\n\n  let t = sizePct / 200; // tab “radius” in edge-length units\n\n  if (maxTabSize) {\n    const absoluteTabWidth = 4 * t * len;\n    if (absoluteTabWidth > maxTabSize) {\n      // recalculate t so that the tab width equals the max size, camping it\n      t = maxTabSize / (4 * len);\n    }\n  }\n\n  const dir = inward ? -1 : 1; // bump (+) or hole (-)\n\n  /* --- 4.  Anchor & control points in (s,w) ---------------------------- */\n\n  const pointsSW: Vec2[] = [\n    [0.0               ,           0],\n    [0.2               ,           A],\n    [0.5 + B + D       , dir * (-t + C)],\n    [0.5 - t + B       , dir * ( t + C)],\n    [0.5 - 2*t + B - D , dir * (3*t + C)],\n    [0.5 + 2*t + B - D , dir * (3*t + C)],\n    [0.5 + t + B       , dir * ( t + C)],\n    [0.5 + B + D       , dir * (-t + C)],\n    [0.8               ,           E],\n    [1.0               ,           0],\n  ];\n\n  /* --- 5.  Map to world coords and split into 3 Béziers ---------------- */\n\n  const points: Vec2[] = pointsSW.map(([s, w]) => P(s, w));\n\n  const bez1: CurveTo = { type: 'bezier', p1: points[1], p2: points[2], p3: points[3] };\n  const bez2: CurveTo = { type: 'bezier', p1: points[4], p2: points[5], p3: points[6] };\n  const bez3: CurveTo = { type: 'bezier', p1: points[7], p2: points[8], p3: points[9] };\n\n  return [bez1, bez2, bez3];\n}\n\n/**\n * Helper function to reverse a single Bézier curve segment.\n * The new curve starts where the old one ended and vice-versa.\n */\nfunction invertCurve(segment: CurveTo, newEndPoint: Vec2): CurveTo {\n  return {\n    type: 'bezier',\n    p1: segment.p2, // Control points are swapped\n    p2: segment.p1,\n    p3: newEndPoint, // The new end point is the start point of the original\n  };\n}\n\n/**\n * A factory that creates a TabGenerator for creating traditional, smoothly curved\n * puzzle piece tabs using a provided geometry function. The nub is built using\n * three cubic Bézier segments that replace a straight edge AB. Curve 1 is a\n * gentle S-curve up to the nub edge, Curve 2 is the arch across the top of the\n * nub, Curve 3 is the mirror of curve 1 back to the baseline.\n */\nexport const TraditionalTabGeneratorFactory: GeneratorFactory<TabGenerator> = (config: TraditionalTabGeneratorConfig): TabGenerator => {\n  const { size = 20, jitter = 8, minTabSize, maxTabSize } = config;\n\n  const TraditionalTabGenerator: TabGenerator = {\n    addTab(edge: Edge, runtimeOpts: TabGeneratorRuntimeOptions) {\n      const { topology, random } = runtimeOpts;\n      const he1 = topology.halfEdges.get(edge.heLeft);\n      const he2 = topology.halfEdges.get(edge.heRight);\n\n      if (!he1 || !he2) return;\n\n      const a = he1.origin;\n      const b = he2.origin;\n\n      if (minTabSize) {\n        const len = Math.hypot(b[0] - a[0], b[1] - a[1]);\n        if (len < minTabSize) {\n          return; // this tab would be too small\n        }\n      }\n\n      const he1IsInward = random() > 0.5;\n\n      const he1Segments = createTraditionalTab(a, b, size, jitter, random, he1IsInward, maxTabSize);\n      if (he1Segments.length === 0) return;\n\n      // Create the exact inverse path for the twin half-edge. This is critical\n      // for a perfect fit and cannot be done by just calling the function again\n      // due to the random perturbations.\n      const he2Segments: EdgeSegment[] = [];\n      for (let i = he1Segments.length - 1; i >= 0; i--) {\n        const currentSegment = he1Segments[i] as CurveTo; // We know they are curves\n        // The new end point is the start point of the original segment.\n        const originOfOriginal = (i > 0) ? (he1Segments[i-1] as CurveTo).p3 : a;\n        he2Segments.push(invertCurve(currentSegment, originOfOriginal));\n      }\n\n      he1.segments = he1Segments;\n      he2.segments = he2Segments;\n    },\n  };\n  return TraditionalTabGenerator;\n};\nexport default TraditionalTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TraditionalTabGeneratorFactory, TraditionalTabUIMetadata);\n","import type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\nexport const Name: GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\n\n/** Required config for this generator */\nexport interface GridJitterPointGeneratorConfig extends GeneratorConfig {\n  name: GridJitterPointGeneratorName;\n  /** Amount of random jitter (0 to 100) */\n  jitter: number;\n}\n\n/** UI metadata needed for this generator */\nexport const GridJitterPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Grid\",\n  description: \"Generate seed points using a grid with optional random jitter. \" +\n    \"Has a more uniform, regular look, especially with low randomness values.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n      helpText: 'Amount of jitter to apply to each grid point (0 to 100%)',\n    },\n  ],\n};\n\n/**\n * A point generator that uses grid + random jitter. `jitter` represents the\n * strength of jitter applied to each point, from 0 (straight grid) to 1\n * (completely random).\n */\nexport const GridJitterPointGeneratorFactory: GeneratorFactory<PointGenerator> = (config: GridJitterPointGeneratorConfig) => {\n  const { jitter = 50 } = config;\n\n  const GridJitterPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      const points: Vec2[] = [];\n      // assemble a grid\n      for (let x = 0; x < width; x += pieceSize) {\n        for (let y = 0; y < height; y += pieceSize) {\n          // initial position is the center of each grid cell\n          const point: Vec2 = [x + pieceSize / 2, y + pieceSize / 2];\n          // add random jitter\n          if (jitter > 0) {\n            point[0] += (random() - 0.5) * (jitter / 100) * pieceSize;\n            point[1] += (random() - 0.5) * (jitter / 100)  * pieceSize;\n          }\n          points.push(point);\n        }\n      }\n      return points;\n    },\n  };\n  return GridJitterPointGenerator;\n};\nexport default GridJitterPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, GridJitterPointGeneratorFactory, GridJitterPointUIMetadata);\n","import type { TabGenerator, TabGeneratorRuntimeOptions } from \"./TabGenerator\";\nimport type { Edge } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other TabGenerators\ntype NullTabGeneratorName = \"NullTabGenerator\";\nexport const Name: NullTabGeneratorName = \"NullTabGenerator\";\n\n/** This generator doesn't take any special config */\nexport interface NullTabGeneratorConfig extends GeneratorConfig {\n  name: NullTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const NullTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"None\",\n  description: \"Do not generate tabs. All pieces have straight edges.\",\n  sortHint: 3,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/** Tab generator that does nothing, piece edges remain straight lines */\nexport const NullTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_config: NullTabGeneratorConfig) => {\n  const NullTabGenerator: TabGenerator = {\n    addTab(_edge: Edge, _runtimeOpts: TabGeneratorRuntimeOptions) {\n      // noop\n    },\n  };\n  return NullTabGenerator;\n};\nexport default NullTabGeneratorFactory;\n\n// register the generator\nTabGeneratorRegistry.register(Name, NullTabGeneratorFactory, NullTabUIMetadata);\n\n","import type { TabGeneratorRuntimeOptions, TabGenerator } from \"./TabGenerator\";\nimport type { CurveTo, Edge, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TriangleTabGeneratorName = \"TriangleTabGenerator\";\nexport const Name: TriangleTabGeneratorName = \"TriangleTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TriangleTabGeneratorConfig extends GeneratorConfig {\n  name: TriangleTabGeneratorName;\n  /** Determines how \"tall\" the tab is relative to the length of the edge as a percent, default 20% */\n  tabHeightRatio?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TriangleTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Triangle\",\n  description: \"Creates a simple triangle between each (internal) piece edge.\",\n  sortHint: 2,\n  // these have to match the config above\n  controls: [\n    {\n      type: 'range',\n      name: 'tabHeightRatio',\n      label: 'Tab Height',\n      optional: true,\n      min: 0,\n      max: 100,\n      step: 1,\n      defaultValue: 20,\n      helpText: 'Determines how \"tall\" the tab is relative to the length of the edge as a percent',\n    },\n  ],\n};\n\n/**\n * A simple TabGenerator that adds a triangular \"nub\" to an edge.\n *\n * This generator serves as a straightforward example of how to implement the\n * TabGenerator interface. It modifies the two half-edges of a given edge,\n * adding a Bézier curve that forms a triangular tab. One half-edge gets an\n * \"outie\" (convex) tab, and its twin gets a corresponding \"innie\" (concave)\n * tab, ensuring the pieces will fit together.\n */\nexport const TriangleTabGeneratorFactory: GeneratorFactory<TabGenerator> = (config: TriangleTabGeneratorConfig) => {\n  const { tabHeightRatio = 20 } = config;\n\n  const TriangleTabGenerator: TabGenerator = {\n    addTab(edge: Edge, runtimeOpts: TabGeneratorRuntimeOptions) {\n      const { topology, random } = runtimeOpts;\n\n      // 1. Get the half-edges from the topology.\n      // We need the full objects to modify them.\n      const he1 = topology.halfEdges.get(edge.heLeft);\n      const he2 = topology.halfEdges.get(edge.heRight);\n\n      // Ensure both half-edges exist (which they should for an internal edge).\n      if (!he1 || !he2) {\n        console.warn(\"Could not find half-edges for a given internal edge:\", edge.id);\n        return;\n      }\n\n      // 2. Define the edge's start and end points.\n      // The edge for he1 goes from p0 -> p3.\n      // The twin edge (he2) goes from p3 -> p0.\n      const p0 = he1.origin;\n      const p3 = he2.origin;\n\n      // 3. Calculate edge vectors and properties.\n      const edgeVector: Vec2 = [p3[0] - p0[0], p3[1] - p0[1]];\n      const edgeLength = Math.sqrt(edgeVector[0] ** 2 + edgeVector[1] ** 2);\n      if (edgeLength < 1e-6) return; // Avoid creating tabs on zero-length edges.\n\n      // Calculate a perpendicular vector (normal) to the edge.\n      // The direction of this normal is consistent relative to he1.\n      const edgeDir: Vec2 = [edgeVector[0] / edgeLength, edgeVector[1] / edgeLength];\n      const normalDir: Vec2 = [-edgeDir[1], edgeDir[0]];\n\n      // 4. Calculate the position of the tab's peak.\n      // Find the midpoint of the edge.\n      const midPoint: Vec2 = [p0[0] + edgeVector[0] / 2, p0[1] + edgeVector[1] / 2];\n\n      // Randomly decide if the tab goes \"out\" or \"in\" for he1.\n      const direction = random() > 0.5 ? 1 : -1;\n      const tabHeight = edgeLength * (tabHeightRatio / 100) * direction;\n\n      // Calculate the nub point by moving from the midpoint along the normal.\n      const nubPoint: Vec2 = [\n        midPoint[0] + normalDir[0] * tabHeight,\n        midPoint[1] + normalDir[1] * tabHeight,\n      ];\n\n      // 5. Create the Bézier curve for he1's tab.\n      // We create a \"sharp\" triangular point by setting both control points\n      // to be the same as the nub's peak. This creates two straight lines\n      // (p0 -> nubPoint -> p3) and is a simple way to represent a triangle\n      // with the CubicBezier interface.\n      const tab1: CurveTo = {\n        type: 'bezier',\n        p1: nubPoint,\n        p2: nubPoint,\n        p3: p3,\n      };\n\n      // 6. Create the corresponding inverse tab for the twin half-edge (he2).\n      // The start and end points are swapped, and the nub is on the opposite side.\n      const nubPointTwin: Vec2 = [\n        midPoint[0] - normalDir[0] * tabHeight, // Invert the nub direction\n        midPoint[1] - normalDir[1] * tabHeight,\n      ];\n      const tab2: CurveTo = {\n        type: 'bezier',\n        p1: nubPointTwin,\n        p2: nubPointTwin,\n        p3: p0,\n      };\n\n      // 7. Attach the generated tabs to the half-edge objects in the topology.\n      he1.segments = [tab1];\n      he2.segments = [tab2];\n    },\n  };\n  return TriangleTabGenerator;\n};\nexport default TriangleTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TriangleTabGeneratorFactory, TriangleTabUIMetadata);\n","// component that renders single page application for generating puzzles\nimport m from 'mithril';\n\n// UI parts\nimport GitHubCorner from './ui/GitHubCorner';\nimport Puzzle from './ui/Puzzle';\nimport DownloadPuzzleButton from './ui/DownloadPuzzleButton';\nimport UploadImageButton from './ui/UploadImageButton';\nimport GeneratorPicker from './ui/GeneratorPicker';\nimport NumberInputControl from './ui/inputs/NumberInputControl';\nimport ColorPicker from './ui/ColorPicker';\n\n// geometry parts\nimport type { PuzzleGeometry } from './geometry/types';\nimport type { GeneratorConfig, GeneratorName, GeneratorRegistry } from './geometry/generators/Generator';\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabGeneratorRegistry } from './geometry/generators/Generator';\nimport { type PoissonPointGeneratorConfig, Name as PoissonGeneratorName } from './geometry/generators/point/PoissonPointGenerator';\nimport { type VoronoiPieceGeneratorConfig, Name as VoronoiGeneratorName } from './geometry/generators/piece/VoronoiPieceGenerator';\nimport { type TraditionalTabGeneratorConfig, Name as TraditionalTabGeneratorName } from './geometry/generators/tab/TraditionalTabGenerator';\nimport { buildPuzzle } from './geometry/PuzzleMaker';\n\n// register generators\nimport \"./geometry/generators/point/GridJitterPointGenerator\";\nimport \"./geometry/generators/point/PoissonPointGenerator\";\nimport \"./geometry/generators/piece/VoronoiPieceGenerator\";\nimport \"./geometry/generators/tab/NullTabGenerator\";\nimport \"./geometry/generators/tab/TriangleTabGenerator\";\nimport \"./geometry/generators/tab/TraditionalTabGenerator\";\n\n// Shoelace CSS\nimport '@shoelace-style/shoelace/dist/themes/light.css';\nimport '@shoelace-style/shoelace/dist/themes/dark.css';\n\n// CSS for this component\nimport './index.css';\n\n// component that draws the page\nconst Page: m.ClosureComponent<unknown> = () => {\n\n  const defaultWidth = 800;\n  const defaultHeight = 600;\n\n  const defaultPointGenerator = PoissonGeneratorName;\n  const defaultPointConfig: PoissonPointGeneratorConfig = {\n    name: PoissonGeneratorName,\n    width: defaultWidth,\n    height: defaultHeight,\n  };\n\n  const defaultPieceGenerator = VoronoiGeneratorName;\n  const defaultPieceConfig: VoronoiPieceGeneratorConfig = {\n    name: VoronoiGeneratorName,\n    width: defaultWidth,\n    height: defaultHeight,\n  };\n\n  const defaultTabGenerator = TraditionalTabGeneratorName;\n  const defaultTabConfig: TraditionalTabGeneratorConfig = {\n    name: TraditionalTabGeneratorName,\n    width: defaultWidth,\n    height: defaultHeight,\n  };\n\n  /** State tracked for each type of generator */\n  interface GeneratorState<C extends GeneratorConfig = GeneratorConfig> {\n    label: string;\n    registry: GeneratorRegistry<unknown>;\n    name : GeneratorName;\n    config: C;\n  }\n\n  interface PageState {\n    /** Random seed */\n    seed: number;\n    /** Width of canvas in pixels */\n    canvasWidth: number;\n    /** Height of canvas in pixels */\n    canvasHeight: number;\n    /** Minimum distance between control points (pixels) */\n    distance: number;\n    /** Color of pieces */\n    color: string;\n    /** Dirty flag that keeps us from hitting the puzzle generation function too hard */\n    dirty: boolean;\n    /** Currently selected and configured generators for each part of puzzle generation */\n    generators: Record<string, GeneratorState>;\n    /** Generated puzzle geometry */\n    puzzle?: PuzzleGeometry;\n    /** User uploaded image */\n    backgroundImageUrl?: string;\n    /** Name of uploaded image */\n    backgroundImageName: string;\n  };\n\n  // component state\n  const state: PageState = {\n    seed: new Date().getTime() % 10240,\n    canvasWidth: defaultWidth,\n    canvasHeight: defaultHeight,\n    distance: 40,\n    color: \"#333333\",\n    dirty: true,\n    generators: {\n      /** Strategy for creating points (which influences piece generation) */\n      point: {\n        label: \"Seed Point Generator\",\n        registry: PointGeneratorRegistry,\n        name: defaultPointGenerator,\n        config: defaultPointConfig,\n      },\n      /** Strategy for turning points into puzzle pieces */\n      piece: {\n        label: \"Piece Generator\",\n        registry: PieceGeneratorRegistry,\n        name: defaultPieceGenerator,\n        config: defaultPieceConfig,\n      },\n      /** Style of tabs to generate */\n      tab: {\n        label: \"Tab Generator\",\n        registry: TabGeneratorRegistry,\n        name: defaultTabGenerator,\n        config: defaultTabConfig,\n      },\n    },\n    puzzle: undefined,\n    backgroundImageUrl: undefined,\n    backgroundImageName: '',\n  };\n\n  // Mithril component\n  return {\n\n    oncreate: () => {\n      buildPuzzle({\n        width: state.canvasWidth,\n        height: state.canvasHeight,\n        pieceSize: state.distance,\n        pointConfig: state.generators.point.config,\n        pieceConfig: state.generators.piece.config,\n        tabConfig: state.generators.tab.config,\n        seed: state.seed,\n      }).then((puzzle) => {\n        state.puzzle = puzzle;\n        m.redraw();\n      }).catch((err) => {\n        console.error(err);\n      });\n    },\n\n    onupdate: () => {\n      if (state.dirty) {\n        state.dirty = false;\n        // rebuild the puzzle geometry\n        buildPuzzle({\n          width: state.canvasWidth,\n          height: state.canvasHeight,\n          pieceSize: state.distance,\n          pointConfig: state.generators.point.config,\n          pieceConfig: state.generators.piece.config,\n          tabConfig: state.generators.tab.config,\n          seed: state.seed,\n        }).then((puzzle) => {\n          state.puzzle = puzzle;\n          m.redraw();\n        }).catch((err) => {\n          console.error(err);\n        });\n      }\n    },\n\n    onremove: () => {\n      if (state.backgroundImageUrl) {\n        // clean up memory\n        URL.revokeObjectURL(state.backgroundImageUrl);\n        state.backgroundImageUrl = undefined;\n      }\n    },\n\n    // component lifecycle: render our output\n    view: () => {\n\n      return m(\".page\", [\n        m(GitHubCorner, {\n          link: \"https://github.com/weevilgenius/puzzle-generator\",\n        }),\n        m(\"h1\", \"Puzzle Generator\"),\n        m(\".container\", [\n\n          state.puzzle && m('.puzzle-stack', [\n\n            // main puzzle display\n            m(Puzzle, {\n              width: state.canvasWidth,\n              height: state.canvasHeight,\n              color: state.color,\n              imageUrl: state.backgroundImageUrl,\n              puzzle: state.puzzle,\n            }),\n\n            // SVG download button\n            m(DownloadPuzzleButton, {\n              puzzle: state.puzzle,\n              width: state.canvasWidth,\n              height: state.canvasHeight,\n              color: state.color,\n            }),\n\n          ]),\n\n          // puzzle generation controls\n          m(\".controls\", [\n            // background image\n            m('.background-image', [\n              m(UploadImageButton, {\n                label: \"Background Image\",\n                onUpload: (imageUrl, filename) => {\n                  // clear any previous image\n                  if (state.backgroundImageUrl) {\n                    URL.revokeObjectURL(state.backgroundImageUrl);\n                  }\n                  state.backgroundImageUrl = imageUrl;\n                  state.backgroundImageName = filename;\n                  m.redraw();\n                },\n              }),\n              m('span.background-image-label', state.backgroundImageName),\n            ]),\n            // Seed value\n            m(NumberInputControl, {\n              config: {\n                name: 'seed',\n                label: 'Seed',\n                type: 'number',\n              },\n              value: state.seed,\n              onChange: (value) => {\n                state.seed = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n            // Piece size config value\n            m(NumberInputControl, {\n              config: {\n                name: 'pieceSize',\n                label: 'Piece size',\n                type: 'number',\n              },\n              value: state.distance,\n              onChange: (value) => {\n                state.distance = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n            // Piece color config value\n            m(ColorPicker, {\n              label: 'Piece color',\n              color: state.color,\n              size: \"small\",\n              onUpdate: (newColor) => {\n                state.color = newColor;\n                m.redraw();\n              },\n            }),\n\n            // render a generator picker for each type of generator\n            ...Object.entries(state.generators).map(([type, generator]) => {\n              return m(\"label\", [\n                generator.label + ':',\n                m(GeneratorPicker, {\n                  generator: generator.name,\n                  registry: generator.registry,\n                  config: generator.config,\n                  onGeneratorChange: (generatorName) => {\n                    if (generatorName != generator.name) {\n                      console.log(`${type} generator changed to ${generatorName}`);\n                      generator.name = generatorName;\n                      // generator changed, we need a new blank config\n                      state.generators[type].config = generator.registry.getDefaultConfig(generatorName, state.canvasWidth, state.canvasHeight);\n                      state.dirty = true;\n                      m.redraw();\n                    }\n                  },\n                  onConfigChange: (key, value) => {\n                    console.log(`${type} generator config \"${key}\" changed to ${String(value)}`);\n                    generator.config[key] = value;\n                    state.dirty = true;\n                    m.redraw();\n                  },\n                }),\n              ]);\n            }),\n\n          ]), // .controls\n\n        ]), // .container\n\n      ]);\n    }, // view()\n  };\n};\n\n\n// Ask Mithril to render the page, our componet gets placed into the root element.\n// Mithril will rerender automatically after DOM event handlers defined in component\n// views and also whenever m.redraw() is called.\nm.mount(document.body, Page);\n"],"names":["GitHubCorner","attrs","m","GeneratorRegistry","name","factory","uiMetadata","config","generator","a","b","g","width","height","newConfig","metadata","control","PointGeneratorRegistry","PieceGeneratorRegistry","TabGeneratorRegistry","mulberry32","seed","t","buildPuzzle","options","pieceSize","pointConfig","pieceConfig","tabConfig","pointGenerator","pieceGenerator","tabGenerator","random","points","topology","edge","puzzle","drawPuzzle","canvas","pieceColor","showPoints","ctx","he","segment","destination","piece","x","y","Puzzle","state","dom","createSVG","pathData","pathD","downloadSvg","svg","filename","blob","url","DownloadPuzzleButton","UploadImageButton","e","file","uploadUrl","BooleanInputControl","newValue","NumberInputControl","RangeInputControl","StringInputControl","GeneratorPicker","generators","newSelected","tab","panel","value","ColorPicker","input","tinyNDArrayOfInteger","gridShape","dimensions","totalLength","stride","dimension","tinyNDArrayOfArray","data","index","tinyNdarray","sphereRandom","sampleSphere","d","rng","v","d2","r2","rr","r","theta","i","moore","range","size","length","neighbors","neighbor","require$$0","getNeighbourhood","dimensionNumber","neighbourhood","origin","n","dist","n1","n2","squareDist1","squareDist2","neighbourhoodCache","getNeighbourhoodMemoized","tinyNDArray","require$$1","require$$2","squaredEuclideanDistance","point1","point2","result","FixedDensityPDS","maxShape","floatPrecisionMitigation","epsilonDistance","point","valid","internalArrayIndex","neighbourIndex","currentDimensionValue","existingPoint","tries","angle","distance","currentPoint","newPoint","inShape","gridData","fixedDensity","euclideanDistance","VariableDensityPDS","pointIndex","existingPointDistance","pointDistance","minDistance","maxDistance","currentDistance","sampleIndex","variableDensity","PoissonDiskSampling","poissonDiskSampling","Name","PoissonPointUIMetadata","PoissonPointGeneratorFactory","_config","runtimeOpts","epsilon","splitter","resulterrbound","sum","elen","flen","f","h","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","EPSILON","EDGE_STACK","Delaunator","getX","defaultGetX","getY","defaultGetY","coords","p","maxTriangles","hullPrev","hullNext","hullTri","hullHash","minX","minY","maxX","maxY","i0","i1","i2","minDist","i0x","i0y","i1x","i1y","minRadius","circumradius","i2x","i2y","quicksort","hull","j","d0","id","center","circumcenter","hullSize","k","xp","yp","start","key","q","pseudoAngle","triangles","halfedges","ar","a0","b0","al","bl","p0","pr","pl","p1","inCircle","hbl","br","dx","dy","px","py","ex","ey","fx","fy","ap","bp","cp","cl","ids","dists","left","right","temp","tempDist","median","swap","arr","tmp","Path","x0","y0","w","Polygon","Voronoi","delaunay","xmin","ymin","xmax","ymax","vectors","circumcenters","t2","t3","x1","y1","x2","y2","x3","y3","ab","context","buffer","inedges","ti","tj","xi","yi","xj","yj","h0","h1","cell","polygon","S","c0","c1","ci","cj","loop","ai","li","aj","lj","e0","V","P","e1","sx0","sy0","sx1","sy1","flip","vx0","vy0","vxn","vyn","vx","vy","tau","pow","pointX","pointY","collinear","jitter","Delaunay","that","flatArray","flatIterable","_","bounds","hullIndex","_hullIndex","l","dc","dt","array","getUniqueId","VoronoiPieceGeneratorUIMetadata","calculateBoundingBox","linkPieceHalfEdges","map","len","pointToKey","arePointsEqual","p2","VoronoiPieceGeneratorFactory","_runtimeOpts","voronoi","halfEdgeEndpointMap","site","pieceHalfEdgeIds","he1","he1_next","keyForTwin","twinId","edgeId","he2","vertexSet","TraditionalTabUIMetadata","createTraditionalTab","sizePct","jitterPct","inward","maxTabSize","ux","uy","s","A","C","E","dir","bez1","bez2","bez3","invertCurve","newEndPoint","TraditionalTabGeneratorFactory","minTabSize","he1IsInward","he1Segments","he2Segments","currentSegment","originOfOriginal","GridJitterPointUIMetadata","GridJitterPointGeneratorFactory","NullTabUIMetadata","NullTabGeneratorFactory","_edge","TriangleTabUIMetadata","TriangleTabGeneratorFactory","tabHeightRatio","p3","edgeVector","edgeLength","edgeDir","normalDir","midPoint","direction","tabHeight","nubPoint","tab1","nubPointTwin","tab2","Page","defaultPointGenerator","PoissonGeneratorName","defaultPointConfig","defaultPieceGenerator","VoronoiGeneratorName","defaultPieceConfig","defaultTabGenerator","TraditionalTabGeneratorName","defaultTabConfig","err","imageUrl","newColor","type","generatorName"],"mappings":"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","x_google_ignoreList":[14,15,16,17,18,19,20,22,23,24,25,26,27,28]}