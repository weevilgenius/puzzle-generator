{"version":3,"file":"index-C9beCZzv.js","sources":["../../src/ui/GitHubCorner.ts","../../src/geometry/generators/Generator.ts","../../src/geometry/utils.ts","../../src/utils/mulberry.ts","../../src/geometry/PuzzleMaker.ts","../../src/geometry/modifiers.ts","../../src/ui/Puzzle.ts","../../src/utils/svg.ts","../../src/ui/DownloadPuzzleButton.ts","../../src/ui/GeometryCheckIndicator.ts","../../src/ui/UploadImageButton.ts","../../src/ui/inputs/BooleanInputControl.ts","../../src/ui/inputs/NumberInputControl.ts","../../src/ui/inputs/RangeInputControl.ts","../../src/ui/inputs/StringInputControl.ts","../../src/ui/GeneratorPicker.ts","../../src/ui/AspectRatioPicker.ts","../../src/ui/ColorPicker.ts","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/tiny-ndarray.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/sphere-random.js","../../node_modules/.pnpm/moore@1.0.0/node_modules/moore/index.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/neighbourhood.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/fixed-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/implementations/variable-density.js","../../node_modules/.pnpm/poisson-disk-sampling@2.3.1/node_modules/poisson-disk-sampling/src/poisson-disk-sampling.js","../../src/geometry/generators/point/PoissonPointGenerator.ts","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/util.js","../../node_modules/.pnpm/robust-predicates@3.0.2/node_modules/robust-predicates/esm/orient2d.js","../../node_modules/.pnpm/delaunator@5.0.1/node_modules/delaunator/index.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/path.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/polygon.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/voronoi.js","../../node_modules/.pnpm/d3-delaunay@6.0.4/node_modules/d3-delaunay/src/delaunay.js","../../src/utils/UniqueId.ts","../../src/geometry/generators/piece/VoronoiPieceGenerator.ts","../../src/geometry/generators/tab_placement/SimpleTabPlacementStrategy.ts","../../src/geometry/generators/tab/TraditionalTabGenerator.ts","../../src/geometry/GeometryChecker.ts","../../src/geometry/generators/point/GridJitterPointGenerator.ts","../../src/geometry/generators/piece/RectangularPieceGenerator.ts","../../src/geometry/generators/tab/NullTabGenerator.ts","../../src/geometry/generators/tab/TriangleTabGenerator.ts","../../src/index.ts"],"sourcesContent":["// SVG rendering the GitHub Octocat in a corner with a link\n// adapted from https://github.com/tholman/github-corners/\nimport m from 'mithril';\n\n// include our CSS\nimport './GitHubCorner.css';\n\n// component attributes\nexport interface GitHubCornerAttrs extends m.Attributes {\n  /** Url to use when clicked */\n  link: string;\n}\n\n// Mithril component\nexport const GitHubCorner: m.Component<GitHubCornerAttrs, unknown> = {\n\n  view: ({ attrs }) => {\n\n    return m(\"a.github-corner\", {\n      href: attrs.link,\n      \"aria-label\": \"View source on GitHub\",\n      title: \"View source on GitHub\",\n      target: \"_blank\",\n    }, m(\"svg\", {\n      width: 80,\n      height: 80,\n      viewBox: \"0 0 250 250\",\n      \"aria-hidden\": \"true\",\n    }, [\n      m('path', {\n        d: \"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\",\n      }),\n      m('path.octo-arm', {\n        fill: \"currentColor\",\n        style: \"transform-origin: 130px 106px;\",\n        d: \"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\",\n      }),\n      m('path.octo-body', {\n        fill: \"currentColor\",\n        d: \"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\",\n      }),\n    ]));\n  },\n\n};\nexport default GitHubCorner;\n","import type { GeneratorUIMetadata } from '../ui_types';\n\n/** The name of a particular generator implementation. Must be unique. */\nexport type GeneratorName = string;\n\n/** Base configuration for any generator */\nexport interface GeneratorConfig {\n  /** The name of the generator to which this config belongs */\n  name: GeneratorName;\n  // additional fields specific to this generator\n  [key: string]: unknown;\n}\n\n/**\n * A generic interface for a function that creates a configured generator instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type GeneratorFactory<T> = (width: number, height: number, options: any) => T;\n\n\ninterface RegisteredGenerator<T> {\n  factory: GeneratorFactory<T>;\n  uiMetadata: GeneratorUIMetadata;\n}\n\n/**\n * A generic registry for creating instances of generates from configurations.\n * This allows for a pluggable system where generators can be added dynamically.\n *\n * @template T The base interface for this type of generator, e.g. `TabGenerator`\n */\nexport class GeneratorRegistry<T> {\n  private generators = new Map<GeneratorName, RegisteredGenerator<T>>();\n\n  /**\n   * Registers a new generator factory associated with a specific generator type.\n   * Intended to be called from within each generator's implementation file.\n   * @param name The unique string identifier for the generator, e.g. \"TraditionalTabGenerator\"\n   * @param factory A function that takes an options object and returns a generator\n   * @param uiMetadata A description of the UI needed to configure the generator\n   */\n  public register(name: GeneratorName, factory: GeneratorFactory<T>, uiMetadata: GeneratorUIMetadata): void {\n    if (this.generators.has(name)) {\n      console.warn(`Generator \"${name}\" is already registered, overwriting`);\n    }\n    this.generators.set(name, { factory, uiMetadata });\n  }\n\n  /**\n   * Creates an instance of a generator based on the provided configuration object.\n   * It looks up the correct factory using the `name` property from the config.\n   * @param config A configuration object for the generator\n   * @returns A configured instance of the requested generator\n   */\n  public create(width: number, height: number, config: GeneratorConfig): T {\n    const generator = this.generators.get(config.name);\n    if (!generator) {\n      throw new Error(`Unknown generator \"${config.name}\". Is it registered?`);\n    }\n    return generator.factory(width, height, config);\n  }\n\n  /**\n   * Returns a list of all available generators for populating a selector UI.\n   * @returns An array of objects with the name and human-readable display name.\n   */\n  public getAvailableGenerators(): { name: GeneratorName, displayName: string }[] {\n    return Array.from(this.generators.values())\n      .sort((a, b) => a.uiMetadata.sortHint - b.uiMetadata.sortHint)\n      .map((g) => ({\n        name: g.uiMetadata.name,\n        displayName: g.uiMetadata.displayName,\n      }));\n  }\n\n  /**\n   * Retrieves the full UI metadata for a single generator.\n   * @param name The name of the generator.\n   * @returns The UI metadata object, or undefined if not found.\n   */\n  public getUIMetadata(name: GeneratorName): GeneratorUIMetadata | undefined {\n    return this.generators.get(name)?.uiMetadata;\n  }\n\n  /**\n   * Builds a default (empty) config object for a given generator.\n   * @param name The name of the generator.\n   * @param width The width of the puzzle\n   * @param height The height of the puzzle\n   * @returns Default config object for the given generator\n   */\n  public getDefaultConfig(name: GeneratorName, width: number, height: number): GeneratorConfig {\n    const newConfig: GeneratorConfig = {\n      name: name,\n      width: width,\n      height: height,\n    };\n\n    const metadata = this.getUIMetadata(name);\n    if (metadata) {\n      for (const control of metadata.controls) {\n        newConfig[control.name] = control.defaultValue;\n      }\n    }\n\n    return newConfig;\n  }\n}\n\n/* ========================================================= *\\\n *  Public registeries                                       *\n\\* ========================================================= */\n\n// Public registry for PointGenerators\nimport type { PointGenerator } from \"./point/PointGenerator\";\nexport const PointGeneratorRegistry = new GeneratorRegistry<PointGenerator>();\n\n// Public registry for PieceGenerators\nimport type { PieceGenerator } from \"./piece/PieceGenerator\";\nexport const PieceGeneratorRegistry = new GeneratorRegistry<PieceGenerator>();\n\n// Public registry for TabPlacementStrategies\nimport type { TabPlacementStrategy } from \"./tab_placement/TabPlacementStrategy\";\nexport const TabPlacementStrategyRegistry = new GeneratorRegistry<TabPlacementStrategy>();\n\n// Public registry for TabGenerators\nimport type { TabGenerator } from \"./tab/TabGenerator\";\nexport const TabGeneratorRegistry = new GeneratorRegistry<TabGenerator>();\n","// this file contains various geometry-related utilities\nimport type {\n  Vec2,\n  PuzzleTopology,\n  Vertex,\n  Piece,\n  PieceID,\n  CurveTo,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  AABB,\n  EdgeSegment,\n  RandomFn,\n  VertexID,\n} from \"./types\";\nimport type { TabGenerator } from \"./generators/tab/TabGenerator\";\n\n/**\n * Calculates the squared Euclidean distance between two points.\n * Used for efficient distance comparisons without the need for Math.sqrt().\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns The squared distance between the points.\n */\nexport function distanceSq(p1: Vec2, p2: Vec2): number {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n  return dx * dx + dy * dy;\n}\n\n/** Serializable version of PuzzleTopology */\nexport interface PuzzleTopologySerializable {\n  vertices: Vertex[];\n  pieces: [PieceID, Piece][];\n  edges: [EdgeID, Edge][];\n  halfEdges: [HalfEdgeID, HalfEdge][];\n  boundary: EdgeID[];\n}\n\n/**\n * Converts a PuzzleTopology with Maps to a plain object representation. Note that\n * modern browsers support Map with structuredClone(), but older browsers do not,\n * so it is safer to manually serialize.\n */\nexport function serializeTopology(topology: PuzzleTopology): PuzzleTopologySerializable {\n  return {\n    vertices: topology.vertices,\n    pieces: Array.from(topology.pieces.entries()),\n    edges: Array.from(topology.edges.entries()),\n    halfEdges: Array.from(topology.halfEdges.entries()),\n    boundary: topology.boundary,\n  };\n}\n\n/** Revives a serialized topology back into a PuzzleTopology with Maps. */\nexport function deserializeTopology(serialized: PuzzleTopologySerializable): PuzzleTopology {\n  return {\n    vertices: serialized.vertices,\n    pieces: new Map(serialized.pieces),\n    edges: new Map(serialized.edges),\n    halfEdges: new Map(serialized.halfEdges),\n    boundary: serialized.boundary,\n  };\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a single edge segment.\n * @param segment - The line or curve segment.\n * @param startPoint - The starting coordinate of the segment.\n * @returns An AABB tuple: [xmin, ymin, xmax, ymax].\n */\nexport function calculateSegmentAABB(segment: EdgeSegment, startPoint: Vec2): AABB {\n  const points: Vec2[] = [startPoint];\n\n  if (segment.type === 'line') {\n    points.push(segment.p);\n  } else { // 'bezier'\n    points.push(segment.p1, segment.p2, segment.p3);\n  }\n\n  const xCoords = points.map((p) => p[0]);\n  const yCoords = points.map((p) => p[1]);\n\n  return [\n    Math.min(...xCoords),\n    Math.min(...yCoords),\n    Math.max(...xCoords),\n    Math.max(...yCoords),\n  ];\n}\n\n/**\n * Checks if two Axis-Aligned Bounding Boxes intersect.\n * @param a - The first AABB.\n * @param b - The second AABB.\n * @returns `true` if they overlap, `false` otherwise.\n */\nexport function doAABBsIntersect(a: AABB, b: AABB): boolean {\n  // x-axis check\n  if (a[2] < b[0] || a[0] > b[2]) {\n    return false;\n  }\n  // y-axis check\n  if (a[3] < b[1] || a[1] > b[3]) {\n    return false;\n  }\n  return true;\n}\n\n\n/**\n * Calculates the precise bounding box for a single puzzle piece by traversing\n * its boundary and finding the extremities of all its geometric segments.\n *\n * @param piece The piece whose bounding box needs to be recalculated.\n * @param topology The full puzzle topology, used to access half-edge data.\n * @returns A new AABB for the piece.\n */\nexport function getPieceAABB(piece: Piece, topology: PuzzleTopology): AABB {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  const startingEdgeId = piece.halfEdge;\n  let currentEdge = topology.halfEdges.get(startingEdgeId);\n\n  if (!currentEdge) {\n    // Should not happen in a valid topology\n    return piece.bounds;\n  }\n\n  // This helper function expands the bounding box to include a given point.\n  const expandBbox = (p: Vec2) => {\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  };\n\n  // Traverse the entire boundary of the piece, one half-edge at a time.\n  do {\n    // Account for the starting point of the current edge\n    expandBbox(currentEdge.origin);\n\n    // Account for all points within the edge's segments (if any)\n    if (currentEdge.segments) {\n      for (const segment of currentEdge.segments) {\n        if (segment.type === 'line') {\n          expandBbox(segment.p);\n        } else { // 'bezier'\n          // For a bezier curve, we check the control points and the end point.\n          // Note: A precise bounding box would require finding the curve's\n          // mathematical extrema, but checking control points is a common\n          // and often sufficient approximation.\n          expandBbox(segment.p1);\n          expandBbox(segment.p2);\n          expandBbox(segment.p3);\n        }\n      }\n    }\n\n    // Move to the next half-edge around the piece\n    currentEdge = topology.halfEdges.get(currentEdge.next);\n\n  } while (currentEdge && currentEdge.id !== startingEdgeId);\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n// The maximum distance (in pixels) from a click to a vertex to consider it a \"hit\".\nconst MAX_CLICK_DISTANCE = 100;\nconst MAX_CLICK_DISTANCE_SQ = MAX_CLICK_DISTANCE * MAX_CLICK_DISTANCE;\n\n/**\n * Finds the index of the vertex closest to a given point.\n *\n * @param puzzle The puzzle topology to search within.\n * @param clickPos The position of the user's click.\n * @returns The index of the closest vertex in the `topology.vertices` array,\n * or `null` if no vertex is within the click threshold.\n */\nexport function findClosestVertex(\n  puzzle: PuzzleTopology,\n  clickPos: Vec2\n): VertexID | null {\n  let closestVertexIndex = -1;\n  let minDistanceSq = MAX_CLICK_DISTANCE_SQ;\n\n  for (let i = 0; i < puzzle.vertices.length; i++) {\n    const distSq = distanceSq(puzzle.vertices[i], clickPos);\n    if (distSq < minDistanceSq) {\n      minDistanceSq = distSq;\n      closestVertexIndex = i;\n    }\n  }\n\n  return closestVertexIndex === -1 ? null : closestVertexIndex;\n}\n\n/**\n * Calculates the Axis-Aligned Bounding Box (AABB) for a given polygon.\n * @param polygon - An array of vertices representing the polygon.\n * @returns The AABB or a zero-area box at the origin if the polygon is empty.\n */\nexport function polygonBounds(polygon: Vec2[]): AABB {\n  if (polygon.length === 0) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = polygon[0][0];\n  let minY = polygon[0][1];\n  let maxX = minX;\n  let maxY = minY;\n\n  for (let i = 1; i < polygon.length; i++) {\n    const p = polygon[i];\n    minX = Math.min(minX, p[0]);\n    minY = Math.min(minY, p[1]);\n    maxX = Math.max(maxX, p[0]);\n    maxY = Math.max(maxY, p[1]);\n  }\n\n  return [minX, minY, maxX, maxY];\n}\n\n\n/**\n * Checks if two points are effectively at the same location.\n * @param p1 The first point.\n * @param p2 The second point.\n * @returns `true` if points are equal.\n */\nexport function arePointsEqual(p1: Vec2, p2: Vec2): boolean {\n  return Math.abs(p1[0] - p2[0]) < 1e-6 && Math.abs(p1[1] - p2[1]) < 1e-6;\n}\n\n/**\n * Generates the full segment path for an edge based on its TabPlacements.\n * This function modifies the half-edges of the provided edge in place.\n */\nexport function generateSegmentsForEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  tabGenerator: TabGenerator,\n  random: RandomFn\n): void {\n  if (!edge.tabs) { return; }\n  const heLeft = topology.halfEdges.get(edge.heLeft)!;\n  const heRight = topology.halfEdges.get(edge.heRight)!;\n\n  const edgeStart = heLeft.origin;\n  const edgeEnd = heRight.origin;\n  //const edgeLength = Math.hypot(edgeEnd[0] - edgeStart[0], edgeEnd[1] - edgeStart[1]);\n\n  const heLeftSegments: EdgeSegment[] = [];\n  let currentPos = edgeStart;\n\n  // Sort tabs by their position to process them in order\n  edge.tabs.sort((a, b) => a.position - b.position);\n\n  for (const tab of edge.tabs) {\n    //const tabWidth = edgeLength * tab.size;\n    // Calculate the start point of this tab's region\n    const tabStartPos = tab.position - tab.size / 2;\n    const tabStartPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * tabStartPos,\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * tabStartPos,\n    ];\n\n    // Add a straight line from the last position to the start of this tab\n    if (Math.hypot(tabStartPoint[0] - currentPos[0], tabStartPoint[1] - currentPos[1]) > 1e-6) {\n      heLeftSegments.push({ type: 'line', p: tabStartPoint });\n    }\n\n    // Generate segments for the tab itself\n    const tabEndPoint: Vec2 = [\n      edgeStart[0] + (edgeEnd[0] - edgeStart[0]) * (tabStartPos + tab.size),\n      edgeStart[1] + (edgeEnd[1] - edgeStart[1]) * (tabStartPos + tab.size),\n    ];\n    const tabSegments = tabGenerator.createTabSegments(tabStartPoint, tabEndPoint, tab, random);\n    heLeftSegments.push(...tabSegments);\n\n    currentPos = tabEndPoint;\n  }\n\n  // Add a final line segment to the end of the edge\n  if (Math.hypot(edgeEnd[0] - currentPos[0], edgeEnd[1] - currentPos[1]) > 1e-6) {\n    heLeftSegments.push({ type: 'line', p: edgeEnd });\n  }\n\n  // Assign the generated segments and create the inverse for the twin\n  heLeft.segments = heLeftSegments;\n  heRight.segments = invertSegments(heLeftSegments, edgeStart);\n}\n\n/**\n * Creates an inverted copy of an array of edge segments.\n */\nexport function invertSegments(segments: EdgeSegment[], originalStart: Vec2): EdgeSegment[] {\n  const inverted: EdgeSegment[] = [];\n\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const segment = segments[i];\n    let segmentStart = originalStart;\n    if (i > 0) {\n      const prevSegment = segments[i-1];\n      segmentStart = (prevSegment.type === 'line') ? prevSegment.p : prevSegment.p3;\n    }\n\n    if (segment.type === 'line') {\n      inverted.push({ type: 'line', p: segmentStart });\n    } else { // 'bezier'\n      inverted.push({\n        type: 'bezier',\n        p1: segment.p2,\n        p2: segment.p1,\n        p3: segmentStart,\n      });\n    }\n  }\n  return inverted;\n}\n\n\n/**\n * Helper function to reverse a single Bézier curve segment.\n * The new curve starts where the old one ended and vice-versa.\n */\nexport function invertCurve(segment: CurveTo, newEndPoint: Vec2): CurveTo {\n  return {\n    type: 'bezier',\n    p1: segment.p2, // Control points are swapped\n    p2: segment.p1,\n    p3: newEndPoint, // The new end point is the start point of the original\n  };\n}\n","\n/**\n * Simple seeded PRNG. The state space is 32 bits, so the period (the point at\n * which random numbers repeat for the same seed) is 2^32.\n * See https://github.com/cprosche/mulberry32 for more details.\n * @param seed seed number\n * @returns function which returns a random number each time it is called\n */\nexport function mulberry32(seed: number) {\n  return function() {\n    let t = seed += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nexport default mulberry32;\n","import type { PuzzleGeometry, Vec2 } from \"./types\";\nimport {\n  PointGeneratorRegistry,\n  PieceGeneratorRegistry,\n  TabPlacementStrategyRegistry,\n  TabGeneratorRegistry,\n  type GeneratorConfig,\n} from \"./generators/Generator\";\nimport { generateSegmentsForEdge } from \"./utils\";\nimport mulberry32 from \"../utils/mulberry\";\n\n/**\n * Configuration options for the entire puzzle generation process.\n */\nexport interface PuzzleGenerationOptions {\n  /** Width of the puzzle */\n  width: number;\n  /** Height of the puzzle */\n  height: number;\n  /** A rough guide for piece size */\n  pieceSize: number;\n  /** Random seed to produce repeatable puzzles */\n  seed?: number;\n  /** How should the points that control the pieces get generated? */\n  pointConfig: GeneratorConfig;\n  /** How should the pieces get built? */\n  pieceConfig: GeneratorConfig;\n  /** How should tabs get placed on piece edges? */\n  placementConfig: GeneratorConfig;\n  /** How should tabs get constructed? */\n  tabConfig: GeneratorConfig;\n}\n\n/**\n * Orchestrates the procedural generation of a jigsaw puzzle\n * by coordinating various pluggable generators.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function buildPuzzle(options: PuzzleGenerationOptions): Promise<PuzzleGeometry> {\n  const { width, height, pieceSize } = options;\n  const { pointConfig, pieceConfig, placementConfig, tabConfig } = options;\n\n  console.log(`rebuilding puzzle with dimensions ${width}x${height}, piece size ${pieceSize}`);\n\n  // get and configure the necessary generators\n  const pointGenerator = PointGeneratorRegistry.create(width, height, pointConfig);\n  const pieceGenerator = PieceGeneratorRegistry.create(width, height, pieceConfig);\n  const placementStrategy = TabPlacementStrategyRegistry.create(width, height, placementConfig);\n  const tabGenerator = TabGeneratorRegistry.create(width, height, tabConfig);\n\n  // seeded PRNG used to generate repeatable random numbers\n  const seed = options.seed ?? new Date().getTime();\n  const random = mulberry32(seed);\n\n  // 1. Generate seed points for the pieces\n  const points = pointGenerator.generatePoints({ width, height, pieceSize, random });\n  console.log(`Generated ${points.length} points`);\n\n  // 2. Convert points to a puzzle topology (pieces and edges)\n  const topology = pieceGenerator.generatePieces(points, { random, pieceSize });\n  console.log(`Generated ${topology.pieces.size} pieces`);\n\n  // 3. Place tabs on internal edges\n  placementStrategy.placeTabs({ topology, random });\n\n  // 4. Generate geometry for placed tabs\n  for (const edge of topology.edges.values()) {\n    // only internal edges can accept tabs\n    const isInternal = edge.heRight !== -1;\n    if (isInternal && edge.tabs && edge.tabs.length > 0) {\n      // use the tab generator to create the segment path for an edge based on its TabPlacements\n      generateSegmentsForEdge(edge, topology, tabGenerator, random);\n    }\n  }\n\n  // 5. Assemble the final puzzle data structure\n  const puzzle: PuzzleGeometry = {\n    created: new Date().toISOString(),\n    seed,\n    width,\n    height,\n    pieceSize,\n    pointConfig,\n    pieceConfig,\n    placementConfig,\n    tabConfig,\n    vertices: topology.vertices,\n    boundary: topology.boundary,\n    pieces: topology.pieces,\n    edges: topology.edges,\n    halfEdges: topology.halfEdges,\n  };\n\n  return puzzle;\n}\n\n/** Draws puzzle geometry onto a canvas */\nexport function drawPuzzle(puzzle: PuzzleGeometry, canvas: HTMLCanvasElement, pieceColor: string, showPoints = false) {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.error(\"Could not get 2D context from canvas\");\n    return;\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // In debug mode, we draw each piece's full boundary in a different color.\n  // This helps visualize the ownership of each edge.\n  const debugMode = false;\n\n  if (debugMode) {\n    const debugColors = [\n      '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',\n      '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff',\n      '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',\n    ];\n    ctx.lineWidth = 2; // Use a thicker line for better visibility\n\n    let pieceIndex = 0;\n    for (const piece of puzzle.pieces.values()) {\n      const pieceColor = debugColors[pieceIndex % debugColors.length];\n      ctx.strokeStyle = pieceColor;\n      ctx.beginPath();\n      ctx.setLineDash([5, 5]); // use dashed lines\n\n      // Get the starting half-edge for this piece's boundary\n      let currentHe = puzzle.halfEdges.get(piece.halfEdge);\n      if (!currentHe) continue;\n\n      const startHeId = currentHe.id;\n      ctx.moveTo(currentHe.origin[0], currentHe.origin[1]);\n\n      // Traverse the boundary of the piece by following the 'next' pointers\n      // until we get back to the starting half-edge.\n      do {\n        if (currentHe.segments) {\n          // If the edge has a custom tab, draw its segments\n          for (const segment of currentHe.segments) {\n            switch (segment.type) {\n            case 'bezier':\n              ctx.bezierCurveTo(segment.p1[0], segment.p1[1], segment.p2[0], segment.p2[1], segment.p3[0], segment.p3[1]);\n              break;\n            case 'line':\n              ctx.lineTo(segment.p[0], segment.p[1]);\n              break;\n            }\n          }\n        } else {\n          // Otherwise, draw a straight line to the start of the next half-edge\n          const nextHe = puzzle.halfEdges.get(currentHe.next)!;\n          ctx.lineTo(nextHe.origin[0], nextHe.origin[1]);\n        }\n        // Move to the next half-edge in the loop\n        currentHe = puzzle.halfEdges.get(currentHe.next)!;\n      } while (currentHe.id !== startHeId);\n\n      ctx.stroke();\n      pieceIndex++;\n    }\n\n    // Reset line dash for subsequent drawing operations.\n    ctx.setLineDash([]);\n\n  } else {\n    // normal mode drawing, optimized for efficiency\n\n    // Style for piece boundaries\n    ctx.strokeStyle = pieceColor;\n    ctx.lineWidth = 1;\n\n    // it's more efficient to batch all paths together\n    ctx.beginPath();\n\n    // By iterating through all unique edges and drawing the curve for one of\n    // its half-edges, we ensure every cut is defined exactly once.\n    for (const edge of puzzle.edges.values()) {\n      // We consistently choose heLeft. The tab generator puts the \"outie\"\n      // or \"innie\" on this half-edge, and the twin gets the inverse.\n      const he = puzzle.halfEdges.get(edge.heLeft);\n      if (!he) continue; // should not happen\n\n      // move to the start of this edge segment\n      ctx.moveTo(he.origin[0], he.origin[1]);\n\n      if (he.segments && he.segments.length > 0) {\n        // if a custom tab is defined, draw each segment in order\n        for (const segment of he.segments) {\n          switch (segment.type) {\n          case 'bezier':\n            ctx.bezierCurveTo(\n              segment.p1[0], segment.p1[1],\n              segment.p2[0], segment.p2[1],\n              segment.p3[0], segment.p3[1]\n            );\n            break;\n          case 'line':\n            ctx.lineTo(segment.p[0], segment.p[1]);\n            break;\n          }\n        }\n      } else {\n        // no tab, draw a straight line to the edge's endpoint.\n        // The end point of a half-edge is the origin of its twin.\n        // For boundary edges, the twin is -1, so we find the end point\n        // by looking at the start of the next half-edge around the piece.\n        let destination: Vec2;\n        // For an internal edge, the destination is the origin of the twin half-edge.\n        if (he.twin !== -1) {\n          const twinHe = puzzle.halfEdges.get(he.twin)!;\n          destination = twinHe.origin;\n        } else {\n          // For a boundary edge, the destination is the origin of the next half-edge in the loop.\n          const nextHe = puzzle.halfEdges.get(he.next)!;\n          destination = nextHe.origin;\n        }\n        ctx.lineTo(destination[0], destination[1]);\n      }\n    }\n\n    // stroke the entire path containing all the unique puzzle edges\n    ctx.stroke();\n  }\n\n  // if the puzzle has problems like intersecting/overlapping pieces, highlight them\n  if (puzzle.problems && puzzle.problems.length > 0) {\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = 'red';\n    for (const problemPoint of puzzle.problems) {\n      const [x, y] = problemPoint;\n      ctx.beginPath();\n      ctx.arc(x, y, 8, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n  }\n\n  // draw the piece sites (original Voronoi points) for reference\n  if (showPoints) {\n    ctx.fillStyle = 'blue';\n    for (const piece of puzzle.pieces.values()) {\n      const [x, y] = piece.site;\n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n}\n","import type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  PieceID,\n  PuzzleGeometry,\n  Vec2,\n  VertexID,\n} from './types';\nimport { TabPlacementStrategyRegistry, TabGeneratorRegistry } from './generators/Generator';\nimport { generateSegmentsForEdge, getPieceAABB } from './utils';\nimport mulberry32 from \"../utils/mulberry\";\n\n\n/**\n * Finds the closest vertex to a click position and moves it to a new position,\n * updating all connected edges and pieces. This function directly modifies the\n * provided puzzle object.\n *\n * @param puzzle The puzzle data structure to modify.\n * @param vertexIndex The index of the vertex to move in the `puzzle.vertices` array\n * @param newPos The new [x, y] coordinates to move the vertex to.\n */\nexport function moveVertex(\n  puzzle: PuzzleGeometry,\n  vertexIndex: VertexID,\n  newPos: Vec2\n): void {\n  // --- 1. Get the vertex's original position ---\n  if (vertexIndex < 0 || vertexIndex >= puzzle.vertices.length) {\n    console.warn(\"moveVertex called with invalid vertex index:\", vertexIndex);\n    return;\n  }\n  const oldPos = puzzle.vertices[vertexIndex];\n\n  // --- 2. Update the master vertex in the vertices array ---\n  puzzle.vertices[vertexIndex] = newPos;\n\n  // --- 3. Identify all half-edges that are affected by this move ---\n  const departingEdges: HalfEdge[] = [];\n  for (const he of puzzle.halfEdges.values()) {\n    // A half-edge \"departs\" from the vertex if its origin is at the old position.\n    if (he.origin[0] === oldPos[0] && he.origin[1] === oldPos[1]) {\n      departingEdges.push(he);\n    }\n  }\n\n  const affectedPieceIDs = new Set<PieceID>();\n  const delta: Vec2 = [newPos[0] - oldPos[0], newPos[1] - oldPos[1]];\n\n  // --- 4. Update the geometry of all affected half-edges ---\n  for (const departingEdge of departingEdges) {\n    // The origin of the departing edge is now the new position.\n    departingEdge.origin = newPos;\n    affectedPieceIDs.add(departingEdge.piece);\n\n    // Now we must update the half-edge that *flows into* this vertex.\n    // This is the predecessor in the piece's boundary loop.\n    const predecessorEdge = puzzle.halfEdges.get(departingEdge.prev);\n\n    if (predecessorEdge?.segments) {\n      const lastSegment = predecessorEdge.segments[predecessorEdge.segments.length - 1];\n\n      // Update the endpoint of the predecessor's final segment.\n      if (lastSegment.type === 'line') {\n        lastSegment.p = newPos;\n      } else { // 'bezier'\n        lastSegment.p3 = newPos;\n        // For a smooth transition, we translate the control points by the same\n        // amount as the endpoint. More sophisticated logic could be used here\n        // for better curve preservation.\n        lastSegment.p1 = [lastSegment.p1[0] + delta[0], lastSegment.p1[1] + delta[1]];\n        lastSegment.p2 = [lastSegment.p2[0] + delta[0], lastSegment.p2[1] + delta[1]];\n      }\n      affectedPieceIDs.add(predecessorEdge.piece);\n    }\n  }\n\n  // --- 5. Rebuild any tabs affected by the vertex move ---\n  regenerateAffectedTabs(puzzle, vertexIndex);\n\n  // --- 6. Recalculate the bounding boxes for all affected pieces ---\n  for (const pieceId of affectedPieceIDs) {\n    const piece = puzzle.pieces.get(pieceId);\n    if (piece) {\n      piece.bounds = getPieceAABB(piece, puzzle);\n    }\n  }\n}\n\n\n/**\n * Finds all full (interior) edges connected to a given vertex and regenerates their tabs.\n *\n * @param puzzle The puzzle and its topology.\n * @param vertex The the vertex that was modified.\n */\nexport function regenerateAffectedTabs(\n  puzzle: PuzzleGeometry,\n  vertex: VertexID\n): void {\n\n  const { seed, width, height, placementConfig, tabConfig } = puzzle;\n  const random = mulberry32(seed);\n\n  // recreate the placement strategy and tab generator that were used for this puzzle\n  const placementStrategy = TabPlacementStrategyRegistry.create(width, height, placementConfig);\n  const tabGenerator = TabGeneratorRegistry.create(width, height, tabConfig);\n\n  const affectedEdges = new Set<Edge>();\n  const movedVertexPos = puzzle.vertices[vertex];\n\n  // To efficiently find the parent Edge of a HalfEdge, we can build a lookup map.\n  // This is much faster than iterating through all edges every time.\n  const halfEdgeToEdgeMap = new Map<EdgeID, Edge>();\n  for (const edge of puzzle.edges.values()) {\n    halfEdgeToEdgeMap.set(edge.heLeft, edge);\n    // heRight can be -1 for boundary edges, so check first.\n    if (edge.heRight !== -1) {\n      halfEdgeToEdgeMap.set(edge.heRight, edge);\n    }\n  }\n\n  // Find all half-edges that either start or end at the moved vertex.\n  for (const he of puzzle.halfEdges.values()) {\n    const destinationVertex = puzzle.halfEdges.get(he.next)?.origin;\n\n    // Is this half-edge starting at the moved vertex?\n    const startsAtVertex = he.origin === movedVertexPos;\n    // Is this half-edge ending at the moved vertex?\n    const endsAtVertex = destinationVertex === movedVertexPos;\n\n    if (startsAtVertex || endsAtVertex) {\n      const parentEdge = halfEdgeToEdgeMap.get(he.id);\n      if (parentEdge) {\n        affectedEdges.add(parentEdge);\n      }\n    }\n  }\n\n  // re-run the placement strategy in case it needs to make a change\n  placementStrategy.updateTabPlacements(Array.from(affectedEdges), { topology: puzzle, random });\n\n  // Now, regenerate the tabs for the unique set of affected edges.\n  for (const edge of affectedEdges) {\n    // only add tabs to internal edges\n    const isInternal = edge.heRight !== -1;\n    if (isInternal) {\n      // remove any existing segments\n      const he1 = puzzle.halfEdges.get(edge.heLeft);\n      if (he1) { he1.segments = undefined; }\n      const he2 = puzzle.halfEdges.get(edge.heRight);\n      if (he2) { he2.segments = undefined; }\n\n      // regenerate segments\n      generateSegmentsForEdge(edge, puzzle, tabGenerator, random);\n    }\n  }\n}","import m from 'mithril';\nimport { drawPuzzle } from \"../geometry/PuzzleMaker\";\nimport { moveVertex } from '../geometry/modifiers';\nimport { findClosestVertex } from '../geometry/utils';\nimport type { VertexID } from '../geometry/types';\nimport type { PuzzleGeometry, Vec2 } from '../geometry/types';\nimport type MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// include our CSS\nimport './Puzzle.css';\n\n// component attributes\nexport interface PuzzleAttrs extends m.Attributes {\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Generated puzzle geometry */\n  puzzle: PuzzleGeometry,\n  /** If true, geometry is being regenerated */\n  isDirty: boolean;\n  /** User uploaded image */\n  imageUrl?: string;\n  /** Callback indicating user modified the puzzle geometry */\n  onPuzzleChanged: (puzzle: PuzzleGeometry) => void;\n}\n\n// Mithril component\nexport const Puzzle: m.ClosureComponent<PuzzleAttrs> = () => {\n\n  // component state\n  const state = {\n    /** Canvas HTML element */\n    canvas: null as HTMLCanvasElement | null,\n    /** Is the user currently dragging a vertex? */\n    isDragging: false,\n    /** The index of the vertex being dragged. */\n    draggedVertexId: -1 as VertexID,\n  };\n\n  return {\n    // component lifecycle: called after our DOM element is created and attached\n    oncreate: ({ dom, attrs }) => {\n      state.canvas = dom.querySelector<HTMLCanvasElement>(\"canvas.puzzle\");\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color);\n      }\n    },\n\n    onupdate: ({ attrs }) => {\n      if (!state.canvas) {\n        console.log('couldn\\'t get canvas element');\n        return;\n      }\n      if (!attrs.isDirty) {\n        drawPuzzle(attrs.puzzle, state.canvas, attrs.color);\n      }\n    },\n\n    // component lifecycle: render our output\n    view: ({ attrs }) => {\n\n      return m(\".puzzle-stack\", [\n\n        // user uploaded image\n        m(\"img.background\", {\n          width: attrs.width,\n          height: attrs.height,\n          src: attrs.imageUrl,\n        }),\n\n        // canvas for rendering the current puzzle\n        m('canvas.puzzle', {\n          width: attrs.width,\n          height: attrs.height,\n          style: {\n            width: `${attrs.width}px`,\n            height: `${attrs.height}px`,\n          },\n          onmousedown: (e: MouseEvent & MithrilViewEvent) => {\n            e.redraw = false;\n            // we only care about the primary mouse button\n            if (e.button !== 0) return;\n            e.preventDefault();\n\n            // find the nearest vertex and store it as a potential drag target\n            const clickPos: Vec2 = [e.offsetX, e.offsetY];\n            const vertex = findClosestVertex(attrs.puzzle, clickPos);\n            if (vertex !== null) {\n              state.draggedVertexId = vertex;\n            }\n          },\n          onmousemove: (e: MouseEvent & MithrilViewEvent) => {\n            e.redraw = false;\n            // if the user didn't target a vertex, do nothing\n            if (state.draggedVertexId < 0) return;\n\n            // have a vertex, this is a drag action\n            state.isDragging = true;\n\n            e.preventDefault();\n            const currentPos: Vec2 = [e.offsetX, e.offsetY];\n\n            // move the dragged vertex and redraw\n            moveVertex(attrs.puzzle, state.draggedVertexId, currentPos);\n            drawPuzzle(attrs.puzzle, state.canvas!, attrs.color);\n          },\n          onmouseup: (e: MouseEvent & MithrilViewEvent) => {\n            e.redraw = false;\n            e.preventDefault();\n            // we only care about the end of a drag, not a click\n            if (state.isDragging) {\n              // the moveVertex() call modifies the puzzle geometry in place, but\n              // we signal the parent that it's been changed to be explicit\n              attrs.onPuzzleChanged(attrs.puzzle);\n            }\n            state.isDragging = false;\n            state.draggedVertexId = -1;\n          },\n          onmouseleave: (e: MouseEvent & MithrilViewEvent) => {\n            e.redraw = false;\n            if (state.isDragging) {\n              e.preventDefault();\n              attrs.onPuzzleChanged(attrs.puzzle);\n              state.isDragging = false;\n              state.draggedVertexId = -1;\n            }\n          },\n        }),\n      ]);\n    },\n\n  };\n};\nexport default Puzzle;\n\n","import { PuzzleTopology, Vec2 } from \"../geometry/types\";\n\n/**\n * Generates an SVG string representation of the puzzle's cut lines.\n *\n * @param topology - The puzzle topology containing the geometric data.\n * @param width - The width of the SVG viewport.\n * @param height - The height of the SVG viewport.\n * @param pieceColor - Optional color to draw the pieces (default black)\n * @returns A string containing the complete SVG markup.\n */\nexport function createSVG(topology: PuzzleTopology, width: number, height: number, pieceColor = \"black\"): string {\n  // how many digits to preserve when converting decimal numbers to SVG string\n  const precisionDigits = 3;\n\n  // Array to hold the individual path commands (e.g., \"M 10 10\", \"L 100 100\").\n  const pathData: string[] = [];\n\n  // Iterate over each unique edge, ensuring each cut is only defined once.\n  for (const edge of topology.edges.values()) {\n    const he = topology.halfEdges.get(edge.heLeft);\n    if (!he) continue;\n\n    // SVG Path Command: \"M\" - move to the starting point of the half-edge.\n    pathData.push(`M ${he.origin[0].toFixed(precisionDigits)} ${he.origin[1].toFixed(precisionDigits)}`);\n\n    if (he.segments) {\n      // if a custom tab is defined, draw each segment in order\n      for (const segment of he.segments) {\n        switch (segment.type) {\n        case 'bezier':\n          // SVG Path Command: \"C\" - draw a cubic Bézier curve.\n          pathData.push(\n            `C ${segment.p1[0].toFixed(precisionDigits)} ${segment.p1[1].toFixed(precisionDigits)}, ` +\n            `${segment.p2[0].toFixed(precisionDigits)} ${segment.p2[1].toFixed(precisionDigits)}, ` +\n            `${segment.p3[0].toFixed(precisionDigits)} ${segment.p3[1].toFixed(precisionDigits)}`\n          );\n          break;\n        case 'line':\n          // SVG Path Command: \"L\" - draw a straight line to the destination.\n          pathData.push(`L ${segment.p[0].toFixed(precisionDigits)} ${segment.p[1].toFixed(precisionDigits)}`);\n          break;\n        }\n      }\n    } else {\n      // SVG Path Command: \"L\" - draw a straight line to the destination.\n      let destination: Vec2;\n      if (he.twin !== -1) {\n        // Internal edge: destination is the start of the twin half-edge.\n        const twinHe = topology.halfEdges.get(he.twin)!;\n        destination = twinHe.origin;\n      } else {\n        // Boundary edge: destination is the start of the next half-edge.\n        const nextHe = topology.halfEdges.get(he.next)!;\n        destination = nextHe.origin;\n      }\n      pathData.push(`L ${destination[0].toFixed(precisionDigits)} ${destination[1].toFixed(precisionDigits)}`);\n    }\n  }\n\n  // Join all path commands into a single string for the 'd' attribute.\n  const pathD = pathData.join(' ');\n\n  // Construct the final SVG markup.\n  // The <path> element uses vector-effect=\"non-scaling-stroke\" which is a best\n  // practice for laser cutting files, as it ensures the line width remains\n  // constant regardless of scaling.\n  const svgString = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg\n  width=\"${width}\"\n  height=\"${height}\"\n  viewBox=\"0 0 ${width} ${height}\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  version=\"1.1\"\n>\n  <path\n    d=\"${pathD}\"\n    fill=\"none\"\n    stroke=\"${pieceColor}\"\n    stroke-width=\"1\"\n    vector-effect=\"non-scaling-stroke\"\n  />\n</svg>`\n    .trim() // strip leading and trailing whitespace\n    .replace(/\\r\\n/g, '\\n'); // use unix line endings for max compatibility\n\n  return svgString;\n}\n\n\n/**\n * Offers a SVG file for download\n * @param svg SVG string as generated by drawSVG()\n * @param filename Optional name of file for download\n */\nexport function downloadSvg(svg: string, filename = \"puzzle.svg\") {\n  // create a blob from the SVG string\n  const blob = new Blob([svg], { type: \"image/svg+xml\" });\n\n  // create a temporary object URL for the blob\n  const url = URL.createObjectURL(blob);\n\n  // create a hidden <a> element with the download attribute\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  a.hidden = true;\n\n  // click it\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n\n  // clean up\n  setTimeout(() => URL.revokeObjectURL(url), 100);\n}\n","// UI component that offers a SVG download when clicked\nimport m from 'mithril';\nimport { createSVG, downloadSvg } from '../utils/svg';\nimport type { PuzzleTopology } from '../geometry/types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\nexport interface DownloadPuzzleButtonAttrs extends m.Attributes {\n  /** Generated puzzle geometry */\n  puzzle: PuzzleTopology;\n  /** Width of rendered puzzle in pixels */\n  width: number;\n  /** Height of rendered puzzle in pixels */\n  height: number;\n  /** Color of pieces */\n  color: string;\n  /** Optional filename for the download */\n  filename?: string;\n}\n\nexport const DownloadPuzzleButton: m.Component<DownloadPuzzleButtonAttrs> = {\n  view: ({ attrs }) => {\n    return m('wa-button.download-svg', {\n      size: 'small',\n      onclick: () => {\n        // convert the puzzle geometry into a SVG string\n        const svg = createSVG(attrs.puzzle, attrs.width, attrs.height, attrs.color);\n        // offer it as a download\n        downloadSvg(svg, attrs.filename ?? 'puzzle.svg');\n      },\n    }, 'Download SVG');\n  },\n};\nexport default DownloadPuzzleButton;\n","// UI component to initiate and display geometry checks\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/badge/badge.js';\nimport '@awesome.me/webawesome/dist/components/button/button.js';\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport '@awesome.me/webawesome/dist/components/icon/icon.js';\nimport '@awesome.me/webawesome/dist/components/progress-bar/progress-bar.js';\nimport '@awesome.me/webawesome/dist/components/tooltip/tooltip.js';\n\n// component CSS\nimport './GeometryCheckIndicator.css';\n\n// component attributes\nexport interface GeometryCheckIndicatorAttrs extends m.Attributes {\n  /** If true, the auto check box is checked */\n  autoCheck: boolean;\n  /** If present, represents the number of geometry problems found in the most recent check */\n  problems?: number;\n  /** If present represents the percent complete of the current geometry check */\n  progressPercent?: number;\n  /** Handler called when user clicks the check now button */\n  onCheckRequested?: () => void;\n  /** Called when the user toggles the auto check on or off */\n  onAutocheckChanged?: (autocheck: boolean) => void;\n};\n\n// component\nexport const GeometryCheckIndicator: m.Component<GeometryCheckIndicatorAttrs> = {\n  view: ({ attrs }) => {\n    const showProgress = attrs.progressPercent !== undefined && attrs.progressPercent < 100;\n    const showOKBadge = !showProgress && attrs.problems !== undefined && attrs.problems == 0;\n    const showProblemBadge = !showProgress && attrs.problems !== undefined && attrs.problems > 0;\n\n    return m('.geometry-check-indicator', [\n\n      // label\n      m('.label', \"Geometry Check:\"),\n\n      // run now button\n      m('wa-tooltip', { for: 'check-geometry-now'}, 'Check geometry now'),\n      m('wa-button#check-geometry-now', {\n        variant: 'neutral',\n        appearance: 'plain',\n        size: 'small',\n        disabled: showProgress,\n        onclick: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          attrs.onCheckRequested?.();\n        },\n      }, m('wa-icon', {\n        library: 'material',\n        name: 'editor_choice',\n        label: 'Check geometry now',\n      })),\n\n      // auto check checkbox\n      m('wa-tooltip', { for: 'auto-check-geometry' }, 'Check geometry after every change'),\n      m('wa-checkbox#auto-check-geometry', {\n        checked: attrs.autoCheck,\n        disabled: showProgress,\n        size: 'small',\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const checkbox = e.target as WaCheckbox;\n          attrs.onAutocheckChanged?.(checkbox.checked);\n        },\n      }, 'auto check'),\n\n      // progress indicator\n      showProgress && m('wa-progress-bar', {\n        label: 'Geometry check progress',\n        value: attrs.progressPercent ?? 0,\n      }),\n\n      // OK badge\n      showOKBadge && m('wa-badge', {\n        variant: 'success',\n        pill: true,\n      }, 'OK'),\n\n      // Problems badge\n      showProblemBadge && m('wa-badge', {\n        variant: 'danger',\n        pill: true,\n      }, `${attrs.problems} issue${attrs.problems === 1 ? '' : 's'}`),\n\n    ]);\n  },\n};\nexport default GeometryCheckIndicator;\n","// UI component that allows the user to select an image to upload when clicked\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/button/button.js';\n\n// component attributes\nexport interface UploadImageAttrs extends m.Attributes {\n  /** Optional label for the button, default \"Upload Image\" */\n  label?: string;\n  /** If true, the button will be disabled */\n  disabled?: boolean;\n  /**\n   * Called when the user uploads an image. The caller is responsible for\n   * cleaning up the returned image URL.\n   */\n  onUpload: (imageUrl: string, filename: string, width: number, height: number) => void;\n};\n\n// utility to determine display dimensions that are the same aspect ratio\nfunction calculateDisplayDimensions(originalWidth: number, originalHeight: number, maxWidth = 800): {\n  width: number;\n  height: number;\n} {\n  if (originalWidth <= maxWidth) {\n    return {\n      width: originalWidth,\n      height: originalHeight,\n    };\n  }\n\n  const aspectRatio = originalHeight / originalWidth;\n  return {\n    width: maxWidth,\n    height: Math.round(maxWidth * aspectRatio),\n  };\n}\n\n// component\nexport const UploadImageButton: m.ClosureComponent<UploadImageAttrs> = () => {\n\n  // component state\n  const state = {\n    inputElement: undefined as HTMLInputElement | undefined,\n  };\n\n  return {\n\n    view: ({ attrs }) => {\n      return [\n\n        // button for display\n        m('wa-button.upload-button', {\n          size: 'small',\n          disabled: attrs.disabled === true,\n          onclick: () => {\n            if (state.inputElement) {\n              state.inputElement.click();\n            }\n          },\n        }, attrs.label ?? 'Upload Image'),\n\n        // hidden file input that does the work\n        m('input[type=file]', {\n          style: { display: 'none' },\n          accept: 'image/*',\n          oncreate: ({ dom }) => {\n            state.inputElement = dom as HTMLInputElement;\n          },\n          onchange: (e: Event & MithrilViewEvent) => {\n            e.redraw = false;\n            if (state.inputElement) {\n              const file = state.inputElement.files?.[0];\n              if (file?.type.startsWith('image/')) {\n                createImageBitmap(file)\n                  .then((bitmap) => {\n                    // get the image dimensions, scaled to fit in the display area\n                    const { width, height } = calculateDisplayDimensions(bitmap.width, bitmap.height);\n                    const uploadUrl = URL.createObjectURL(file);\n                    bitmap.close();\n                    attrs.onUpload(uploadUrl, file.name, width, height);\n                  })\n                  .catch((err) => {\n                    console.error('could not create a bitmap image: ', err);\n                  });\n              }\n            }\n          },\n        }),\n      ];\n    },\n  };\n};\nexport default UploadImageButton;\n","// UI component to take boolean input\nimport m from 'mithril';\nimport type { BooleanUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\nimport WaCheckbox from '@awesome.me/webawesome/dist/components/checkbox/checkbox.js';\n\n// component attributes\nexport interface BooleanInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: BooleanUIControl;\n  /** Current value */\n  value: boolean;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: boolean) => void;\n}\n\n// component\nexport const BooleanInputControl: m.ClosureComponent<BooleanInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-checkbox.boolean-input', {\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        checked: attrs.value,\n        onchange: (e: Event) => {\n          const input = e.target as WaCheckbox;\n          const newValue = input.checked;\n          attrs.onChange(newValue);\n        },\n      }, attrs.config.label);\n    },\n  };\n};\nexport default BooleanInputControl;\n","// UI component to take a number input\nimport m from 'mithril';\nimport type { NumberUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface NumberInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: NumberUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const NumberInputControl: m.ClosureComponent<NumberInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.number-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"number\",\n        inputmode: \"numeric\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        onchange: (e: Event) => {\n          const input = e.target as WaInput;\n          const newValue = parseFloat(input.value ?? '');\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default NumberInputControl;\n","// UI component to take number input from a slider\nimport m from 'mithril';\nimport type { RangeUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// component attributes\nexport interface RangeInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: RangeUIControl;\n  /** Current value */\n  value?: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: number | undefined) => void;\n}\n\n// component\nexport const RangeInputControl: m.ClosureComponent<RangeInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-slider.range-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        disabled: attrs.disabled,\n        value: attrs.value,\n        min: attrs.config.min,\n        max: attrs.config.max,\n        step: attrs.config.step,\n        onchange: (e: Event) => {\n          const input = e.target as WaSlider;\n          const newValue = input.value;\n          attrs.onChange(isNaN(newValue) ? undefined : newValue);\n        },\n      });\n    },\n  };\n};\nexport default RangeInputControl;\n","// UI component to take string input\nimport m from 'mithril';\nimport type { StringUIControl } from '../../geometry/ui_types';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/input/input.js';\nimport WaInput from '@awesome.me/webawesome/dist/components/input/input.js';\n\n// component attributes\nexport interface StringInputControlAttr extends m.Attributes {\n  /** Details of this configuration value */\n  config: StringUIControl;\n  /** Current value */\n  value?: string;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current value */\n  onChange: (value: string | undefined) => void;\n}\n\n// component\nexport const StringInputControl: m.ClosureComponent<StringInputControlAttr> = () => {\n\n  // no component state\n\n  return {\n    view: ({ attrs }) => {\n      // use Webawesome for the heavy lifting\n      return m('wa-input.string-input', {\n        label: attrs.config.label,\n        hint: attrs.config.helpText,\n        type: \"text\",\n        inputmode: \"text\",\n        size: \"small\",\n        disabled: attrs.disabled,\n        value: attrs.value,\n        onchange: (e: Event) => {\n          const input = e.target as WaInput;\n          const newValue = input.value ?? '';\n          attrs.onChange(newValue.length > 0 ? newValue : undefined);\n        },\n      });\n    },\n  };\n};\nexport default StringInputControl;\n","// UI component that lets the user pick and configure a generator\nimport m from 'mithril';\nimport type { GeneratorRegistry, GeneratorConfig, GeneratorName } from '../geometry/generators/Generator';\nimport BooleanInputControl from './inputs/BooleanInputControl';\nimport NumberInputControl from './inputs/NumberInputControl';\nimport RangeInputControl from './inputs/RangeInputControl';\nimport StringInputControl from './inputs/StringInputControl';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/tab/tab.js';\nimport '@awesome.me/webawesome/dist/components/tab-group/tab-group.js';\nimport '@awesome.me/webawesome/dist/components/tab-panel/tab-panel.js';\nimport type { WaTabShowEvent } from '@awesome.me/webawesome';\n\n\n// include our CSS\nimport './GeneratorPicker.css';\n\n// component attributes\nexport interface GeneratorPickerAttrs<C extends GeneratorConfig = GeneratorConfig> extends m.Attributes {\n  /** Currently selected generator for this type */\n  generator: GeneratorName;\n  /** All the registered generators for this type */\n  registry: GeneratorRegistry<unknown>;\n  /** Current configuration for the selected generator */\n  config: C;\n  /** Called when the selected generator changes */\n  onGeneratorChange: (generatorName: string) => void;\n  /** Called when any config value changes */\n  onConfigChange: <K extends keyof C>(key: K, value: C[K]) => void;\n}\n\n// component\nexport const GeneratorPicker: m.ClosureComponent<GeneratorPickerAttrs> = () => {\n\n  // no component state\n\n  // component\n  return {\n\n    view: ({ attrs }) => {\n\n      const generators = attrs.registry.getAvailableGenerators();\n\n      return m(\".generator-picker\",\n        m('wa-tab-group', {\n          active: attrs.generator,\n          // custom Webawesome event triggered when a new tab panel is shown\n          'onwa-tab-show': (e: WaTabShowEvent) => {\n            const newSelected = e.detail.name;\n            if (attrs.generator !== newSelected) {\n              attrs.onGeneratorChange(newSelected);\n            }\n          },\n        }, [\n          ...generators.map((generator) => {\n            // get the UI metadata associated with this generator\n            const uiMetadata = attrs.registry.getUIMetadata(generator.name);\n\n            // tab contains name of generator\n            const tab = m('wa-tab', { panel: generator.name }, generator.displayName);\n\n            // matching panel contains controls specific to that generator\n            const panel = m('wa-tab-panel', { name: generator.name }, m('.controls',\n              [\n                // detailed description of the generator if available\n                uiMetadata?.description ? m('p', uiMetadata.description) : null,\n\n                // UI controls defined by the generator\n                ...uiMetadata?.controls.map((control) => {\n                  switch(control.type) {\n                  case \"range\":\n                    return m(RangeInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"boolean\":\n                    return m(BooleanInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) === true,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"number\":\n                    return m(NumberInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as number | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  case \"string\":\n                    return m(StringInputControl, {\n                      config: control,\n                      value: (attrs.config?.[control.name] ?? control.defaultValue) as string | undefined,\n                      onChange: (value) => {\n                        attrs.onConfigChange(control.name, value);\n                      },\n                    });\n                  }\n                }) ?? [],\n\n                // no controls message when appropriate\n                (!uiMetadata?.description && uiMetadata?.controls.length == 0) ? m('p', 'No controls for this strategy.') : null,\n              ])\n            );\n            return [tab, panel];\n          }),\n        ])\n      );\n    },\n  };\n};\nexport default GeneratorPicker;\n","// UI component to let the user select an aspect ratio\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/option/option.js';\nimport '@awesome.me/webawesome/dist/components/select/select.js';\nimport WaSelect from '@awesome.me/webawesome/dist/components/select/select.js';\nimport '@awesome.me/webawesome/dist/components/slider/slider.js';\nimport WaSlider from '@awesome.me/webawesome/dist/components/slider/slider.js';\n\n// this component's CSS\nimport './AspectRatioPicker.css';\n\n// component attributes\nexport interface AspectRatioPickerAttr extends m.Attributes {\n  /** Current ratio */\n  ratio: number;\n  /** If true, the control will be disabled */\n  disabled?: boolean;\n  /** Called when the user changes the current ratio */\n  onChange: (ratio: number) => void;\n}\n\n// data\nconst commonAspectRatios: [string, string, number][] = [\n  [\"Square\",           \"1:1\",    1],\n\n  // --- Landscape ---\n  [\"Classic Photo\",    \"5:4\",    5/4],\n  [\"Standard Photo\",   \"4:3\",    4/3],\n  [\"35mm/DSLR\",        \"3:2\",    3/2],\n  [\"Widescreen\",       \"16:9\",   16/9],\n  [\"UltraWide\",        \"21:9\",   21/9],\n  [\"Panorama\",         \"2:1\",    2/1],\n\n  // --- Portrait ---\n  [\"Instagram Portrait\",       \"4:5\",    4/5],\n  [\"Classic Portrait\",         \"3:4\",    3/4],\n  [\"DSLR Portrait\",            \"2:3\",    2/3],\n  [\"Phone Portrait\",           \"9:16\",   9/16],\n  [\"Tall Poster\",              \"9:21\",   9/21],\n  [\"Tall Panorama\",            \"1:2\",    1/2],\n];\n\n// component\nexport const AspectRatioPicker: m.Component<AspectRatioPickerAttr> = {\n  view: ({ attrs }) => {\n\n    // Determine if the current ratio is a custom value (not in our predefined list)\n    const isCustom = !commonAspectRatios.some(([, , value]) => value === attrs.ratio);\n\n    // Generate the list of <wa-option> elements\n    const selectOptions = commonAspectRatios.map(([name, ratioStr, value]) =>\n      m('wa-option', {\n        value: String(value), // select values are strings\n      }, `${name} [${ratioStr}]`)\n    );\n\n    // If the ratio is custom, add a temporary \"Custom\" option to the start of the list\n    if (isCustom) {\n      selectOptions.unshift(m('wa-option', { value: 'custom' }, 'Custom'));\n    }\n\n    return m('.aspect-ratio-picker', [\n\n      // drop down with common ratios\n      m('wa-select', {\n        label: 'Aspect Ratio',\n        size: 'small',\n        disabled: attrs.disabled,\n        value: isCustom ? 'custom' : String(attrs.ratio),\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const select = e.target as WaSelect;\n          const selectedValue = select.value as string;\n\n          // 'custom' is a placeholder, so we only trigger onChange for actual numeric values.\n          if (selectedValue && selectedValue !== 'custom') {\n            attrs.onChange(Number(selectedValue));\n          }\n        },\n      }, selectOptions),\n\n      // slider for any ratio\n      m('wa-slider', {\n        // allow ratios from 1:4 (0.25) to 4:1 (4.0)\n        min: 0.25,\n        max: 4,\n        step: 0.01,\n        'with-tooltip': true,\n        size: 'small',\n        disabled: attrs.disabled,\n        value: attrs.ratio,\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false; // parent component triggers redraws as necessary\n          const range = e.target as WaSlider;\n          attrs.onChange(range.value);\n        },\n      }),\n    ]);\n  },\n};\nexport default AspectRatioPicker;\n","// UI component to let the user select a color\nimport m from 'mithril';\nimport MithrilViewEvent from '../utils/MithrilViewEvent';\n\n// Webawesome components\nimport '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\nimport WaColorPicker from '@awesome.me/webawesome/dist/components/color-picker/color-picker.js';\n\n// this component's CSS\nimport './ColorPicker.css';\n\n// component attributes\nexport interface ColorPickerAttrs extends m.Attributes {\n  /** Label to display next to the color picker */\n  label: string;\n  /** Current color */\n  color: string;\n  /** Optional size of picker trigger area */\n  size?: \"small\" | \"medium\" | \"large\";\n  /** Called when the user changes the color */\n  onUpdate: (newColor: string) => void;\n};\n\n// component with no state\nexport const ColorPicker: m.Component<ColorPickerAttrs> = {\n  view: ({ attrs }) => {\n    return m('.color-picker', [\n      m('.label', attrs.label),\n      m('wa-color-picker', {\n        label: 'Select a color', // used by assistive devices\n        value: attrs.color,\n        size: attrs.size ?? \"medium\",\n        format: 'rgb',\n        onchange: (e: Event & MithrilViewEvent) => {\n          e.redraw = false;\n          const input = e.target as WaColorPicker;\n          attrs.onUpdate(input.value ?? '');\n        },\n      }),\n    ]);\n  },\n};\nexport default ColorPicker;\n","\"use strict\";\n\nfunction tinyNDArrayOfInteger (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        dimension;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    return {\n        stride: stride,\n        data: new Uint32Array(totalLength)\n    };\n}\n\nfunction tinyNDArrayOfArray (gridShape) {\n    var dimensions = gridShape.length,\n        totalLength = 1,\n        stride = new Array(dimensions),\n        data = [],\n        dimension, index;\n\n    for (dimension = dimensions; dimension > 0; dimension--) {\n        stride[dimension - 1] = totalLength;\n        totalLength = totalLength * gridShape[dimension - 1];\n    }\n\n    for (index = 0; index < totalLength; index++) {\n        data.push([]);\n    }\n\n    return {\n        stride: stride,\n        data: data\n    };\n}\n\nmodule.exports = {\n    integer: tinyNDArrayOfInteger,\n    array: tinyNDArrayOfArray\n};","\"use strict\";\n\n// sphere-random module by Mikola Lysenko under the MIT License\n// waiting for https://github.com/scijs/sphere-random/pull/1 to be merged\n\nmodule.exports = sampleSphere;\n\n/**\n * @param {int} d Dimensions\n * @param {Function} rng\n * @returns {Array}\n */\nfunction sampleSphere(d, rng) {\n    var v = new Array(d),\n        d2 = Math.floor(d/2) << 1,\n        r2 = 0.0,\n        rr,\n        r,\n        theta,\n        h,\n        i;\n\n    for (i = 0; i < d2; i += 2) {\n        rr = -2.0 * Math.log(rng());\n        r =  Math.sqrt(rr);\n        theta = 2.0 * Math.PI * rng();\n\n        r2+= rr;\n        v[i] = r * Math.cos(theta);\n        v[i+1] = r * Math.sin(theta);\n    }\n\n    if (d % 2) {\n        var x = Math.sqrt(-2.0 * Math.log(rng())) * Math.cos(2.0 * Math.PI * rng());\n        v[d - 1] = x;\n        r2+= Math.pow(x, 2);\n    }\n\n    h = 1.0 / Math.sqrt(r2);\n\n    for (i = 0; i < d; ++i) {\n        v[i] *= h;\n    }\n\n    return v;\n}\n","module.exports = function moore(range, dimensions) {\n  range = range || 1\n  dimensions = dimensions || 2\n\n  var size = range * 2 + 1\n  var length = Math.pow(size, dimensions) - 1\n  var neighbors = new Array(length)\n\n  for (var i = 0; i < length; i++) {\n    var neighbor = neighbors[i] = new Array(dimensions)\n    var index = i < length / 2 ? i : i + 1\n    for (var dimension = 1; dimension <= dimensions; dimension++) {\n      var value = index % Math.pow(size, dimension)\n      neighbor[dimension - 1] = value / Math.pow(size, dimension - 1) - range\n      index -= value\n    }\n  }\n\n  return neighbors\n}\n","\"use strict\";\n\nvar moore = require('moore');\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhood (dimensionNumber) {\n    var neighbourhood = moore(2, dimensionNumber),\n        origin = [],\n        dimension;\n\n    // filter out neighbours who are too far from the center cell\n    // the impact of this, performance wise, is surprisingly small, even in 3d and higher dimensions\n    neighbourhood = neighbourhood.filter(function (n) {\n        var dist = 0;\n\n        for (var d = 0; d < dimensionNumber; d++) {\n            dist += Math.pow(Math.max(0, Math.abs(n[d]) - 1), 2);\n        }\n\n        return dist < dimensionNumber; // cellSize = Math.sqrt(this.dimension)\n    });\n\n    for (dimension = 0; dimension < dimensionNumber; dimension++) {\n        origin.push(0);\n    }\n\n    neighbourhood.push(origin);\n\n    // sort by ascending distance to optimize proximity checks\n    // see point 5.1 in Parallel Poisson Disk Sampling by Li-Yi Wei, 2008\n    // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.460.3061&rank=1\n    neighbourhood.sort(function (n1, n2) {\n        var squareDist1 = 0,\n            squareDist2 = 0,\n            dimension;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            squareDist1 += Math.pow(n1[dimension], 2);\n            squareDist2 += Math.pow(n2[dimension], 2);\n        }\n\n        if (squareDist1 < squareDist2) {\n            return -1;\n        } else if(squareDist1 > squareDist2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n\n    return neighbourhood;\n}\n\nvar neighbourhoodCache = {};\n\n/**\n * Get the neighbourhood ordered by distance, including the origin point\n * @param {int} dimensionNumber Number of dimensions\n * @returns {Array} Neighbourhood\n */\nfunction getNeighbourhoodMemoized (dimensionNumber) {\n    if (!neighbourhoodCache[dimensionNumber]) {\n        neighbourhoodCache[dimensionNumber] = getNeighbourhood(dimensionNumber);\n    }\n\n    return neighbourhoodCache[dimensionNumber];\n}\n\nmodule.exports = getNeighbourhoodMemoized;","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').integer,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the squared euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Squared euclidean distance\n */\nfunction squaredEuclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return result;\n}\n\n/**\n * FixedDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction FixedDensityPDS (options, rng) {\n    if (typeof options.distanceFunction === 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the fixed density implementation with a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.squaredMinDistance = this.minDistance * this.minDistance;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.minDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.processList = [];\n    this.samplePoints = [];\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints\n}\n\nFixedDensityPDS.prototype.shape = null;\nFixedDensityPDS.prototype.dimension = null;\nFixedDensityPDS.prototype.minDistance = null;\nFixedDensityPDS.prototype.maxDistance = null;\nFixedDensityPDS.prototype.minDistancePlusEpsilon = null;\nFixedDensityPDS.prototype.squaredMinDistance = null;\nFixedDensityPDS.prototype.deltaDistance = null;\nFixedDensityPDS.prototype.cellSize = null;\nFixedDensityPDS.prototype.maxTries = null;\nFixedDensityPDS.prototype.rng = null;\nFixedDensityPDS.prototype.neighbourhood = null;\n\nFixedDensityPDS.prototype.currentPoint = null;\nFixedDensityPDS.prototype.processList = null;\nFixedDensityPDS.prototype.samplePoints = null;\nFixedDensityPDS.prototype.gridShape = null;\nFixedDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nFixedDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nFixedDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nFixedDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        dimension;\n\n    this.processList.push(point);\n    this.samplePoints.push(point);\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nFixedDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint;\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {\n            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];\n\n            if (squaredEuclideanDistance(point, existingPoint) < this.squaredMinDistance) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nFixedDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            this.currentPoint = this.processList.shift();\n        }\n\n        currentPoint = this.currentPoint;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * this.rng();\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nFixedDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will always throw an error.\n */\nFixedDensityPDS.prototype.getAllPointsWithDistance = function () {\n    throw new Error('PoissonDiskSampling: getAllPointsWithDistance() is not available in fixed-density implementation');\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nFixedDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = 0;\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = FixedDensityPDS;\n","\"use strict\";\n\nvar tinyNDArray = require('./../tiny-ndarray').array,\n    sphereRandom = require('./../sphere-random'),\n    getNeighbourhood = require('./../neighbourhood');\n\n/**\n * Get the euclidean distance from two points of arbitrary, but equal, dimensions\n * @param {Array} point1\n * @param {Array} point2\n * @returns {number} Euclidean distance\n */\nfunction euclideanDistance (point1, point2) {\n    var result = 0,\n        i = 0;\n\n    for (; i < point1.length; i++) {\n        result += Math.pow(point1[i] - point2[i], 2);\n    }\n\n    return Math.sqrt(result);\n}\n\n/**\n * VariableDensityPDS constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function} options.distanceFunction Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {float} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} rng RNG function, defaults to Math.random\n * @constructor\n */\nfunction VariableDensityPDS (options, rng) {\n    if (typeof options.distanceFunction !== 'function') {\n        throw new Error('PoissonDiskSampling: Tried to instantiate the variable density implementation without a distanceFunction');\n    }\n\n    this.shape = options.shape;\n    this.minDistance = options.minDistance;\n    this.maxDistance = options.maxDistance || options.minDistance * 2;\n    this.maxTries = Math.ceil(Math.max(1, options.tries || 30));\n    this.distanceFunction = options.distanceFunction;\n    this.bias = Math.max(0, Math.min(1, options.bias || 0));\n\n    this.rng = rng || Math.random;\n\n    // to replace with floatPrecisionMitigation = Math.max(1, Math.max(...this.shape) / 64 | 0) on the next major update\n    var maxShape = 0;\n    for (var i = 0; i < this.shape.length; i++) {\n        maxShape = Math.max(maxShape, this.shape[i]);\n    }\n    var floatPrecisionMitigation = Math.max(1, maxShape / 128 | 0);\n    var epsilonDistance = 1e-14 * floatPrecisionMitigation;\n\n    this.dimension = this.shape.length;\n    this.minDistancePlusEpsilon = this.minDistance + epsilonDistance;\n    this.deltaDistance = Math.max(0, this.maxDistance - this.minDistancePlusEpsilon);\n    this.cellSize = this.maxDistance / Math.sqrt(this.dimension);\n\n    this.neighbourhood = getNeighbourhood(this.dimension);\n\n    this.currentPoint = null;\n    this.currentDistance = 0;\n    this.processList = [];\n    this.samplePoints = [];\n    this.sampleDistance = []; // used to store the distance for a given point\n\n    // cache grid\n\n    this.gridShape = [];\n\n    for (var i = 0; i < this.dimension; i++) {\n        this.gridShape.push(Math.ceil(this.shape[i] / this.cellSize));\n    }\n\n    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints and sampleDistance\n}\n\nVariableDensityPDS.prototype.shape = null;\nVariableDensityPDS.prototype.dimension = null;\nVariableDensityPDS.prototype.minDistance = null;\nVariableDensityPDS.prototype.maxDistance = null;\nVariableDensityPDS.prototype.minDistancePlusEpsilon = null;\nVariableDensityPDS.prototype.deltaDistance = null;\nVariableDensityPDS.prototype.cellSize = null;\nVariableDensityPDS.prototype.maxTries = null;\nVariableDensityPDS.prototype.distanceFunction = null;\nVariableDensityPDS.prototype.bias = null;\nVariableDensityPDS.prototype.rng = null;\nVariableDensityPDS.prototype.neighbourhood = null;\n\nVariableDensityPDS.prototype.currentPoint = null;\nVariableDensityPDS.prototype.currentDistance = null;\nVariableDensityPDS.prototype.processList = null;\nVariableDensityPDS.prototype.samplePoints = null;\nVariableDensityPDS.prototype.sampleDistance = null;\nVariableDensityPDS.prototype.gridShape = null;\nVariableDensityPDS.prototype.grid = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nVariableDensityPDS.prototype.addRandomPoint = function () {\n    var point = new Array(this.dimension);\n\n    for (var i = 0; i < this.dimension; i++) {\n        point[i] = this.rng() * this.shape[i];\n    }\n\n    return this.directAddPoint(point);\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nVariableDensityPDS.prototype.addPoint = function (point) {\n    var dimension,\n        valid = true;\n\n    if (point.length === this.dimension) {\n        for (dimension = 0; dimension < this.dimension && valid; dimension++) {\n            valid = (point[dimension] >= 0 && point[dimension] < this.shape[dimension]);\n        }\n    } else {\n        valid = false;\n    }\n\n    return valid ? this.directAddPoint(point) : null;\n};\n\n/**\n * Add a given point to the grid, without any check\n * @param {Array} point Point\n * @returns {Array} The point added to the grid\n * @protected\n */\nVariableDensityPDS.prototype.directAddPoint = function (point) {\n    var internalArrayIndex = 0,\n        stride = this.grid.stride,\n        pointIndex = this.samplePoints.length,\n        dimension;\n\n    this.processList.push(pointIndex);\n    this.samplePoints.push(point);\n    this.sampleDistance.push(this.distanceFunction(point));\n\n    for (dimension = 0; dimension < this.dimension; dimension++) {\n        internalArrayIndex += ((point[dimension] / this.cellSize) | 0) * stride[dimension];\n    }\n\n    this.grid.data[internalArrayIndex].push(pointIndex); // store the point reference\n\n    return point;\n};\n\n/**\n * Check whether a given point is in the neighbourhood of existing points\n * @param {Array} point Point\n * @returns {boolean} Whether the point is in the neighbourhood of another point\n * @protected\n */\nVariableDensityPDS.prototype.inNeighbourhood = function (point) {\n    var dimensionNumber = this.dimension,\n        stride = this.grid.stride,\n        neighbourIndex,\n        internalArrayIndex,\n        dimension,\n        currentDimensionValue,\n        existingPoint,\n        existingPointDistance;\n\n    var pointDistance = this.distanceFunction(point);\n\n    for (neighbourIndex = 0; neighbourIndex < this.neighbourhood.length; neighbourIndex++) {\n        internalArrayIndex = 0;\n\n        for (dimension = 0; dimension < dimensionNumber; dimension++) {\n            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + this.neighbourhood[neighbourIndex][dimension];\n\n            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {\n                internalArrayIndex = -1;\n                break;\n            }\n\n            internalArrayIndex += currentDimensionValue * stride[dimension];\n        }\n\n        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex].length > 0) {\n            for (var i = 0; i < this.grid.data[internalArrayIndex].length; i++) {\n                existingPoint = this.samplePoints[this.grid.data[internalArrayIndex][i]];\n                existingPointDistance = this.sampleDistance[this.grid.data[internalArrayIndex][i]];\n\n                var minDistance = Math.min(existingPointDistance, pointDistance);\n                var maxDistance = Math.max(existingPointDistance, pointDistance);\n                var dist = minDistance + (maxDistance - minDistance) * this.bias;\n\n                if (euclideanDistance(point, existingPoint) < this.minDistance + this.deltaDistance * dist) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nVariableDensityPDS.prototype.next = function () {\n    var tries,\n        angle,\n        distance,\n        currentPoint,\n        currentDistance,\n        newPoint,\n        inShape,\n        i;\n\n    while (this.processList.length > 0) {\n        if (this.currentPoint === null) {\n            var sampleIndex = this.processList.shift();\n            this.currentPoint = this.samplePoints[sampleIndex];\n            this.currentDistance = this.sampleDistance[sampleIndex];\n        }\n\n        currentPoint = this.currentPoint;\n        currentDistance = this.currentDistance;\n\n        for (tries = 0; tries < this.maxTries; tries++) {\n            inShape = true;\n            distance = this.minDistancePlusEpsilon + this.deltaDistance * (currentDistance + (1 - currentDistance) * this.bias);\n\n            if (this.dimension === 2) {\n                angle = this.rng() * Math.PI * 2;\n                newPoint = [\n                    Math.cos(angle),\n                    Math.sin(angle)\n                ];\n            } else {\n                newPoint = sphereRandom(this.dimension, this.rng);\n            }\n\n            for (i = 0; inShape && i < this.dimension; i++) {\n                newPoint[i] = currentPoint[i] + newPoint[i] * distance;\n                inShape = (newPoint[i] >= 0 && newPoint[i] < this.shape[i])\n            }\n\n            if (inShape && !this.inNeighbourhood(newPoint)) {\n                return this.directAddPoint(newPoint);\n            }\n        }\n\n        if (tries === this.maxTries) {\n            this.currentPoint = null;\n        }\n    }\n\n    return null;\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.fill = function () {\n    if (this.samplePoints.length === 0) {\n        this.addRandomPoint();\n    }\n\n    while(this.next()) {}\n\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nVariableDensityPDS.prototype.getAllPoints = function () {\n    return this.samplePoints;\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @returns {Array[]} Sample points with their distance function result\n */\nVariableDensityPDS.prototype.getAllPointsWithDistance = function () {\n    var result = new Array(this.samplePoints.length),\n        i = 0,\n        dimension = 0,\n        point;\n\n    for (i = 0; i < this.samplePoints.length; i++) {\n        point = new Array(this.dimension + 1);\n\n        for (dimension = 0; dimension < this.dimension; dimension++) {\n            point[dimension] = this.samplePoints[i][dimension];\n        }\n\n        point[this.dimension] = this.sampleDistance[i];\n\n        result[i] = point;\n    }\n\n    return result;\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nVariableDensityPDS.prototype.reset = function () {\n    var gridData = this.grid.data,\n        i = 0;\n\n    // reset the cache grid\n    for (i = 0; i < gridData.length; i++) {\n        gridData[i] = [];\n    }\n\n    // new array for the samplePoints as it is passed by reference to the outside\n    this.samplePoints = [];\n\n    // reset the internal state\n    this.currentPoint = null;\n    this.processList.length = 0;\n};\n\nmodule.exports = VariableDensityPDS;\n","\"use strict\";\n\nvar FixedDensityPDS = require('./implementations/fixed-density');\nvar VariableDensityPDS = require('./implementations/variable-density');\n\n/**\n * PoissonDiskSampling constructor\n * @param {object} options Options\n * @param {Array} options.shape Shape of the space\n * @param {float} options.minDistance Minimum distance between each points\n * @param {float} [options.maxDistance] Maximum distance between each points, defaults to minDistance * 2\n * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30\n * @param {function|null} [options.distanceFunction] Function to control the distance between each point depending on their position, must return a value between 0 and 1\n * @param {function|null} [options.bias] When using a distanceFunction, will indicate which point constraint takes priority when evaluating two points (0 for the lowest distance, 1 for the highest distance), defaults to 0\n * @param {function|null} [rng] RNG function, defaults to Math.random\n * @constructor\n */\nfunction PoissonDiskSampling (options, rng) {\n    this.shape = options.shape;\n\n    if (typeof options.distanceFunction === 'function') {\n        this.implementation = new VariableDensityPDS(options, rng);\n    } else {\n        this.implementation = new FixedDensityPDS(options, rng);\n    }\n}\n\nPoissonDiskSampling.prototype.implementation = null;\n\n/**\n * Add a totally random point in the grid\n * @returns {Array} The point added to the grid\n */\nPoissonDiskSampling.prototype.addRandomPoint = function () {\n    return this.implementation.addRandomPoint();\n};\n\n/**\n * Add a given point to the grid\n * @param {Array} point Point\n * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension\n */\nPoissonDiskSampling.prototype.addPoint = function (point) {\n    return this.implementation.addPoint(point);\n};\n\n/**\n * Try to generate a new point in the grid, returns null if it wasn't possible\n * @returns {Array|null} The added point or null\n */\nPoissonDiskSampling.prototype.next = function () {\n    return this.implementation.next();\n};\n\n/**\n * Automatically fill the grid, adding a random point to start the process if needed.\n * Will block the thread, probably best to use it in a web worker or child process.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.fill = function () {\n    return this.implementation.fill();\n};\n\n/**\n * Get all the points in the grid.\n * @returns {Array[]} Sample points\n */\nPoissonDiskSampling.prototype.getAllPoints = function () {\n    return this.implementation.getAllPoints();\n};\n\n/**\n * Get all the points in the grid along with the result of the distance function.\n * @throws Will throw an error if a distance function was not provided to the constructor.\n * @returns {Array[]} Sample points with their distance function result\n */\nPoissonDiskSampling.prototype.getAllPointsWithDistance = function () {\n    return this.implementation.getAllPointsWithDistance();\n};\n\n/**\n * Reinitialize the grid as well as the internal state\n */\nPoissonDiskSampling.prototype.reset = function () {\n    this.implementation.reset();\n};\n\nmodule.exports = PoissonDiskSampling;\n","import PoissonDiskSampling from 'poisson-disk-sampling';\nimport type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype PoissonPointGeneratorName = \"PoissonPointGenerator\";\nexport const Name: PoissonPointGeneratorName = \"PoissonPointGenerator\";\n\n/** Required config for this generator */\nexport interface PoissonPointGeneratorConfig extends GeneratorConfig {\n  name: PoissonPointGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const PoissonPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Poisson\",\n  description: \"Generate seed points using Poisson disk sampling. \" +\n    \"The algorithm produces points that are tightly-packed, but no closer to \" +\n    \"each other than a specified minimum distance (the piece size), resulting \" +\n    \"in a natural, organic look.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A point generator that uses Poisson disk sampling to create a more organic\n * distribution of random points. `pieceSize` is interpreted as the minimum\n * distance between generated points.\n */\nexport const PoissonPointGeneratorFactory: GeneratorFactory<PointGenerator> = (_width: number, _height: number, _config: PoissonPointGeneratorConfig) => {\n  const PoissonPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      // generate points randomly in a Poisson disk sampling\n      const poisson = new PoissonDiskSampling(\n        {\n          shape: [width, height], // clamps generated points within bounds\n          minDistance: pieceSize,\n          tries: 20,\n        },\n        random\n      );\n\n      // have to cast because @types/PoissonDiskSampling is not correct for fill()\n      const points = poisson.fill() as unknown as Vec2[];\n      return points;\n    },\n  };\n  return PoissonPointGenerator;\n};\nexport default PoissonPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, PoissonPointGeneratorFactory, PoissonPointUIMetadata);\n","export const epsilon = 1.1102230246251565e-16;\nexport const splitter = 134217729;\nexport const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n// fast_expansion_sum_zeroelim routine from oritinal code\nexport function sum(elen, e, flen, f, h) {\n    let Q, Qnew, hh, bvirt;\n    let enow = e[0];\n    let fnow = f[0];\n    let eindex = 0;\n    let findex = 0;\n    if ((fnow > enow) === (fnow > -enow)) {\n        Q = enow;\n        enow = e[++eindex];\n    } else {\n        Q = fnow;\n        fnow = f[++findex];\n    }\n    let hindex = 0;\n    if (eindex < elen && findex < flen) {\n        if ((fnow > enow) === (fnow > -enow)) {\n            Qnew = enow + Q;\n            hh = Q - (Qnew - enow);\n            enow = e[++eindex];\n        } else {\n            Qnew = fnow + Q;\n            hh = Q - (Qnew - fnow);\n            fnow = f[++findex];\n        }\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        while (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = Q + enow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                enow = e[++eindex];\n            } else {\n                Qnew = Q + fnow;\n                bvirt = Qnew - Q;\n                hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n    }\n    while (eindex < elen) {\n        Qnew = Q + enow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (enow - bvirt);\n        enow = e[++eindex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    while (findex < flen) {\n        Qnew = Q + fnow;\n        bvirt = Qnew - Q;\n        hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n        fnow = f[++findex];\n        Q = Qnew;\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function sum_three(alen, a, blen, b, clen, c, tmp, out) {\n    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);\n}\n\n// scale_expansion_zeroelim routine from oritinal code\nexport function scale(elen, e, b, h) {\n    let Q, sum, hh, product1, product0;\n    let bvirt, c, ahi, alo, bhi, blo;\n\n    c = splitter * b;\n    bhi = c - (c - b);\n    blo = b - bhi;\n    let enow = e[0];\n    Q = enow * b;\n    c = splitter * enow;\n    ahi = c - (c - enow);\n    alo = enow - ahi;\n    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);\n    let hindex = 0;\n    if (hh !== 0) {\n        h[hindex++] = hh;\n    }\n    for (let i = 1; i < elen; i++) {\n        enow = e[i];\n        product1 = enow * b;\n        c = splitter * enow;\n        ahi = c - (c - enow);\n        alo = enow - ahi;\n        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);\n        sum = Q + product0;\n        bvirt = sum - Q;\n        hh = Q - (sum - bvirt) + (product0 - bvirt);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n        Q = product1 + sum;\n        hh = sum - (Q - product1);\n        if (hh !== 0) {\n            h[hindex++] = hh;\n        }\n    }\n    if (Q !== 0 || hindex === 0) {\n        h[hindex++] = Q;\n    }\n    return hindex;\n}\n\nexport function negate(elen, e) {\n    for (let i = 0; i < elen; i++) e[i] = -e[i];\n    return elen;\n}\n\nexport function estimate(elen, e) {\n    let Q = e[0];\n    for (let i = 1; i < elen; i++) Q += e[i];\n    return Q;\n}\n\nexport function vec(n) {\n    return new Float64Array(n);\n}\n","import {epsilon, splitter, resulterrbound, estimate, vec, sum} from './util.js';\n\nconst ccwerrboundA = (3 + 16 * epsilon) * epsilon;\nconst ccwerrboundB = (2 + 12 * epsilon) * epsilon;\nconst ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\nconst B = vec(4);\nconst C1 = vec(8);\nconst C2 = vec(12);\nconst D = vec(16);\nconst u = vec(4);\n\nfunction orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n    let acxtail, acytail, bcxtail, bcytail;\n    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n    const acx = ax - cx;\n    const bcx = bx - cx;\n    const acy = ay - cy;\n    const bcy = by - cy;\n\n    s1 = acx * bcy;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcx;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    B[3] = u3;\n\n    let det = estimate(4, B);\n    let errbound = ccwerrboundB * detsum;\n    if (det >= errbound || -det >= errbound) {\n        return det;\n    }\n\n    bvirt = ax - acx;\n    acxtail = ax - (acx + bvirt) + (bvirt - cx);\n    bvirt = bx - bcx;\n    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n    bvirt = ay - acy;\n    acytail = ay - (acy + bvirt) + (bvirt - cy);\n    bvirt = by - bcy;\n    bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n        return det;\n    }\n\n    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n    if (det >= errbound || -det >= errbound) return det;\n\n    s1 = acxtail * bcy;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcy;\n    bhi = c - (c - bcy);\n    blo = bcy - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcx;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcx;\n    bhi = c - (c - bcx);\n    blo = bcx - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C1len = sum(4, B, 4, u, C1);\n\n    s1 = acx * bcytail;\n    c = splitter * acx;\n    ahi = c - (c - acx);\n    alo = acx - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acy * bcxtail;\n    c = splitter * acy;\n    ahi = c - (c - acy);\n    alo = acy - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const C2len = sum(C1len, C1, 4, u, C2);\n\n    s1 = acxtail * bcytail;\n    c = splitter * acxtail;\n    ahi = c - (c - acxtail);\n    alo = acxtail - ahi;\n    c = splitter * bcytail;\n    bhi = c - (c - bcytail);\n    blo = bcytail - bhi;\n    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n    t1 = acytail * bcxtail;\n    c = splitter * acytail;\n    ahi = c - (c - acytail);\n    alo = acytail - ahi;\n    c = splitter * bcxtail;\n    bhi = c - (c - bcxtail);\n    blo = bcxtail - bhi;\n    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n    _i = s0 - t0;\n    bvirt = s0 - _i;\n    u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n    _j = s1 + _i;\n    bvirt = _j - s1;\n    _0 = s1 - (_j - bvirt) + (_i - bvirt);\n    _i = _0 - t1;\n    bvirt = _0 - _i;\n    u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n    u3 = _j + _i;\n    bvirt = u3 - _j;\n    u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n    u[3] = u3;\n    const Dlen = sum(C2len, C2, 4, u, D);\n\n    return D[Dlen - 1];\n}\n\nexport function orient2d(ax, ay, bx, by, cx, cy) {\n    const detleft = (ay - cy) * (bx - cx);\n    const detright = (ax - cx) * (by - cy);\n    const det = detleft - detright;\n\n    const detsum = Math.abs(detleft + detright);\n    if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n}\n\nexport function orient2dfast(ax, ay, bx, by, cx, cy) {\n    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);\n}\n","\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n","const epsilon = 1e-6;\n\nexport default class Path {\n  constructor() {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n  }\n  moveTo(x, y) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  }\n  lineTo(x, y) {\n    this._ += `L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arc(x, y, r) {\n    x = +x, y = +y, r = +r;\n    const x0 = x + r;\n    const y0 = y;\n    if (r < 0) throw new Error(\"negative radius\");\n    if (this._x1 === null) this._ += `M${x0},${y0}`;\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += \"L\" + x0 + \",\" + y0;\n    if (!r) return;\n    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;\n  }\n  rect(x, y, w, h) {\n    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;\n  }\n  value() {\n    return this._ || null;\n  }\n}\n","export default class Polygon {\n  constructor() {\n    this._ = [];\n  }\n  moveTo(x, y) {\n    this._.push([x, y]);\n  }\n  closePath() {\n    this._.push(this._[0].slice());\n  }\n  lineTo(x, y) {\n    this._.push([x, y]);\n  }\n  value() {\n    return this._.length ? this._ : null;\n  }\n}\n","import Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\n\nexport default class Voronoi {\n  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  update() {\n    this.delaunay.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const {delaunay: {points, hull, triangles}, vectors} = this;\n    let bx, by; // lazily computed barycenter of the hull\n\n    // Compute circumcenters.\n    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n      const t1 = triangles[i] * 2;\n      const t2 = triangles[i + 1] * 2;\n      const t3 = triangles[i + 2] * 2;\n      const x1 = points[t1];\n      const y1 = points[t1 + 1];\n      const x2 = points[t2];\n      const y2 = points[t2 + 1];\n      const x3 = points[t3];\n      const y3 = points[t3 + 1];\n\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const ex = x3 - x1;\n      const ey = y3 - y1;\n      const ab = (dx * ey - dy * ex) * 2;\n\n      if (Math.abs(ab) < 1e-9) {\n        // For a degenerate triangle, the circumcenter is at the infinity, in a\n        // direction orthogonal to the halfedge and away from the “center” of\n        // the diagram <bx, by>, defined as the hull’s barycenter.\n        if (bx === undefined) {\n          bx = by = 0;\n          for (const i of hull) bx += points[i * 2], by += points[i * 2 + 1];\n          bx /= hull.length, by /= hull.length;\n        }\n        const a = 1e9 * Math.sign((bx - x1) * ey - (by - y1) * ex);\n        x = (x1 + x3) / 2 - a * ey;\n        y = (y1 + y3) / 2 + a * ex;\n      } else {\n        const d = 1 / ab;\n        const bl = dx * dx + dy * dy;\n        const cl = ex * ex + ey * ey;\n        x = x1 + (ey * bl - dy * cl) * d;\n        y = y1 + (dx * cl - ex * bl) * d;\n      }\n      circumcenters[j] = x;\n      circumcenters[j + 1] = y;\n    }\n\n    // Compute exterior cell rays.\n    let h = hull[hull.length - 1];\n    let p0, p1 = h * 4;\n    let x0, x1 = points[2 * h];\n    let y0, y1 = points[2 * h + 1];\n    vectors.fill(0);\n    for (let i = 0; i < hull.length; ++i) {\n      h = hull[i];\n      p0 = p1, x0 = x1, y0 = y1;\n      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n      vectors[p0 + 2] = vectors[p1] = y0 - y1;\n      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n    }\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;\n    if (hull.length <= 1) return null;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = Math.floor(i / 3) * 2;\n      const tj = Math.floor(j / 3) * 2;\n      const xi = circumcenters[ti];\n      const yi = circumcenters[ti + 1];\n      const xj = circumcenters[tj];\n      const yj = circumcenters[tj + 1];\n      this._renderSegment(xi, yi, xj, yj, context);\n    }\n    let h0, h1 = hull[hull.length - 1];\n    for (let i = 0; i < hull.length; ++i) {\n      h0 = h1, h1 = hull[i];\n      const t = Math.floor(inedges[h1] / 3) * 2;\n      const x = circumcenters[t];\n      const y = circumcenters[t + 1];\n      const v = h0 * 4;\n      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n      if (p) this._renderSegment(x, y, p[0], p[1], context);\n    }\n    return buffer && buffer.value();\n  }\n  renderBounds(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n    return buffer && buffer.value();\n  }\n  renderCell(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const points = this._clip(i);\n    if (points === null || !points.length) return;\n    context.moveTo(points[0], points[1]);\n    let n = points.length;\n    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;\n    for (let i = 2; i < n; i += 2) {\n      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])\n        context.lineTo(points[i], points[i + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *cellPolygons() {\n    const {delaunay: {points}} = this;\n    for (let i = 0, n = points.length / 2; i < n; ++i) {\n      const cell = this.cellPolygon(i);\n      if (cell) cell.index = i, yield cell;\n    }\n  }\n  cellPolygon(i) {\n    const polygon = new Polygon;\n    this.renderCell(i, polygon);\n    return polygon.value();\n  }\n  _renderSegment(x0, y0, x1, y1, context) {\n    let S;\n    const c0 = this._regioncode(x0, y0);\n    const c1 = this._regioncode(x1, y1);\n    if (c0 === 0 && c1 === 0) {\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n      context.moveTo(S[0], S[1]);\n      context.lineTo(S[2], S[3]);\n    }\n  }\n  contains(i, x, y) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n    return this.delaunay._step(i, x, y) === i;\n  }\n  *neighbors(i) {\n    const ci = this._clip(i);\n    if (ci) for (const j of this.delaunay.neighbors(i)) {\n      const cj = this._clip(j);\n      // find the common edge\n      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {\n        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {\n          if (ci[ai] === cj[aj]\n              && ci[ai + 1] === cj[aj + 1]\n              && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj]\n              && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {\n            yield j;\n            break loop;\n          }\n        }\n      }\n    }\n  }\n  _cell(i) {\n    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;\n    const e0 = inedges[i];\n    if (e0 === -1) return null; // coincident point\n    const points = [];\n    let e = e0;\n    do {\n      const t = Math.floor(e / 3);\n      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n    } while (e !== e0 && e !== -1);\n    return points;\n  }\n  _clip(i) {\n    // degenerate case (1 valid point: return the box)\n    if (i === 0 && this.delaunay.hull.length === 1) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    const points = this._cell(i);\n    if (points === null) return null;\n    const {vectors: V} = this;\n    const v = i * 4;\n    return this._simplify(V[v] || V[v + 1]\n        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])\n        : this._clipFinite(i, points));\n  }\n  _clipFinite(i, points) {\n    const n = points.length;\n    let P = null;\n    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];\n    let c0, c1 = this._regioncode(x1, y1);\n    let e0, e1 = 0;\n    for (let j = 0; j < n; j += 2) {\n      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n      c0 = c1, c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        e0 = e1, e1 = 0;\n        if (P) P.push(x1, y1);\n        else P = [x1, y1];\n      } else {\n        let S, sx0, sy0, sx1, sy1;\n        if (c0 === 0) {\n          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n          [sx0, sy0, sx1, sy1] = S;\n        } else {\n          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n          [sx1, sy1, sx0, sy0] = S;\n          e0 = e1, e1 = this._edgecode(sx0, sy0);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx0, sy0);\n          else P = [sx0, sy0];\n        }\n        e0 = e1, e1 = this._edgecode(sx1, sy1);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n        if (P) P.push(sx1, sy1);\n        else P = [sx1, sy1];\n      }\n    }\n    if (P) {\n      e0 = e1, e1 = this._edgecode(P[0], P[1]);\n      if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n    }\n    return P;\n  }\n  _clipSegment(x0, y0, x1, y1, c0, c1) {\n    // for more robustness, always consider the segment in the same order\n    const flip = c0 < c1;\n    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];\n    while (true) {\n      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n      if (c0 & c1) return null;\n      let x, y, c = c0 || c1;\n      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;\n      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;\n      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;\n      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);\n      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n    }\n  }\n  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n    let P = Array.from(points), p;\n    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n    if (P = this._clipFinite(i, P)) {\n      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n      }\n    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n    }\n    return P;\n  }\n  _edge(i, e0, e1, P, j) {\n    while (e0 !== e1) {\n      let x, y;\n      switch (e0) {\n        case 0b0101: e0 = 0b0100; continue; // top-left\n        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top\n        case 0b0110: e0 = 0b0010; continue; // top-right\n        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right\n        case 0b1010: e0 = 0b1000; continue; // bottom-right\n        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom\n        case 0b1001: e0 = 0b0001; continue; // bottom-left\n        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left\n      }\n      // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n      // undefined, the conditional statement will be executed.\n      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n        P.splice(j, 0, x, y), j += 2;\n      }\n    }\n    return j;\n  }\n  _project(x0, y0, vx, vy) {\n    let t = Infinity, c, x, y;\n    if (vy < 0) { // top\n      if (y0 <= this.ymin) return null;\n      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n    } else if (vy > 0) { // bottom\n      if (y0 >= this.ymax) return null;\n      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n    }\n    if (vx > 0) { // right\n      if (x0 >= this.xmax) return null;\n      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n    } else if (vx < 0) { // left\n      if (x0 <= this.xmin) return null;\n      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n    }\n    return [x, y];\n  }\n  _edgecode(x, y) {\n    return (x === this.xmin ? 0b0001\n        : x === this.xmax ? 0b0010 : 0b0000)\n        | (y === this.ymin ? 0b0100\n        : y === this.ymax ? 0b1000 : 0b0000);\n  }\n  _regioncode(x, y) {\n    return (x < this.xmin ? 0b0001\n        : x > this.xmax ? 0b0010 : 0b0000)\n        | (y < this.ymin ? 0b0100\n        : y > this.ymax ? 0b1000 : 0b0000);\n  }\n  _simplify(P) {\n    if (P && P.length > 4) {\n      for (let i = 0; i < P.length; i+= 2) {\n        const j = (i + 2) % P.length, k = (i + 4) % P.length;\n        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n          P.splice(j, 2), i -= 2;\n        }\n      }\n      if (!P.length) P = null;\n    }\n    return P;\n  }\n}\n","import Delaunator from \"delaunator\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nimport Voronoi from \"./voronoi.js\";\n\nconst tau = 2 * Math.PI, pow = Math.pow;\n\nfunction pointX(p) {\n  return p[0];\n}\n\nfunction pointY(p) {\n  return p[1];\n}\n\n// A triangulation is collinear if all its triangles have a non-null area\nfunction collinear(d) {\n  const {triangles, coords} = d;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = 2 * triangles[i],\n          b = 2 * triangles[i + 1],\n          c = 2 * triangles[i + 2],\n          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])\n                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);\n    if (cross > 1e-10) return false;\n  }\n  return true;\n}\n\nfunction jitter(x, y, r) {\n  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];\n}\n\nexport default class Delaunay {\n  static from(points, fx = pointX, fy = pointY, that) {\n    return new Delaunay(\"length\" in points\n        ? flatArray(points, fx, fy, that)\n        : Float64Array.from(flatIterable(points, fx, fy, that)));\n  }\n  constructor(points) {\n    this._delaunator = new Delaunator(points);\n    this.inedges = new Int32Array(points.length / 2);\n    this._hullIndex = new Int32Array(points.length / 2);\n    this.points = this._delaunator.coords;\n    this._init();\n  }\n  update() {\n    this._delaunator.update();\n    this._init();\n    return this;\n  }\n  _init() {\n    const d = this._delaunator, points = this.points;\n\n    // check for collinear\n    if (d.hull && d.hull.length > 2 && collinear(d)) {\n      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)\n        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors\n      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],\n        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],\n        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);\n      for (let i = 0, n = points.length / 2; i < n; ++i) {\n        const p = jitter(points[2 * i], points[2 * i + 1], r);\n        points[2 * i] = p[0];\n        points[2 * i + 1] = p[1];\n      }\n      this._delaunator = new Delaunator(points);\n    } else {\n      delete this.collinear;\n    }\n\n    const halfedges = this.halfedges = this._delaunator.halfedges;\n    const hull = this.hull = this._delaunator.hull;\n    const triangles = this.triangles = this._delaunator.triangles;\n    const inedges = this.inedges.fill(-1);\n    const hullIndex = this._hullIndex.fill(-1);\n\n    // Compute an index from each point to an (arbitrary) incoming halfedge\n    // Used to give the first neighbor of each point; for this reason,\n    // on the hull we give priority to exterior halfedges\n    for (let e = 0, n = halfedges.length; e < n; ++e) {\n      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];\n      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;\n    }\n    for (let i = 0, n = hull.length; i < n; ++i) {\n      hullIndex[hull[i]] = i;\n    }\n\n    // degenerate case: 1 or 2 (distinct) points\n    if (hull.length <= 2 && hull.length > 0) {\n      this.triangles = new Int32Array(3).fill(-1);\n      this.halfedges = new Int32Array(3).fill(-1);\n      this.triangles[0] = hull[0];\n      inedges[hull[0]] = 1;\n      if (hull.length === 2) {\n        inedges[hull[1]] = 0;\n        this.triangles[1] = hull[1];\n        this.triangles[2] = hull[1];\n      }\n    }\n  }\n  voronoi(bounds) {\n    return new Voronoi(this, bounds);\n  }\n  *neighbors(i) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;\n\n    // degenerate case with several collinear points\n    if (collinear) {\n      const l = collinear.indexOf(i);\n      if (l > 0) yield collinear[l - 1];\n      if (l < collinear.length - 1) yield collinear[l + 1];\n      return;\n    }\n\n    const e0 = inedges[i];\n    if (e0 === -1) return; // coincident point\n    let e = e0, p0 = -1;\n    do {\n      yield p0 = triangles[e];\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) return; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        const p = hull[(_hullIndex[i] + 1) % hull.length];\n        if (p !== p0) yield p;\n        return;\n      }\n    } while (e !== e0);\n  }\n  find(x, y, i = 0) {\n    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;\n    const i0 = i;\n    let c;\n    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;\n    return c;\n  }\n  _step(i, x, y) {\n    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;\n    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);\n    let c = i;\n    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);\n    const e0 = inedges[i];\n    let e = e0;\n    do {\n      let t = triangles[e];\n      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);\n      if (dt < dc) dc = dt, c = t;\n      e = e % 3 === 2 ? e - 2 : e + 1;\n      if (triangles[e] !== i) break; // bad triangulation\n      e = halfedges[e];\n      if (e === -1) {\n        e = hull[(_hullIndex[i] + 1) % hull.length];\n        if (e !== t) {\n          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;\n        }\n        break;\n      }\n    } while (e !== e0);\n    return c;\n  }\n  render(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, halfedges, triangles} = this;\n    for (let i = 0, n = halfedges.length; i < n; ++i) {\n      const j = halfedges[i];\n      if (j < i) continue;\n      const ti = triangles[i] * 2;\n      const tj = triangles[j] * 2;\n      context.moveTo(points[ti], points[ti + 1]);\n      context.lineTo(points[tj], points[tj + 1]);\n    }\n    this.renderHull(context);\n    return buffer && buffer.value();\n  }\n  renderPoints(context, r) {\n    if (r === undefined && (!context || typeof context.moveTo !== \"function\")) r = context, context = null;\n    r = r == undefined ? 2 : +r;\n    const buffer = context == null ? context = new Path : undefined;\n    const {points} = this;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i], y = points[i + 1];\n      context.moveTo(x + r, y);\n      context.arc(x, y, r, 0, tau);\n    }\n    return buffer && buffer.value();\n  }\n  renderHull(context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {hull, points} = this;\n    const h = hull[0] * 2, n = hull.length;\n    context.moveTo(points[h], points[h + 1]);\n    for (let i = 1; i < n; ++i) {\n      const h = 2 * hull[i];\n      context.lineTo(points[h], points[h + 1]);\n    }\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  hullPolygon() {\n    const polygon = new Polygon;\n    this.renderHull(polygon);\n    return polygon.value();\n  }\n  renderTriangle(i, context) {\n    const buffer = context == null ? context = new Path : undefined;\n    const {points, triangles} = this;\n    const t0 = triangles[i *= 3] * 2;\n    const t1 = triangles[i + 1] * 2;\n    const t2 = triangles[i + 2] * 2;\n    context.moveTo(points[t0], points[t0 + 1]);\n    context.lineTo(points[t1], points[t1 + 1]);\n    context.lineTo(points[t2], points[t2 + 1]);\n    context.closePath();\n    return buffer && buffer.value();\n  }\n  *trianglePolygons() {\n    const {triangles} = this;\n    for (let i = 0, n = triangles.length / 3; i < n; ++i) {\n      yield this.trianglePolygon(i);\n    }\n  }\n  trianglePolygon(i) {\n    const polygon = new Polygon;\n    this.renderTriangle(i, polygon);\n    return polygon.value();\n  }\n}\n\nfunction flatArray(points, fx, fy, that) {\n  const n = points.length;\n  const array = new Float64Array(n * 2);\n  for (let i = 0; i < n; ++i) {\n    const p = points[i];\n    array[i * 2] = fx.call(that, p, i, points);\n    array[i * 2 + 1] = fy.call(that, p, i, points);\n  }\n  return array;\n}\n\nfunction* flatIterable(points, fx, fy, that) {\n  let i = 0;\n  for (const p of points) {\n    yield fx.call(that, p, i, points);\n    yield fy.call(that, p, i, points);\n    ++i;\n  }\n}\n","\nexport type UniqueId = number;\n\nlet id = 0;\nexport function getUniqueId(): UniqueId {\n  return id++;\n}\n","import { Delaunay } from 'd3-delaunay';\nimport { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { polygonBounds, arePointsEqual } from '../../utils';\nimport { getUniqueId } from '../../../utils/UniqueId';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\nexport const Name: VoronoiPieceGeneratorName = \"VoronoiPieceGenerator\";\n\n/** Required config for this generator */\nexport interface VoronoiPieceGeneratorConfig extends GeneratorConfig {\n  name: VoronoiPieceGeneratorName;\n  // no special config\n}\n\n/** UI metadata needed for this generator */\nexport const VoronoiPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Voronoi\",\n  description: \"Construct pieces by building a Voronoi diagram from the seed points. \" +\n    \"Each piece consists of all area of the plane closer to its seed point than \" +\n    \"any other seed point. In practice, this creates irregular polygons with 3-8 \" +\n    \"sides.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * Links the `next` and `prev` properties of a circular list of half-edges for a single piece.\n * @param ids The array of half-edge IDs belonging to a piece.\n * @param map The map containing all half-edge objects.\n */\nfunction linkPieceHalfEdges(ids: HalfEdgeID[], map: Map<HalfEdgeID, HalfEdge>): void {\n  const len = ids.length;\n  for (let i = 0; i < len; i++) {\n    const he = map.get(ids[i])!;\n    he.next = ids[(i + 1) % len];\n    he.prev = ids[(i - 1 + len) % len];\n  }\n}\n\n/**\n * Creates a consistent string key for a point, handling floating point inaccuracies.\n * @param p The point.\n * @returns A string key.\n */\nfunction pointToKey(p: Vec2): string {\n  return `${p[0].toPrecision(7)},${p[1].toPrecision(7)}`;\n}\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const VoronoiPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (width: number, height: number, _config: VoronoiPieceGeneratorConfig) => {\n  const VoronoiPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param points The seed points for the centers of the puzzle pieces.\n     * @param _runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(points: Vec2[], _runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n\n      // Note: Lloyd's relaxation could be performed here to create more uniform\n      // piece shapes. This would involve creating the Voronoi diagram, calculating\n      // the centroid of each cell, moving the input point to that centroid, and\n      // repeating for a number of iterations before proceeding.\n\n      console.log(`VoronoiPieceGenerator using dimensions ${width}x${height}`);\n      // 1. Generate Voronoi diagram from points, clipped to the puzzle bounds.\n      const delaunay = Delaunay.from(points);\n      const voronoi = delaunay.voronoi([0, 0, width, height]);\n\n      // 2. Initialize data structures for the topology.\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n      };\n\n      // A map to find a half-edge's twin, keyed by its start and end vertex coordinates.\n      const halfEdgeEndpointMap = new Map<string, HalfEdgeID>();\n\n      // 3. First pass: Create Piece and HalfEdge objects for each cell.\n      // At this stage, the half-edges are not yet linked (next, prev, twin).\n      for (let i = 0; i < points.length; i++) {\n        const site = points[i];\n        const polygon = voronoi.cellPolygon(i);\n\n        if (!polygon) continue;\n\n        const piece: Piece = {\n          id: i,\n          site,\n          halfEdge: -1, // Placeholder, will be set after creating half-edges.\n          bounds: polygonBounds(polygon),\n        };\n\n        const pieceHalfEdgeIds: HalfEdgeID[] = [];\n\n        // Create a half-edge for each segment of the piece's polygon boundary.\n        for (let j = 0; j < polygon.length - 1; j++) {\n          const p1 = polygon[j];\n          const p2 = polygon[j + 1];\n\n          // Skip zero-length edges that can sometimes occur at the boundary.\n          if (arePointsEqual(p1, p2)) continue;\n\n          const he: HalfEdge = {\n            id: getUniqueId(),\n            origin: p1,\n            twin: -1, // To be linked in the second pass.\n            next: -1, // To be linked next.\n            prev: -1, // To be linked next.\n            piece: i,\n          };\n\n          topology.halfEdges.set(he.id, he);\n          pieceHalfEdgeIds.push(he.id);\n\n          // Store the half-edge in a map to easily find its twin later.\n          // The key is a string representation of its start and end points.\n          const key = `${pointToKey(p1)}-${pointToKey(p2)}`;\n          halfEdgeEndpointMap.set(key, he.id);\n        }\n\n        if (pieceHalfEdgeIds.length === 0) continue;\n\n        // Link the `next` and `prev` pointers for the half-edges of the current piece.\n        linkPieceHalfEdges(pieceHalfEdgeIds, topology.halfEdges);\n\n        // Set a starting half-edge for the piece and save it.\n        piece.halfEdge = pieceHalfEdgeIds[0];\n        topology.pieces.set(i, piece);\n      }\n\n      // 4. Second pass: Link twins and create the undirected Edge objects.\n      for (const he1 of topology.halfEdges.values()) {\n        // If twin is already set, it was handled when we processed its pair.\n        if (he1.twin !== -1) continue;\n\n        const he1_next = topology.halfEdges.get(he1.next)!;\n        const p1 = he1.origin;\n        const p2 = he1_next.origin;\n\n        const keyForTwin = `${pointToKey(p2)}-${pointToKey(p1)}`;\n        const twinId = halfEdgeEndpointMap.get(keyForTwin);\n\n        const edgeId = getUniqueId();\n        let edge: Edge;\n\n        if (twinId !== undefined) {\n          // This is an internal edge with a twin.\n          const he2 = topology.halfEdges.get(twinId)!;\n          he1.twin = he2.id;\n          he2.twin = he1.id;\n\n          // he1 is the \"left\" half-edge when looking from p1 to p2.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id,\n            heRight: he2.id,\n            bounds: polygonBounds([p1, p2]), // no tabs yet\n          };\n        } else {\n          // This is a boundary edge with no twin.\n          edge = {\n            id: edgeId,\n            heLeft: he1.id, // The one existing half-edge.\n            heRight: -1,     // Sentinel for no half-edge.\n            bounds: polygonBounds([p1, p2]), // no tabs yet\n          };\n          topology.boundary.push(edgeId);\n        }\n\n        topology.edges.set(edgeId, edge);\n      }\n\n      // 5. Final step: Collect all unique vertices.\n      const vertexSet = new Map<string, Vec2>();\n      for (const he of topology.halfEdges.values()) {\n        const key = pointToKey(he.origin);\n        if (!vertexSet.has(key)) {\n          vertexSet.set(key, he.origin);\n        }\n      }\n      topology.vertices = Array.from(vertexSet.values());\n\n      return topology;\n    },\n  };\n  return VoronoiPieceGenerator;\n};\nexport default VoronoiPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, VoronoiPieceGeneratorFactory, VoronoiPieceGeneratorUIMetadata);\n","import type { PuzzleTopology, Edge, RandomFn, TabPlacement } from \"../../types\";\nimport type { TabPlacementStrategy, TabPlacementStrategyRuntimeOptions } from \"./TabPlacementStrategy\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabPlacementStrategyRegistry } from \"../Generator\";\n\n// Name of this strategy, uniquely identifies from all other TabPlacementStrategies\ntype SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\nexport const Name: SimpleTabPlacementStrategyName = \"SimpleTabPlacementStrategy\";\n\n/** Custom config for this strategy */\nexport interface SimpleTabPlacementStrategyConfig extends GeneratorConfig {\n  name: SimpleTabPlacementStrategyName;\n  /** The default size of the tab as a fraction (0-1) of the edge length. */\n  tabSize?: number;\n  /** Edges shorter than this value will not have a tab. */\n  minEdgeLength?: number;\n}\n\n/** UI metadata needed for this strategy */\nexport const SimpleTabPlacementStrategyUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Simple\",\n  description: \"Creates a single tab in the center of each edge with a random orientation.\",\n  sortHint: 1,\n  // these have to match the config above\n  controls: [\n    {\n      type: 'range',\n      name: 'tabSize',\n      label: 'Tab Size',\n      optional: true,\n      min: 0.01,\n      max: 1.0,\n      step: 0.01,\n      defaultValue: 0.5,\n      helpText: 'The width of the tab as a fraction of the edge length',\n    },\n    {\n      type: 'number',\n      name: 'minEdgeLength',\n      label: 'Minimum Edge Length',\n      optional: true,\n      defaultValue: 15,\n      helpText: 'Edges shorter than this value will not have a tab',\n    },\n  ],\n};\n\n// helper function to do the actual placement work\nfunction placeTabOnEdge(\n  edge: Edge,\n  topology: PuzzleTopology,\n  config: { tabSize: number, minEdgeLength: number },\n  random: RandomFn\n): void {\n  // clear any existing tabs in case we're re-evaluating\n  edge.tabs = undefined;\n\n  // we only place on internal edges\n  const isInternal = edge.heRight !== -1;\n  if (!isInternal) { return; }\n\n  const he1 = topology.halfEdges.get(edge.heLeft);\n  const he2 = topology.halfEdges.get(edge.heRight);\n  if (!he1 || !he2) return;\n\n  const p1 = he1.origin;\n  const p2 = he2.origin;\n  const edgeLength = Math.hypot(p2[0] - p1[0], p2[1] - p1[1]);\n\n  // add a tab, if the edge is long enough\n  if (edgeLength >= config.minEdgeLength) {\n    const tab: TabPlacement = {\n      position: 0.5, // center of the edge\n      size: config.tabSize,\n      convex: random() > 0.5, // tab is \"innie\" or \"outie\"\n    };\n    edge.tabs = [tab];\n  }\n}\n\n/**\n * A straightforward tab placement strategy that adds a single tab to the\n * center of each internal edge of the puzzle.\n */\nexport const SimpleTabPlacementStrategyFactory: GeneratorFactory<TabPlacementStrategy> = (\n  _width: number,\n  _height: number,\n  config: SimpleTabPlacementStrategyConfig,\n): TabPlacementStrategy => {\n  const { tabSize = 0.5, minEdgeLength = 0 } = config;\n  const placementConfig = { tabSize, minEdgeLength };\n\n  return {\n    placeTabs(runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of topology.edges.values()) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n    updateTabPlacements(edges: Edge[], runtimeOpts: TabPlacementStrategyRuntimeOptions): void {\n      const { topology, random } = runtimeOpts;\n      for (const edge of edges) {\n        placeTabOnEdge(edge, topology, placementConfig, random);\n      }\n    },\n  };\n};\nexport default SimpleTabPlacementStrategyFactory;\n\n// register the strategy\nTabPlacementStrategyRegistry.register(Name, SimpleTabPlacementStrategyFactory, SimpleTabPlacementStrategyUIMetadata);","import type { TabGenerator } from \"./TabGenerator\";\nimport type { CurveTo, EdgeSegment, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\nexport const Name: TraditionalTabGeneratorName = \"TraditionalTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TraditionalTabGeneratorConfig extends GeneratorConfig {\n  name: TraditionalTabGeneratorName;\n  /** Amount of randomness to apply to each tab (0-100) */\n  jitter?: number;\n  /** If provided, the width of a tab's features will be clamped to this value */\n  maxTabSize?: number;\n}\n\n/** UI metadata needed for this generator */\nexport const TraditionalTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Traditional\",\n  description: \"Creates a traditional rounded tab for each (internal) piece edge.\",\n  sortHint: 1,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      defaultValue: 8,\n      min: 0,\n      max: 100,\n      step: 1,\n      helpText: 'Adds randomness to the tab shape. 0 means completely uniform tabs',\n    },\n    {\n      type: 'number',\n      name: 'maxTabSize',\n      label: 'Maximum Tab Width',\n      optional: true,\n      helpText: 'If provided, the width of a tab\\'s features will be clamped to this value',\n    },\n  ],\n};\n\n\n/**\n * Build a puzzle nub using three cubic Bézier segments that replace a straight\n * edge AB. Curve 1 is a gentle S-curve up to the nub edge, Curve 2 is the arch\n * across the top of the nub, Curve 3 is the mirror of curve 1 back to the baseline.\n *   - the edge is parameterised from 0.0 → 1.0 along its length;\n *   - the nub is centred roughly at s = 0.5 and spans ≈ 4 · t of the edge;\n *   - the peak of the nub reaches ± 3 · t away from the baseline.\n *\n * @param a         Edge start point.\n * @param b         Edge end point.\n * @param sizePct   “Tab size” slider value (0–100 %).\n * @param jitterPct “Jitter” slider value (0–100 %).\n * @param random    Seeded RNG so callers can reproduce shapes.\n * @param inward    If true the nub is an **indent**; otherwise a **bump**.\n * @param maxTabSize Optional maximum absolute width for the tab.\n *\n * @returns Three cubic Bézier segments, ordered from a→b.\n */\nfunction createTraditionalTab(\n  a: Vec2,\n  b: Vec2,\n  sizePct: number,\n  jitterPct: number,\n  random: RandomFn,\n  inward = false,\n  maxTabSize?: number\n): EdgeSegment[] {\n  /* --- 1.  Work in a local (u,v) coordinate frame ---------------------- */\n\n  const ux = b[0] - a[0];\n  const uy = b[1] - a[1];\n  const len = Math.hypot(ux, uy);\n  if (len === 0) throw new Error(\"Edge has zero length\");\n\n  // Basis vectors:  u along the edge, v = +90° (right-hand rule).\n  const u: Vec2 = [ux / len, uy / len];\n  const v: Vec2 = [-u[1], u[0]]; // perpendicular\n\n  /** Convert (s,w) → world coordinates.  Both s and w are normalised by len. */\n  const P = (s: number, w: number): Vec2 => [\n    a[0] + (u[0] * s + v[0] * w) * len,\n    a[1] + (u[1] * s + v[1] * w) * len,\n  ];\n\n  /* --- 2.  Derive the five random perturbations a…e -------------------- */\n\n  const j = jitterPct / 100;\n  const rng = () => (random() * 2 - 1) * j; // uniform(-j, +j)\n\n  const A = rng(); // entry handle offset\n  const B = rng(); // l-shift of whole nub\n  const C = rng(); // vertical wobble of apex\n  const D = rng(); // anti-sym tweak\n  const E = rng(); // exit handle offset\n\n  /* --- 3.  Fixed shape constants -------------------------------------- */\n\n  let t = sizePct / 200; // tab “radius” in edge-length units\n\n  if (maxTabSize) {\n    const absoluteTabWidth = 4 * t * len;\n    if (absoluteTabWidth > maxTabSize) {\n      // recalculate t so that the tab width equals the max size, clamping it\n      t = maxTabSize / (4 * len);\n    }\n  }\n\n  const dir = inward ? -1 : 1; // bump (+) or hole (-)\n\n  /* --- 4.  Anchor & control points in (s,w) ---------------------------- */\n\n  const pointsSW: Vec2[] = [\n    [0.0               ,           0],\n    [0.2               ,           A],\n    [0.5 + B + D       , dir * (-t + C)],\n    [0.5 - t + B       , dir * ( t + C)],\n    [0.5 - 2*t + B - D , dir * (3*t + C)],\n    [0.5 + 2*t + B - D , dir * (3*t + C)],\n    [0.5 + t + B       , dir * ( t + C)],\n    [0.5 + B + D       , dir * (-t + C)],\n    [0.8               ,           E],\n    [1.0               ,           0],\n  ];\n\n  /* --- 5.  Map to world coords and split into 3 Béziers ---------------- */\n\n  const points: Vec2[] = pointsSW.map(([s, w]) => P(s, w));\n\n  const bez1: CurveTo = { type: 'bezier', p1: points[1], p2: points[2], p3: points[3] };\n  const bez2: CurveTo = { type: 'bezier', p1: points[4], p2: points[5], p3: points[6] };\n  const bez3: CurveTo = { type: 'bezier', p1: points[7], p2: points[8], p3: points[9] };\n\n  return [bez1, bez2, bez3];\n}\n\n/**\n * A factory that creates a TabGenerator for creating traditional, smoothly curved\n * puzzle piece tabs using a provided geometry function. The nub is built using\n * three cubic Bézier segments that replace a straight edge AB. Curve 1 is a\n * gentle S-curve up to the nub edge, Curve 2 is the arch across the top of the\n * nub, Curve 3 is the mirror of curve 1 back to the baseline.\n */\nexport const TraditionalTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number, config: TraditionalTabGeneratorConfig): TabGenerator => {\n  const { jitter = 8, maxTabSize } = config;\n\n  const TraditionalTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, random: RandomFn): EdgeSegment[] {\n      const sizePct = tab.size * 100; // convert to percent\n      const inward = !tab.convex;\n      return createTraditionalTab(start, end, sizePct, jitter, random, inward, maxTabSize);\n    },\n  };\n  return TraditionalTabGenerator;\n};\nexport default TraditionalTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TraditionalTabGeneratorFactory, TraditionalTabUIMetadata);\n","import type {\n  AABB,\n  EdgeSegment,\n  LineTo,\n  Piece,\n  PuzzleTopology,\n  Vec2,\n} from \"./types\";\nimport {\n  distanceSq,\n  calculateSegmentAABB,\n  serializeTopology,\n  doAABBsIntersect,\n} from \"./utils\";\nimport type { CheckGeometryWorkerInput, CheckGeometryWorkerOutput } from '../workers/CheckGeometryWorker';\nimport { Bezier } from 'bezier-js';\n\n// import the worker script\nimport CheckGeometryWorker from '../workers/CheckGeometryWorker?worker';\n\n/** An internal structure to hold a segment and its pre-calculated properties. */\ninterface BoundarySegment {\n  /** The geometric definition of the segment. */\n  segment: EdgeSegment;\n  /** The starting point of this segment. */\n  startPoint: Vec2;\n  /** The pre-calculated bounding box for this segment. */\n  bbox: AABB;\n}\n\n// helper to gets the end point of a segment.\nfunction getEndPoint(s: EdgeSegment): Vec2 {\n  return s.type === 'line' ? s.p : s.p3;\n}\n\n// helper to get a Bezier object for use with bezier-js\nfunction boundaryToBezier(boundary: BoundarySegment): Bezier {\n  if (boundary.segment.type !== 'bezier') {\n    throw new Error('Boundary segment is not a Bezier curve');\n  }\n  const { startPoint } = boundary;\n  const { p1, p2, p3 } = boundary.segment;\n  return new Bezier(\n    { x: startPoint[0], y: startPoint[1] },\n    { x: p1[0], y: p1[1] },\n    { x: p2[0], y: p2[1] },\n    { x: p3[0], y: p3[1] }\n  );\n}\n\n/**\n * Traverses a piece's boundary and collects all its geometric segments.\n * @param piece - The piece to process.\n * @param puzzle - The full puzzle geometry, for half-edge lookups.\n * @returns An ordered array of BoundarySegment objects.\n */\nfunction getPieceBoundary(piece: Piece, puzzle: PuzzleTopology): BoundarySegment[] {\n  const boundary: BoundarySegment[] = [];\n  const startHeId = piece.halfEdge;\n  let currentHeId = startHeId;\n\n  do {\n    const he = puzzle.halfEdges.get(currentHeId);\n    if (!he) {\n      console.error(`Could not find half-edge with ID: ${currentHeId}`);\n      break;\n    }\n\n    let startPoint = he.origin;\n\n    if (he.segments && he.segments.length > 0) {\n      // Add segments from the half-edge definition\n      for (const segment of he.segments) {\n        boundary.push({\n          segment,\n          startPoint,\n          bbox: calculateSegmentAABB(segment, startPoint),\n        });\n        // The next segment starts where the current one ends\n        startPoint = segment.type === 'line' ? segment.p : segment.p3;\n      }\n    } else {\n      // If no segments, it's a straight line to the next half-edge's origin\n      const nextHe = puzzle.halfEdges.get(he.next);\n      if (!nextHe) {\n        console.error(`Could not find next half-edge for ID: ${he.next}`);\n        continue;\n      }\n      const lineSegment: LineTo = { type: 'line', p: nextHe.origin };\n      boundary.push({\n        segment: lineSegment,\n        startPoint: startPoint,\n        bbox: calculateSegmentAABB(lineSegment, startPoint),\n      });\n    }\n\n    currentHeId = he.next;\n  } while (currentHeId !== startHeId);\n\n  return boundary;\n}\n\n/**\n * Performs precise intersection detection between two geometric segments.\n * This function handles Line/Line, Line/Curve, and Curve/Curve cases.\n *\n * @param s1 - The first boundary segment.\n * @param s2 - The second boundary segment.\n * @param adjacent - True of the segments are next to each other on the boundary.\n * @returns An array of Vec2 points representing all found intersections.\n */\nfunction narrowPhaseDetection(s1: BoundarySegment, s2: BoundarySegment, adjacent: boolean): Promise<Vec2[]> {\n  return new Promise<Vec2[]>((resolve) => {\n\n    const intersections: Vec2[] = [];\n    const type1 = s1.segment.type;\n    const type2 = s2.segment.type;\n    const tolerance = 0.01; // values this close to the beginning or end of a curve are effectively at the ends\n\n\n    // Bezier vs. Bezier\n    if (type1 === 'bezier' && type2 === 'bezier') {\n      const bezier1 = boundaryToBezier(s1);\n      const bezier2 = boundaryToBezier(s2);\n\n      // intersects() returns an array of strings that look like \"float/float\"\n      const pairs = bezier1.intersects(bezier2) as string[];\n\n      pairs.forEach((pair) => {\n        const tValues = pair.split('/');\n        const t1 = parseFloat(tValues[0]);\n        const t2 = parseFloat(tValues[1]);\n\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t1 > (1.0 - tolerance) && t2 < tolerance || t1 < tolerance && t2 > (1.0 - tolerance);\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n\n        // extract the intersection point\n        const p = bezier1.get(t1);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Bezier vs. Line\n    else if (type1 === 'bezier' || type2 === 'bezier') {\n      const curveBoundary = type1 === 'bezier' ? s1 : s2;\n      const lineBoundary = type1 === 'line' ? s1 : s2;\n\n      const curve = boundaryToBezier(curveBoundary);\n      const line = {\n        p1: { x: lineBoundary.startPoint[0], y: lineBoundary.startPoint[1] },\n        p2: { x: (lineBoundary.segment as LineTo).p[0], y: (lineBoundary.segment as LineTo).p[1] },\n      };\n\n      // intersects() returns an array of t-values on the curve\n      const tValues = curve.intersects(line) as number[]; // always numbers when comparing to line\n      tValues.forEach((t) => {\n        // if adjacent, they are allowed to touch at their connection point\n        if (adjacent) {\n          const isConnectionPoint = t > (1.0 - tolerance) || t < tolerance;\n          if (isConnectionPoint) {\n            // valid touch, not an intersection\n            return;\n          }\n        }\n        const p = curve.get(t);\n        intersections.push([p.x, p.y]);\n      });\n    }\n    // Line vs. Line\n    else {\n      // only non-adjacent line segments need to be compared\n      if (!adjacent) {\n        return resolve(intersections);\n      }\n\n      const p1 = s1.startPoint;\n      const p2 = s1.segment.p;\n      const p3 = s2.startPoint;\n      const p4 = s2.segment.p;\n\n      const [x1, y1] = p1;\n      const [x2, y2] = p2;\n      const [x3, y3] = p3;\n      const [x4, y4] = p4;\n\n      const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n      if (den !== 0) { // Ensure lines are not parallel or collinear\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;\n\n        // If an intersection exists on both line segments\n        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n          const intersectX = x1 + t * (x2 - x1);\n          const intersectY = y1 + t * (y2 - y1);\n          intersections.push([intersectX, intersectY]);\n        }\n      }\n    }\n\n    resolve(intersections);\n  });\n}\n\n/**\n * Detects self-intersections within each piece of a puzzle geometry.\n *\n * @param puzzle - The fully generated puzzle geometry.\n * @param onProgress - Optional callback invoked to report progress.\n * @returns An array of Vec2 points, where each point is an overlap.\n */\nasync function detectIntersections(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  const intersections: Vec2[] = [];\n  const EPSILON_SQUARED = 1e-8; // Tolerance for floating point comparisons\n\n  const pieces = Array.from(puzzle.pieces.values());\n  const totalPieces = pieces.length;\n  let processedCount = 0;\n\n  // 1. Iterate through each piece\n  for (const piece of puzzle.pieces.values()) {\n\n    // report progress\n    onProgress?.(processedCount, totalPieces);\n\n    const boundary = getPieceBoundary(piece, puzzle);\n    const numSegments = boundary.length;\n    if (numSegments < 2) {\n      processedCount++;\n      continue;\n    }\n\n    // 2. Compare every segment with every other segment that comes after it\n    for (let i = 0; i < numSegments; i++) {\n      for (let j = i + 1; j < numSegments; j++) {\n        const seg1 = boundary[i];\n        const seg2 = boundary[j];\n\n        // 3. Broad-phase detection using bounding boxes\n        if (!doAABBsIntersect(seg1.bbox, seg2.bbox)) {\n          // no intersections\n          continue;\n        }\n\n        // 4. Distinguish between adjacent and non-adjacent intersections\n        const areAdjacent = (j === i + 1) || (i === 0 && j === numSegments - 1);\n\n        // 5. Narrow-phase detection (using a bezier library)\n        const potentialPoints = await narrowPhaseDetection(seg1, seg2, areAdjacent);\n\n        if (potentialPoints.length === 0) {\n          // no intersections\n          continue;\n        }\n\n        if (areAdjacent) {\n          const connectionPoint = (i === 0 && j === numSegments - 1)\n            ? seg1.startPoint // we're comparing the final segment with the first segment\n            : getEndPoint(seg1.segment); // we're comparing adjacent segments\n\n          for (const point of potentialPoints) {\n            // An intersection is only an error if it's NOT at the connection point.\n            if (distanceSq(point, connectionPoint) > EPSILON_SQUARED) {\n              intersections.push(point);\n            }\n          }\n        } else {\n          // For non-adjacent segments, ANY intersection is an error.\n          intersections.push(...potentialPoints);\n        }\n      }\n    }\n    processedCount++;\n  }\n\n  // final call to signify completion\n  onProgress?.(totalPieces, totalPieces);\n\n  console.log(`detected ${intersections.length} intersections in ${puzzle.pieces.size} pieces`);\n  return intersections;\n}\n\n\n/**\n * Checks a puzzle for geometry issues such as intersecting pieces or too narrow geometry.\n * @param puzzle - Geometry to check\n * @param onProgress - Optional callpack for managing a progress bar\n * @returns A Promise for coordinates that have problem geometry\n */\nexport async function checkGeometry(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n\n  // find points where pieces intersect/overlap\n  const intersections = await detectIntersections(puzzle, onProgress);\n\n  if (intersections.length < 2) {\n    return intersections;\n  }\n\n  // Note: the intersection algorithm can return multiple points clustered very\n  // closely, which is confusing for the user, so here we filter them out\n  const MIN_DISTANCE = 1;\n  const filtered: Vec2[] = [intersections[0]];\n\n  for (let i = 1; i < intersections.length; i++) {\n    const current = intersections[i];\n    const last = filtered[filtered.length - 1];\n    if (distanceSq(current, last) > MIN_DISTANCE * MIN_DISTANCE) {\n      filtered.push(current);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Wraps the `checkGeometry` function in a web worker to run it off the main thread,\n * preventing the UI from freezing during intensive calculations.\n *\n * @param puzzle - The puzzle topology to check.\n * @param onProgress - An optional callback to receive progress updates.\n * @returns A promise that resolves with an array of intersection points or rejects on error.\n */\nexport function checkGeometryInWorker(\n  puzzle: PuzzleTopology,\n  onProgress?: (processed: number, total: number) => void\n): Promise<Vec2[]> {\n  return new Promise((resolve, reject) => {\n    const worker = new CheckGeometryWorker();\n\n    // Handle messages received from the worker\n    worker.onmessage = (event: MessageEvent<CheckGeometryWorkerOutput>) => {\n      const data = event.data;\n\n      switch (data.type) {\n      case 'progress':\n        onProgress?.(data.processed, data.total);\n        break;\n      case 'done':\n        resolve(data.results);\n        worker.terminate();\n        break;\n      case 'error':\n        reject(new Error(data.message));\n        worker.terminate();\n        break;\n      }\n    };\n\n    // Handle any critical errors with the worker itself\n    worker.onerror = (error: ErrorEvent) => {\n      reject(new Error(error.message));\n      worker.terminate();\n    };\n\n    // serialize the puzzle topology and send it to the worker to kick off the process\n    const message: CheckGeometryWorkerInput = {\n      topology: serializeTopology(puzzle),\n    };\n    worker.postMessage(message);\n  });\n}","import type { Vec2 } from \"../../types\";\nimport type { PointGenerator, PointGenerationRuntimeOptions } from \"./PointGenerator\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PointGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other PointGenerators\ntype GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\nexport const Name: GridJitterPointGeneratorName = \"GridJitterPointGenerator\";\n\n/** Required config for this generator */\nexport interface GridJitterPointGeneratorConfig extends GeneratorConfig {\n  name: GridJitterPointGeneratorName;\n  /** Amount of random jitter (0 to 100) */\n  jitter: number;\n}\n\n/** UI metadata needed for this generator */\nexport const GridJitterPointUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Grid\",\n  description: \"Generate seed points using a grid with optional random jitter. \" +\n    \"Has a uniform, regular look, especially with low randomness values.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [\n    {\n      type: 'range',\n      name: 'jitter',\n      label: 'Randomness',\n      min: 0,\n      max: 100,\n      step: 5,\n      defaultValue: 50,\n      helpText: 'Amount of jitter to apply to each grid point (0 to 100%)',\n    },\n  ],\n};\n\n/**\n * A point generator that uses grid + random jitter. `jitter` represents the\n * strength of jitter applied to each point, from 0 (straight grid) to 1\n * (completely random).\n */\nexport const GridJitterPointGeneratorFactory: GeneratorFactory<PointGenerator> = (width: number, height: number, config: GridJitterPointGeneratorConfig) => {\n  const { jitter = 50 } = config;\n\n  const GridJitterPointGenerator: PointGenerator = {\n    generatePoints(runtimeOpts: PointGenerationRuntimeOptions): Vec2[] {\n      const { width, height, pieceSize, random } = runtimeOpts;\n\n      const points: Vec2[] = [];\n      // assemble a grid\n      for (let x = 0; x < width; x += pieceSize) {\n        for (let y = 0; y < height; y += pieceSize) {\n          // initial position is the center of each grid cell\n          const point: Vec2 = [x + pieceSize / 2, y + pieceSize / 2];\n          // add random jitter\n          if (jitter > 0) {\n            point[0] += (random() - 0.5) * (jitter / 100) * pieceSize;\n            point[1] += (random() - 0.5) * (jitter / 100)  * pieceSize;\n          }\n          points.push(point);\n        }\n      }\n      return points;\n    },\n  };\n  return GridJitterPointGenerator;\n};\nexport default GridJitterPointGeneratorFactory;\n\n// register the generator\nPointGeneratorRegistry.register(Name, GridJitterPointGeneratorFactory, GridJitterPointUIMetadata);\n","import { PieceGenerator, PieceGeneratorRuntimeOptions } from \"./PieceGenerator\";\nimport type {\n  AABB,\n  Edge,\n  EdgeID,\n  HalfEdge,\n  HalfEdgeID,\n  Piece,\n  PieceID,\n  PuzzleTopology,\n  Vec2,\n} from '../../types';\nimport { polygonBounds } from \"../../utils\";\nimport { getUniqueId } from '../../../utils/UniqueId';\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { PieceGeneratorRegistry } from \"../Generator\";\n\n\n// Name of this generator, uniquely identifies it from all other PieceGenerators\ntype RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\nexport const Name: RectangularPieceGeneratorName = \"RectangularPieceGenerator\";\n\n/** Required config for this generator */\nexport interface RectangularPieceGeneratorConfig extends GeneratorConfig {\n  name: RectangularPieceGeneratorName;\n  // no custom config values\n}\n\n/** UI metadata needed for this generator */\nexport const RectangularPieceGeneratorUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Rectangular\",\n  description: \"Construct pieces from a regular grid. All pieces have 4 sides \" +\n    \"and are the same size. This generator ignores seed points.\",\n  sortHint: 2,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/**\n * A `PieceGenerator` that uses a Voronoi diagram to create the puzzle's topology.\n * It builds a full half-edge data structure representing the pieces and their\n * connectivity.\n */\nexport const RectangularPieceGeneratorFactory: GeneratorFactory<PieceGenerator> = (width: number, height: number, _config: RectangularPieceGeneratorConfig) => {\n\n  const RectangularPieceGenerator: PieceGenerator = {\n    /**\n     * Converts a set of seed points into a puzzle topology using a Voronoi diagram.\n     * @param _points The seed points. Ignored by this generator.\n     * @param runtimeOpts Runtime configuration for generation.\n     * @returns A `PuzzleTopology` data structure.\n     */\n    generatePieces(_points: Vec2[], runtimeOpts: PieceGeneratorRuntimeOptions): PuzzleTopology {\n      const { pieceSize } = runtimeOpts;\n\n      const topology: PuzzleTopology = {\n        vertices: [],\n        pieces: new Map<PieceID, Piece>(),\n        edges: new Map<EdgeID, Edge>(),\n        halfEdges: new Map<HalfEdgeID, HalfEdge>(),\n        boundary: [],\n      };\n\n      // --- 1. Calculate Grid Dimensions ---\n      // Determine the number of rows and columns based on the desired piece size.\n      const cols = Math.ceil(width / pieceSize);\n      const rows = Math.ceil(height / pieceSize);\n\n      // Calculate the actual width and height of each cell\n      const cellWidth = Math.round(width / cols);\n      const cellHeight = Math.round(height / rows);\n\n      // --- 2. Create Vertices ---\n      // A 2D array to hold all vertex points for easy lookup by grid index.\n      const gridVertices: Vec2[][] = [];\n      for (let r = 0; r <= rows; r++) {\n        const rowVertices: Vec2[] = [];\n        for (let c = 0; c <= cols; c++) {\n          const x = c * cellWidth;\n          const y = r * cellHeight;\n          rowVertices.push([x, y]);\n        }\n        gridVertices.push(rowVertices);\n      }\n      // Flatten the 2D array into the final list for the topology.\n      topology.vertices = gridVertices.flat();\n\n      // --- 3. Create Pieces and Half-Edges ---\n      // This map will help us find the twin of a half-edge. The key is a string\n      // representing the start and end vertices of an edge, e.g., \"x1,y1-x2,y2\".\n      const halfEdgeTwinMap = new Map<string, HalfEdgeID>();\n\n      // NOTE: Using a string key based on floating point coordinates can be very\n      // fragile. Tiny precision errors can cause lookups to fail. This approach\n      // is safe here because the grid coordinates are normalized to integers.\n      // For a generator with less regular vertex points it is more robust to\n      // assign a unique ID to each vertex and use those IDs to build the key,\n      // or to use a helper function to perform an approximate \"epsilon\" comparison.\n\n      // build each piece\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          const pieceId = r * cols + c;\n\n          // Get the four corner vertices for the current piece.\n          const topLeft = gridVertices[r][c];\n          const topRight = gridVertices[r][c + 1];\n          const bottomLeft = gridVertices[r + 1][c];\n          const bottomRight = gridVertices[r + 1][c + 1];\n\n          // Define the four half-edges for this piece in counter-clockwise (CCW) order.\n          const he_top: HalfEdge =    { id: getUniqueId(), origin: topLeft,     twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_right: HalfEdge =  { id: getUniqueId(), origin: topRight,    twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_bottom: HalfEdge = { id: getUniqueId(), origin: bottomRight, twin: -1, next: -1, prev: -1, piece: pieceId };\n          const he_left: HalfEdge =   { id: getUniqueId(), origin: bottomLeft,  twin: -1, next: -1, prev: -1, piece: pieceId };\n\n          // Link the half-edges for this piece in a circular loop.\n          he_top.next = he_right.id;\n          he_right.next = he_bottom.id;\n          he_bottom.next = he_left.id;\n          he_left.next = he_top.id;\n\n          he_top.prev = he_left.id;\n          he_left.prev = he_bottom.id;\n          he_bottom.prev = he_right.id;\n          he_right.prev = he_top.id;\n\n          // Add the half-edges to the main topology map.\n          topology.halfEdges.set(he_top.id, he_top);\n          topology.halfEdges.set(he_right.id, he_right);\n          topology.halfEdges.set(he_bottom.id, he_bottom);\n          topology.halfEdges.set(he_left.id, he_left);\n\n          // Create and add the piece to the topology.\n          const piece: Piece = {\n            id: pieceId,\n            site: [ (topLeft[0] + bottomRight[0]) / 2, (topLeft[1] + bottomRight[1]) / 2 ], // Site is the center\n            halfEdge: he_top.id, // Point to any half-edge on its boundary\n            bounds: [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]] as AABB,\n          };\n          topology.pieces.set(pieceId, piece);\n\n          // --- 4. Link Twins and Create Edges ---\n          // An edge is defined by its start and end points. We create a consistent key\n          // to look up potential twins created by neighboring pieces.\n          const key = (p1: Vec2, p2: Vec2) => `${p1[0]},${p1[1]}-${p2[0]},${p2[1]}`;\n\n          const edgesToProcess = [\n            { he: he_top,    p1: topLeft,     p2: topRight,    isBoundary: r === 0 },\n            { he: he_right,  p1: topRight,    p2: bottomRight, isBoundary: c === cols - 1 },\n            { he: he_bottom, p1: bottomRight, p2: bottomLeft,  isBoundary: r === rows - 1 },\n            { he: he_left,   p1: bottomLeft,  p2: topLeft,     isBoundary: c === 0 },\n          ];\n\n          for (const edgeInfo of edgesToProcess) {\n            const twinKey = key(edgeInfo.p2, edgeInfo.p1);\n            const twinId = halfEdgeTwinMap.get(twinKey);\n\n            const edgeId = getUniqueId();\n            let edge: Edge;\n\n            if (twinId !== undefined) {\n              // Found a twin! This is an internal edge.\n              const twinHe = topology.halfEdges.get(twinId)!;\n              edgeInfo.he.twin = twinHe.id;\n              twinHe.twin = edgeInfo.he.id;\n\n              // The half-edge from the neighbor is the \"left\" one, ours is the \"right\".\n              edge = {\n                id: edgeId,\n                heLeft: twinHe.id,\n                heRight: edgeInfo.he.id,\n                bounds: polygonBounds([edgeInfo.p1, edgeInfo.p2]),\n              };\n              halfEdgeTwinMap.delete(twinKey); // Clean up map\n            } else {\n              // No twin found. This could be a boundary edge or its twin hasn't been created yet.\n              // We add it to the map to be found by a future neighbor.\n              const selfKey = key(edgeInfo.p1, edgeInfo.p2);\n              halfEdgeTwinMap.set(selfKey, edgeInfo.he.id);\n\n              // If we know it's on the boundary, create the edge now.\n              if (edgeInfo.isBoundary) {\n                edge = {\n                  id: edgeId,\n                  heLeft: edgeInfo.he.id,\n                  heRight: -1,\n                  bounds: polygonBounds([edgeInfo.p1, edgeInfo.p2]),\n                };\n                topology.boundary.push(edgeId);\n              } else {\n                continue; // It's an internal edge, wait for its twin to create the Edge object.\n              }\n            }\n            topology.edges.set(edgeId, edge);\n          }\n        }\n      }\n\n      return topology;\n    },\n  };\n  return RectangularPieceGenerator;\n};\nexport default RectangularPieceGeneratorFactory;\n\n// register the generator\nPieceGeneratorRegistry.register(Name, RectangularPieceGeneratorFactory, RectangularPieceGeneratorUIMetadata);\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, RandomFn, TabPlacement, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all other TabGenerators\ntype NullTabGeneratorName = \"NullTabGenerator\";\nexport const Name: NullTabGeneratorName = \"NullTabGenerator\";\n\n/** This generator doesn't take any special config */\nexport interface NullTabGeneratorConfig extends GeneratorConfig {\n  name: NullTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const NullTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"None\",\n  description: \"Do not generate tabs. All pieces have straight edges.\",\n  sortHint: 3,\n  // these have to match the GeneratorConfig above\n  controls: [],\n};\n\n/** Tab generator that does nothing, piece edges remain straight lines */\nexport const NullTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number,_config: NullTabGeneratorConfig) => {\n  const NullTabGenerator: TabGenerator = {\n    createTabSegments(_start: Vec2, _end: Vec2, _tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      return []; // does nothing\n    },\n  };\n  return NullTabGenerator;\n};\nexport default NullTabGeneratorFactory;\n\n// register the generator\nTabGeneratorRegistry.register(Name, NullTabGeneratorFactory, NullTabUIMetadata);\n\n","import type { TabGenerator } from \"./TabGenerator\";\nimport type { EdgeSegment, TabPlacement, RandomFn, Vec2 } from \"../../types\";\nimport type { GeneratorUIMetadata } from '../../ui_types';\nimport type { GeneratorConfig, GeneratorFactory } from \"../Generator\";\nimport { TabGeneratorRegistry } from \"../Generator\";\n\n// Name of this generator, uniquely identifies it from all the other TabGenerators\ntype TriangleTabGeneratorName = \"TriangleTabGenerator\";\nexport const Name: TriangleTabGeneratorName = \"TriangleTabGenerator\";\n\n/** Custom config for this generator */\nexport interface TriangleTabGeneratorConfig extends GeneratorConfig {\n  name: TriangleTabGeneratorName;\n}\n\n/** UI metadata needed for this generator */\nexport const TriangleTabUIMetadata: GeneratorUIMetadata = {\n  name: Name,\n  displayName: \"Triangle\",\n  description: \"Creates a simple triangle between each (internal) piece edge.\",\n  sortHint: 2,\n  // these have to match the config above\n  controls: [],\n};\n\n/**\n * A simple TabGenerator that adds a triangular \"nub\" to an edge.\n *\n * This generator serves as a straightforward example of how to implement the\n * TabGenerator interface. It generates a three line segment that forms a\n * triangular tab.\n */\nexport const TriangleTabGeneratorFactory: GeneratorFactory<TabGenerator> = (_width: number, _height: number, _config: TriangleTabGeneratorConfig) => {\n\n  const TriangleTabGenerator: TabGenerator = {\n    createTabSegments(start: Vec2, end: Vec2, tab: TabPlacement, _random: RandomFn): EdgeSegment[] {\n      // 1. Calculate edge vectors from the provided start and end points.\n      const edgeVector: Vec2 = [end[0] - start[0], end[1] - start[1]];\n      const edgeLength = Math.hypot(edgeVector[0], edgeVector[1]);\n\n      // Return nothing for zero-length edges.\n      if (edgeLength < 1e-6) {\n        return [];\n      }\n\n      // Calculate a perpendicular vector (normal) to the edge.\n      const edgeDir: Vec2 = [edgeVector[0] / edgeLength, edgeVector[1] / edgeLength];\n      const normalDir: Vec2 = [-edgeDir[1], edgeDir[0]];\n\n      // 2. Calculate the position of the tab's peak.\n      // Find the midpoint of the edge segment this tab occupies.\n      const midPoint: Vec2 = [start[0] + edgeVector[0] / 2, start[1] + edgeVector[1] / 2];\n\n      // Determine the tab's direction from the `convex` property.\n      // `true` (outward) is a positive direction, `false` (inward) is negative.\n      const direction = tab.convex ? 1 : -1;\n\n      // The tab's height is defined by its `size` property (a fraction of the edge length).\n      const tabHeight = edgeLength * tab.size * direction;\n\n      // Calculate the nub point by moving from the midpoint along the normal.\n      const nubPoint: Vec2 = [\n        midPoint[0] + normalDir[0] * tabHeight,\n        midPoint[1] + normalDir[1] * tabHeight,\n      ];\n\n      // 3. Create the segments for the tab.\n      const result: EdgeSegment[] = [];\n      result.push({ type: 'line', p: start });\n      result.push({ type: 'line', p: nubPoint });\n      result.push({ type: 'line', p: end });\n\n      return result;\n    },\n  };\n  return TriangleTabGenerator;\n};\nexport default TriangleTabGeneratorFactory;\n\n\n// register the generator\nTabGeneratorRegistry.register(Name, TriangleTabGeneratorFactory, TriangleTabUIMetadata);\n","// component that renders single page application for generating puzzles\nimport m from 'mithril';\n\n// UI parts\nimport GitHubCorner from './ui/GitHubCorner';\nimport Puzzle from './ui/Puzzle';\nimport DownloadPuzzleButton from './ui/DownloadPuzzleButton';\nimport GeometryCheckIndicator from './ui/GeometryCheckIndicator';\nimport UploadImageButton from './ui/UploadImageButton';\nimport GeneratorPicker from './ui/GeneratorPicker';\nimport NumberInputControl from './ui/inputs/NumberInputControl';\nimport AspectRatioPicker from './ui/AspectRatioPicker';\nimport ColorPicker from './ui/ColorPicker';\n\n// geometry parts\nimport type { PuzzleGeometry } from './geometry/types';\nimport type { GeneratorConfig, GeneratorName, GeneratorRegistry } from './geometry/generators/Generator';\nimport { PointGeneratorRegistry, PieceGeneratorRegistry, TabPlacementStrategyRegistry, TabGeneratorRegistry } from './geometry/generators/Generator';\nimport { Name as PoissonGeneratorName } from './geometry/generators/point/PoissonPointGenerator';\nimport { Name as VoronoiGeneratorName } from './geometry/generators/piece/VoronoiPieceGenerator';\nimport { Name as SimpleTabPlacementStrategyName } from './geometry/generators/tab_placement/SimpleTabPlacementStrategy';\nimport { Name as TraditionalTabGeneratorName } from './geometry/generators/tab/TraditionalTabGenerator';\nimport { buildPuzzle } from './geometry/PuzzleMaker';\nimport { checkGeometryInWorker } from './geometry/GeometryChecker';\n\n// register generators\nimport \"./geometry/generators/point/GridJitterPointGenerator\";\nimport \"./geometry/generators/point/PoissonPointGenerator\";\nimport \"./geometry/generators/piece/VoronoiPieceGenerator\";\nimport \"./geometry/generators/piece/RectangularPieceGenerator\";\nimport \"./geometry/generators/tab_placement/SimpleTabPlacementStrategy\";\nimport \"./geometry/generators/tab/NullTabGenerator\";\nimport \"./geometry/generators/tab/TriangleTabGenerator\";\nimport \"./geometry/generators/tab/TraditionalTabGenerator\";\n\n// Webawesome components\nimport { registerIconLibrary } from '@awesome.me/webawesome/dist/webawesome.js';\nimport \"@awesome.me/webawesome/dist/styles/themes/default.css\";\n\n// CSS for this component\nimport './index.css';\n\n// detect light/dark mode\nlet isDarkMode = false;\nfunction configureDarkLightTheme() {\n  const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n  function manageDarkLightTheme() {\n    if (darkModeQuery.matches) {\n      document.documentElement.classList.add('wa-dark');\n      isDarkMode = true;\n    } else {\n      document.documentElement.classList.remove('wa-dark');\n      isDarkMode = false;\n    }\n  }\n  manageDarkLightTheme();\n  darkModeQuery.addEventListener('change', manageDarkLightTheme);\n}\nconfigureDarkLightTheme();\n\n// component that draws the page\nconst Page: m.ClosureComponent<unknown> = () => {\n\n  const defaultWidth = 800;\n  const defaultHeight = 600;\n\n  const defaultPointGenerator = PoissonGeneratorName;\n  const defaultPieceGenerator = VoronoiGeneratorName;\n  const defaultTabGenerator = TraditionalTabGeneratorName;\n\n  /** State tracked for each type of generator */\n  interface GeneratorState<C extends GeneratorConfig = GeneratorConfig> {\n    label: string;\n    registry: GeneratorRegistry<unknown>;\n    name : GeneratorName;\n    config: C;\n  }\n\n  interface PageState {\n    /** Random seed */\n    seed: number;\n    /** Width of canvas in pixels */\n    canvasWidth: number;\n    /** Height of canvas in pixels */\n    canvasHeight: number;\n    /** Aspect ratio of canvas, width/height */\n    aspectRatio: number;\n    /** Minimum distance between control points (pixels) */\n    distance: number;\n    /** Color of pieces */\n    color: string;\n    /** Problems found by the geometry check algorithms */\n    geometryProblems: {\n      /** If true, the geometry will be re-checked whenever a new puzzle is generated */\n      autoCheck: boolean;\n      /** Count of problems found in the last check */\n      problems?: number;\n      /** Percent complete of in-progress geometry check */\n      progress?: number;\n    },\n    /** Dirty flag that keeps us from hitting the puzzle generation function too hard */\n    dirty: boolean;\n    /** Currently selected and configured generators for each part of puzzle generation */\n    generators: Record<string, GeneratorState>;\n    /** Generated puzzle geometry */\n    puzzle?: PuzzleGeometry;\n    /** User uploaded image */\n    backgroundImageUrl?: string;\n    /** Name of uploaded image */\n    backgroundImageName: string;\n  };\n\n  // component state\n  const state: PageState = {\n    seed: new Date().getTime() % 10240,\n    canvasWidth: defaultWidth,\n    canvasHeight: defaultHeight,\n    aspectRatio: defaultWidth / defaultHeight,\n    distance: 40,\n    color: isDarkMode ? \"#DDDDDD\" : \"#333333\",\n    geometryProblems: {\n      autoCheck: false,\n      problems: undefined,\n      progress: undefined,\n    },\n    dirty: true,\n    generators: {\n      /** Strategy for creating points (which influences piece generation) */\n      point: {\n        label: \"Seed Points\",\n        registry: PointGeneratorRegistry,\n        name: defaultPointGenerator,\n        config: PointGeneratorRegistry.getDefaultConfig(defaultPointGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for turning points into puzzle pieces */\n      piece: {\n        label: \"Piece Generation\",\n        registry: PieceGeneratorRegistry,\n        name: defaultPieceGenerator,\n        config: PieceGeneratorRegistry.getDefaultConfig(defaultPieceGenerator, defaultWidth, defaultHeight),\n      },\n      /** Strategy for placing tabs on piece edges */\n      placement: {\n        label: \"Tab Placement\",\n        registry: TabPlacementStrategyRegistry,\n        name: SimpleTabPlacementStrategyName,\n        config: TabPlacementStrategyRegistry.getDefaultConfig(SimpleTabPlacementStrategyName, defaultWidth, defaultHeight),\n      },\n      /** Style of tabs to generate */\n      tab: {\n        label: \"Tabs\",\n        registry: TabGeneratorRegistry,\n        name: defaultTabGenerator,\n        config: TabGeneratorRegistry.getDefaultConfig(defaultTabGenerator, defaultWidth, defaultHeight),\n      },\n    },\n    puzzle: undefined,\n    backgroundImageUrl: undefined,\n    backgroundImageName: '',\n  };\n\n  // utility to invoke the geometry checks\n  function handleCheckGeometry() {\n    if (!state.puzzle) return;\n\n    state.geometryProblems.progress = 0;\n    m.redraw();\n\n    // this uses a web worker to not block the main thread\n    checkGeometryInWorker(state.puzzle, (processed, total) => {\n      state.geometryProblems.progress = (processed / total) * 100;\n      m.redraw();\n    }).then((problems) => {\n      state.geometryProblems.problems = problems.length;\n      state.geometryProblems.progress = undefined;\n      if (state.puzzle) {\n        state.puzzle.problems = problems;\n      }\n      m.redraw();\n    }).catch((err) => {\n      state.geometryProblems.progress = undefined;\n      console.error(err);\n      m.redraw();\n    });\n  }\n\n  // Mithril component\n  return {\n\n    oncreate: () => {\n      buildPuzzle({\n        width: state.canvasWidth,\n        height: state.canvasHeight,\n        pieceSize: state.distance,\n        pointConfig: state.generators.point.config,\n        pieceConfig: state.generators.piece.config,\n        placementConfig: state.generators.placement.config,\n        tabConfig: state.generators.tab.config,\n        seed: state.seed,\n      }).then((puzzle) => {\n        state.puzzle = puzzle;\n        m.redraw();\n        if (state.geometryProblems.autoCheck) {\n          handleCheckGeometry();\n        }\n      }).catch((err) => {\n        console.error(err);\n      });\n    },\n\n    onupdate: () => {\n      if (state.dirty) {\n        state.dirty = false;\n        // rebuild the puzzle geometry\n        buildPuzzle({\n          width: state.canvasWidth,\n          height: state.canvasHeight,\n          pieceSize: state.distance,\n          pointConfig: state.generators.point.config,\n          pieceConfig: state.generators.piece.config,\n          placementConfig: state.generators.placement.config,\n          tabConfig: state.generators.tab.config,\n          seed: state.seed,\n        }).then((puzzle) => {\n          state.geometryProblems.problems = undefined;\n          state.geometryProblems.progress = undefined;\n          state.puzzle = puzzle;\n          m.redraw();\n          if (state.geometryProblems.autoCheck) {\n            handleCheckGeometry();\n          }\n        }).catch((err) => {\n          console.error(err);\n        });\n      }\n    },\n\n    onremove: () => {\n      if (state.backgroundImageUrl) {\n        // clean up memory\n        URL.revokeObjectURL(state.backgroundImageUrl);\n        state.backgroundImageUrl = undefined;\n      }\n    },\n\n    // component lifecycle: render our output\n    view: () => {\n\n      return m(\".page\", [\n        m(GitHubCorner, {\n          link: \"https://github.com/weevilgenius/puzzle-generator\",\n        }),\n        m(\"h1\", \"Puzzle Generator\"),\n        m(\".container\", [\n\n          state.puzzle && m('.puzzle-stack', [\n\n            // main puzzle display\n            m(Puzzle, {\n              width: state.canvasWidth,\n              height: state.canvasHeight,\n              color: state.color,\n              imageUrl: state.backgroundImageUrl,\n              puzzle: state.puzzle,\n              isDirty: state.dirty,\n              onPuzzleChanged: (puzzle) => {\n                // user dragged a vertex to tweak the puzzle\n                state.puzzle = puzzle;\n                m.redraw();\n              },\n            }),\n\n            m('.actions', [\n\n              // SVG download button\n              m(DownloadPuzzleButton, {\n                puzzle: state.puzzle,\n                width: state.canvasWidth,\n                height: state.canvasHeight,\n                color: state.color,\n              }),\n\n              // Geometry check display\n              m(GeometryCheckIndicator, {\n                autoCheck: state.geometryProblems.autoCheck,\n                problems: state.geometryProblems.problems,\n                progressPercent: state.geometryProblems.progress,\n                onCheckRequested: () => {\n                  if (!state.dirty) {\n                    handleCheckGeometry();\n                  }\n                  m.redraw();\n                },\n                onAutocheckChanged: (autocheck) => {\n                  if (autocheck !== state.geometryProblems.autoCheck) {\n                    state.geometryProblems.autoCheck = autocheck;\n                    m.redraw();\n                  }\n                },\n              }),\n\n            ]),\n          ]),\n\n          // puzzle generation controls\n          m(\".controls\", [\n\n            // background image\n            m('.background-image', [\n              m(UploadImageButton, {\n                label: \"Background Image\",\n                onUpload: (imageUrl, filename, width, height) => {\n                  // clear any previous image\n                  if (state.backgroundImageUrl) {\n                    URL.revokeObjectURL(state.backgroundImageUrl);\n                  }\n                  state.canvasWidth = width;\n                  state.canvasHeight = height;\n                  state.aspectRatio = width / height;\n                  state.backgroundImageUrl = imageUrl;\n                  state.backgroundImageName = filename;\n                  state.dirty = true;\n                  m.redraw();\n                },\n              }),\n              m('span.background-image-label', state.backgroundImageName),\n            ]),\n\n            // Puzzle aspect ratio\n            m(AspectRatioPicker, {\n              ratio: state.aspectRatio,\n              disabled: state.backgroundImageUrl !== undefined,\n              onChange: (ratio) => {\n                state.aspectRatio = ratio;\n                state.canvasWidth = state.canvasHeight * ratio;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Random number seed\n            m(NumberInputControl, {\n              config: {\n                name: 'seed',\n                label: 'Seed',\n                type: 'number',\n              },\n              value: state.seed,\n              onChange: (value) => {\n                state.seed = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece size\n            m(NumberInputControl, {\n              config: {\n                name: 'pieceSize',\n                label: 'Piece size',\n                type: 'number',\n              },\n              value: state.distance,\n              onChange: (value) => {\n                state.distance = value ?? 0;\n                state.dirty = true;\n                m.redraw();\n              },\n            }),\n\n            // Piece color\n            m(ColorPicker, {\n              label: 'Piece color',\n              color: state.color,\n              size: \"small\",\n              onUpdate: (newColor) => {\n                state.color = newColor;\n                m.redraw();\n              },\n            }),\n\n            // render a generator picker for each type of generator\n            ...Object.entries(state.generators).map(([type, generator]) => {\n              return m(\"label\", [\n                generator.label + ':',\n                m(GeneratorPicker, {\n                  generator: generator.name,\n                  registry: generator.registry,\n                  config: generator.config,\n                  onGeneratorChange: (generatorName) => {\n                    if (generatorName != generator.name) {\n                      console.log(`${type} generator changed to ${generatorName}`);\n                      generator.name = generatorName;\n                      // generator changed, we need a new blank config\n                      state.generators[type].config = generator.registry.getDefaultConfig(generatorName, state.canvasWidth, state.canvasHeight);\n                      state.dirty = true;\n                      m.redraw();\n                    }\n                  },\n                  onConfigChange: (key, value) => {\n                    console.log(`${type} generator config \"${key}\" changed to ${String(value)}`);\n                    generator.config[key] = value;\n                    state.dirty = true;\n                    m.redraw();\n                  },\n                }),\n              ]);\n            }),\n\n          ]), // .controls\n\n        ]), // .container\n\n      ]);\n    }, // view()\n  };\n};\n\n// configure Webawesome icons to use Material Symbols\nregisterIconLibrary('material', {\n  resolver: (name) => {\n    const match = name.match(/^(.*?)(_(rounded|sharp))?$/);\n    if (match) {\n      return `https://cdn.jsdelivr.net/npm/@material-symbols/svg-400@0.32.0/${match[3] ?? 'outlined'}/${match[1]}.svg`;\n    }\n    return '';\n  },\n  mutator: (svg) => svg.setAttribute('fill', 'currentColor'),\n});\n\n// Ask Mithril to render the page, our componet gets placed into the root element.\n// Mithril will rerender automatically after DOM event handlers defined in component\n// views and also whenever m.redraw() is called.\nm.mount(document.body, Page);\n"],"names":["GitHubCorner","attrs","m","GeneratorRegistry","name","factory","uiMetadata","width","height","config","generator","a","b","g","newConfig","metadata","control","PointGeneratorRegistry","PieceGeneratorRegistry","TabPlacementStrategyRegistry","TabGeneratorRegistry","distanceSq","p1","p2","dx","dy","serializeTopology","topology","getPieceAABB","piece","minX","minY","maxX","maxY","startingEdgeId","currentEdge","expandBbox","p","segment","MAX_CLICK_DISTANCE","MAX_CLICK_DISTANCE_SQ","findClosestVertex","puzzle","clickPos","closestVertexIndex","minDistanceSq","distSq","polygonBounds","polygon","i","arePointsEqual","generateSegmentsForEdge","edge","tabGenerator","random","heLeft","heRight","edgeStart","edgeEnd","heLeftSegments","currentPos","tab","tabStartPos","tabStartPoint","tabEndPoint","tabSegments","invertSegments","segments","originalStart","inverted","segmentStart","prevSegment","mulberry32","seed","t","buildPuzzle","options","pieceSize","pointConfig","pieceConfig","placementConfig","tabConfig","pointGenerator","pieceGenerator","placementStrategy","points","drawPuzzle","canvas","pieceColor","showPoints","ctx","he","destination","problemPoint","x","y","moveVertex","vertexIndex","newPos","oldPos","departingEdges","affectedPieceIDs","delta","departingEdge","predecessorEdge","lastSegment","regenerateAffectedTabs","pieceId","vertex","affectedEdges","movedVertexPos","halfEdgeToEdgeMap","destinationVertex","parentEdge","he1","he2","Puzzle","state","dom","e","createSVG","pathData","pathD","downloadSvg","svg","filename","blob","url","DownloadPuzzleButton","GeometryCheckIndicator","showProgress","showOKBadge","showProblemBadge","checkbox","calculateDisplayDimensions","originalWidth","originalHeight","maxWidth","aspectRatio","UploadImageButton","file","bitmap","uploadUrl","err","BooleanInputControl","newValue","NumberInputControl","input","RangeInputControl","StringInputControl","GeneratorPicker","generators","newSelected","panel","value","commonAspectRatios","AspectRatioPicker","isCustom","selectOptions","ratioStr","selectedValue","range","ColorPicker","tinyNDArrayOfInteger","gridShape","dimensions","totalLength","stride","dimension","tinyNDArrayOfArray","data","index","tinyNdarray","sphereRandom","sampleSphere","d","rng","v","d2","r2","rr","r","theta","h","moore","size","length","neighbors","neighbor","require$$0","getNeighbourhood","dimensionNumber","neighbourhood","origin","n","dist","n1","n2","squareDist1","squareDist2","neighbourhoodCache","getNeighbourhoodMemoized","tinyNDArray","require$$1","require$$2","squaredEuclideanDistance","point1","point2","result","FixedDensityPDS","maxShape","floatPrecisionMitigation","epsilonDistance","point","valid","internalArrayIndex","neighbourIndex","currentDimensionValue","existingPoint","tries","angle","distance","currentPoint","newPoint","inShape","gridData","fixedDensity","euclideanDistance","VariableDensityPDS","pointIndex","existingPointDistance","pointDistance","minDistance","maxDistance","currentDistance","sampleIndex","variableDensity","PoissonDiskSampling","poissonDiskSampling","Name","PoissonPointUIMetadata","PoissonPointGeneratorFactory","_width","_height","_config","runtimeOpts","epsilon","splitter","resulterrbound","sum","elen","flen","f","Q","Qnew","hh","bvirt","enow","fnow","eindex","findex","hindex","estimate","vec","ccwerrboundA","ccwerrboundB","ccwerrboundC","B","C1","C2","D","u","orient2dadapt","ax","ay","bx","by","cx","cy","detsum","acxtail","acytail","bcxtail","bcytail","c","ahi","alo","bhi","blo","_i","_j","_0","s1","s0","t1","t0","u3","acx","bcx","acy","bcy","det","errbound","C1len","C2len","Dlen","orient2d","detleft","detright","EPSILON","EDGE_STACK","Delaunator","getX","defaultGetX","getY","defaultGetY","coords","maxTriangles","hullPrev","hullNext","hullTri","hullHash","i0","i1","i2","minDist","i0x","i0y","i1x","i1y","minRadius","circumradius","i2x","i2y","quicksort","hull","j","d0","id","center","circumcenter","hullSize","k","xp","yp","start","key","q","pseudoAngle","triangles","halfedges","ar","a0","b0","al","bl","p0","pr","pl","inCircle","hbl","br","px","py","ex","ey","fx","fy","ap","bp","cp","cl","ids","dists","left","right","temp","tempDist","median","swap","arr","tmp","Path","x0","y0","w","Polygon","Voronoi","delaunay","xmin","ymin","xmax","ymax","vectors","circumcenters","t2","t3","x1","y1","x2","y2","x3","y3","ab","context","buffer","inedges","ti","tj","xi","yi","xj","yj","h0","h1","cell","S","c0","c1","ci","cj","loop","ai","li","aj","lj","e0","V","P","e1","sx0","sy0","sx1","sy1","flip","vx0","vy0","vxn","vyn","vx","vy","tau","pow","pointX","pointY","collinear","jitter","Delaunay","that","flatArray","flatIterable","_","bounds","hullIndex","_hullIndex","l","dc","dt","array","getUniqueId","VoronoiPieceGeneratorUIMetadata","linkPieceHalfEdges","map","len","pointToKey","VoronoiPieceGeneratorFactory","_runtimeOpts","voronoi","halfEdgeEndpointMap","site","pieceHalfEdgeIds","he1_next","keyForTwin","twinId","edgeId","vertexSet","SimpleTabPlacementStrategyUIMetadata","placeTabOnEdge","SimpleTabPlacementStrategyFactory","tabSize","minEdgeLength","edges","TraditionalTabUIMetadata","createTraditionalTab","sizePct","jitterPct","inward","maxTabSize","ux","uy","s","A","C","E","dir","bez1","bez2","bez3","TraditionalTabGeneratorFactory","end","checkGeometryInWorker","onProgress","resolve","reject","worker","CheckGeometryWorker","event","error","message","GridJitterPointUIMetadata","GridJitterPointGeneratorFactory","RectangularPieceGeneratorUIMetadata","RectangularPieceGeneratorFactory","_points","cols","rows","cellWidth","cellHeight","gridVertices","rowVertices","halfEdgeTwinMap","topLeft","topRight","bottomLeft","bottomRight","he_top","he_right","he_bottom","he_left","edgesToProcess","edgeInfo","twinKey","twinHe","selfKey","NullTabUIMetadata","NullTabGeneratorFactory","_start","_end","_tab","_random","TriangleTabUIMetadata","TriangleTabGeneratorFactory","edgeVector","edgeLength","edgeDir","normalDir","midPoint","direction","tabHeight","nubPoint","isDarkMode","configureDarkLightTheme","darkModeQuery","manageDarkLightTheme","Page","defaultPointGenerator","PoissonGeneratorName","defaultPieceGenerator","VoronoiGeneratorName","defaultTabGenerator","TraditionalTabGeneratorName","SimpleTabPlacementStrategyName","handleCheckGeometry","processed","total","problems","autocheck","imageUrl","ratio","newColor","type","generatorName","registerIconLibrary","match"],"mappings":"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","x_google_ignoreList":[18,19,20,21,22,23,24,26,27,28,29,30,31,32]}